bug_id,creation_ts,Assignee,Description
1521,10/10/2001 22:14,eclipse,"StringBuffer representation (1GE3BFA) JGS (5/21/01 2:09:10 PM)	To be consistent should we represent StringBuffer objects in the variables view like	we do Strings with their values shown on the top node so the user doesn't have to	expand the object and look at the char array?DW (5/21/01 6:33:02 PM)	Deferred - requires an evaluation."
1681,10/10/2001 22:17,darin.eclipse,"make Java Debug UI a seperate plugin (1GIGG3X) DW (8/14/01 10:33:38 AM)	The Java Debug UI launching and Snippet Editor should be in a seperate plugin."
1768,10/10/2001 22:19,jared_burns,"Variables view stays empty with stack frame selected (1GLE8PW) 1. Debug a program or two and let them terminated. Keep the	old launches in the debug view.2. Debug a program to a breakpoint such that the stack frame will have	a few variables to display in the variables view.3. With the suspended stack frame selected and variables showing in the	variables view select ""Remove all terminated"" from the debug view.4. Note that the suspended stack frame is properly selected after the	old launches are removed but the variables view is empty.The user must manually reselect the stack frame to force the variablesview to update.NOTES:"
5582,11/6/2001 12:19,darin.eclipse,Keyboard shortcut for run/debug We should have keyboard shortcuts for run & debug.
9790,2/13/2002 16:42,Olivier_Thomann,"Add constructors from superclass inserts in wrong place Build 200202121) Start with following classes:public class A { public A(String s) {} public void foo() {}}public class B {}2) Open an editor on class B3) In the content outline select Override Methods -> foo4) Now select ""Add Constructors From Superclass""The result is below. The constructor gets inserted between the method comment and the method body. This is probably because ""Override Methods"" creates non-javadoc method comments.	/*	 * @see A#foo()	 */	/**	 * Constructor for B.	 * @param s	 */	public B(String s) {		super(s);	}	public void foo() {		super.foo();	}}"
11807,3/20/2002 6:13,kai-uwe_maetzel,print margin w2k and linux 20020319-I: 0) Preferences->Java->Editor 1) Disable print margin 2) Press apply 3) Enable print margin 4) Press apply 5) Observe that the print margin is not displayed in the editor. 6) Press apply again 7) The print margin is displayedThe same problem occurs with pressing 'OK' instead of 'Apply'. The printmargin is drawn when I click into the editor.
12014,3/21/2002 7:21,philippe_mulet,No delta when adding package where src=bin and src!=proj Build 200203191. Create java project Test2. Change build path so that Test has one source folder src and its output folder is also src3. Create package p in srcObserve: The package view is not updated. JDT/Core fails to generate a delta in such case
15684,5/9/2002 17:54,daniel_megert,Invalid Menu Extension on search pages 508Following is an almost useless defect report but it contains all of the information we have.After using the 508 build for some time (and exiting and restarting at least once) we discovered the following text in the console (we don't know exactly when it occurs)(paraphrased error messages)Invalid Menu Extension (path invalid) referencesSubMenu(many messages like the above)I thought this was trivially reproducable but now cannot make it occur at all. Will annotate the defect report with steps when (if) I discover them.
21904,7/25/2002 10:35,daniel_megert,[misc] Can't Ctrl+C copy from class file editor without source The 'Ctrl+C' copy shortcut doesn't work in the Java class file editor (the one which appears when no source is available). The Windows shortcut 'Ctrl+Ins' works correctly.There's also no context menu with 'Copy' on it nor is 'Copy' eabled on the 'Edit' pull down menu. Curiously 'Select All' IS enabled but doesn't seem to do anything.
23171,9/4/2002 14:01,darin.eclipse,Method entry breakpoints on abstract methods Currently you can set method entry breakpoints on abstract methods (in interfaces or otherwise).The breakpoints are installed but never appear to be hit in the manner I would expect: the concrete implementation is entered the breakpoint is hit.What is the intended behavior here?
29865,1/21/2003 4:18,philippe_mulet,"Source visibility in project dependency When having a reference on another project you ""see"" all the sources that are in this referenced projects. It appears that in projects you can have API sources and CORE sources (generally in 2 different src folders) because only the target packaging of the project defines what is public and what is not in the end. (by external tool)I would like to have to possibily in the ""Order and export"" tab of the project properties->java build path to uncheck some of the source folders so that referencing projects would not see these classes. This can let me hide core classes and have a clean dependency between projects.One could say the solution is to create 2 different projects. The problem is that I need another one to gather both api and core classes for packaging purposes and it's not possible in Eclipse to have nested projects (is it ??)Thanks."
35526,3/21/2003 17:14,martinae,"Error not surfaced on failed quick fix [quick fix] Build: 2.1 RC3a1) Create a java file A.java:public class A {}2) In the java editor change the class name to ""Com1"".3) The word ""Com1"" will be underlined because it doesn't match the compilationunit name. Select the name and invoke quick fix.4) Choose the quick fix option ""Rename the compilation unit to Com1.java""-> Nothing happens.The log file contains several stack tracesExpectation: The error should be reported to the user not to the log (sinceit's a user error not a program failure)."
36032,4/3/2003 13:22,frederic_fusier,[plan] JavaProject.findType() fails to find second type in source file Given a file with two classes the findType() method is apparently unable tolocate the secondary type in a source file. For example: given the followingfindType() will be able to find Foo but not Bar.// Foo.javapublic class Foo {}class Bar {}
41443,8/12/2003 13:45,daniel_megert,overview ruler not working smoke test for 20030812The overview ruler in the Java editor does not work when starting with a fresh workspace as described in the smoke test scenario.
41468,8/13/2003 6:50,markus.kell.r,"move instance method: method parameter lost [refactoring] 20030806+0812exportA.javapackage p;public class A {	Second s;	public void print() {		s.foo(s);		s.bar();			}}Second.javapackage p;class Second {	public void foo(Second s) {		s.bar();	}	public void bar() {	}}move print from A to Second - the code does not compile after that becausethe call to foo looses an argument"
41489,8/13/2003 11:27,markus.kell.r,"[Dialogs] Move resource should filter closed projects The move resource dialog should either filter closed projects or should offer afunctionality to open closed projects.The error message ""The selected destination is not accessible"" is inadaquate."
41491,8/13/2003 11:41,rfaust,Add constructors from fields issues 200300813a. add visibility buttons like 'Add constructor from super class'
41500,8/13/2003 13:12,jdt-ui-inbox,call hierarchy: history dialog button enablement incorrect [call hierarchy] 20030806in the history dialog the 'Remove' button isenabled when nothing is selected anddisabled when everything is selectedboth are wrong
45408,10/22/2003 14:49,markus.kell.r,"Enable assertions during unit tests [JUnit] As I understand it Java 1.4 assertions are disabled by default unless the vmargument ""-ea"" exists. I would like very much for Eclipse to have an option toalways enable assertions while running my unit tests from the ""run as... JUnittest"" menu item. I realize that I can define a runtime configuration and specify the parametersthere but if this were the ""default"" that would be very helpful."
45507,10/24/2003 10:49,sarika.sinha,"[evaluation] cannot access inner class fields in expressions 3.0 M4I cannot use inner class field in a breakpoint condition expression. ""this"" willpoint to the outer class instance. That forces me to change the method code tofirst copy the inner class instance field to a local variable. Then I can usethat local variable in my breakpoint condition:public class MyClass { public Runnable m1() { return new Runnable() { private int innerClassField; public void run() { int localVariable = innerClassField; // << workaround: copy to local var innerClassField++; // << breakpoint goes here } }; }}In the example above I cannot use ""innerClassField"" in the breakpointcondition but I can use ""localVariable""."
47339,11/24/2003 8:34,frederic_fusier,Javadoc problem while using @see tag I am working with 3.0 M5 and I doesn't ignore problem in Javadoc Tags:when I use @see JDT gives problem for missing tags which are described in the Javadoc of the indicated method in the @see tag
49619,1/7/2004 5:16,jarthana,[formatting] comment formatter leaves whitespace in comments if you format the follwing---------------------------------public class A{ /** * the line below will end in whitespace * * @param x something blah */ public void method(int x) { }}---------------------------------------------the middle line in the comments will have a whitespace at the end.
56062,3/24/2004 18:06,sarika.sinha,[source lookup] Duplicate source lookup should indicate full location of duplicate If you have duplicate source for a classfile the duplicate source files found dialog does not indicate the full location of the duplicates.For example the JAR should be indicated as well as the package name (which may be the same).
56323,3/26/2004 5:41,daniel_megert,"[implementation] NPE when opening file from reprository view 20040325Got this NPE when opening an editor from the rep viewjava.lang.NullPointerException	at java.lang.Throwable.<init>(Throwable.java)	at java.lang.Throwable.<init>(Throwable.java)	at java.lang.NullPointerException.<init>(NullPointerException.java:60)	atorg.eclipse.jdt.internal.ui.javaeditor.ASTProvider.activeJavaEditorChanged(ASTProvider.java:210)	atorg.eclipse.jdt.internal.ui.javaeditor.ASTProvider.access$0(ASTProvider.java:199)	atorg.eclipse.jdt.internal.ui.javaeditor.ASTProvider$ActivationListener.partVisible(ASTProvider.java:102)	at org.eclipse.ui.internal.PartListenerList2$7.run(PartListenerList2.java:175)	at org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java)	at org.eclipse.core.runtime.Platform.run(Platform.java)	atorg.eclipse.ui.internal.PartListenerList2.firePartVisible(PartListenerList2.java)	at org.eclipse.ui.internal.WWinPartService$1.partVisible(WWinPartService.java:68)	at org.eclipse.ui.internal.PartListenerList2$7.run(PartListenerList2.java:175)	at org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java)	at org.eclipse.core.runtime.Platform.run(Platform.java)	atorg.eclipse.ui.internal.PartListenerList2.firePartVisible(PartListenerList2.java)	at org.eclipse.ui.internal.WorkbenchPage$1.propertyChange(WorkbenchPage.java)	at org.eclipse.ui.internal.LayoutPart.setVisible(LayoutPart.java)	at org.eclipse.ui.internal.PartPane.setVisible(PartPane.java:309)	atorg.eclipse.ui.internal.PresentableEditorPart.setVisible(PresentableEditorPart.java:93)	atorg.eclipse.ui.internal.presentations.BasicStackPresentation.selectPart(BasicStackPresentation.java:652)	at org.eclipse.ui.internal.EditorWorkbook.setSelection(EditorWorkbook.java:777)	atorg.eclipse.ui.internal.EditorWorkbook.setVisibleEditor(EditorWorkbook.java:1118)	atorg.eclipse.ui.internal.EditorPresentation.setVisibleEditor(EditorPresentation.java:287)	at org.eclipse.ui.internal.EditorManager.setVisibleEditor(EditorManager.java:1048)	at org.eclipse.ui.internal.WorkbenchPage.bringToTop(WorkbenchPage.java:586)	at org.eclipse.ui.internal.WorkbenchPage.activate(WorkbenchPage.java:454)	at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:2142)	at org.eclipse.ui.internal.WorkbenchPage.access$6(WorkbenchPage.java:2071)	at org.eclipse.ui.internal.WorkbenchPage$9.run(WorkbenchPage.java:2058)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java)	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2053)	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2036)	atorg.eclipse.team.internal.ccvs.ui.actions.OpenRemoteFileAction$1.run(OpenRemoteFileAction.java:101)	atorg.eclipse.team.internal.ccvs.ui.repo.RepositoryManager.run(RepositoryManager.java:741)	at org.eclipse.team.internal.ccvs.ui.actions.CVSAction$1.run(CVSAction.java:225)	at org.eclipse.team.internal.ccvs.ui.actions.CVSAction$2.run(CVSAction.java:244)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java)	at org.eclipse.team.internal.ccvs.ui.actions.CVSAction.run(CVSAction.java:241)	atorg.eclipse.team.internal.ccvs.ui.actions.OpenRemoteFileAction.execute(OpenRemoteFileAction.java:73)	at org.eclipse.team.internal.ccvs.ui.actions.CVSAction.run(CVSAction.java:52)	atorg.eclipse.team.internal.ccvs.ui.repo.RemoteViewPart.handleDoubleClick(RemoteViewPart.java:397)	atorg.eclipse.team.internal.ccvs.ui.repo.RemoteViewPart.access$1(RemoteViewPart.java:387)	atorg.eclipse.team.internal.ccvs.ui.repo.RemoteViewPart$8.doubleClick(RemoteViewPart.java:305)	at org.eclipse.jface.viewers.StructuredViewer$1.run(StructuredViewer.java:381)	at org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java)	at org.eclipse.core.runtime.Platform.run(Platform.java)	atorg.eclipse.jface.viewers.StructuredViewer.fireDoubleClick(StructuredViewer.java:379)	atorg.eclipse.jface.viewers.StructuredViewer.handleDoubleSelect(StructuredViewer.java:598)	atorg.eclipse.jface.viewers.StructuredViewer$4.widgetDefaultSelected(StructuredViewer.java:693)	atorg.eclipse.jface.util.OpenStrategy.fireDefaultSelectionEvent(OpenStrategy.java:187)	at org.eclipse.jface.util.OpenStrategy.access$0(OpenStrategy.java)	at org.eclipse.jface.util.OpenStrategy$1.handleEvent(OpenStrategy.java)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java)	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java)	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1562)	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1536)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:257)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:139)	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:90)	atorg.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:288)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:232)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:116)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:79)	atsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:41)	at java.lang.reflect.Method.invoke(Method.java:386)	at org.eclipse.core.launcher.Main.basicRun(Main.java:315)	at org.eclipse.core.launcher.Main.run(Main.java:740)	at org.eclipse.core.launcher.Main.main(Main.java:724)"
57294,4/2/2004 14:33,philippe_mulet,Ignore serialVersionUID hiding another field When I enabled the compiler warning Advanced -> Field declaration hides anotherfield or variable I get the warning:The field Two.serialVersionUID is hiding a field from type One.This is pretty simple to reproduce:public class One implements Serializable{ static final long serialVersionUID = 1234567890L;}public class Two extends One{ static final long serialVersionUID = 987654321L;}I'd suggest that serialVersionUID should be ignored for this set of warnings.
65604,6/3/2004 15:06,jared_burns,"Invalid stack frame exceptions Build 200406030854After debugging Eclipse for a little while I noticed that I have a ton of ""Invalid stack frame"" exceptions in my log (around 40 of them - I guess one for each frame?). Looks like Bug 57467 but I'm not sure if the underlying cause is really a dup.org.eclipse.debug.core.DebugException: Invalid stack frame	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingStackFrame(JDIStackFrame.java:961)	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.getUnderlyingMethod(JDIStackFrame.java:226)	at org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.isOutOfSynch(JDIStackFrame.java:880)	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.computeJDIAdornmentFlags(JDIModelPresentation.java:831)	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getDebugElementImage(JDIModelPresentation.java:797)	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getImage(JDIModelPresentation.java:637)	at org.eclipse.debug.internal.ui.LazyModelPresentation.getImage(LazyModelPresentation.java:94)	at org.eclipse.debug.internal.ui.DelegatingModelPresentation.getImage(DelegatingModelPresentation.java:141)	at org.eclipse.debug.internal.ui.views.DebugViewInterimLabelProvider.getImage(DebugViewInterimLabelProvider.java:58)	at org.eclipse.jface.viewers.DecoratingLabelProvider.getImage(DecoratingLabelProvider.java:74)	at org.eclipse.debug.internal.ui.views.launch.LaunchViewer.doUpdateItem(LaunchViewer.java:92)	at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run(AbstractTreeViewer.java:83)	at org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:615)	at org.eclipse.core.runtime.Platform.run(Platform.java:758)	at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem(AbstractTreeViewer.java:459)	at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run(StructuredViewer.java:128)	at org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:615)	at org.eclipse.core.runtime.Platform.run(Platform.java:758)	at org.eclipse.jface.viewers.StructuredViewer.updateItem(StructuredViewer.java:1368)	at org.eclipse.jface.viewers.StructuredViewer.update(StructuredViewer.java:1352)	at org.eclipse.jface.viewers.StructuredViewer.update(StructuredViewer.java:1280)	at org.eclipse.debug.internal.ui.views.DebugViewDecoratingLabelProvider.labelsComputed(DebugViewDecoratingLabelProvider.java:67)	at org.eclipse.debug.internal.ui.views.DebugViewLabelDecorator$1.run(DebugViewLabelDecorator.java:135)	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:106)	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:2489)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2226)	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1363)	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1334)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:253)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:141)	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:96)	at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:334)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:273)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:128)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)	at java.lang.reflect.Method.invoke(Method.java:324)	at org.eclipse.core.launcher.Main.basicRun(Main.java:185)	at org.eclipse.core.launcher.Main.run(Main.java:638)	at org.eclipse.core.launcher.Main.main(Main.java:622)"
65875,6/5/2004 15:26,nicohoess,"[extract local] puts declaration at wrong position Extract Local Variable puts the declaration at a wrong position iff- the selected expression is in an ExpressionStatement and- there's a matching fragment before the selected expressionpublic class ExpressionStatement {	void m() {		System.out.println(calculateCount());		calculateCount(); //Extract Local Variable	}	private int calculateCount() {		return 1;	}}The declaration is created at the position of the ExpressionStatement instead ofbefore the first matching fragment. The fix is very local and the code todetermine the right position is already there and can be reused."
68233,6/22/2004 16:42,sarika.sinha,Null Pointer in JavaBreakpoint I was using RC3 and doing hyades development hyades wasn't installed in myplugins but the hyades projects were open in my workspace. The workspace I wasusing was originally produced by the M9 build if that's any help. The nullpointer occured during one of a long series of debugging sessions I had beenrunning the backtrace was$ java.lang.NullPointerException atorg.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.installableReferenceType(JavaBreakpoint.java:318) atorg.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.handleClassPrepareEvent(JavaBreakpoint.java:276) atorg.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.handleEvent(JavaBreakpoint.java:256) atorg.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch(EventDispatcher.java:137) atorg.eclipse.jdt.internal.debug.core.EventDispatcher.run(EventDispatcher.java:221) at java.lang.Thread.run(Thread.java:534)after the backtrace I cannot be sure but the debugging session seemed to stallthe runtime-workbench continued to refresh but actions would no longer have anyeffect. I tried terminating the runtime-workbench and debugging again a numberof times but again the application would go unresponsive in certain areas itoccurs to me that the unresponsive areas may of been in the same spots as somedisabled Breakpoints but I can't confirm that either way the exact spot theprogram grew unresponsive varied the state of the debugging window didn'treflect having hit any kind of breakpoint. I shut down the program after notingthe Null Pointer did show up once more later on (important to note that Idebugged many times before and after with out the null pointer). The problemappears to have desisted when I restarted eclipse.I'm sorry I can't give steps to reproduce but felt I might as well give what Ihave I'll continue to play around with it and update this report if I find anymore info.
71627,8/9/2004 5:15,jerome.cambon,"[code style] don't generate redundant modifiers ""public static final abstract"" for interface members There should be a preference (on the Code Style page?) where users can configuremodifiers to be generated for new interface members.The JLS allows to redundantly add any of- ""public static final"" to a field declaration - ""public static"" to a class declaration - ""public abstract"" to a method declaration in an interface.I'd suggest to add 4 checkboxes with label ""Add redundant modifiers to interfacemembers:"".Move Static Members and Extract Interface should respect this preference."
71761,8/11/2004 5:45,eclipse,"[import rewrite] ImportRewrite should let me add explicit import to existing on demand import ImportRewrite is too smart for me. In order to fix 71707 I need to add anexplicit import p.A to a CU with an existing import p.* (to avoid hiding ofreferences to ""A"" in an existing CU ""pack.User"" when a new type ""A"" is added topackage ""pack"").setFindAmbiguosImports() and setFilterImplicitImports() don't allow me toconfigure this behavior - the added import p.A is always swallowed when p.*already exists. setFindAmbiguosImports(true) doesn't work in my use case sincethe ambiguity is only to be introduced by the refactoring."
72847,8/29/2004 13:50,noopur_gupta,[JUnit] Add 'Show Stack Trace in Console View' toolbar button (was: Use regular console for JUnit stack trace) Currently JUnit view is using list-based widget to show error/failure stacktrace. It would be more natural to use standard console widget there (kepingfiltering feature for stack trace). This will allow to select fragment of stacktrace without copying it into clipboard.
77861,11/4/2004 11:59,kent_johnson,"[1.5] Illegal class file generated with duplicate methods 3.1M3 test passThe following class gets compiled without errors: public class K implements Comparable<K> { public int compareTo(Object o) { return 0; } public int compareTo(K o) { return 1; } }The class file gets 3 methods:- public int compareTo(Object arg);- public int compareTo(K arg);- public bridge synthetic int compareTo(Object arg);Using the class with ... class User { public static void main(String[] args) { K k= new K(); k.compareTo(new K()); } }... gives a classloader exception:Exception in thread ""main"" java.lang.ClassFormatError: Repetitive methodname/signature in class file k/Kjavac1.5.0 resists to compile the source:name clash: compareTo(java.lang.Object) in k.K and compareTo(T) injava.lang.Comparable<k.K> have the same erasure yet neither overrides the other"
78422,11/11/2004 15:26,darin.eclipse,test failure: testSimpleLineCounter On occasion the following test failure occurs on Linux. See I20041110-1000I've frequently seen the same failure running locally on Mac.Wrong number of lines output expected:<11> but was:<0>junit.framework.AssertionFailedError: Wrong number of lines output expected:<11> but was:<0>at org.eclipse.jdt.debug.tests.core.LineTrackerTests.testSimpleLineCounter(LineTrackerTests.java:78)at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)at org.eclipse.jdt.debug.tests.DebugSuite$1.run(DebugSuite.java:53)at java.lang.Thread.run(Thread.java:534)
79068,11/19/2004 8:47,Olivier_Thomann,"[formatter] Need option to control line wrapping before/after operators need option to control line wrapping before/after operatorsIt would be nice if there was a code formatting option (that could ideally bereferenced by the wrap java strings feature of the java editor) to set wrappingbefore or after operators. One example of where this option would apply is when formatting code that lookslike this: if (a.getSomeBooleanValue() && b.getSomeOtherBooleanValue() && c.getYetAnotherBooleanValue()) { doSomething(); }The code formatter currently always changes the code above to the code belowand there's no option (at least not that I've found) to control this behavior. if (a.getSomeBooleanValue() && b.getSomeOtherBooleanValue() && c.getYetAnotherBooleanValue()) { doSomething(); }Note also that the wrap java strings feature and the code formatter areinconsistent with respect to this behavior. Specifically if I use the wrapjava strings feature I get this: System.out.println(""asdlfj asfl;kj saflksj fl;ksaj flsjd f;asl fsjdf"" + ""sdflkjsdfl;jaslfdjsdlfkj sdflk sdjflks f"");Now when I format the code using the code formatter I get System.out.println(""asdlfj asfl;kj saflksj fl;ksaj flsjd f;asl fsjdf"" + ""sdflkjsdfl;jaslfdjsdlfkj sdflk sdjflks f"");Note that one wraps before the + operator and the other wraps after the plusoperator (not to mention the inconsistent indentation)."
80014,12/2/2004 10:19,Olivier_Thomann,@Retention(RetentionPolicy.RUNTIME) is ignored for annotations I'm using eclipse-SDK-I20041201-win32.zip.Runtime retention policy does not seems to be implemented in the compiler. Inthe provided test null should not be returned from getAnnotation() method
81824,12/22/2004 16:19,kent_johnson,"A generic interface is allowed to be implemented more than once - contrary to Java language specification Implementing a generic interface with different type parameters is allowed bythe JDT compiler however this should not be so. Loading such an implementingclass in the JVM causes:java.lang.ClassFormatError: Repetitive interface name in class file X	at java.lang.ClassLoader.defineClass1(Native Method)	at java.lang.ClassLoader.defineClass(ClassLoader.java:620)and so on...(Note: I am assuming that the language specification disallows the describedbehaviour just because I see the exception at runtime - I haven't really readthe specs)The shortest code to reproduce the problem is:interface I<T> {}public class X implements I<Integer> I<String> {	public static void main(String... args) {} }Just execute the main method to get the exception.Note that compiling by the original javac yields:X.java:2: I cannot be inherited with different arguments: <java.lang.Integer>and <java.lang.String>public class X implements I<Integer> I<String> { ^1 errorThe problem was discovered in Eclipse 3.1M4 under Windows XP with Sun's JDK5.0(javac 1.5.0-rc). Not tested on any other configuration but /should/ beEclipse-specific and presumably reproducible on other platforms with thisEclipse build.-- Irfy"
90140,4/4/2005 6:29,sandra.lions-piron,[quick fix] for qualified enum constants in switch-case labels
90351,4/5/2005 15:11,darin.eclipse,[performance test] Tests completing too quickly Many debug performance tests are completing in under 1 second (elapsed time). These tests should be removed or refactored to run longer (between 1 and 10 seconds).
91104,4/12/2005 6:33,noopur_gupta,"[hovering] Javadoc hover does not show Javadoc of (type) parameters I20050405-0800 + ZRH plugin exportThe javadoc hover does not show javadoc associated with type parameters.Steps to reproduce:- Create cu	/**	 * Description of foo	 * @param <T> description of type parameter	 * @param t description of argument	 */	public final <T> void foo(T t) { }- Hover over the type of the method argument 't'-> No javadoc available-> Same also happens for type parameters of classes"
93459,5/2/2005 17:23,mateusz.matela,"[formatter] HTML tags in Javadoc sometimes don't get wrapped Version: 3.1.0Build id: I20050401-1645A Javadoc 120 max line width limit is not applied to: /** * <p> * Returns whether the named charset is supported. * </p> * <p> * This is similar to <a *href=""http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html#isSupported(java.lang.String)"">java.nio.charset.Charset.isSupported(String)</a> * </p> * * @param name * the name of the requested charset; may be either a canonicalname or an alias * @return <code>true</code> if and only if support for the named charsetis available in the current Java * virtual machine * * @see <ahref=""http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc"">JREcharacter * encoding names</a> */Note that the @see properly breaks the line appart in the <a>."
94452,5/10/2005 14:06,loskutov,Timeout exceptions I20050509-2010I am able to produce timeout exceptions by stepping in a method while a logical structure is displayed for a Vector. Stepping quickly - allow the UI to start to update and then step again - seems to cause the problem. I am not holding down the step key. This may be flooding the target with requests as the views are attempting to update as the next step starts.
95414,5/16/2005 13:50,markus.kell.r,[open type] Multi-select in Open Type dialog Build: 3.1 M7I find the new history section of the Open Type dialog to be so useful that Inow frequently close all (Ctrl+Shift+W) when things become cluttered. Afterthat I frequently want to just reopen a small number of types from my history. It would be neat if I could multi-select types in the Open Type dialogallowing me to quickly reopen several recently used types in my history at once.
102512,7/1/2005 13:55,xcoulon,"[JUnit] test method name cut off before ( In case my test's name is ""log on test (user peter)"" the JUnit view will in the left window only show ""log on test "" leaving out the most interesting part."
103672,7/13/2005 12:03,markus.kell.r,"compiler problem VARARGS_ARGUMENT_NEED_CAST only explains one of two solutions 3.1The compiler problem COMPILER_PB_VARARGS_ARGUMENT_NEED_CAST is a bit misleadingsince it only explains one of two solutions to the underlying problem (see bug103667) when it says:""Varargs argument null should be cast to Object[] when passed to the methodaddElements(Object...) from type VarargExample"".The compiler preference page calls this 'Inexact type match for varargsargument' and I think the error message should rather explain this problem thanpropose a solution.My proposal for a more neutral error message:""Varargs argument null does not match argument type Object[] of method addElements(Object...) from type VarargExample""."
107001,8/15/2005 5:55,Olivier_Thomann,"ITypeBinding#getBinaryName() returns java.lang.Object for type variable I20050811-1530The javadoc of ITypeBinding#getBinaryName() says:	 * The binary name of a class is defined in the Java Language 	 * Specification 2nd edition section 13.1.It is not clear what should be returned for type variables. Currently themethod returns java.lang.Object. I would expect to get either null or thebinary name as defined in JLS3.No big deal for me right now just an API glitch."
113946,10/27/2005 6:01,mateusz.matela,[formatter] Ctrl+Shift+F does not reformat Javadoc above package keyword in package-info.java [formatting] CtrlShiftF does not reformat JavaDoc above package keyword in package-info.java. If you have a lot of Javadoc text some going past the 80 column mark and try to reformat it it does not work. Moving the Javadoc below the package keyword allows you to reformat the Javadoc comments.The comments need to be above the package keyword however if they are to appear in the html output of the javadoc tool.
117215,11/20/2005 11:05,hanke,"[templates][content assist] Content assist for 'for' loop should suggest member variables public class test {		private int[] arr = new int[5];		testmethod(){		//loop on the array		for*ctrl+space* 	}}Here suggestions for different for loops will be suggested - but they won't usethe private member ""arr"" in the code they generate.I hope this qualifies for an enhancement - especially for the new foreach loopthis will be nice to have.Thanks Anders"
117890,11/24/2005 6:38,Olivier_Thomann,JavaElement.getURLContents(...) leaves file open I20051123The AttachedJavadocTests sometimes fail because JavaElement.getURLContents(...) leaves a file open and the test cannot delete the project in the tearDownSuite() method because of that. More specifcally URLConnection.getContentEncoding() opens a file stream on the doc.zip and never closes it. So this looks like a bug in the implementation of URLConnection.getContentEncoding().
118264,11/28/2005 13:29,mateusz.matela,"[formatter] Enable wrapping of for loop setup I'd like the formatter to insert line breaks to wrap the for loop setup (or whatever that part in parens that immediately follows the ""for"" keyword is called) for example if I have this for loop:for (Thing foo = really.long.initializer(); foo.conditionIsStillTrue(); foo.proceedToNextValue()) { foo.doStuff(); ...}I'd like the first line to get wrapped by the formatter ideally like this:for (Thing foo = really.long.initializer(); foo.conditionIsStillTrue(); foo.proceedToNextValue()) { foo.doStuff(); ...}Simultaneously I'd like short things not to be wrapped for example:for (int i = 0; i < MAX; i++) { ...}I looked through the formatter options but didn't see anything related to for loops.I also looked through the bugs and on the web but didn't find any info."
121057,12/15/2005 10:21,sarika.sinha,[jres] 'Execution Environments' preference page not updated after JRE addition I20051214-2000- start with a new workspace and a 1.4 VM- on the 'Installed JREs' page add a 1.5 SDK- without leaving the preferences dialog go to the 'Execution Environments' page and select J2SE-1.5=> compatible JREs list is empty although I just installed one
121728,12/21/2005 9:46,mateusz.matela,[formatter] Code formatter thinks <P> generic class parameter is a HTML <p> tag If I have a code like:/** * Test Class * * @param <P> Some generic class parameter */public class Test<P> {...}and apply the code formatter (Ctrl+Shift+F) the code will be like this:/** * Test Class * * @param * <P> * Some generic class parameter */public class Test<P> {...}Note that the parameter must be named P for this to happen.I have not tested the effect of using other HTML tag names as generic parameters.
129725,2/28/2006 2:55,markus.kell.r,"JDT JUnit: java.lang.Exception: Unexpected TestElement type for testId '230': I20060221-1300I got several exceptions in .log but nothing visibly in the UI. I started the JDT Text tests several times in Debug and Run mode (in sequence not parallel). I also terminated one of those via Debug view.!ENTRY org.eclipse.jdt.junit 4 4 2006-02-27 17:54:28.022!MESSAGE Error!STACK 0java.lang.Exception: Unexpected TestElement type for testId '230': org.eclipse.jdt.text.tests.JUnitProjectTestSetup: NOT_RUN (1)	at org.eclipse.jdt.internal.junit.model.TestRunSession$TestSessionNotifier.logUnexpectedTest(TestRunSession.java:476)	at org.eclipse.jdt.internal.junit.model.TestRunSession$TestSessionNotifier.testFailed(TestRunSession.java:414)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$7.run(RemoteTestRunnerClient.java:525)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)	at org.eclipse.core.runtime.Platform.run(Platform.java:816)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.notifyTestFailed(RemoteTestRunnerClient.java:522)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.access$16(RemoteTestRunnerClient.java:517)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$TraceProcessingState.readMessage(RemoteTestRunnerClient.java:170)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.receiveMessage(RemoteTestRunnerClient.java:342)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.access$26(RemoteTestRunnerClient.java:341)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$ServerConnection.run(RemoteTestRunnerClient.java:267)!ENTRY org.eclipse.jdt.junit 4 4 2006-02-27 17:54:28.053!MESSAGE Error!STACK 0java.lang.Exception: Unexpected TestElement type for testId '243': org.eclipse.jdt.text.tests.JUnitProjectTestSetup: NOT_RUN (1)	at org.eclipse.jdt.internal.junit.model.TestRunSession$TestSessionNotifier.logUnexpectedTest(TestRunSession.java:476)	at org.eclipse.jdt.internal.junit.model.TestRunSession$TestSessionNotifier.testFailed(TestRunSession.java:414)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$7.run(RemoteTestRunnerClient.java:525)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)	at org.eclipse.core.runtime.Platform.run(Platform.java:816)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.notifyTestFailed(RemoteTestRunnerClient.java:522)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.access$16(RemoteTestRunnerClient.java:517)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$TraceProcessingState.readMessage(RemoteTestRunnerClient.java:170)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.receiveMessage(RemoteTestRunnerClient.java:342)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.access$26(RemoteTestRunnerClient.java:341)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$ServerConnection.run(RemoteTestRunnerClient.java:267)!ENTRY org.eclipse.jdt.junit 4 4 2006-02-27 17:54:30.251!MESSAGE Error!STACK 0java.lang.Exception: Unexpected TestElement type for testId '301': org.eclipse.jdt.text.tests.AbstractSemanticHighlightingTest$SemanticHighlightingTestSetup: NOT_RUN (1)	at org.eclipse.jdt.internal.junit.model.TestRunSession$TestSessionNotifier.logUnexpectedTest(TestRunSession.java:476)	at org.eclipse.jdt.internal.junit.model.TestRunSession$TestSessionNotifier.testFailed(TestRunSession.java:414)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$7.run(RemoteTestRunnerClient.java:525)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)	at org.eclipse.core.runtime.Platform.run(Platform.java:816)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.notifyTestFailed(RemoteTestRunnerClient.java:522)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.access$16(RemoteTestRunnerClient.java:517)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$TraceProcessingState.readMessage(RemoteTestRunnerClient.java:170)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.receiveMessage(RemoteTestRunnerClient.java:342)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.access$26(RemoteTestRunnerClient.java:341)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$ServerConnection.run(RemoteTestRunnerClient.java:267)!ENTRY org.eclipse.jdt.junit 4 4 2006-02-27 17:54:30.261!MESSAGE Error!STACK 0java.lang.Exception: Unexpected TestElement type for testId '321': org.eclipse.jdt.text.tests.AbstractSemanticHighlightingTest$SemanticHighlightingTestSetup: NOT_RUN (1)	at org.eclipse.jdt.internal.junit.model.TestRunSession$TestSessionNotifier.logUnexpectedTest(TestRunSession.java:476)	at org.eclipse.jdt.internal.junit.model.TestRunSession$TestSessionNotifier.testFailed(TestRunSession.java:414)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$7.run(RemoteTestRunnerClient.java:525)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)	at org.eclipse.core.runtime.Platform.run(Platform.java:816)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.notifyTestFailed(RemoteTestRunnerClient.java:522)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.access$16(RemoteTestRunnerClient.java:517)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$TraceProcessingState.readMessage(RemoteTestRunnerClient.java:170)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.receiveMessage(RemoteTestRunnerClient.java:342)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.access$26(RemoteTestRunnerClient.java:341)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$ServerConnection.run(RemoteTestRunnerClient.java:267)!ENTRY org.eclipse.jdt.junit 4 4 2006-02-27 17:54:31.607!MESSAGE Error!STACK 0java.lang.Exception: Unexpected TestElement type for testId '363': org.eclipse.jdt.ui.tests.core.ProjectTestSetup: NOT_RUN (1)	at org.eclipse.jdt.internal.junit.model.TestRunSession$TestSessionNotifier.logUnexpectedTest(TestRunSession.java:476)	at org.eclipse.jdt.internal.junit.model.TestRunSession$TestSessionNotifier.testFailed(TestRunSession.java:414)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$7.run(RemoteTestRunnerClient.java:525)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)	at org.eclipse.core.runtime.Platform.run(Platform.java:816)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.notifyTestFailed(RemoteTestRunnerClient.java:522)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.access$16(RemoteTestRunnerClient.java:517)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$TraceProcessingState.readMessage(RemoteTestRunnerClient.java:170)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.receiveMessage(RemoteTestRunnerClient.java:342)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.access$26(RemoteTestRunnerClient.java:341)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$ServerConnection.run(RemoteTestRunnerClient.java:267)!ENTRY org.eclipse.jdt.junit 4 4 2006-02-27 17:54:33.343!MESSAGE Error!STACK 0java.lang.Exception: Unexpected TestElement type for testId '512': org.eclipse.jdt.text.tests.IndentActionTest$IndentTestSetup: NOT_RUN (1)	at org.eclipse.jdt.internal.junit.model.TestRunSession$TestSessionNotifier.logUnexpectedTest(TestRunSession.java:476)	at org.eclipse.jdt.internal.junit.model.TestRunSession$TestSessionNotifier.testFailed(TestRunSession.java:414)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$7.run(RemoteTestRunnerClient.java:525)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)	at org.eclipse.core.runtime.Platform.run(Platform.java:816)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.notifyTestFailed(RemoteTestRunnerClient.java:522)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.access$16(RemoteTestRunnerClient.java:517)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$TraceProcessingState.readMessage(RemoteTestRunnerClient.java:170)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.receiveMessage(RemoteTestRunnerClient.java:342)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient.access$26(RemoteTestRunnerClient.java:341)	at org.eclipse.jdt.internal.junit.model.RemoteTestRunnerClient$ServerConnection.run(RemoteTestRunnerClient.java:267)"
131445,3/11/2006 21:53,Lars.Vogel,"[templates] Provide templates that check for 'null' I find the following template very useful and would suggest that it be included by default:Name: ifnotnullDescription: if not null statementPattern:if (${name} != null) {	${cursor}}"
151668,7/25/2006 4:52,yves.joan,[reorg] Copy action should NOT add 'copy of' prefix Yes I add this issue though it contradicts to issue #3985 and issue #33071. I really wonder what the advantage of this prefix should be. I never just wanted to create a copy where the name is not important like a backup. Whenever I copy a file I want to specify a new name. And there it is really annoying to remove the prefix over and over again. If this is now different for other people (otherwise it would probably not have been added this way) it might make sense to make this prefix configurable.
154181,8/17/2006 3:30,markus.kell.r,"[actions] ""Occurrences in File"" (Shift+Ctrl+U) shortcut doesn't work on GTK I can't use the default shortcut for ""show occurences"" anymore with version 3.2. I f I redefine it to be the shortcut Ctrl-U it does function.I've created a new workspace to check if it's caused by some odd old preferences but even then it doesn't function.I'm using the linux-gtk Version of eclipse 3.2 on SuSE 10.0 and I have never modified the gnome/gtk settings.The shortcut Shift-Ctrl-T does function very weird."
156349,9/6/2006 8:39,jdt-ui-inbox,"[quick fix] quick fix generates incorrect imports on classname collisions Taking the example code from #36481 quickfix now fails differently on eclipse 3.2.0:given two types with same name package a; public class A { } package b; public class A {	public void doSomething(a.A obj) {		newMethod(obj); // this should be quickfixed	} }the generated method has the signatureprivate void newMethod(A obj) but should have private void newMethod(a.A obj). Differing from #36481 the class b.A now has a generated ""import a.A"" which is unused and the call to newMethod(obj) that was used to quickfix is flagged as invalid (The method newMethod(A) in the type A is not applicable for the arguments (A))As in the mentioned old entry the usage seems esoteric but results from generated code calling to nongenerated code with same classnames in different package by convention."
161403,10/18/2006 9:11,daniel_megert,[content assist] Auto Activation Delay Could Be Smaller Currently the default value for auto activation delay is 200 (ms)IMHO it's too long it makes me happier when I changed it to 100.seems eclipse is really not that slow.Maybe you guys I mean eclipse developers can track the contentassist to get an average delay I believe its smaller than 200ms :PThanks
165684,11/23/2006 12:01,daniel_megert,[content assist] Code assist for spelling proposals does not work 3.2.1 and latest 3.3 buildCode assist for spelling proposals does not work.
178912,3/22/2007 18:20,sarika.sinha,"IVMInstallType api and AbstractVMInstallType impl are not thread safe The IVMInstallType.createVMInstall(<id>) method call immediately makes the vm install visible to everyone. I hit a race condition that looked like this:Thread 1========IVMInstall vm = type.createVMInstall(vmId);vm.setInstallLocation( vmLocation );vm.setName(vmName);Thread 2========java.lang.NullPointerExceptionat org.eclipse.jdt.launching.AbstractVMInstallType.findVMInstallByName(AbstractVMInstallType.java:146)at org.eclipse.jdt.internal.launching.JREContainerInitializer.resolveVM(JREContainerInitializer.java:82)at org.eclipse.jdt.internal.launching.JREContainerInitializer.initialize(JREContainerInitializer.java:52)at org.eclipse.jdt.internal.launching.LaunchingPlugin$VMChanges.rebind(LaunchingPlugin.java:279)at org.eclipse.jdt.internal.launching.LaunchingPlugin$VMChanges.access$0(LaunchingPlugin.java:244)at org.eclipse.jdt.internal.launching.LaunchingPlugin$1.run(LaunchingPlugin.java:232)at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:720)at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1737)at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:4024)at org.eclipse.jdt.internal.launching.LaunchingPlugin$VMChanges.doit(LaunchingPlugin.java:236)at org.eclipse.jdt.internal.launching.LaunchingPlugin$JREUpdateJob.run(LaunchingPlugin.java:316)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)	public IVMInstall findVMInstallByName(String name) {		for (int i= 0; i < fVMs.size(); i++) {			IVMInstall vm= (IVMInstall)fVMs.get(i);			if (vm.getName().equals(name)) { <-- NPE right here				return vm;			}		}		return null;	}There are two thread safety problems here:1. IVMInstallType api causes new runtimes to be made available to everyone before they can be fully initialized.2. AbstractVMInstallType internally does not use synchronization. Most specifically access to fVMs list member variable is not synchronized.Potential fix:Can't change existing IVMInstallType api but the AbstractVMInstallType implementation can be changed to synchronize on the vm type object for all getter and setter methods that deal with vm instances. That directly addresses #2 and allows #1 to be worked around by adding a synchronized block around code in Thread 1 above...synchronized( type ){ IVMInstall vm = type.createVMInstall(vmId); vm.setInstallLocation( vmLocation ); vm.setName(vmName);}"
184222,4/26/2007 9:11,robert.roth.off,[templates] 2 new code templates: finally & lock Build ID: xxSteps To Reproduce:try {} finally {}@@@@lock.lock();try {} finally { lock.unlock();}@@@@Both patterns are very common in concurrent programming.More information:
188796,5/23/2007 21:23,olsok,[jsr199] Using JSR199 to extend ECJ Build ID: S-3.3RC1-200705171700Steps To Reproduce:1. Take the interfaces defined in JSR199 (see the javax.tools package)2. Attempt to implement classes which provide an implementation of the interfaces providing all the IO needed by the compiler.3. See that the JavaFileManager passed in as parameter to javax.tools.JavaCompiler.getTask is not used by ECJ to load classes or sources but instead the setPaths method on org.eclipse.jdt.internal.compiler.tool.EclipseCompiler assumes that it is dealing with implementations that are not abstracted away from the file system.More information:Quoting from section 2.1 of JSR199see: http://jcp.org/en/jsr/detail?id=199#2---------------The JavaTM Compiler API is a set of interfaces that describes the functions provided by a JavaTM Language Compiler and a service provider framework so vendors can provide implementations of these interfaces.The interfaces abstract the way a compiler interacts with its environment. While the existing command-line versions of compiler receive their inputs from the file systems and deposit their outputs there reporting errors in a single output stream the new compiler API will allow a compiler to interact with an abstraction of the file system. ...---------------While it is true that the JSR199 specification is somewhat vague about how exactly a compiler is supposed to interact with the interfaces defined it seems that it should interact in a way which enables the aforementioned goals.
189804,5/29/2007 20:11,noopur_gupta,[preferences] Imported formatter preferences do not get automatically recognized To reproduce:1. Create a new workspace2. Import the preference file attached3. Create a new Java project (without enabling project specific settings)4. Create a HelloWorld class with method braces on same line as method signature5. Select all the code and run the code formatterExpected:Braces are moved to line below signature since this is what the code formatter is setup to doActual:The custom code formatting is not appliedWork-around:Open the General Preferences windows and navigate to the code formatter optionNotice that the SJM custom code formatter is selected in the drop downSelect another code formatter then reselect the SJM code formatterHit OK on the preferences windowNow the code will format correctly
193004,6/16/2007 12:29,jan.rosczak,"[CommonNavigator] Project Explorer view lacks menu item ""show Referenced Libraries Node"" Build ID: I20070608-1718Steps To Reproduce:1. in java perspective include the views Package explorer and project explorer.2. compare their customization menus3. the project explorer cannot group libraries in a separate nodeMore information:The package explorer has received a very useful facelift in that it can display libraries inside of a library container. However this capability is not available within the project explorer for plain java projects.--I chose to label this as a bug for two reasons- other users filed similar reports concerning the lack of feature synchronization between the two views (package explorer and project explorer) and chose to classify their reports as bugs. (see bug 192931)- it can be argued that making a newly introduced feature accessible wheresoever applicable is part the quality assurance process and not something to be explicitly requested as a feature."
195185,7/2/2007 17:51,darin.eclipse,Cannot debug java class Run Debug as ... Java application for compiled class and after that in Progress view is showed process Launching : Constructing command line... and status is still 80% and nothing happen. CPU is used about 95-99% but debug is not launched.
203151,9/12/2007 16:36,jan.rosczak,[common navigator] Add 'Empty Library Containers' filter If you enable the 'Libraries from external' customization filter in the Project Explorer in the Java EE perspective it correctly removes these jars from the view but does not remove the classpath containers that they are contained in. Other views (e.g. Java Package Explorer) remove the classpath container as well.As an example the normal tree might show:Java Resources: src > Libraries > Apache Tomcat > [list of jars]When you turn on the 'Libraries from external' filter it shows:Java Resources: src > Libraries > Apache TomcatBut should show:Java Resources: src > Libraries
206930,10/19/2007 13:56,kent_johnson,"[1.5][compiler] Mismatch between javac and Eclipse compiler javac reports an error for the following test case where the Eclipse compiler simply reports a warning that is not related to the error reported by javac.interface A<T> {}class B { void foo(A<?> x) { }}class D implements A {}public class X extends B { void bar() { foo(new D()); } void foo(D d) { }}The Eclipse compiler from HEAD reports:----------1. WARNING in D:\tests_sources\X.java (at line 9)	class D implements A {	 ^A is a raw type. References to generic type A<T> should be parameterized----------where javac 1.5 1.6 and 1.7 report:X.java:13: reference to foo is ambiguous both method foo(A<?>) in B and method foo(D) in X match foo(new D()); ^1 errorD can also be defined as a static member of the class X with the same error."
216098,1/22/2008 4:48,sarika.sinha,[breakpoints] Can't set a watchpoint on a final field Build ID: I20071213-1700Steps To Reproduce:1. Copy the code below2. Click on the left space of the java editor in order to set a breakpoint/watchpoint on the final field3. The watchpoint is not setMore information:Knowing when a final field is read can be useful.
217984,2/6/2008 7:29,markus.kell.r,"[quick assist] Wrong type inferred by assign to new local variable If type parameter is ? quickfix ignores bounds placed on it. Below it is known that T is a subtype of Number therefore ArrayList<T>.get() returns a Number yet the quickfix offers the type Object. The code compiles with both Eclipse and javac (1.6.0_03).Version: 3.3.0Build id: I20070621-1340import java.util.ArrayList;public class NumberThing<T extends Number> extends ArrayList<T> {	void test() {		NumberThing<?> questionmarkThing = new NumberThing<Double>();		// produced by 'Assign statement to new local variable'		Object object = questionmarkThing.get(0);		// although this is valid too		Number n = questionmarkThing.get(0);	}}"
218645,2/12/2008 11:32,markus.kell.r,[dom] Implicit type bounds not available from capture binding I20080207-1530import java.util.ArrayList;public class NumberThing<T extends Number> extends ArrayList<T> { void test() { NumberThing<?> questionmarkThing = new NumberThing<Double>(); questionmarkThing.get(0); }}Look at the resolved type binding of the method invocation 'questionmarkThing.get(0)'. This is a capture binding with type bounds {java.lang.Number} (the 'Number' comes from the declaration of type variable T).ITypeBinding#isCapture() says that these bounds should be available from getTypeBounds() but that method's Javadoc contradicts this by talking about the 'declared' or 'explicit' bounds.The current implementation of getTypeBounds() does not return the first bound but it does return additional bounds (e.g. with <T extends Number & Runnable & Cloneable>).I don't think it makes sense to keep up the current implementation of getTypeBounds() for capture types since capture types are always generated and never have 'explicit' type bounds. Clients dealing with capture types need all bounds so I propose to change getTypeBounds() to this:/** * Returns the upper type bounds of this type variable or capture. If the * variable or the capture had no bound then it returns an empty list. [..]We need this to fix bug 217984.
220007,2/22/2008 13:06,sarika.sinha,"Incorrect syntax highlighting in scrapbook Build: I20080207-1530The scrapbook editor incorrectly highlights keywords in string literals. For example:String s = ""hello null"";In this snippet null is highlighted as a Java keyword."
228845,4/25/2008 5:18,srikanth_sankaran,"[hierarchy] Type hierarchy should include subtypes in primary working copies N20080423-2000- paste to Package Explorer:package xy;public interface I { }package xy;public class C /*implements I*/ { }- in C.java remove the /* and */ around ""implements I""- do NOT save- select I- F4=> type hierarchy on I no subtypes=> I thought the TH works on working copies but working on saved state is also acceptable- Ctrl+S=> type hierarchy not updated (should show C as child of I)- F4 on I does not refresh the hierarchy. Need to open hierarchy on another type first or press F5 in Hierarchy view to get correct hierarchy."
237709,6/18/2008 18:49,Michael_Rennie,"[preferences] Installed JRE tab does not pick up new JRE created in other Preference Pages Build ID: M20080221-1800Steps To Reproduce:In WebLogic Server Tools plugin we create a new JRE when user creates a new WLS Server Runtimein the WTP ""Server"" Preference Page.The code to create JRE looks like: final VMStandin vmWorkingCopy = new VMStandin( type vmId ); vmWorkingCopy.setName( vmId ); vmWorkingCopy.setInstallLocation( vmLocation ); vm = vmWorkingCopy.convertToRealVM(); JavaRuntime.saveVMConfiguration(); The last call persists the change to Preference store.If user immediately switch to Installed JRE pagethe new JRE does not show up. Even worse is thatif user closes the Preference now the change is overridden.More information:If user creates the WebLogic server runtime outside of the Preference the JRE is picked up next time user"
238681,6/26/2008 17:32,sarika.sinha,"NPE while starting Eclipse Just noticed in error log.nullErrorThu Jun 26 23:10:20 CEST 2008An internal error occurred during: ""Initializing Java Tooling"".java.lang.NullPointerExceptionat org.eclipse.core.runtime.Plugin$1.run(Plugin.java:353)at org.eclipse.core.runtime.Plugin.getPluginPreferences(Plugin.java:356)at org.eclipse.jdt.launching.JavaRuntime.getPreferences(JavaRuntime.java:2060)at org.eclipse.jdt.launching.JavaRuntime.addPersistedVMs(JavaRuntime.java:1408)at org.eclipse.jdt.launching.JavaRuntime.initializeVMs(JavaRuntime.java:2554)at org.eclipse.jdt.launching.JavaRuntime.getDefaultVMId(JavaRuntime.java:501)at org.eclipse.jdt.launching.JavaRuntime.getDefaultVMInstall(JavaRuntime.java:446)at org.eclipse.jdt.internal.launching.JREContainerInitializer.resolveVM(JREContainerInitializer.java:115)at org.eclipse.jdt.internal.launching.JREContainerInitializer.initialize(JREContainerInitializer.java:57)at org.eclipse.jdt.internal.core.JavaModelManager.initializeContainer(JavaModelManager.java:2371)at org.eclipse.jdt.internal.core.JavaModelManager$13.run(JavaModelManager.java:2301)at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1800)at org.eclipse.jdt.internal.core.JavaModelManager.initializeAllContainers(JavaModelManager.java:2317)at org.eclipse.jdt.internal.core.JavaModelManager.getClasspathContainer(JavaModelManager.java:1679)at org.eclipse.jdt.core.JavaCore.initializeAfterLoad(JavaCore.java:3398)at org.eclipse.jdt.internal.ui.InitializeAfterLoadJob$RealJob.run(InitializeAfterLoadJob.java:35)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)"
241696,7/22/2008 12:05,hanke,[quick fix][quick assist] quickfix to iterate over a collection Created attachment 108083editor screenshotIt would be convenient to have a quickfix for iterating over a collection without the need to store it (eg as a local var).void foo(Map<String Integer> map) { map.keySet()<-- Cursor position here}The best way (I know) to iterate over a computed collection is - quickfix to assign as local var - use the foreach template - inline the local varA quickfix for iterating over the collection at the cursor position could save several key strokes.
242933,8/1/2008 18:00,jerome_lanneluc,"[1.5] NullPointerException for @Range(min=1 max=9999999999999999) Build ID: I20080617-2000Steps To Reproduce:1.Copy && paste the following code:package net.cellbell.model;import java.util.Date;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.SequenceGenerator;import javax.persistence.Table;import org.hibernate.validator.Range;@Entity@Table(name = ""CB_BSENDER_CH"")@org.hibernate.annotations.Entity(dynamicUpdate=true dynamicInsert=true)public class CbBsenderCh{	 // PK Type NULL? DEFAULT VAL.	private int id; // 1/1 NUMBER(9) n -	private int channel;	private Date entTime;	private Date until;	private String addr;	private String reasonDesc;		public CbBsenderCh()	{		// Intentionally empty.	}	@Id	@Column(unique = true nullable = false precision = 18 scale = 0)	//@GeneratedValue(strategy = GenerationType.AUTO generator = ""zdefinitions_seq"")	@GeneratedValue(strategy = GenerationType.SEQUENCE generator = ""cb_bsender_ch_generator"")	@SequenceGenerator(name = ""cb_bsender_ch_generator"" sequenceName = ""CB_BSENDER_CH_SEQ"" allocationSize=1)	@Range(min=1 max=9999999999999999)	public long getId()	{		return id;	}	void setId(final long id)	{		this.id = id;	}}2.Then you will get a following Exception:java.lang.NullPointerException	at org.eclipse.jdt.internal.core.util.Util.getAnnotationMemberValue(Util.java:3003)	at org.eclipse.jdt.internal.core.CompilationUnitStructureRequestor.getMemberValue(CompilationUnitStructureRequestor.java:650)	at org.eclipse.jdt.internal.core.CompilationUnitStructureRequestor.getMemberValuePair(CompilationUnitStructureRequestor.java:631)	at org.eclipse.jdt.internal.core.CompilationUnitStructureRequestor.getMemberValuePairs(CompilationUnitStructureRequestor.java:638)	at org.eclipse.jdt.internal.core.CompilationUnitStructureRequestor.enterAnnotation(CompilationUnitStructureRequestor.java:272)	at org.eclipse.jdt.internal.core.CompilationUnitStructureRequestor.enterMethod(CompilationUnitStructureRequestor.java:438)	at org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(SourceElementNotifier.java:347)	at org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(SourceElementNotifier.java:665)	at org.eclipse.jdt.internal.compiler.SourceElementNotifier.notifySourceElementRequestor(SourceElementNotifier.java:431)	at org.eclipse.jdt.internal.compiler.SourceElementParser.parseCompilationUnit(SourceElementParser.java:912)	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:196)	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:257)	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:514)	at org.eclipse.jdt.internal.core.BecomeWorkingCopyOperation.executeOperation(BecomeWorkingCopyOperation.java:38)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:709)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:770)	at org.eclipse.jdt.internal.core.CompilationUnit.becomeWorkingCopy(CompilationUnit.java:100)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.createFileInfo(CompilationUnitDocumentProvider.java:982)	at org.eclipse.ui.editors.text.TextFileDocumentProvider.connect(TextFileDocumentProvider.java:476)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.connect(CompilationUnitDocumentProvider.java:1197)	at org.eclipse.ui.texteditor.AbstractTextEditor.doSetInput(AbstractTextEditor.java:3990)	at org.eclipse.ui.texteditor.StatusTextEditor.doSetInput(StatusTextEditor.java:190)	at org.eclipse.ui.texteditor.AbstractDecoratedTextEditor.doSetInput(AbstractDecoratedTextEditor.java:1325)	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2512)	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2485)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1350)	at org.eclipse.ui.texteditor.AbstractTextEditor$19.run(AbstractTextEditor.java:3025)	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:446)	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:354)	at org.eclipse.jface.window.ApplicationWindow$1.run(ApplicationWindow.java:758)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.jface.window.ApplicationWindow.run(ApplicationWindow.java:755)	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2483)	at org.eclipse.ui.texteditor.AbstractTextEditor.internalInit(AbstractTextEditor.java:3043)	at org.eclipse.ui.texteditor.AbstractTextEditor.init(AbstractTextEditor.java:3070)	at org.eclipse.ui.internal.EditorManager.createSite(EditorManager.java:799)	at org.eclipse.ui.internal.EditorReference.createPartHelper(EditorReference.java:643)	at org.eclipse.ui.internal.EditorReference.createPart(EditorReference.java:428)	at org.eclipse.ui.internal.WorkbenchPartReference.getPart(WorkbenchPartReference.java:594)	at org.eclipse.ui.internal.EditorAreaHelper.setVisibleEditor(EditorAreaHelper.java:263)	at org.eclipse.ui.internal.EditorManager.setVisibleEditor(EditorManager.java:1410)	at org.eclipse.ui.internal.EditorManager$5.runWithException(EditorManager.java:944)	at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:31)	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:133)	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3800)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3425)	at org.eclipse.ui.application.WorkbenchAdvisor.openWindows(WorkbenchAdvisor.java:803)	at org.eclipse.ui.internal.Workbench$27.runWithException(Workbench.java:1361)	at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:31)	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:133)	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3800)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3425)	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2293)	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2198)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:493)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:288)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:488)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:113)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:193)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:382)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)	at java.lang.reflect.Method.invoke(Unknown Source)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:549)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:504)	at org.eclipse.equinox.launcher.Main.run(Main.java:1236)3.The victim is a line:@Range(min=1 max=9999999999999999)RegardsAdamMore information:"
242961,8/2/2008 14:01,Olivier_Thomann,"[DOM] ITypeBinding.getDeclaredFields returns empty results if any field has undefined type Build ID: I20080617-2000Steps To Reproduce:in a plug-in which supplies an extension to the org.eclipse.core.resources.builders extension point parse a Java compilation unit called ""A.java"" containing code like this: class A { int k; B b; }Note: there is no such class named B.in the plug-in run some code like this:parser = ASTParser.newParser(AST.JLS3);// in the delta visitor of my IncrementalProjectBuilder ...visit(IResourceDelta d) { IResource r = d.getResource(); IJavaElement je = JavaCore.create(r); icu0 = je.getAdapter(ICompilationUnit.class); // icu0 != null icu = (ICompilationUnit)icu0; parser.setSource(icu); parser.setResolveBindings(true); compilationUnit = (CompilationUnit)parser.createAST(null) compilationUnit.accept(new ASTVisitor() { public boolean visit(TypeDeclaration typeDeclaration) { typeBinding = typeDeclaration.resolveBinding(); // typeBinding != null fields = typeBinding.getDeclaredFields(); // fields.length == 0More information:There is no such class named ""B"". However I expect that getDeclaredFields() should return information about field ""k"".This used to work in Eclipse 3.3; it seems to have changed in 3.4."
243917,8/12/2008 13:43,srikanth_sankaran,"[compiler] should not warn about unused field when native method present I have a class simple as this:/* * Created on 19/05/2008 */package br.com.voicetechnology.vp.brooktrout.tasks;import java.io.IOException;import br.com.voicetechnology.vp.provider.Device;public class WaitForCall implements ChannelTask{	static	{		System.loadLibrary(""tpbrooktrout"");	}		private final int time;		public WaitForCall(int delay)	{		time = delay;	}	public native void run(Device d) throws IOException;}which has a variable and a native method. In the presence of a native method eclipse has no way to tell whether this variable is being used locally or not. Still it issues warning message. There should be an option at best to set whether I want or not this warning in the presence of native methods or at least the platform should issue no warning at all for this circumstance."
244789,8/21/2008 5:06,mateusz.matela,[formatter] Java source formatter ignores maximum line width for no obvious reason Build ID: I20080617-2000Steps To Reproduce:Set maximum line width to 80 characters.Set indentation size to 2 spaces.Set all braces to 'same line'.Try to format the files below:--- Sandbox.java ------------------------import java.util.ArrayList;import java.util.HashMap;import java.util.Map;import javax.swing.JButton;import sun.text.normalizer.UnicodeMatcher;public class Sandbox { private Map<String ArrayList<UnicodeMatcher>> m_Matchers = new HashMap<String ArrayList<UnicodeMatcher>>(); private Map<String ArrayList<JButton>> m_BlockButtons = new HashMap<String ArrayList<JButton>>();}-------------------------------------------- SelectionModuleWithTwoInputs.java ---abstract class AbstractSelectionModule {}public final class SelectionModuleWithTwoInputs extends AbstractSelectionModule {}-----------------------------------------More information:The first file maybe shows a problem with formatting generics.The problem in the second file disappears when the line is made one character longer (e.g. by substituting 'public' by 'abstract'). Possibly the attached brace is not counted when the line length is calculated.
246239,9/4/2008 11:54,jdt-ui-inbox,"[preferences] 'Restore Defaults' on Java > Compiler page does not see changed default JRE HEAD (and 3.4.2) after bug 243712The 'Restore Defaults' button on the Java > Compiler preference page does not see a changed or added default JRE (i.e. change it on the 'Installed JREs' page and then go to Compiler and click the restore button without leaving the dialog).The problem is that there's no ""working copy"" for VM installs see bug 121057."
251824,10/23/2008 6:39,daniel_megert,[save actions][clean up] Correct Indentation blocks Remove trailing whitespace from working in comments Build ID: M20080911-1700Steps To Reproduce:1. Enable save actions 'remove trailing whitespace' and 'correct indentation'.2. Create a new class add a first line of comment.3. Hit return a few times to add blank lines of comment.4. Save.5. Note trailing whitespace...6. Disable 'remove trailing whitespace'.7. Make a further edit (more blank lines whatever) and save.8. Note no trailing whitespace.More information:Maybe bug 173081 is related? Seems undesirable to ever leave trailing whitespace if the user chooses to remove it.For example we have a coding style check that our files don't contain trailing whitespace and naturally it doesn't make any exemptions for comments or anything else.It seems like its trimming whitespace first then correcting indentation which involves adding trailing whitespace to blank lines of comment. Perhaps this is down to some option in the formatter but I can't find it and I want my comments indented by a character provided there is one.===May be unrelated but I noted that if you hit return in a comment that doesn't have any trailing whitespace then the next line isn't indented either. This seems undesirable but I think padding comments with whitespace isn't a good solution if indeed that's what's how this came about.
253896,11/5/2008 6:57,amj87.iitr,"[compiler][null] wrong ""Null comparison always yields false"" problem for auto-unboxing I20081104-0916public class Unboxing {	public static void main(String[] args) {		a();		b();	}	private static void a() {		Integer i= null;		if (i == 1) // wrong problem: ""Null comparison always yields// false: The variable i can only be null at this location""			System.out.println(""a"");	}		private static void b() {		Integer i= null;		if (i.intValue() == 1) // correct: ""Null pointer access: The// variable i can only be null at this location""			System.out.println(""b"");	}}The problem reported in a() should be the same problem as in b() since both methods are effectively the same and result in an NPE."
256463,11/25/2008 11:59,philippe_mulet,"[compiler] Support common debug pattern in unreachable code detection I20081119-1600Follow-up to bug 48399.After enabling the new dead code detection compiler option we found that most hits in our codebase were debug switches as exemplified in JLS3 13.4.9 and 14.21:class Flags { final static boolean DEBUG = true; }class Test { public static void main(String[] args) { if (Flags.DEBUG) System.out.println(""debug is true""); }}Could you add this as a sub-option of COMPILER_PB_DEAD_CODE? I would only expect this exception rule to suppress warnings of one of the forms ...- 'if (DEBUG) THEN' or- 'if (DEBUG) THEN else ELSE'... where ...- DEBUG is the qualified or unqualified name of a 'static final boolean' field which is initialized to either 'true' or 'false' and- either THEN or ELSE is a statement that is marked as dead code."
257505,12/4/2008 7:09,yves.joan,"[quick fix] Dead code quick fix should remove unnecessary parentheses I20081202-1812On following unit 'b1' is flagged as dead code:class BB {	void foo(boolean b1 boolean b2) {		if ((false && b1) && b2) {		}	}}after applying quickfix (remove) it becomes:class BB {	void foo(boolean b1 boolean b2) {		if ((false) && b2) {		}	}}"
262304,1/24/2009 20:51,philippe_mulet,[1.5][compiler] Enum constant in annotation value: javac vs Eclipse differ When compiling the following code public class Foo { protected enum E { E1 E2 } protected @interface AnnoE { E value(); } @AnnoE(true ? E.E1 : E.E2) public void foo() {} }Eclipse does not produce an error but javac 1.6 does: Foo.java:8: an enum annotation value must be an enum constant @AnnoE(true ? E.E1 : E.E2) ^I suspect this has to do with whether the result of the expression (true ? E.E1 : E.E2) is considered an enum constant and I am not sure whether this is a javac bug or an Eclipse bug.
263769,2/5/2009 6:39,jerome_lanneluc,Javadoc glitches in JavaCore#setComplianceOptions(String Map) Created attachment 124793proposed fixHEADJavadoc glitches in JavaCore#setComplianceOptions(String Map):- COMPILER_CODEGEN_INLINE_JSR_BYTECODE missing- list of options appears to be fixed- typo
263771,2/5/2009 6:51,noopur_gupta,[hashcode/equals] Generated equals/hashCode implementation wrong for multidimensional arrays Build ID: M20070921-1145Steps To Reproduce:let Character[][] world...be a declared field. Select it in the generation dialog as included field in hashCode and equals. It generates - hashCode: result = prime * result + Arrays.hashCode(world);- equals: if (!Arrays.equals(world other.world)) return false;These implementations of Arrays.hashCode / Arrays.equals do not work for multidim arrays.Solution:- hashCode: for (int x = 0; x < width; x++) { for (int y = 0; y < height; y++) { result = prime * result + world[x][y].hashCode(); } }- equals for (int x = 0; x < width; x++) { for (int y = 0; y < height; y++) { if (!world[x][y].equals(other.world[x][y])) return false; } }More information:
269201,3/18/2009 10:54,ferenc.hechler,[jar exporter] ant file produced by Export runnable jar contains absolute paths instead of relative to workspace Build ID: I20090313-0100Steps To Reproduce:1. Open project with a launch configuration2. File -> Export -> Java -> Runnable JAR file3. Fill out fields (we use the new Copy required libraries into a sub-folder) and check Save as ANT script with a filename (e.g. c:\test.xml)Open test.xml with a editorSee that all file and directory references are absolute including C:\...More information:It would be very beneficial if the paths put in the ant file are relative (if possible) from the workspace folder and that that folder was stored in an ant variableThe same with the target directory. This will allow us to put the generated ant script in our source repository instead of having each developer generating the file themselves each time they start a new workspace.This is such an important facility to us that I am willing to help getting this ready for the release version of 3.5 if the Eclipse folks do not already have this in place.Best regards/Thorbj??rn
270209,3/27/2009 1:23,frederic_fusier,[format] Condensed block comment formatting I was thrilled to see all of the formatting settings that are available in Java > Code Style > Formatter. I am much happier now that I can use Ctrl+Shift+F more liberally! I'd very much like one more option (which is why I originally went looking for all of those formatting settings). I'd like block comments (non-Javadoc) to be smaller let me draw an example.(I hope this renders well on your screen. I used short lines to try and help out your email client.)/* I'd like the option to format my block * comments like this. *//* * Instead of like this. I use these a lot and * this can take up a lot of space. */I hope this is possible. Thanks everyone!Jeffonkenj@gmail.com
272657,4/17/2009 4:49,markus.kell.r,"[quick fix] 'Add Unimplemented method' should favor more specific covariant return types and subsignatures Build ID: M20090211-1700Steps To Reproduce:public class Test { interface Interface1 {Object getX();} interface Interface2 {Integer getX();} class Cls implements Interface1 Interface2 {}}More information:The ""add unimplemented methods"" quick fix generates a method with signature ""public Object getX()"" instead of ""public Integer getX()""."
275471,5/8/2009 11:19,kent_johnson,Eclipse Compiler needs a compile dependency to a plug-in but javac does not need that dependency Build ID: I20090430-2300After upgrading to Eclipse 3.5M7 my workspace does not compile anymore error message:The type org.eclipse.emf.ecore.EObject cannot be resolved. It is indirectly referenced from required .class filesWe are using Java 6. The following class does not compile with 3.5M7 (compiles well with 3.5M3):package com.avaloq.ice.core.internal;import static org.mockito.Mockito.*;import junit.framework.TestCase;import com.avaloq.ice.core.ISessionState;import com.avaloq.ice.model.dbobjects.DBObject;import com.avaloq.util.ServiceLocator;/** * Tests the class {@link DataModel}. */public class DataModelTest extends TestCase { /** * Checks the changed events: registration raising and removal. * * @throws Exception the exception */ public void testChangedEvent() throws Exception { DBObject mock = mock(DBObject.class); ServiceLocator.find(ISessionState.class).raiseChangedEvent(mock); }}- The classes DataModelTest and ISessionState are in plugin com.avaloq.ice.core. - com.avaloq.ice.core has a dependency to plugin com.avaloq.ice.model where the Interface DBObject.class is defined. - The type DBObject extends the EObject interface of EMF.- The type ServiceLocator is defined in another plugin: com.avaloq.util.- The plug-in com.avaloq.ice.model has a dependency to org.eclipse.emf.ecore but the plugin com.avaloq.ice.core has no such dependency.If I add a dependency of org.eclipse.emf.ecore in the plugin com.avaloq.ice.core the everything compiles. But this dependency shouldn't be required. otherwise a plugin would need all transitive dependencies of all parent classes...
277643,5/25/2009 3:35,srikanth_sankaran,"Generics compile error public final void addShortDescription(Object object StringBuffer buf) {		try {			W_Description wdescription = get(W_Description.classobject); // GIVES AN ERROR// Type mismatch: cannot convert from WrapperLogic to W_Description			wdescription.setVerbosity(Verbosity.terse);			wdescription.setIncludeSubDescriptions(false);			wdescription.getDescription(buf);		} catch (Exception e) {		}}public <T W extends WrapperLogic<? super T>> W get(Class<W> wrapperClass T entity) {	return getLogicFactory().get(wrapperClass entity);}It seems the compiler is unable to recognise that the get method return a W.The code compiles fine with ant and it works in Eclipse 3.4 and below."
289916,9/18/2009 18:13,sarika.sinha,StandardVMDebugger cuts of PATH environment that set in configuration User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.2; en-US) AppleWebKit/530.5 (KHTML like Gecko) Chrome/2.0.172.43 Safari/530.5Build Identifier: trunkThis is strange bug and only happens when you set exactly 4 environment variables in VMRunnerConfiguration. And of cause this happens in debug mode. The provided among these three env. vars PATH environment will be cut off in attempt to append jre bin path. See patch fix how this happens.Reproducible: Always
295401,11/17/2009 18:06,sarika.sinha,"[breakpoints] Renaming Java project with a breakpoint throws an exception User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5Build Identifier: 3.5 (20090920-1017). Also verified in 3.4.2When renaming a project in which I have created a line breakpoint an exception is thrown during the refactoring.The key to this bug seems to be that the Java source is in ""src/main/java"" instead of ""src"". I'm seeing that when LineBreakpointTypeChange.perform() is called the first thing that happens is the resource is determined by a call to BreakpointUtils.getBreakpointResource(fDestType); This returns 'L/foooo/java/A.java' instead of 'L/foob/src/main/java/A.java'The stack trace is below. Notice that the bkpt refactoring mentions '/foob/java/A.java' when it should be finding 'foob/src/main/java'.org.eclipse.debug.core.DebugException: Resource '/foob/java/A.java' does not exist.at org.eclipse.debug.core.model.Breakpoint.run(Breakpoint.java:337)at org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.<init>(JavaLineBreakpoint.java:153)at org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.<init>(JavaLineBreakpoint.java:132)at org.eclipse.jdt.debug.core.JDIDebugModel.createLineBreakpoint(JDIDebugModel.java:268)at org.eclipse.jdt.internal.debug.core.refactoring.LineBreakpointTypeChange.perform(LineBreakpointTypeChange.java:59)at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:278)at org.eclipse.ltk.core.refactoring.PerformChangeOperation$1.run(PerformChangeOperation.java:260)at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1800)at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:308)at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.executeChange(UIPerformChangeOperation.java:92)at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:220)at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1800)at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)Reproducible: AlwaysSteps to Reproduce:1. Import the attached project. (It has the .classpath set up to src/main/java)2. Set a breakpoint in A.java on the System.out line.3. Refactor - Rename project 'foo' to 'foob'==> Dialog pops up. Stack tarce above is in error log.==> Breakpoint is removed and subsequent breakpoint refactorings seem to be disabled."
297840,12/15/2009 9:18,sarika.sinha,"Strange Code in ExpressionInputDialog.dispose User-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.1.1) Gecko/20090715 Firefox/3.5.1Build Identifier: Three things make ExpressionInputDialog.dispose not ""standard"": 1) it contains a misleading dispose method although it is not a SWT widget. It seems that this kind of code is usually located in close();2) dispose was called twice (bug #296552 - verified fixed) 3) it is not necessary to dispose widgets since they are automatically disposed when closing the dialog (from Window.close()). For instance almost no other dialog uses ""getTextWidget().dispose()"". Cf. discussion around bug #296494. This seems to be a code smell and deserves a high degree of strangeness by our strange code detector. Is it worth cleaning it?Best regards -- MartinReproducible: Always"
301990,2/5/2010 12:55,noopur_gupta,"[5.0][content assist] remove '>' on backspace when type arguments inserted by content assist HEADBug 283950 shows examples where content assist automatically adds type arguments. There are also other cases where we insert them but the user does not want them (e.g. when prototyping code where raw types are good enough for the moment).Currently it's quite cumbersome to delete the arguments the '<' and the '>'. The problem could be alleviated a bit if it would be easier to remove the arguments when this happens.Example:- have ""Map|""- content assist at | gives ""Map<K V>"" with ""K"" selected- backspace gives ""Map<| V>""- second backspace gives ""Map| V>""Proposal:The second backspace should work similar to what happens today if I type ""("" or and then press backspace: In that case the auto-inserted "")"" is removed automatically.For parameterized types the analogon would be to remove the whole arguments list on the second backspace i.e. make it just leave ""Map""."
305182,3/9/2010 11:26,sarika.sinha,"[breakpoints] Refactoring a method/field with associated breakpoint changes working set Using I20100309-0100* Create breakpoint working sets A and B* Make working set A default* Create a method entry breakpoint (appears in A)* Make working set B default* refactor the method name where the breakpoint is* The breakpoint will move to working set B after being refactoredIf there is no default working set it will move to the ""Other"" category. Looks like the newly created breakpoint gets the current ""defaut working set"" applied to it rather than retaining its original working set. Same happens for refactored watch points."
306419,3/18/2010 14:05,mateusz.matela,"[formatter] Javadoc formatter should not break adjacent tokens Created attachment 162443Example CUHEADThe Javadoc formatter should not break (start a new line) between an HTML tag and an adjacent character. In the attached example ""String)</code>"" is split up into ""String)</code>"" and """" which adds a space between "")"" and """" when the Javadoc is rendered."
308217,4/6/2010 10:58,noopur_gupta,"[content assist] Override method proposal not working if '(' is typed while content assist is open UsingI got this weird problem with code completion.1) Use the following test case:public class X {	static class Y {		public boolean foo2(String s) {			return true;		}		public boolean foo2(Number n) {			return true;		}	}	public static void main(String[] args) {		Y y = new Y() {		// code assist here		};	}}2) remove the comment with ""code assist here and do Ctrl + Space at this location3) Once you have all the completion proposals type ""foo2(N"".This leaves only foo2(Number) in the list of proposals.Try to apply it it won't work.Two issues:1) If autoinsertion of ')' is set then the completion doesn't do anything2) If it is disabled then you end up with:			public boolean foo2(Number n) {};which doesn't compile.If the completion is done after typing only: foo2 and selecting ""foo2(Number) then it works as expected."
314283,5/25/2010 10:40,markus.kell.r,"[package explorer][render] Decorator on CUs for deprecated and package-visible Build Identifier: 20100318-1801In the Preferences window (General->Appearance->Label Decorations) user can set a check-box ""Java Type Indicator"". If the box is checked small icons appear in the Package Explorer: I (interface) A (abstract) E (enum).I propose the following extensions:1) (more important). Add check-box ""Java Deprecated Decorator"" which means that deprecated classes will be highlighted somehow in Package Explorer. At once I can imagine 3 variants a) strike-out; b) italic; c) diagonal line like in Outline. As for me (a) strike-out is the best variant (if the name of a class remains readable).2) (less important). Add the check-box ""Java Throwable Indicator/Decorator"" for Throwable and possibly for abstract Throwable (because Throwable can be abstract also). It can be a) Indicator so small icon will be shown for Throwable (maybe letter ""T"" and letters ""AT"" for abstract one). Or b) Decorator and the name of the class become italic for example (if deprecated decorator is not italic) or something like this.Reproducible: AlwaysSteps to Reproduce:1. Open Package Explorer."
317216,6/17/2010 12:38,sxenos,"NullPointerException in ParameterizedTypeBinding.readableName Build Identifier: I20100603-1500Running an annotation processor I'm getting the following stack trace while calling TypeMirror.toString():java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.readableName(ParameterizedTypeBinding.java:828)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.readableName(ParameterizedTypeBinding.java:836)	at org.eclipse.jdt.internal.compiler.apt.model.DeclaredTypeImpl.toString(DeclaredTypeImpl.java:123)	at org.bindgen.processor.util.BoundProperty.<init>(BoundProperty.java:51)	at org.bindgen.processor.generators.MethodPropertyGenerator.<init>(MethodPropertyGenerator.java:41)	at org.bindgen.processor.generators.MethodPropertyGenerator$Factory.newGenerator(MethodPropertyGenerator.java:260)	at org.bindgen.processor.generators.MethodPropertyGenerator$Factory.newGenerator(MethodPropertyGenerator.java:229)	at org.bindgen.processor.generators.BindingClassGenerator.getPropertyGenerators(BindingClassGenerator.java:184)	at org.bindgen.processor.generators.BindingClassGenerator.addProperties(BindingClassGenerator.java:119)	at org.bindgen.processor.generators.BindingClassGenerator.generate(BindingClassGenerator.java:62)	at org.bindgen.processor.GenerationQueue.processQueue(GenerationQueue.java:65)	at org.bindgen.processor.Processor.process(Processor.java:67)	at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundDispatcher.handleProcessor(RoundDispatcher.java:139)	at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundDispatcher.round(RoundDispatcher.java:121)	at org.eclipse.jdt.internal.compiler.apt.dispatch.BaseAnnotationProcessorManager.processAnnotations(BaseAnnotationProcessorManager.java:159)	at org.eclipse.jdt.internal.apt.pluggable.core.dispatch.IdeAnnotationProcessorManager.processAnnotations(IdeAnnotationProcessorManager.java:134)	at org.eclipse.jdt.internal.compiler.Compiler.processAnnotations(Compiler.java:809)	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:428)	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:364)	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:178)	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:301)	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:60)	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:254)	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:173)	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:629)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:172)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:203)	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:255)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:258)	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:311)	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:343)	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:144)	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:242)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)The line that is failing is enclosingType().readableName():	public char[] readableName() {	 StringBuffer nameBuffer = new StringBuffer(10);		if (isMemberType()) {			nameBuffer.append(CharOperation.concat(enclosingType().readableName() this.sourceName '.'));		} else {			nameBuffer.append(CharOperation.concatWith(this.type.compoundName '.'));		}isMemberType() is true but the enclosingType field is null.The error is happening with:* TypeElement te = java.util.Map* ExecutableElement ee = te.getEnclosed() if kind==name and name==entrySet* TypeMirror tm = ee.getReturnType* tm.toString() --> NPENote that tm is the DeclaredTypeImpl that is 3 lines into the NPE stack trace.While tm.toString() fails (it calls _binding.readableName()) if I debug and look at _binding it toStrings() as: public interface Set<Entry<KV>>	extends NULL TYPENULL SUPERINTERFACESNULL FIELDSNULL METHODSInside the _binding.readableName nameBuffer had gotten to: java.util.Set<And it is calling into the 1st type parameters readableName. This binding can also toString:public static interface Entry<KV>	extends NULL TYPENULL SUPERINTERFACESNULL FIELDSNULL METHODSBut it's readableName is what is blowing up.I've made a separate project to reproduce it but unfortunately it works just fine. I get to the same binding and in this new project it toStrings as:public static interface Entry<KV>	extends NULL TYPENULL SUPERINTERFACES	enclosing type : Map#RAWNULL FIELDSNULL METHODSNote that enclosign type is no longer null.I have no idea why my more complex project would lead to the enclosing type being null.I can keep poking around but suggestions are welcome.Also note that I'm seeing this behavior in both the latest 3.5 and 3.6.RC4.Reproducible: AlwaysSteps to Reproduce:I cannot reproduce it outside of my current project yet."
317719,6/23/2010 11:42,amj87.iitr,"Method incorrectly flagged as having same erasure output when return type differs The following class fails to compile under Eclipse 3.6 but works fine with Eclipse 3.5 and javac. The methods are distinguished by the different return type as having the same return type makes javac report two compilation errors as well.bc.. package com.example;import java.util.List;public class ErasureBug { public String output(List<Integer> integers) { return """"; } public void output(List<Double> doubles) { }}"
318437,6/30/2010 7:01,eclipse,Organize Imports ignores Number of Imports needed for .* Build Identifier: 20100617-1415The Number of Imports needed for .* is ignored when organizing imports via Ctrl+Shift+O.The Number of Imports is configured to 2. My class has 3 imports of the same package which could be replaced by .*. When the imports are organized nothing is happenening.If I replace the 3 imports manually with .* and then organize the imports via Ctrl+Shift+O again .* is replaced with the 3 imports again.Reproducible: AlwaysSteps to Reproduce:1. Configure Number of Imports to 2 (Preferences/Java/Code Style/Organize Imports/Number of Imports needed for .*)2. Create a Class with more than 2 imports of the same package.3. Organize the imports via Ctrl+Shift+P.4. Nothing is happening although the imports should be replaced with .*.
318680,7/2/2010 5:27,lshanmug,"Update SWT cheat sheet: Unable to install the ""SWT Binary and Source"" package as project in Eclipse Helios Build Identifier: 20100617-1415I followed the cheat sheet ""Create a Hello World SWT Application"" and downloaded the SWT Binary and Source Package for Windows 32 Bit (swt-3.6-win32-win32-x86.zip).It is not possible to import this package as project (as described in the cheat sheet) because the files .project and .classpath are missing in the archive.As a workaround I used the archive for Eclipse 3.5 imported the project and the replaced the files by the content of the archive for 3.6.Reproducible: AlwaysSteps to Reproduce:1. Download the package swt-3.6-win32-win32-x86.zip2. Try to import the SWT project from the main menu via File > Import... and select Existing Projects into Workspace. Specify the archive file you downloaded and click Finish3. This process will fail."
318681,7/2/2010 5:35,noopur_gupta,"[quick assist] create fields from multiple parameters Build Identifier: There is already a function Source->Create constructor using fields. I would like just the opposite.When I program I call constructors that do not exists:MyClass m = new MyClass(""first"" ""second"" ""third"");I then use the light bulb to create this new constructor. Inside the constructor I change the names of the parameters and begin the hard work I would like some help with:public MyClass(String firstValue String secondValue String thirdValue){// These lines could be generated automatically// Prefix 'i' is already there under ""Code Templates""iFirstValue = firstValue;iSecondValue = secondValue;iThirdValue = thirdValue;}// Also the fields would have to be created:private String iFirstValue;private String iSecondValue;private String iThirdValue;Reproducible: Always"
321695,8/4/2010 6:59,Olivier_Thomann,"Test added for bug 319425 doesn't detect the bug Look at https://bugs.eclipse.org/bugs/show_bug.cgi?id=319425#c17. The test added org.eclipse.jdt.core.tests.compiler.regression.ProblemTypeAndMethodTest#test107 doesn't detect the bug. The ""catch (Error)"" also catches the bogus ClassFormatError. The comment also includes the patch from Stephan."
321926,8/5/2010 17:25,srikanth_sankaran,"Erroneously deems null check conditional branch to be dead code and produces incorrect bytecode On upgrading to Eclipse 3.6.0 I found erroneous reporting of ""Dead code"" in some of my projects. My unit tests revealed that the eclipse compiler was erroneously optimizing out a condition branch!I produced a minimal example and retested under the current 3.6.1 M-build M20100728-0800.Here is the code:=======================================================================package bugdemo;import java.io.IOException;public class BugDemo { public static void main(String[] args) { String someVariable = null; int i = 0; try { while (true) { if (i == 0) { someVariable = ""not null""; i++; } else { throw new IOException(); } } } catch (IOException e) { // having broken from loop continue on } if (someVariable == null) { System.out.println(""The compiler is buggy""); } else { System.out.println(""The compiler is not buggy""); } }}=======================================================================Compile and run under Eclipse 3.5 --> prints ""The compiler is not buggy""Compile and run under Eclipse 3.6 --> prints ""The compiler is buggy"""
325631,9/17/2010 12:52,mateusz.matela,"[formatter] Code formatter Expressions > Assignments lacks ""Wrap before operator"" option Build Identifier: 20090621-0832In the code formatter options under ""Binary expressions"" there is a checkbox to activate the ""Wrap before operator"" option. This feature is missing from Expressions > AssignmentsReproducible: AlwaysSteps to Reproduce:Project Properties > Java Code Style > Formatter > Line Wrapping > Expressions > AssignmentsThere is no checkbox for ""Wrap before operator"" as there is in Project Properties > Java Code Style > Formatter > Line Wrapping > Expressions > Binary expressions"
326505,9/29/2010 5:48,darin.eclipse,Missing 'null' check: fetching lib/launchingsupport.jar can return null HEAD.Missing 'null' check: fetching lib/launchingsupport.jar can return null.
327193,10/7/2010 4:53,Michael_Rennie,"[patch] Launching command line exceeds the process creation command limit on Windows Build Identifier: 3.6.x I20100608-0911In case you have a very huge classpath and also many VM arguments for your junit test suite you are not able to run it inside eclipse. The internal builded command line for the RemoteTestRunner process gets too long and reaches the windows xp limit (8191 characters).The error you get looks like this: Pop up ""Problem occured"" with Message: Exception occurred executing command line.Cannot run program ""C:\Apps\Tip60\cs\java\jdk160_16\bin\javaw.exe"" (in directory ""C:\DevWork\Projects\Frontnet\rmt.head\RMT\lib\RMT""): CreateProcess error=87 The parameter is incorrectStack Trace from Error Log:java.io.IOException: Cannot run program ""C:\Apps\Tip60\cs\java\jdk160_16\bin\javaw.exe"" (in directory ""C:\DevWork\Projects\Frontnet\rmt.head\RMT\lib\RMT""): CreateProcess error=87 The parameter is incorrectat java.lang.ProcessBuilder.start(Unknown Source)at java.lang.Runtime.exec(Unknown Source)at org.eclipse.debug.core.DebugPlugin.exec(DebugPlugin.java:827)at org.eclipse.jdt.launching.AbstractVMRunner.exec(AbstractVMRunner.java:73)at org.eclipse.jdt.internal.launching.StandardVMRunner.run(StandardVMRunner.java:317)at org.eclipse.jdt.junit.launcher.JUnitLaunchConfigurationDelegate.launch(JUnitLaunchConfigurationDelegate.java:174)at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:853)at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:702)at org.eclipse.debug.internal.ui.DebugUIPlugin.buildAndLaunch(DebugUIPlugin.java:923)at org.eclipse.debug.internal.ui.DebugUIPlugin$8.run(DebugUIPlugin.java:1126)at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)Caused by: java.io.IOException: CreateProcess error=87 The parameter is incorrectat java.lang.ProcessImpl.create(Native Method)at java.lang.ProcessImpl.<init>(Unknown Source)at java.lang.ProcessImpl.start(Unknown Source)... 11 moreThere exist currently no workaround to solve that issue. You need to rewrite your testsuite e.g. by using ant inorder to shorten the command line by uisng a ""proxy"" process which has an own class loader andconfiguration loader.Expectation:- extend the Junit Runner add a configuration option for passing over an own classpath which uses a java class loader before the test starts.- don't use the command line to pass over the classpath or configuration (syste m properties)- Please have a look at the IDE ""Idea"" there they are using also an own runner but the classpath configuration is not passed via a command linerefer also to: http://www.eclipse.org/forums/index.php?t=msg&th=197955http://support.microsoft.com/kb/830473many thanks in advance.regardsMarkReproducible: AlwaysSteps to Reproduce:1. create one single project with many jar files in the classpath. The path for each jar file should be long. The overall string for the full class path should approx. exceeds 8100 characters 2. write a junit test for that project3. setting up a junt run configuration and some VM arguments. Use as classpath the path of the project. If necessary add the Junit library additionally to the classpath4. try to run the junit test."
330313,11/16/2010 3:06,frederic_fusier,"[formatter] 'Never join already wrapped lines' formatter option does correctly indent N20101114-2000.1. enable 'Never join already wrapped lines' in the formatter profile2. paste this (all indents are tabs):public class Test {	private void helper2(boolean[] booleans) {		if (booleans[0]) {		}	}}3. format (Ctrl+Shift+F) ==> correctly indents the third line with 3 tabs4. now add some more indentation to line 3 (either tabs and/or spaces)5. format (Ctrl+Shift+F) ==> BUG: the indentation of line 3 is not correct"
330878,11/23/2010 1:12,sarika.sinha,"[breakpoints] BreakpointMarkerUpdater not removing markers correctly I20101109-0800Use the following snippet and place the breakpoints where indicated:public class C {	public static void main(String[] args) {		System.out.println(); //BP on this line		System.err.println(); //BP on this line	}}Steps:1. create the class above2. add the breakpoints as indicated3. remove the System.out.println(); line4. saveExpectedThe breakpoint on the System.out.println(); would be removedHappensYou are left with a breakpoint on an empty line"
335224,1/24/2011 13:04,raksha.vasisht,[JUnit] New JUnit Test Case wizard doesn't store method stub selection state HEADThe New JUnit Test Case wizard doesn't store method stub selection state when you click Finish on the first page. Reason is that NewTestCaseWizardPageOne#saveWidgetValues() is only called on setVisible(false).
335363,1/25/2011 13:51,Michael_Rennie,'Add Java Exception Breakpoint' dialog has truncated text for its checkboxes if font size is increased Created attachment 187559Screenshot depicting the problem in question.I20110124-18001. Window > Preferences > General > Appearance > Colors and Fonts2. Basic > Dialog Font3. Increase the font size.4. Click 'OK'.5. Run > Add Java Exception Breakpoint...6. Notice that the text in the checkbox is truncated(!). Resizing/maximizing the dialog doesn't seem to help.
337799,2/22/2011 4:24,srikanth_sankaran,"[1.7][compiler][varargs] Eclipse fails to report error on incorrect SafeVarargs usage The following program is supposed to elicit two compilererrors on the application of the SafeVarargs annotationto (a) a non varargs method (b) a non final instance method.javac correctly complains on these while eclipse fails to.import java.util.List;public class X {	@SafeVarargs	public static <T> List<T> asList() { // Error not varargs		return null;	}	@SafeVarargs	public <T> List<T> asList2(T ... a) { // error not static or final		return null;	}	@SafeVarargs	public static <T> List<T> asList3(T ... a) { // OK varargs & static		return null;	}	@SafeVarargs	public final <T> List<T> asList4(T ... a) { // OK varargs & final		return null;	}	@SafeVarargs	public final static <T> List<T> asList5(T ... a) { // OK varargs & static & final		return null;	}}"
338398,2/28/2011 6:39,jarthana,"Code assist is case sensitive for statically imported methods In a Java file with:import static org.junit.Assert.assertNotNull;typing in code ""assertno"" and then pressing ctrl+space gives no proposals.Typing ""assertNo"" and the ctrl+space on the other hand offers assertNotNull as expected.-- Configuration Details --Product: Eclipse 1.3.1.20100913-1228 (org.eclipse.epp.package.jee.product)Installed Features: org.eclipse.jdt 3.6.1.r361_v20100714-0800-7z8XFUSFLFlmgLc5z-Bvrt8-HVkH"
339292,3/8/2011 17:20,eclipse,"[type wizards] New Annotation dialog could allow generating @Documented @Retention and @Target Build Identifier: 20110301-1815When creating an annotation through the ""New > Annotation"" mechanism a developer must always manually add the desired @Retention and @Target annotations in the text editor after the initial code is generated. Code completion can help this but it could be done more simply (from the user's perspective) by having radio buttons (for @Retention) and checkboxes (for @Target) in the New Annotation dialog.Reproducible: AlwaysSteps to Reproduce:1. Right-click a Java package or source folder.2. In the context menu select New then Annotation.3. No Retention or Target controls are present."
340635,3/22/2011 6:16,jarthana,Types#erasure() doesn't return the raw type. Build Identifier: 20110301-1815Currently the Types#erasure() method doesn't return the erased type. If a generic type is given as a parameter the raw type isn't returned. For example if the generic type is something like MyClass<String> the erased type is MyClass<T> and not the raw type MyClass (which is the return of the Oracle implementation of JSR 269).Reproducible: Always
341232,3/29/2011 9:50,Michael_Rennie,Eclipse is not able to set the simplest of conditional breakpoints and reports that the condition has compilation errors when it doesn't Build Identifier: 20110218-0911I have set a conditional breakpoint in one of my objects with the following condition:this.hashCode() == 518877755Whenever this method is called by the application Eclipse complains that:Conditional breakpoint has compilation error(s).Reason:Evaluations must contain either an expression or a block of well-formed statementsReproducible: SometimesSteps to Reproduce:1. Set a conditional breakpoint in an object's method.2. Run debugger and get that method to be executed.3.
342858,4/14/2011 11:31,jdt-ui-inbox,"[inline] inlining all invocations of a method does not work for method with non-final enum type Build Identifier: M20110210-1200Not always but often selecting a method and inlining ""All invocations"" of it does not work. If you have ""Delete method declaration"" selected that does take affect leaving all the callers referring to a now deleted method and thus compilation breaks.There are no errors from the refactoring itself it just fails silently.I'm marking this Major I think of this as being a critical refactoring. It's necessary whenever a change to a method is more than just a signature change.Reproducible: AlwaysSteps to Reproduce:1. Inline CouponChoice.getFrequency().2. See the caller not change."
348338,6/5/2011 14:17,mateusz.matela,[formatter] Bad line breaking in Eclipse javadoc comments Build Identifier: 20110218-0911If a javadoc line ends with the closing brace of a tag in the last line before the current line wrap setting and is followed immediately by a period formatting the code will move the period to the start of the next javadoc line. This puts white space between the text and the period in the generated output so a browser rendering the Javadoc in HTML for instance will also think it's okay to break there. This doesn't seem to happen unless the period follows a Javadoc tag. (For instance if the line ended with a closing parenthesis and a period in column 81 it would correctly break before the last word.)Reproducible: AlwaysSteps to Reproduce:1. Write some Javadoc like this:/** * - - - stuff - - - {@code mTasksBelow}. */where the period is at the wrap column + 1.2. Format the code (using CTRL-SHIFT-F or Source > Format.
349032,6/10/2011 9:58,sarika.sinha,"Can't traverse Map.Entry in display mode Build Identifier: 20110218-0911While debugging a desktop application I tried to evaluate the follwoing expression on the display tab:for(java.util.Map.Entry<StringObject> o : extraParams.entrySet()) {	System.out.println(o.getKey() + "" "" + o.getValue());}The following exception occurs:An internal error occurred during: ""JDI thread evaluations"".Invalid primitive signature: ""Ljava.util.Map$Entry;""Reproducible: AlwaysSteps to Reproduce:1. Debug some code with a map in it2. Try to evaluate the expression above"
350000,6/22/2011 1:30,gabor,"[content assist] Include non-prefix matches in auto-complete suggestions Build Identifier: 20110218-0911As we bring new developers in to our group one enhancement request from devs coming from visual studio or intelliJ is the matching of identifiers based on substrings-- not just prefixes. I thought for sure this had to have been opened before but I couldn't find this in bugzilla. If this is a duplicate then please disregard.For example:I have a class:class A { private String connectionsStringInformation; private String getCnxString() { return Info[ctrl+space]In VS and IDEA connectionStringInformation shows up in the autocompletion list whereas in Eclipse the list seems to only work based on prefixes.I looked around through the source a little and I (have no idea if I'm in the right place) but BinaryTypeEncoding has getFields and getMemberType where I see it doing a binary search on a lazily sorted list of field names -- which makes sense. Obviously you wouldn't want the cost of linearly scanning everything. However perhaps they are ""indexing"" the prefixes and all of the camelCase boundaries so that a match on any of those would add that to the completion list. I see that the idea of ""prefix"" matching seems pretty pervasive through the autocomplete code (param names etc.).Has this been something you have considered? It does seem like a potentially large effort but if it's not as bad as it might seem I would love to be able to contribute a plugin that could do this. Mylyn messes around with the autocomplete list today -- so obviously its possible...Reproducible: Always"
351956,7/13/2011 7:53,manju656,[1.7][clean up][quick assist] Remove unnecessary type arguments (was: Suggest to use <> where applicable) Bug 349336 provides a quick fix. This can be provided as a cleanup and also possibly as a quick assist (see Bug 349336 comment 12)
356851,9/6/2011 15:22,manpalat,[formatter] Default line size of Java code formatter should be increased to 120 I suggest to change the default line size of the Java Editor to 120. I did a poll in my blog and the majority would like to see this change. http://www.vogella.de/blog/2011/09/06/eclipse-default-line-length-of-80-chars-outdateComments on Google+ seemed to follow the same pattern:https://plus.google.com/104044918586174763681/posts/EydgeWHdvyX
357450,9/13/2011 4:10,noopur_gupta,Class folder in Java project have refresh problem Build Identifier: 20110615-0604If you rename a file that is contained in a class folder the file get renamed but the Package Explorer still shows the old name. Doing a refresh (F5) solve the issue.Note: this issue also exists in bothVersion: Indigo Release Build id: 20110615-0604Version: Helios Service Release 2 Build id: 20110218-0911Reproducible: AlwaysSteps to Reproduce:1. Create a java project (i.e. test)2. Create a folder at the root of the project (i.e. classFolder)3. Edit the Java Build Path4. In the Libraries tab click Add Class Folder...5. Select the folder created in step 2 (i.e. classFolder)6. In the Package Explorer create a file (i.e. Right click > New > File > test.txt)7. (BUG) The file is shown in test/Referenced Libararies/classFolder BUT NOT in test/classFolder. (see screenshot1.png)8. (WORKAROUND) Do a refresh on the test/classFolder. The file appears. (see screenshot2.png)9. Rename the file in the test/classFolder. (i.e. Right click > Refactor > Rename...) (see screenshot3.png)10. (BUG) The UI doesn't get refreshed. (see screenshot3.png)11. (WORKAROUND) Do a refresh on the test/classFolder. The file appears. (see screenshot4.png)
357795,9/15/2011 9:15,eclipse,"[organize imports] Organize imports discards unresolvable imports Build Identifier: I20110613-1736 (3.7.0)If the Organize Imports functionality cannot resolve an import statement it simply discards it. I consider this as plain wrong - preferably Eclipse should leave code it cannot process untouched.This one is especially annoying when ""organize imports"" is / has to be used as safe action due to project requirements as such inconsistent states might very well be worth saving from time to time.Reproducible: AlwaysSteps to Reproduce:1. Create a class with some unresolvable non-qualified type reference and an import for this type2. Call Organize-Imports"
360368,10/9/2011 17:25,markus.kell.r,[key binding] Hot Key for Skip All Breakpoints Build Identifier: 20110916-0149I am a developer and I always add two hot keys to Skip All Breakpoints and Remove All Breakpoints commands. I use it a lot and think it could help others if the original JDT comes with these hot keys.I use Ctrl + Alt + S to Skip all and Ctrl + Alt + R to Remove All. They aren't binding in original JDT.Reproducible: AlwaysSteps to Reproduce:1. Add Ctrl + Alt + S to Skip All Breakpoints command2. Add Ctrl + Alt + R to Remove All Breakpoints command3. Use it. :)Sorry as this is a simple enhancement suggestion I dont know what exactly to put here.
360789,10/13/2011 6:27,eclipse,Organize imports changes static imports to .* even when that introduces compile errors Build Identifier: I20110613-1736I have two enums with similarly named fields:enum Horizontal {TOP CENTER BOTTOM}enum Vertical {LEFT CENTER RIGHT}I have code that uses them like this:import Horizontal.TOP;import Vertical.CENTER;// in some methodsetAlignment(TOP CENTER);I have the organize imports action configured to replace static imports with .* whenever there's 1 or more. (Window menu -> Preferences -> Java -> Code Style -> Organize Imports -> Number of static imports needed for .* = 1)Now organizing imports will change the imports to:import Horizontal.*;import Vertical.*;Since Horizontal also offers a CENTER constant my method call no longer compiles since it expects an instance of Horizontal and one of Vertical and it now gets two of Horizontal.Reproducible: AlwaysSteps to Reproduce:1. Organize imports in code and settings as described above
362888,11/4/2011 7:02,matthias,[spell checking] New words for spelling check Please add the following word(s) to the JDT spell check:+screenshot+screenshots
364450,11/22/2011 5:24,amj87.iitr,"Dubious class path error triggers a full rebuild The following test case should show two fatal errors regarding unresolved w.I. If we do some change e.g. change the type of w.W#i from w.I to I and then undo this change we will get two build path errors:1. ""The project was not built since its build path is incomplete. Cannot find the class file for w.I. Fix the build path then try building this project""2. ""The type w.I cannot be resolved. It is indirectly referenced from required .class files""We can observe the same problem if we change the order of imports in a.A instead of changing the type of w.W#i. After the clean correct errors are shows again.----------%<-----------package a;import w.I;import w.W;public class A {}package w;public class W {	private w.I i;}----------%<-----------"
366014,12/8/2011 7:08,markus.kell.r,Make it easier to setup null analysis I20111207-2118.Make it easier to setup null analysis.Ideas:- Add Quick Assists that allow to declare stuff as being null/non-null and when invoked help with the initial setup (if needed).- Do it similar to what we do for JUnit4.
368152,1/9/2012 8:10,jarthana,"ConcurrentModificationException on startup in ExternalFoldersManager.createPendingFolders Build ID: 3.7.1 M20110909-1335When launching Eclipse with an existing workspace I got an error dialog An internal error occurred during ""Initialize Java Tooling""and following backtrace was listed in the error log:java.util.ConcurrentModificationException	at java.util.HashMap$HashIterator.nextEntry(HashMap.java:793)	at java.util.HashMap$KeyIterator.next(HashMap.java:828)	at org.eclipse.jdt.internal.core.ExternalFoldersManager.createPendingFolders(ExternalFoldersManager.java:171)	at org.eclipse.jdt.core.JavaCore.initializeAfterLoad(JavaCore.java:3614)	at org.eclipse.jdt.internal.ui.InitializeAfterLoadJob$RealJob.run(InitializeAfterLoadJob.java:36)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)"
368435,1/12/2012 5:56,srikanth_sankaran,[compiler] NPE while compile a method with unused local Build Identifier: I20110613-1736with https://bugs.eclipse.org/bugs/show_bug.cgi?id=328519 you have made an change in the jdt java compiler.since this change you can??t create class files from the attached code.in my oppinion is this an error in the java compile.see AbstractMethodDeclaration.java / generateCode(ClassScope classScope ClassFile classFile) {...}thx.Olliver JohannReproducible: AlwaysSteps to Reproduce:1. see eclipse project2. compile java-files3. check class files
368527,1/13/2012 5:13,sarika.sinha,[search] Allow search for references in workspace to start from multiple selection I want to for example mark more all constructors in the outline and searchfor all of them but the search menu is only available for a single selection.
370540,2/3/2012 6:56,mateusz.matela,[Formatter] New settings for parentheses positions Build Identifier: 20110916-0149Examples of my preferred formatting/wrapping style:If max line length not exceeded:void exampleMethod(ExampleClass1 exampleparam1 ExampleClass2 exampleParam2) { // ...}If max line length exceeded:void exampleMethod( ExampleClass1 exampleparam1 ExampleClass2 exampleParam2) { // ...}The closest that I can currently get to that with Eclipse's formatter is this:void exampleMethod( ExampleClass1 exampleparam1 ExampleClass2 exampleParam2) { // ...}I can get it to put each parameter on a separate line and use regular indentation for them but there doesn't seem to be an option to put the ending parenthesis on a new line.Having such an option would be greatly appreciated :)Another example with class declarations:class ChildClass extends ParentClass implements ExampleInterface{ // ...}This is achievable if I set opening braces to always be on a new line but I'd still like it to remain on the same line if the line does not exceed the max length:class ChildClass extends ParentClass { // ...}Plus even if I set braces to be on a new line closing parenthesis will still remain on the previous line when wrapped.More examples of preferred wrapping in other areas:if ( exampleValue1 == exampleValue2 && exampleValue3 == exampleValue4) { // ...}exampleObject.exampleMethod( exampleParam1 exampleParam2 exampleParam3 exampleParam4);try ( ExampleClass1 exampleObject1 = new ExampleClass1(); ExampleClass2 exampleObject2 = new ExampleClass2()) { // ...}catch ( ExampleExceptionClass1 | ExampleExceptionClass2 | ExampleExceptionClass3 e) { // ...}Reproducible: Always
376977,4/17/2012 9:53,anchakrk,"Content Assist / Quick Fix import suggestion for nested annotations with argument list Build Identifier: 3.6.2. Build id: 20120216-185Not sure if this is JPA related or JDT related however I met this during playing with JPA and Hibernate annotations.Use this code:package org.jira;import javax.persistence.Entity;import javax.persistence.Id;import org.hibernate.annotations.Index;//import org.hibernate.annotations.Parameter;import org.hibernate.annotations.Type;import org.hibernate.annotations.TypeDef;@Entity(name=""EntityWithType"")@TypeDef(name=""encryptedPasswor"" typeClass=org.jira.EncryptedStringType.classparameters = { @Parameter(name=""password"" value=""blah blah blah."") })public class EntityWithType { @Id private int id; @Index(name = ""rrr"") @Type(type = ""encryptedPasswor"") private StringBuilder typeClass; }There is no quick fix import for inner @JPA or @Hibernate annotation (@Parameter in this case)Reproducible: AlwaysSteps to Reproduce:1. Create Class2. See description paste code or anything similar (@annotation with inner @Annotations defined)3. Try quickfix there is no import suggestion for inner annotations"
377710,4/25/2012 18:06,jarthana,"IJavaProject.findType(String) returns incorrect IType If a Java project has a class named ""Foo"" in the default package IJavaProject#findType(String) will return the IType corresponding to ""Foo"" if the named passed to the method is "".Foo"". (Note the '.' at the beginning of the string.) The method should return null."
379793,5/17/2012 6:56,amj87.iitr,"formatter hangs Build Identifier: Version: 3.8.0 Build id: I20120516-2100Every time I try to format the source for the attached file eclipse hangs.I will attach a zip containing the file and the exported formatter-xml.My Java-Version: java version ""1.7.0_06-ea"" Java(TM) SE Runtime Environment (build 1.7.0_06-ea-b09) Java HotSpot(TM) Server VM (build 23.0-b21 mixed mode)This is not the only source - but with this I can reproduce it always.Reproducible: Always"
380188,5/21/2012 21:00,srikanth_sankaran,[1.8][lambda] Add support for Lambda Expressions (JSR 335) This will serve as the root bug for the project to addsupport for JSR 335: Lambda Expressions aka Closures akaAnonymous methods. The draft specification is under review and as this progressesvarious other defects will be spawned off to address specific lineitems/unit tasks that are best addressed independently and linkedto this root bug as blockers. Folks interested in listening in on and/or tracking discussion work breakdown ownership progress issues concerns estimates etcshould subscribe here.
380190,5/21/2012 21:10,srikanth_sankaran,[1.8] Add support for Java SE 8 This is the top level bug to track Java 8 implementation effortin JDT/Core. At the moment the JDT team has been invited to listen in and sois privy to discussions on two topics: JSR308: Type annotations tracked via bug# 287648 and JSR335: Lambda Expressions tracked via bug# 380188
381392,6/1/2012 11:11,manpalat,"[1.5][search] for references to overriding method with bound type variable doesn't work across projects Created attachment 216671example projectsFollow-up to bug 123836 (which fixed the single-project version of this bug)Search for references to org.eclipse.egit.ui.internal.history.SWTPlotRenderer#laneColor(SWTLane)=> no match although org.eclipse.jgit.revplot.AbstractPlotRenderer#paintCommit(PlotCommit<TLane> int) refers to the super method org.eclipse.jgit.revplot.AbstractPlotRenderer#laneColor(TLane)I think the problem is inMatchLocator.getType(Object char[]) line: 899where unitScope is org.eclipse.jgit.revplot.AbstractPlotRenderer so the sought type ""org.eclipse.egit.ui.internal.history.SWTPlotRenderer"" is not in scope since it is in a dependent project.The attached example projects replicate the involved classes of the original example. When you move the classes from the egit project into the jgit project then the search works fine."
381768,6/5/2012 15:49,Michael_Rennie,"'Parts did not open' test failures In the I20120604-1900 build (but have failed before this as well)testAutoCloseDebugPerspective	Failure	Parts did not open: org.eclipse.jdt.debug.tests.context.view.one org.eclipse.jdt.debug.tests.context.view.twojunit.framework.AssertionFailedError: Parts did not open: org.eclipse.jdt.debug.tests.context.view.one org.eclipse.jdt.debug.tests.context.view.twoat org.eclipse.jdt.debug.tests.ui.ViewMangementTests.testAutoCloseDebugPerspective(ViewMangementTests.java:230)at org.eclipse.jdt.debug.tests.AbstractDebugTest.runBare(AbstractDebugTest.java:2294)at org.eclipse.jdt.debug.tests.DebugSuite$1.run(DebugSuite.java:55)at java.lang.Thread.run(Thread.java:722)The test do not fail locally although I did notice that while the tests are running the entire debug perspective opens as a fast view - not sure if that affects the tests on the build machine or not."
381942,6/7/2012 0:38,markus.kell.r,JavaLeakTest fails in 4.2 build The test has been failing for a few days on all 3 platforms.http://download.eclipse.org/eclipse/downloads/drops4/I20120604-1900/testresults/html/org.eclipse.jdt.ui.tests_linux.gtk.x86_6.0.htmlhttp://download.eclipse.org/eclipse/downloads/drops4/I20120604-1900/testresults/html/org.eclipse.jdt.ui.tests_macosx.cocoa.x86_5.0.htmlhttp://download.eclipse.org/eclipse/downloads/drops4/I20120604-1900/testresults/html/org.eclipse.jdt.ui.tests_win32.win32.x86_7.0.html
382590,6/14/2012 3:30,jarthana,"TypesImpl.asMemberOf must also work with a subclass and its superclass' element Build Identifier: Version: Indigo Service Release 2 Build id: 20120216-1857Let's say we have two classes:public class Base<T> { T field;}public class Concrete extends Base<Long> {}Then the following call should be legitimate and it is so in Oracle javac but raises IllegalArgumentException in JDT:Types types = ...;Elements elems = ...;TypeMirror concreteType = elems.getTypeElement(""Concrete"").asType();Element baseField = elems.getTypeElement(""Base"").getEnclosedElements().get(0);TypeMirror tm = types.asMemberOf(concreteType baseField);Reproducible: AlwaysSteps to Reproduce:1. Write an annotation processor having the code snippet shown in Details section.2. Prepare forementioned classes too.3. Compile the codebase and see what's shown in the error log."
382701,6/15/2012 3:32,srikanth_sankaran,[1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expressions. This ER will serve as the top level umbrella entry to track semanticanalysis support for Lambda expressions & Method and constructor references.(https://bugs.eclipse.org/bugs/show_bug.cgi?id=380501 will be used totrack support for default methods.)Separate bugs will be spawned for unit tasks in this project and linkedto this entry.When resolved we would be able to reject every semantically illegal programwith a suitable/appropriate diagnostic. The further treatment of welldefined programs will be the subject matter of ERs that will be createdlater.
382721,6/15/2012 5:56,jesper,[1.8][compiler] Effectively final variables needs special treatment BETA_JAVA8(1) The following program which does not compile under 1.7-should now begin to compile with Java 8:// -------- 8< -----------public class X { public static void main(String[] args) { X x = new X() { void foo() { System.out.println(args); } }; }}The proposed amends to 8.1.3 allow for a local class including anonymousclasses to use effectively final variables from its surrounding context.(2) Likewise we need to also allow lambda expressions to reference effectivelyfinal definitely assigned local variables formal parameters orexception handler parameter from the surrounding context (in additionto finals)
383096,6/20/2012 8:55,srikanth_sankaran,"[1.8][compiler]NullPointerException with a wrong lambda code snippet With this code snippet I get a NullPointerException. ###interface I {}class XI {	void foo() { 	I t1 = f -> {{}; 	I t2 = () -> 42; } }###java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:195)	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:105)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:507)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:259)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:466)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1162)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1272)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:561)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1200)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:685)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1181)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:807)"
383378,6/24/2012 14:19,srikanth_sankaran,[1.8][compiler] analyze performance impact of scanner/parser changes Bug 380194 introduced same changes to the parser / scanner that affect performance. The design works hard to avoid performance degradation but so far we have no measurements that can guide us in the choice between different strategies.E.g. I'd like to see if method Parser.parserAtConflictScenario() is worth the effort: is it saving relevant efforts in scanner look-ahead (Scanner.atLambdaParameterList() and atReferenceExpression()) to balance the initial efforts?In a first naive measurement I ran org.eclipse.jdt.core.tests.compiler.parser.TestAll with slight variations in the code.To my own surprise I saw that simply turning 1.8 mode on seemed to degrade performance by approx. 9% but I could not observe any difference related to parserAtConflictScenario() (delta < 0.1%).At this point the experiment was too naive to yield reliable figures but there seems to be some issue that I'd like to narrow down before finalizing the new parser design.Can we identify a relevant subset of tests? Is ...parser.TestAll already a good candidate?What would be a test case for the worst case scenarios mentioned in bug 380194 comment 24?
383780,6/28/2012 7:54,amj87.iitr,[compiler] Eclipse 4.2 creates ambiguous varargs method error in 1.6 compliance mode (does not mimic JDK bug) Build Identifier: Build id: I20120608-1400The following code works in java 1.6 and Eclipse 3.7 but fails to compile in Eclipse 4.2 with compiler level set to 1.6 and autoboxing to error:The method test(int[]) is ambiguous for the type VarargPrimitiveTestimport java.util.Arrays;public class VarargPrimitiveTest { public static void test(int... a) { System.out.println(Arrays.toString(a)); } public static <T> void test(Object... a) { System.out.println(Arrays.toString(a)); } public static void main(String[] args) { test(1); }}Reproducible: Always
384567,7/9/2012 3:02,jesper,[1.5][compiler] Compiler accepts illegal modifiers on package declaration 3.8: Probably has always been buggy.The following program compiles with ECJ while it should not:// --------------public package p;public class X {}
384667,7/9/2012 17:48,shankhba,"[1.8][compiler] better source positions for lambda expressions Is it OK to always just use one pair of sourceStart/sourceEnd? If a lambda has a - possibly large - block as its body signaling an error against the lambda might be nicer when just highlighting the ""header"" not the entire construct don't you think?What about a scheme that is a bit closer to how we handle method declarations?"
384687,7/10/2012 2:54,jesper,"[1.8] Wildcard type arguments should be rejected for lambda and reference expressions BETA_JAVA8interface I {	}public class Action<T> {		<K> Action(int i) {			}		Action (int i1 int i2) {		<?>this(i1); //gives error:GOOD	}		public void f1(Object[] o[][]) {} public void foo() { 	 I len = List::<?>size; // no error:BAD }}Just like explicit constrcutor invocations method and const. references should also not accept wildcard type arguments"
384959,7/12/2012 10:54,mateusz.matela,[formatter] Add line wrapping options for generics Build Identifier: Version: Juno Release Build id: 20120510-1218Declaration of generic parameters inside a <> is not wrapped. For example<A extends InterfaceA B extends InterfaceB C extends InterfaceC D extends InterfaceD>will not be wrapped by the formatter even if it exceeds the maximum line width.Options for line wrapping similar to the existing ones (under Formatter->Line Wrapping) would be useful. Reproducible: AlwaysSteps to Reproduce:N/A
385134,7/15/2012 22:52,jarthana,[1.8] Investigate APT changes to support JSR 308 JSR308 is under active development and consideration for Java SE 8.On behalf of APT it needs to be ascertained what exactly is the workto be done in APT and if there are any special requirements againstJDT/Core.The relevant ER on JDT/Core side is bug 287648
385237,7/16/2012 16:49,samrat.dhillon,"[move member type] Moving a member interface to its own file adds the host's type parameters to it Build Identifier: I20120608 - 1400Interfaces are inherently static therefore interfaces that are members of an enclosing type do not inherit type parameters from their hosts. The Eclipse compiler knows this. For example given this codeclass Foo<T> { interface Bar { T baz(); }}the compiler reports an error ""Cannot make a static reference to the non-static type T"". Perfect.The refactoring engine seems to be confused on this issue however. If we correct the above code toclass Foo<T> { interface Bar { void baz(); }}and then attempt to refactor it to a top-level type via Refactor > Move Type to New File then the original host class's type parameter(s) are added to the resulting top-level interface:interface Bar<T> { void baz();}The original unparametrized interface is erroneously transformed into a parametrized one. At least the refactoring engine is (maddeningly) consistent in that it adds the new type parameter to all declarations involving the moved interface type. What a mess!For comparison the refactoring engine gets it right with static classes: the host's type parameters do not get tagged onto a static member class when it is moved to top level. In particular if the example interface is changed to a pure abstract class then it does not get an added type parameter when it is moved.I am inclined to rate the severity of this issue as ""Major"" as it can do quite a lot of damage but I leave it as ""Normal"" instead mainly because I suspect that this kind of refactoring is relatively uncommon.Reproducible: AlwaysSteps to Reproduce:1. Create a parametrized class with a member interface2. In the Java editor right-click the name of the member interface and select ""Refactor"" > ""Move Type to New File..."" from the context menus3. Click ""Ok"" on the confirmation dialog"
385486,7/19/2012 6:20,sarika.sinha,problems when there are two classes with the same name in different projects Eclipse gets confused on runtime when there are two classes with the same name at the time of pointing where the error line.- I have a class called TestA in project P1 and a class called TestA in project P2. I was running project P1 and an error trace came in the console in relationship to class TestA. When I clicked on the error message in order eclipse takes me to the error line in class TestA from project P1 I was taken to class TestA in project P2 instead.-- Configuration Details --Product: Eclipse 1.5.0.20120131-1544 (org.eclipse.epp.package.jee.product)Installed Features: org.eclipse.jdt 3.8.0.v20120525-1249-8-8nFqlFNOfwKDRGz-pXLdGxEM83
385707,7/23/2012 5:52,tomasz.zarna,Provide a maven script for jdt.gerrit hudson build With Gerrit enabled for the project [1] and a hudson job waiting to start spinning [2] the next step should be to provide a maven script (pom.xml) to be executed by the job. The script should build JDT/Core and run all tests. As the result Hudson should be able to tell if the propose change is cool. Or not.[1] bug 379652[2] bug 384258
386280,7/31/2012 1:20,tomasz.zarna,Eclipse freezes during compiling
386901,8/9/2012 0:06,jarthana,"Eclipse does not pass all annotated classes to annotation processor ModuleACLModuleAsset*ModuleCloudModuleCore*ModuleESB*ModuleFioranoMqModuleHTTPWeb*ModuleIbmMqModuleJ2EE*ModuleJcapsModuleJndiModuleLegacy*ModuleMessaging*ModuleNBEditorModulePFCoreBridgeModuleReportingModuleSonicMqModuleTibcoModuleVSEModuleWeb20ModuleWSModuleXMLWe have the above 22 annotated classes that all look like the following:import com.itko.lisa.annotations.NonNls;import com.itko.lisa.app.AbstractModule;import com.itko.lisa.app.Resources;import com.itko.lisa.core.ModuleCore;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;@com.itko.lisa.annotations.Module(key = ModuleACL.KEY bundle = ModuleACL.BUNDLE depends = {ModuleCore.KEY})public class ModuleACL extends AbstractModule { private static final Log log = LogFactory.getLog(""com.itko.lisa.acl.ModuleACL""); @NonNls public static final String KEY = ""com.itko.lisa.acl.ModuleACL""; @NonNls static final String BUNDLE = ""com.itko.lisa.resources.acl""; public static final Resources.Wrapper resources = new Resources.Wrapper(KEY); public ModuleACL() { super(KEY BUNDLE); }}The classes with the asterisks do not typically get passed to the 'com.itko.lisa.annotations.Module' Annotation Processor (AP). I say typically because every blue moon eclipse will pass all 22 annotated classes to the AP during a build. What usually happens is that we consistently get 8 annotated classes in the 1st AP round and then 7 in the 2nd.The AP's process() methid looks like the following:public boolean process( final Set<? extends TypeElement> annotations final RoundEnvironment roundEnv ){ for( TypeElement annotation : annotations ) { List<Tuple<Element AnnotationMirror>> elements = new ArrayList<>(); Set<? extends Element> annotatedElements = roundEnv.getElementsAnnotatedWith( annotation ); ... }}Stepping into the roundEnv.getElementsAnnotatedWith(...) methods shows that the missing classes are not in the set returned from line 142""return Collections.unmodifiableSet(_annoToUnit.getValues(a));""So I pulled in the source for the org.eclipse.jdt.internal.compiler.Compiler and changed the compile(ICompilationUnit[] sourceUnits) method to	public void compile(ICompilationUnit[] sourceUnits) {		this.stats.startTime = System.currentTimeMillis();		CompilationUnitDeclaration unit = null;		ProcessTaskManager processingTask = null;		System.out.println(""=============================================================================="");		System.out.println(new Date(stats.startTime));		System.out.println(""=============================================================================="");		for (int i = 0; i < sourceUnits.length; ++i)		{			ICompilationUnit icu = sourceUnits[i];			StringBuilder sb = new StringBuilder();			sb.append(icu.getFileName());			System.out.println(sb.toString());		}		System.out.println();...Next I launched a debug session against eclipse and discover that 1.) the missing modules are not in the list of sourceUnits handed to the compile method and2.) there are over 1000+ source files that are in my project however they are never output by this debug code.Our project has 4412 java source files however the above compile code will only output lines for 2923 source units over 2 invocations in a single build. And to make matters more ""magical"" the project's output folder has all the source files compiled into it.How can this be and more importantly how can I get eclipse to consistently pass all annotated files to the AP?Also originally tried this with Eclipse 4.2 but for some reason the src was not matching up to what the debugger said I should see so I dropped down a version."
388724,9/4/2012 4:34,samrat.dhillon,"[surround with try/catch][quick fix] Multi-Catch QuickFix creates compiler error This somehow looks like #348860 which should be fixed since a long time but I see this on 4.2.0----8<----package test;import java.io.IOException;import java.net.MalformedURLException;public class TestException {	private static void call() throws MalformedURLException IOException {			}		public static void main(String[] args) {		call();	}}----8<----when executing the multi-catch quickfix it creates code like this:----8<----package test;import java.io.IOException;import java.net.MalformedURLException;public class TestException {	private static void call() throws MalformedURLException IOException {			}		public static void main(String[] args) {		try {			call();		} catch (MalformedURLException | IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}	}}----8<----"
390665,9/28/2012 5:13,jarthana,Java Model Exception when creating new Java project Created attachment 221630Error Log detailsWhen creating new Java project Eclipse Juno writes error to error log:Internal ErrorJava Model Exception: Java Model Status [<project root> [in prj] is not on its project's build path]
391389,10/9/2012 2:15,jerome.cambon,"[ltk] Rename refactoring should give more control over new file name When using rename resource refactoring via resource rename dialog (see RenameResourceProcessor and RenameResourceWizard classes) my users frequently fail to keep the file extension. For example they rename ""Screen1.screen"" to ""Screen2"" which breaks things down the way.I'd like to have a say over the file name. Ideally it should be possible to append the required extension automatically. Another option would be to allow custom validations of the file name.If none of the above is possible then at least pre-select the file-name part (before the dot) the way Gnome does. This makes changing the name and leaving the extension in place a little easier.My current fix is to make check this condition in checkConditions method in my rename participant. However this is not ideal because the error is only shown on the next page and user has to return to fix the problem."
391521,10/10/2012 6:16,shankhba,"[1.8][compiler] Error highlighting is not accurate for type references with type annotations In the following code:class Y {	class Z {	}	Z z1 = (@Marker ZZ) null; // 1	Z z2 = new @Marker ZZ(); // 2}@java.lang.annotation.Target (java.lang.annotation.ElementType.TYPE_USE)@interface Marker{}The error highlighting includes the annotations as well which shouldn't be the case. It appears that the we are reporting the problem against the TypeReference and the source locations for the type reference includes the annotations as well.It doesn't happen in other cases let's say arguments because the annotations are part of the argument and not TypeReference and hence the location for the TypeReference is accurate.Also note that in the first line the same error ""ZZ cannot be resolved"" is reported twice!"
392539,10/22/2012 3:03,daniel_megert,"[content assist] Content assist inside Javadoc of a file that isn't in the workspace throws API violation warning Created attachment 222623Eclipse log containing the error from a fresh setupUsing Eclipse IDE for Java Developers 1.5.1.20120920-0737 in Windows 7 Home Premium:When typing a Javadoc comment into a standalone Java file (a .java file I've dragged into an empty Eclipse workspace) whenever I begin a line with the @ symbol Eclipse tries to do a Content Assist autocomplete and gives me an error:""The 'org.eclipse.jdt.ui.JavadocHTMLCompletionProposalComputer_all' proposal computer from the 'org.eclipse.jdt.ui' plug-in did not complete normally. The extension violated the API contract of the 'computeCompletionProposals()' operation. To avoid this message disable the 'org.eclipse.jdt.ui' plug in or disable the 'Java Proposals' category on the content assist preference page""After I close the error window the Content Assist window displays correctly.I have tried fixing this issue by restarting Eclipse deleting and re-extracting Eclipse and deleting the Eclipse metadata folder created in my user folder. The issue still occurs."
393098,10/29/2012 16:55,samrat.dhillon,"[extract method] Extracted method should be declared static if extracted expression is also used in another static method Extracted method should be declared static if extracted expression is also used in another static method.Steps to reproduce:1. In the example below invoke ""Extract Method"" on ""shared()"" expression in non-static method (nsm).2. New method will not be declared as static.3. There will be a compilation error because non-static method is invoked from static context.Note: Originally the bug was encountered when extracting ""getTestConstructor(theClass)"" on line 136 in junit.framework.TestSuite JUnit commit e8b91fa9f797dfe16aff66ed6ad5d6104e5133fe.public class ExtractMethodBug { public static void sm() { // Compilation error will be on the next line shared(); } public void nsm() { // Invoke Extract Method refactoring on the ""shared()"" expression shared(); } public static void shared() { }}"
393192,10/30/2012 15:52,jesper,"Incomplete type hierarchy with > 10 annotations Pull Up Method refactoring does not delete method from the original class.Steps to reproduce:0. Include three files below in a project in ""pullup"" package.1. Invoke Pull Up refactoring on ""pullUp"" method in class ""PullUpBug"" shown below.2. The method ""pullUp"" will not be deleted from ""PullUpBug"" which leads to a compilation error.3. Note that the method ""pullUp"" is not deleted from ""PullUpBug"" even if method ""mb"" is removed (although there will be no compilation error).Note the following is relevant (on my machine): (1) two classes (see below) must be in separate files; (2) there must be 11 methods with annotations (any annotation will be sufficient to reproduce the bug) (3) package-info.java must exist (4) comment with ""@param"" must exist on one of the methods.package-info.java----------package pullup;----------PullUpBug.java----------package pullup;class PullUpBug extends A { void mb() { pullUp(); } // INVOKE Pull Up REFACTORING ON ""pullUp"" private void pullUp() { }}----------A.java----------package pullup;class A { @Deprecated void m0() { } @Deprecated void m1() { } @Deprecated void m2() { } @Deprecated void m3() { } @Deprecated void m4() { } @Deprecated void m5() { } @Deprecated void m6() { } @Deprecated void m7() { } @Deprecated void m8() { } @Deprecated void m9() { } /** * @param */ @Deprecated void m10() { }}----------"
394030,11/10/2012 9:06,samrat.dhillon,"[extract method] Extracting expression of parameterized type that is passed as argument to this constructor yields compilation error Steps to reproduce:1. Invoke ""Extract Method"" refactoring on ""c.size()"" expression in the example below.2. Resulting file does not compile (""Cannot make a static reference to the non-static type V""). The problem is that the extracted method must be static because it is used as argument to ""this"" and at the same time it needs type parameter ""V"" which is non-static.public class ExtractMethodBug<V> { public ExtractMethodBug(Map<? ? extends V> c) { // Invoke ""Extract Method"" on ""c.size()"" this(c.size()); } public ExtractMethodBug(int size) { }}(Thanks to Anirudh Balagopal for helping with this bug report.)"
394382,11/15/2012 7:51,jarthana,"JavaElement.getURLContents() not comaptible with javadoc generated with Java 1.7 The HTML header format of generated javadoc has changed between java 1.6 and 1.7.In 1.6 with have this :<!-- Generated by javadoc (build 1.6.0_37) on Thu Nov 15 12:16:38 CET 2012 --><META http-equiv=""Content-Type"" content=""text/html; charset=UTF-8"">and in 1.7 :<!-- Generated by javadoc (version 1.7.0_09) on Thu Nov 15 10:58:53 CET 2012 --><meta http-equiv=""Content-Type"" content=""text/html"" charset=""UTF-8"">There is an algorithm in getURLContents() trying to retrieve the charset value and throw this exception when javadoc is generated in 1.7 :java.lang.StringIndexOutOfBoundsException: String index out of range: -10	at java.lang.String.checkBounds(String.java:397)	at java.lang.String.<init>(String.java:442)	at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:786)"
394548,11/18/2012 22:12,samrat.dhillon,"[extract class] Extract class on a field with generic type yields compilation error Steps to reproduce:1. Invoke ""Extract Class..."" on ""m"" in code below2. Select ""Nested Class in ...""3. There is a compilation error in the resulting file (""Cannot make a static reference to the non-static type T"")class ExtractClassBug<T> { // Invoke ""Extract Class..."" on ""m"" (and specify ""Nested Class in ..."") T m;}(Thanks to Yilong Li for helping with the bug report.)"
394721,11/20/2012 19:15,nikolaymetchev,"[inline] Inline local variable with initializer generates assignment where left-hand side is not a variable Steps to reproduce:1. Invoke ""Inline"" on ""m"" in code below2. The resulting file cannot be compiled (""The left-hand side of an assignment must be a variable"")class InlineLocalVariableBug1 { void f() { // Invoke ""Inline..."" on ""m"" result in ""new int[10][0] = 0;"" int[] m = new int[10]; m[0] = 0; }}"
395016,11/25/2012 1:32,samrat.dhillon,"[introduce factory] Introduce Factory on an abstract class adds a statement to create an instance of that class Steps to reproduce:1. Invoke ""Introduce Factory"" on the constructor in code below2. The resulting code does not compileabstract class IntroduceFactoryBug1 { // Invoke ""Introduce Factory"" on the constructor IntroduceFactoryBug1() { }}(Thanks to Yilong Li for helping with the bug report.)"
395202,11/27/2012 13:47,markus.kell.r,"[type hierarchy][navigation] StackOverflow in quick outline I was looking at an inner class (an enum) pressed ctrl-o ctrl-o started typing ""va"" (wanted to type ""valueOf"") and then got the stack overflow error.Inner class enum has 2 fields 2 methods. outer class has at most 20 fields 20 methods.-- Error Details --Date: Tue Nov 27 13:43:12 EST 2012Message: Unhandled event loop exceptionSeverity: ErrorProduct: Eclipse 1.5.1.20121004-1506 (org.eclipse.epp.package.rcp.product)Plugin: org.eclipse.uiSession Data:eclipse.buildId=M20120914-1800java.version=1.7.0_07java.vendor=Oracle CorporationBootLoader constants: OS=win32 ARCH=x86_64 WS=win32 NL=en_USFramework arguments: -product org.eclipse.epp.package.rcp.productCommand-line arguments: -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.rcp.productException Stack Trace:java.lang.StackOverflowError	at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:471)	at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:471)	at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:471)	at org.eclipse.jdt.internal.core.SourceMethod.hashCode(SourceMethod.java:202)	at java.util.HashMap.hash(Unknown Source)	at java.util.HashMap.getEntry(Unknown Source)	at java.util.HashMap.get(Unknown Source)	at org.eclipse.jdt.internal.core.JavaModelCache.getInfo(JavaModelCache.java:139)	at org.eclipse.jdt.internal.core.JavaModelManager.getInfo(JavaModelManager.java:1948)	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:253)	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:241)	at org.eclipse.jdt.internal.core.JavaElement.exists(JavaElement.java:159)	at org.eclipse.jdt.internal.ui.viewsupport.JavaElementLabelComposer.appendMethodLabel(JavaElementLabelComposer.java:403)	at org.eclipse.jdt.internal.ui.viewsupport.JavaElementLabelComposer.appendElementLabel(JavaElementLabelComposer.java:270)	at org.eclipse.jdt.ui.JavaElementLabels.getElementLabel(JavaElementLabels.java:531)	at org.eclipse.jdt.ui.JavaElementLabels.getStyledElementLabel(JavaElementLabels.java:506)	at org.eclipse.jdt.ui.JavaElementLabels.getStyledTextLabel(JavaElementLabels.java:434)	at org.eclipse.jdt.internal.ui.viewsupport.JavaUILabelProvider.getStyledText(JavaUILabelProvider.java:178)	at org.eclipse.jface.viewers.DelegatingStyledCellLabelProvider.getStyledText(DelegatingStyledCellLabelProvider.java:195)	at org.eclipse.jface.viewers.DecoratingStyledCellLabelProvider.getStyledText(DecoratingStyledCellLabelProvider.java:192)	at org.eclipse.jdt.internal.ui.viewsupport.ColoringLabelProvider.getText(ColoringLabelProvider.java:87)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:111)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at(STRIPPED)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:123)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:116)"
395228,11/27/2012 19:38,nikolaymetchev,"[introduce indirection] Adds unneccessary import when inner class is used as parameter in surrounding class Steps to reproduce:1. Invoke ""Introduce Indirection"" on 'f' method in code below2. The resulting file does not compile (""The type IntroduceIndirectionBug1.C is not visible"")class IntroduceIndirectionBug1 { // Invoke ""Introduce Indirection"" on 'f' void f(C c) { } private class C { }}The cause of this bug is probably the same as for bug 394725. (Thanks to Yilong Li for helping with the bug report.)"
395231,11/27/2012 19:58,nikolaymetchev,"[introduce indirection] ClassCastException when introducing indirection on method in generic class Steps to reproduce:1. Invoke ""Introduce Indirection"" on 'g' method in code below2. ClassCastException is throws (see part of the log below)class IntroduceIndirectionBug3<T extends IntroduceIndirectionBug3<T>> { // Invoke ""Introduce Indirection"" on 'g' void g(T t) { } void f(T t) { t.g(null); }}(Thanks to Yilong Li for helping with the bug report.)java.lang.ClassCastException: org.eclipse.jdt.internal.core.TypeParameter cannot be cast to org.eclipse.jdt.core.IType	at org.eclipse.jdt.internal.corext.refactoring.code.IntroduceIndirectionRefactoring.checkFinalConditions(IntroduceIndirectionRefactoring.java:545)	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:209)	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344)	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)"
395348,11/28/2012 23:50,manpalat,"[search] NPE while searching for declarations of a generic function inside an anonymous class (was originally: Rename method does not detect renaming of binary method in anonymous class) Steps to reproduce:1. Invoke ""Rename"" on ""compare"" in code below2. The resulting code does not compile (""The type new Comparator<C2>(){} must implement the inherited abstract method Comparator<C2>.compare(C2 C2)"")class RenameMethodBug2 { static void f() { new Comparator<C2>() { // <<< This type parameter is necessary // Invoke ""Rename"" on ""compare"" public int compare(C2 o1 C2 o2) { return 0; } }; }}class C2 {}(Thanks to Yilong Li for helping with the bug report.)"
395558,12/2/2012 13:12,samrat.dhillon,"[introduce parameter object] Introduce Parameter Object introduce use of non-static type in static context Steps to reproduce:1. Invoke ""Introduce Parameter Object"" on 't' in code below2. Choose ""Destination"" as ""Nested class in IntroduceParameterObjectBug1""3. There is a compilation error in the resulting file (""Cannot make a static reference to the non-static type T"")interface IntroduceParameterObjectBug1<T> { // Invoke ""Introduce Parameter Object"" on 't' choose ""Destination"" as // ""Nested class in IntroduceParameterObjectBug1"" void f(T t);}(Thanks to Yilong Li for helping with the bug reports.)Probably related to bug 394549."
395561,12/2/2012 15:57,samrat.dhillon,"[introduce parameter object] Introduce Parameter Object does not add type parameter for newly created top level class Steps to reproduce:1. Invoke ""Introduce Parameter Object"" on 't' in code below2. Choose ""Destination"" as ""Top level class""3. ""Destination"" class does not compile (""T cannot be resolved to a type"")interface IntroduceParameterObjectBug2<T> { // Invoke ""Introduce Parameter Object"" on 't' choose ""Destination"" as // ""Top level class"" void f(T t);}(Thanks to Yilong Li for helping with the bug report.)Also see bug 395558."
395886,12/6/2012 0:24,manpalat,[1.8][DOM/AST] Withdraw annotations property from Name nodes. As part of the fix for bug 391890 ANNOTATIONS_PROPERTY was added to Name nodes.These need to be removed since the specification has changed to disallowconstructs of the form: @Marker java.util.ListThe proper way to annotate these is to say: java.util. @Marker ListThus the presence of annotations before a certain segment of a qualified typesignals that what follows is a type and cannot be a name. Very similar to howthe presence of type parameters signals a type.See also:https://bugs.eclipse.org/bugs/show_bug.cgi?id=391847#c4https://bugs.eclipse.org/bugs/show_bug.cgi?id=391847#c7https://bugs.eclipse.org/bugs/show_bug.cgi?id=391847#c33https://bugs.eclipse.org/bugs/show_bug.cgi?id=391847#c34https://bugs.eclipse.org/bugs/show_bug.cgi?id=391847#c37https://bugs.eclipse.org/bugs/show_bug.cgi?id=391847#c39https://bugs.eclipse.org/bugs/show_bug.cgi?id=391847#c46When we converty a QualifiedTypeReference or its subtypes we shouldconvert everything before the first type annotation seen as a SimpleType ofQualifiedName/SimpleName and convert everything further as types.Compare how type parameters are handled in conversion of PQTR.
395897,12/6/2012 4:47,jarthana,INDEX_LOCATION_ATTRIBUTE_NAME attribute value is ignored when the index is rebuilt The INDEX_LOCATION_ATTRIBUTE_NAME classpath attribute can be used to explicitly specify the location for the index file. However this is currently used only for the pre-built indexes. When index has to be rebuilt the index is stored in the default location and not as per the attribute value.When the index location is specified the index should always be created there.
395989,12/6/2012 16:38,samrat.dhillon,"[generalize type] Generalize Declared Type does not consider use of variable in throw statement which yields compilation error Steps to reproduce:1. See the instructions in code below2. The resulting code does not compile (""No exception of type Object can be thrown; an exception type must be a subclass of Throwable"")class GeneralizeDeclaredTypeBug3 { void f() throws Exception { // Invoke ""Generalize Declared Type"" on ""Exception"" // and select ""Object"" as new type Exception e = new Exception(); throw e; }}(Thanks to Yilong Li for helping with the bug report.)"
395992,12/6/2012 17:05,samrat.dhillon,"[generalize type] Generalize Declared Type offers types that are not visible Steps to reproduce:1. See the instructions in code below2. The resulting code does not compile (""The type AbstractStringBuilder is not visible"")class GeneralizeDeclaredTypeBug6 { void f() { // Invoke ""Generalize Declared Type"" on ""StringBuffer"" // and select ""AbstractStringBuffer"" as new type StringBuffer b; }}Result:class GeneralizeDeclaredTypeBug6 { void f() { AbstractStringBuilder b; }}(Thanks to Yilong Li for helping with the bug report.)"
396139,12/9/2012 6:31,manpalat,[1.8] define which JRE8 build we are targeting in BETA_JAVA8 Various regressions in the BETA_JAVA8 branch are caused by incompatible changes in the lambda-enabled JRE8.Examples:JavadocTestForClass had to be change back-and-forth in commits cc1c110e9641a2cecfab702ac9383376aefe030a and 5da4268a6e911ad3865241747a8e9714544fc990.Manoj reported 103 test failures regarding the following types:- java.util.Fillable- java.util.functions.Mapper and sub-types- java.util.functions.* vs. java.util.function.*At a closer look this problem was caused by using a *newer* JRE8 than other team members. I can currently reproduce this kind of failure using a build 67 JRE.Since the download page of project lambda only offers the latest beta build at any point in time it is difficult to reproduce the exact same environment of another team member unless we coordinate this upgrade process.I propose to use this bug for tracking the current build version of the JRE8 against which all tests in BETA_JAVA8 should be green.In HEAD I observe that b50 is too old for the current state of JavadocTestForClass. OTOH b67 is too new for the current state of many other tests. Unfortunately I don't have the builds in between.
396524,12/13/2012 12:22,register.eclipse,[refactoring] Pull Up and Extract Interface refactorings add unexpected @Override Pull-up refactoring - does not add imports for parameters and return types to destiantion type- adds an @Override to the source member even if the runtime environment is set to Java 5 and the target is an interrface=> broken code
400374,2/8/2013 17:41,markus.kell.r,"opening an editor when the maximum allowed is reached will result in an exception (and editor will not be opened) this is the exception:!ENTRY org.eclipse.ui 4 0 2013-02-08 23:36:40.932!MESSAGE Unhandled event loop exception!STACK 0org.eclipse.core.runtime.AssertionFailedException: assertion failed: 	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:110)	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:96)	at org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.prepareDelayedProjection(JavaSourceViewer.java:658)	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.internalDoSetInput(JavaEditor.java:2582)	at org.eclipse.jdt.internal.ui.javaeditor.JavaEditor.doSetInput(JavaEditor.java:2571)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSetInput(CompilationUnitEditor.java:1395)	at org.eclipse.ui.texteditor.AbstractTextEditor.setInputWithNotify(AbstractTextEditor.java:4289)	at org.eclipse.ui.texteditor.AbstractTextEditor.setInput(AbstractTextEditor.java:4311)	at org.eclipse.ui.internal.WorkbenchPage.reuseEditor(WorkbenchPage.java:2885)	at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:3023)	at org.eclipse.ui.internal.WorkbenchPage.access$22(WorkbenchPage.java:2969)	at org.eclipse.ui.internal.WorkbenchPage$8.run(WorkbenchPage.java:2951)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2947)	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2911)	at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2902)	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:373)	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:179)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl.gotoSelectedElement(AbstractInformationControl.java:440)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl.access$0(AbstractInformationControl.java:435)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$2.widgetDefaultSelected(AbstractInformationControl.java:227)	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:119)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1053)	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4169)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3758)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1057)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:941)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:79)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:588)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:543)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)	at java.lang.reflect.Method.invoke(Unknown Source)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)	at org.eclipse.equinox.launcher.Main.run(Main.java:1450)I already had that also in my 3.8.x version but now i am on the 4.3 stream:Version: 4.3.0Build id: I20130205-0800i i still have this.For that workspace i really need to say that it shouldn't close editors automatically for a specific number (16) now.If this happens i really have first to close 1 and then i can reopen on."
400670,2/13/2013 6:18,noopur_gupta,"[Save actions] Correct indentation conflicts with formatter causing staircase effect Created attachment 226996formatter settings to reproduceHiVersion: Juno Service Release 1Build id: 20121004-1855I noticed that the Save Action 'correct indentation' conflicts with the formatter 'line wrapping'.I attached my formatter configuration as reference.The issue can be seen when using arguments with enums.The formatter uses indentation so that all types are indented on the same column as well as the arguments for the enums and arguments to those arguments (think arrays).Desired result (which the formatter does correctly):<pre>public enum TestEnum {	FIRST_ENUM(""first type""	 new SomeClass()	 new OtherEnumType[] { OtherEnumType.FOO})	SECOND_ENUM(""second type""	 new SomeClassOtherClass()	 new OtherEnumType[] { OtherEnumType.BAR})	THIRD_ENUM(""third type""	 new SomeThirdClass()	 new OtherEnumType[] { OtherEnumType.BAZ})	FOURTH_ENUM(""fourth type""	 new YetAnotherClass()	 new OtherEnumType[] { OtherEnumType.FOOBAR	 OtherEnumType.FOO	 OtherEnumType.FOOBARBAZ	 OtherEnumType.LONGERFOOBARBAZ	 OtherEnumType.REALLYLONGFOOBARBAZ	 OtherEnumType.MORELETTERSINHERE});/* data members and methods go here */}</pre>However when using the save action 'correct indentation' the 'SECOND_ENUM' start on the column of the arguments for 'FIRST_ENUM' the 'THIRD_ENUM' start on the column for arguments to the second one and so on.This creates the dreaded staircase effect."
400871,2/14/2013 22:37,srikanth_sankaran,[1.8][compiler] Overhaul overload resolution to reconcile with JLS8 15.12.2 BETA_JAVA8:A number of changes are being made to overload resolution mechanismto accommodate poly expressions in method invocation context.ECJ needs to evolve to address this scenario which creates some interestingproblems: When a lambda expression occurs in method invocation context asan argument the type of the lambda expression cannot be determined untilthe overloaded method is chosen and the overloaded method cannot be chosenuntil the lambda expression's type is known.JLS8 15.12.2 (part F of JSR335 specification) spells out the amended overload resolution rules to address this and other scenarios.
400875,2/14/2013 22:49,srikanth_sankaran,[1.8][compiler] Code generation for lambda/reference expressions This will be the master bug for this project.
400899,2/15/2013 4:57,manpalat,[1.8][search] Search engine/indexer should evolve to support Java 8 constructs BETA_JAVA8:This ER will be used as the master/umbrella entry for search engine changesto support Java 8. Please don't attach patches/fixes here. Any high leveldiscussions can be had here but all activity should be on broken down blockerunit level tasks each with its own bug number.Some quick experiments show that the search engine as is is able to discovertypes and variables properly for lambda expressions.For type annotations and reference expressions there are various thingsthat appear broken.
400905,2/15/2013 5:19,srikanth_sankaran,"[1.8][search] Search engine skips functional interface types. BETA_JAVA8:Attempt to search for the declarations of an interface method failsto find lambda methods:// ----interface I {	void doit();}class X {	static void foo() {}	I i = () -> {};	I i2 = new I() {		void doit() {					}	};}Search for implementations of I#doit brings up the one inside theanonymous class but not the anonymous lambda method."
401138,2/18/2013 18:03,jarthana,"Implementation of Elements.getAllAnnotationMirrors includes non-inherited annotations from superclass. Per the javadoc for org.eclipse.jdt.internal.compiler.apt.model.ElementsImpl#getAllAnnotations(Element) ""Annotations are inherited only if the annotation type is meta-annotated with @Inherited"". However the check for the @Inherited meta-annotation does not occur and indeed all annotations on super classes of the class represented by element are returned regardless of whether they are annotated with @Inherited.Steps To Reproduce:1. create annotation @Foo which is *not* annotated with @Inherited 2. create annotation processor with @SupportedAnnotationTypes(""*"") and have it call processingEnv.getElementUtils().getAllAnnotationMirrors(element) for each root element and print out the results (or use a debugger to see what it gets)3. use annotation and processor like this: a. create BaseClass and apply the annotation @Foo b. create SubClass inheriting BaseClass.4. The processor will be told that SubClass has the @Foo annotation on it."
401847,2/26/2013 20:08,srikanth_sankaran,"[1.8][compiler] Polyconditionals not accepted in method invocation contexts. BETA_JAVA8:The following program should compile but fails instead with aClassCastException:// ---interface I {	Integer foo(X x);}public class X {	int foo(I ...i) { return 10;}	int goo() { return 0;}		{		foo(true ? X::goo : X::goo);		foo(true ? x-> 1 : x->0);	}}"
401848,2/26/2013 20:14,markus.kell.r,"ASTRewrite on type annotations adds an additional <CR> Created attachment 227640Testcase to reproduce the errorA ""\n"" introduced when an additional Annotation is added using rewrite"
402079,2/28/2013 20:21,srikanth_sankaran,[1.8][assist] Code assistant needs to evolve to support Java 8.
402080,2/28/2013 20:22,srikanth_sankaran,"[1.8][code select] Unable to navigate to method declaration from method reference BETA_JAVA8:I am unable to control+click or use F3 to jump to declaration from themethod reference. Constructor reference may also be broken:// ---interface I { String foo(String x);}public class X { public String goo(String x) { return null; } void foo() { 	X x = new X(); 	I i = x::goo; // control+click/F3 on goo. }}"
402081,2/28/2013 21:23,srikanth_sankaran,"[1.8][code complete] No proposals while completing at method/constructor references BETA_JAVA8:No proposals offered at |//-----interface I { String foo(String x);}public class X { public String longMethodName(String x) { return null; } void foo() { 	X x = new X(); 	I i = x::longMethodN| }}"
402219,3/2/2013 22:16,srikanth_sankaran,"[1.8][compiler] Compile time errors in lambda during hypothetical type check should render candidate method inapplicable. BETA_JAVA8:The following program is required to be rejected per 0.6.1 witha ""method is ambiguous"" error. Beginning 0.6.2 though compileerrors discovered during (potential and full) applicability analysisshould disqualify an overload resolution candidate method and theprogram should compile.// ----interface I {	String foo(String s1 String s2);}interface J {	X foo(X x1 X x2);}public class X { 	void goo(I i) {}	void goo(J j) {} public static void main(String [] args) {	new X().goo((p1 p2) -> p1 = p1 + p2); }} // -----ECJ has already been ""partly"" implementing this semantics: if the body ofthe lambda were to be p1 + p2 instead of p1 = p1 + p2 we would not reportany ambiguity - (because return expressions need to be analyzed for assignmentcompatibility as a part of cpmpatibility check an erroneous return typewould fail to quality)"
403154,3/13/2013 5:28,jarthana,IJavaElement.getAttachedJavadoc(IProgressMonitor) should throw exception if base URL is wrong 4.3 M6.IJavaElement.getAttachedJavadoc(IProgressMonitor) should throw exception if base URL is wrong.See bug 403036 comment 1 for details.A point to consider is a potential performance impact.
403410,3/15/2013 0:32,jarthana,Modifiers should be rejected on receiver parameters The latest spec doesn't allow modifiers on explicit 'this' parameters:FormalParameterOrReceiverDecls:Type [Identifier .] this [ FormalParameterDecls]FormalParameterDeclsThe javac allows final but rejects static. But as per the spec all modifiers should be rejected on receiver params.
403475,3/15/2013 10:36,Michael_Rennie,Hot Code Replace drops too much frames in some cases In Following test case too much frames gets dropped without need:1. In the test program (TestHCR.java) set a breakpoint in TestHCR.run()2. After the breakpoint gets hit change TestHCR.run() (e.g. add new println)3. Save the file.Now 2 frames are dropped and we are at the start of TestHCR.InnerClass.run() even though we should be at the start of TestHCR.run() (only one frame should have been dropped not two).The reason for this behavior is that both methods TestHCR.run() and TestHCR.InnerClass.run() have the same name and in JavaHotCodeReplaceManager.getAffectedFrame() CompilationUnitDelta.hasChanged() and MethodSearchVisitor.setTargetMethod() only name of the method gets checked without checking to which class the method belongs. I've made a short bugfix (see MethodSearchVisitor.java JavaHotCodeReplaceManager.java CompilationUnitDelta.java in the attachment) which works for me but am not sure if this is enought in general.
403674,3/18/2013 14:46,shankhba,"[compiler][null] Switching on @Nullable enum value does not trigger ""Potential null pointer access"" warning Created attachment 228586Code that reproduces the bugUsing a @Nullable enum value in a switch statement does not trigger the ""Potential null pointer access"" warning that it should potentially leading to runtime NullPointerExceptions. The warning appears correctly when switching on a @Nullable String or Integer object (the latter presumably because of the auto-unboxing operation).I've attached example code that for me shows an error when trying to switch on a @Nullable String value but does not show errors when switching on @Nullable enum values."
403923,3/20/2013 13:26,noopur_gupta,[1.8] Handle annotations on extra dimensions in the AST Handle annotations on extra dimensions in the AST.For jsr308 a new extraDimensions2 property has been added to MethodDeclaration and to the two concrete VariableDeclaration types. Make a pass over all JDT UI code that uses the old property in any way (direct access or via property descriptor) and update usages.File separate bugs if things get too complicated somewhere or if you think we should add new features for handling these constructs.
403924,3/20/2013 13:29,noopur_gupta,[1.8] Replace usages of MethodDeclaration#thrownExceptions() in the AST Replace usages of MethodDeclaration#thrownExceptions() in the AST.For jsr308 MethodDeclaration's thrownExceptions property has been replaced with thrownExceptionTypes. Make a pass over all JDT UI code that uses the old property in any way (direct access or via property descriptor) and update usages.File separate bugs if things get too complicated somewhere or if you think we should add new features for handling these constructs.
403927,3/20/2013 13:46,markus.kell.r,[1.8] Switch ASTs to JLS8
404471,3/27/2013 12:55,nikolaymetchev,"[move method] Annotation error in applying move-refactoring to inherited methods Class A is super-class of class B.Method m of B is inherited from A.public class A { public void m(C c) { }}public class B extends A { @Override public void m(C c) { }}When method m of B is moved to class C (making delegate of m)""@Override"" annotation is also moved to C.public class C { @Override //error public void m() { }}"
404477,3/27/2013 13:16,markus.kell.r,"[move method] Wrong detection of duplicate methods (can result in compile errors) Here is the original source code:public class A {	public int i = 0;	public void m(B b) {		i++;	}	}public class B {	public void m() {			}}When method m of A is moved to B by applying move-refactoringEclipse error occurs saying that ""A method with name 'm' already exists in the target type 'B'.But it should not be an error since method m will have different parameters in B:public class B {	public void m() {			}	public void m(A a) {		a.i++;	}}"
404605,3/29/2013 6:24,sarika.sinha,Need additional property for Virtual Machine XML support for execution environment descriptions We are using Execution Environment Descriptions http://wiki.eclipse.org/Execution_Environment_Descriptions to contribute custom Java VM installations to eclipse. VM has ee.language.level=1.4 and eclipse IDE decides that it has support for JAXP for some reason. This is needed to evaluating VM system properties by executing special class org.eclipse.jdt.internal.launching.support.SystemProperties used for retrieving system information for the VM itself. This class uses JAXP which is NOT mandatory functionality for jdk 1.4. As result all features of eclipse which use these system properties doesn't work. New property should be added to the execution environment descriptions which informs eclipse to use the legacy org.eclipse.jdt.internal.launching.support.LegacySystemProperties instead of detecting XML support by language level.
404668,4/1/2013 9:31,markus.kell.r,"[1.8][dom ast] Incorrect output of the AST rewrite formatter for insertion of Annotations in Empty List Created attachment 229203Patch file where the test case is mentioned. Can be applied to ASTRewritingExpressionTest.javaExpected Output: String myString = (@Annot String) myObject;\n"");Actual Output : String myString = ( @AnnotString) myObject"
404784,4/3/2013 4:35,Michael_Rennie,Open popup when suspended on exception doesn't work Preferences>Java>Debug>Open popup when suspended on exceptiondoesn't work.Even if it is checked ExceptionInspector won't popup.Maybe because...It is stored atorg.eclipse.jdt.internal.debug.ui.JavaDebugPreferencePage.performOk()with JDIDebugUIPlugin.getDefault().getPreferenceStore().So I can see it in org.eclipse.jdt.debug.ui.prefs under .metadata.Howeverorg.eclipse.jdt.internal.debug.ui.breakpoints.ExceptionInspector.ExceptionInspector()refers JDIDebugPlugin.getUniqueIdentifier().I cannot see the option in org.eclipse.jdt.debug.prefs of course.(Sorry if I misunderstood)
405026,4/5/2013 13:59,shankhba,"IJavaProject#findType(String) finds secondary type if editor is open master (from bug 405015)IJavaProject#findType(String) should never find a secondary type. But if you call this methods with ""x.y.z.test13outer"" for the CU below then you get an IType iff the CU is open in a Java editor.--------------------------------------package x.y.z;public interface test13 {}/** * @noreference */interface test13outer {}--------------------------------------The problem is that ""considerSecondaryTypes"" is dropped in org.eclipse.jdt.internal.core.NameLookup.findType(String String boolean int boolean boolean boolean IProgressMonitor) line 662 and eventually seekTypesInWorkingCopies(..) finds the secondary type."
405051,4/5/2013 17:54,jarthana,JavaModel.refreshExternalArchives needs to happen before search is primed When the search engine is primed (as part of calling JavaCore.initializeAfterLoad(IProgressMonitor)) then it populates the index manager based on the information returned from IndexManager#computeIndexLocation(IPath containerPath). If the underlying index is a pre-built index but it has been deleted from the file-system then the index is re-created in the workspace metadata and not in the location specified by the INDEX_LOCATION_ATTRIBUTE_NAME classpath attribute. This is because search has no concept of the classpath containers - it simply knows a list of project and the corresponding archive files.In JavaCore.initializeAfterLoad(IProgressMonitor) the call to refresh external archives (which populates the index manager with the correct classpath attribute information) happens after the search occurs. Since the index has already been built from the search call then it ends up being used.There are two ways to fix this:1) In JavaCore.initializeAfterLoad(IProgressMonitor) move the call to refresh the archives to happen BEFORE the search engine is primed.2) In IndexManager#computeIndexLocation(IPath containerPath final URL newIndexURL) added via bug 395897 if the existing URL is different from the new URL then the index needs to be rebuilt after it is removed.I think fix 1 makes more sense as ideally you want to know the latest archive state before a search is done. This approach also ensures that the indexer manager is doing less work
405104,4/7/2013 7:28,aclement,[1.8][compiler][codegen] Implement support for serializeable lambdas BETA_JAVA8:This ER will be used to implement track support for serializeable lambdas.
405125,4/8/2013 1:30,anchakrk,"[1.8][code assist] static members of an interface appearing after the declaration of a static member lambda expression are not being suggested. public interface Foo { 	int run(int s1 int s2); }interface X {	 static Foo f = (int s5 int s6) -> x<ctrl-space> static int x1 = 2;}x1 should have been suggested in assist; but not happening that way.ThanksAnirban"
405126,4/8/2013 1:39,srikanth_sankaran,"[1.8][code assist] Lambda parameters incorrectly recovered as fields. public interface Foo { 	int run(int s1 int s2); }interface X {	 static Foo f = (int x5 int x11) -> x static int x1 = 2;}class C {	void method1(){		int p = X.<ctrl-space>	}}Wrongly suggesting x5 x11. Only x1 should have been suggested."
405134,4/8/2013 5:28,srikanth_sankaran,"[1.8][code assist + compiler] compiler and code assist problem in multilevel lambda with curly bracketed body public interface Foo { 	int run1(int s1 int s2);	static int x2 = 0;}interface Foo1 {	Foo run2(int argFoo1);}interface X extends Foo{	 static int x1 = 2; static Foo f = (x5 x6) -> x5; static Foo1 f1 = af1 -> (a1b1) -> {int uniqueName = 4; return uniqueName;}; 		}eclipse compiler clean reference commandline compiler crash and seemingly total breakdown of code-assist inside the curly braces in the above multilevel lambda.ThanksAnirban"
405139,4/8/2013 6:06,srikanth_sankaran,"[1.8][code assist] Error in code assist suggestions in curly bracketed lambda body public interface Foo { 	int run1(int s1 int s2);}interface X extends Foo{	 static Foo f = (x5 x6) -> {x<ctrl-space> 		}x5 x6 are not suggested."
405225,4/8/2013 21:35,jarthana,"BatchCompiler throws NPE in Java 7 when compiling a project via the BatchCompiler on Java 7 I get an NPE thrown from org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.concatFiles(EclipseFileManager.java:202)the problem seem to be at line 573: return this.locations.get(location.getName());which works fine in Java 6 but returns null for Java 7. location.getName() is ""PLATFORM_CLASS_PATH"" at that point.building the same project with Java 6 works fine.see more details at:http://stackoverflow.com/questions/15819926/eclipse-jdt-compiler-ecj-throws-npe-in-java-1-7stacktrace:java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.concatFiles(EclipseFileManager.java:202) at org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.handleOption(EclipseFileManager.java:669) at org.eclipse.jdt.internal.compiler.apt.dispatch.BatchProcessingEnvImpl.(BatchProcessingEnvImpl.java:88) at org.eclipse.jdt.internal.compiler.apt.dispatch.BatchAnnotationProcessorManager.configure(BatchAnnotationProcessorManager.java:69) at org.eclipse.jdt.internal.compiler.batch.Main.initializeAnnotationProcessorManager(Main.java:3632) at org.eclipse.jdt.internal.compiler.batch.Main.performCompilation(Main.java:3737) at org.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1679) at org.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1372) at org.eclipse.jdt.core.compiler.batch.BatchCompiler.compile(BatchCompiler.java:80) at org.eclipse.jdt.core.compiler.batch.BatchCompiler.compile(BatchCompiler.java:52) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601)... at java.lang.Thread.run(Thread.java:722)"
405250,4/9/2013 5:13,anchakrk,[1.8][code assist] Annotations getting suggested at import statements import java.util.@<ctrl-space>
405305,4/9/2013 13:48,noopur_gupta,[1.8] UI work for LambdaExpression Investigate what we have to do for LambdaExpressions in the UI.Possible pain points:- code that traverses the parent chain to find the enclosing scope (e.g. to find visibility of variables possible target position for Extract Local Variable or Extract Method)- type of lambda expression is inferred from context (e.g. extracting a lambda expression into a local variable may need special handling to get the right type; compare to MethodInvocation.isResolvedTypeInferredFromExpectedType())- problems with lambda parameters without a declared type- ...
405338,4/10/2013 4:45,jesper,[formatter] Running from command line on many files causes ArrayIndexOutOfBoundsException When using the formatter from the command line on a large number of files an ArrayIndexOutOfBoundsException is thrown by the formatter. Here's the contents of the log file denoted by the resulting error dialog:!SESSION 2013-04-09 21:49:29.546 -----------------------------------------------eclipse.buildId=M20130204-1200java.version=1.7.0_15java.vendor=Oracle CorporationBootLoader constants: OS=linux ARCH=x86_64 WS=gtk NL=en_USFramework arguments: -application org.eclipse.jdt.core.JavaCodeFormatter -config [elided about 190 more arguments]Command-line arguments: -os linux -ws gtk -arch x86_64 -application org.eclipse.jdt.core.JavaCodeFormatter -config [elided about 190 more arguments]!ENTRY org.eclipse.osgi 4 0 2013-04-09 21:49:31.580!MESSAGE Application error!STACK 1java.lang.ArrayIndexOutOfBoundsException: 100 at org.eclipse.jdt.internal.formatter.Scribe.printNewLinesCharacters(Scribe.java:4867) at org.eclipse.jdt.internal.formatter.Scribe.addOptimizedReplaceEdit(Scribe.java:571) at org.eclipse.jdt.internal.formatter.Scribe.addReplaceEdit(Scribe.java:663) at org.eclipse.jdt.internal.formatter.Scribe.printComment(Scribe.java:2553) at org.eclipse.jdt.internal.formatter.Scribe.printComment(Scribe.java:2406) at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.visit(CodeFormatterVisitor.java:4379) at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:277) at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.format(CodeFormatterVisitor.java:593) at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.formatTypeMembers(CodeFormatterVisitor.java:2212) at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.format(CodeFormatterVisitor.java:1217) at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.visit(CodeFormatterVisitor.java:5586) at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1286) at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.visit(CodeFormatterVisitor.java:3305) at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:679) at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.format(CodeFormatterVisitor.java:863) at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.formatCompilationUnit(DefaultCodeFormatter.java:241) at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:163) at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:146) at org.eclipse.jdt.core.formatter.CodeFormatterApplication.formatFile(CodeFormatterApplication.java:223) at org.eclipse.jdt.core.formatter.CodeFormatterApplication.start(CodeFormatterApplication.java:418) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:353) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:180) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:629) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:584) at org.eclipse.equinox.launcher.Main.run(Main.java:1438) at org.eclipse.equinox.launcher.Main.main(Main.java:1414)The command I run is:~/eclipse-4.2/eclipse -nosplash -application org.eclipse.jdt.core.JavaCodeFormatter -config ...In my particular case it crashes when there are 183 or more files. This seems like a simple case of not checking the current size of the Scribe.edits array before appending to it.
405778,4/16/2013 6:59,sasikanth.bharadwaj,"[1.8][dom ast] method body recovery broken (empty body) Our org.eclipse.jdt.ui.tests.refactoring.ExtractMethodTests#test803() fails in BETA_JAVA8 because the error recovery in the AST doesn't work any more and we don't get the AST we expect.Source:package error_in;public class A_test803 {	void m(String[] names) {		/*[*/		for (String string : names) {			System.out.println(string.);		}		/*]*/	}	}}In master the method body is recovered down to the method argument ""string."".In BETA_JAVA8 the whole method body is just one recovered Block whose children are missing.The additional '}' at the end doesn't make a difference."
405843,4/17/2013 1:14,jarthana,[1.8] SourceTypeConverter should expose type annotations. This bug to be used to discuss and come up with changes that are required in Java model to support type annotations (JSR 308). At this point there is nothing critical or broken but the requirement will be driven largely by the client.If needed raise separate bugs to track individual requirements.Some of the things that may need correction are method signatures type parameter signatures etc.
405932,4/17/2013 22:07,jarthana,JDT managed pre-built indexes are deleted when the project is deleted Created attachment 229839possible patchIf the JDT index manager rebuilds a pre-built index (see bug 395897) then it is saved in the index manager with a SAVE_STATE rather than REUSE_STATE. If a single project in the workspace uses these indexes and is then deleted then the underlying index is also deleted. A pre-built index (even if rebuilt by JDT) should never be deleted programmatically by JDT.
406274,4/23/2013 1:54,manju656,"[1.8][extract interface] Invoking 'Extract Interface' on an interface with default method results in losing the default method implementation. Consider the below interfacepackage p1;public interface I1 {		 default int defaultMethod(){		 return 10;	 }	}Invoke 'Refactor-> Extract Interface...' on I1. Select #defaultMethod to be part of the new interface. Click 'OK' button. In the newly created interface the method is created as abstract and in the original interface the method is removed. So basically the method implementation is lost after refactoring."
406468,4/24/2013 13:02,anchakrk,"[1.8][code assist] No completion proposals after the use of a constructor reference BETA_JAVA8: interface I {	X [][][] copy (int x);}public class X {	public static void main(String[] args) {		I i = X[][][]::new;		X[][][] x = i.copy(136);		System.out.println(x.length); | // - no completion proposals here.			}	}"
406744,4/27/2013 23:21,srikanth_sankaran,"[1.8][compiler][codegen] LambdaConversionException seen when method reference targets a varargs method. BETA_JAVA8:We generate bad code that triggers a LCE for this program:// ---interface I { void foo(Integer a1 Integer a2 String a3);}class Y { static void m(Number a1 Object... rest) { System.out.println(a1); print(rest); } static void print (Object [] o) { for (int i = 0; i < o.length; i++) System.out.println(o[i]); } }public class X { public static void main(String [] args) { I i = Y::m; i.foo(10 20 ""10 20""); }}"
406786,4/29/2013 7:44,noopur_gupta,"[1.8][extract method] Extract Method refactoring in interfaces not handled Consider the following interfaces: I2 (having lambda expression) and I3 (having default and static methods). Perform ""Extract Method"" refactoring on the lines with comments. We get exception and no refactoring is performed.It should be possible to extract methods in interfaces which would be created as default or static methods in those interfaces.@FunctionalInterfacepublic interface I1 {	int foo(int a);}interface I2 {	I1 i1= (a) -> {		int b= 10; // Exception on extracting to method		return a + b;	};}interface I3 {	default int foo () {		int a= 10; // Exception on extracting to method		return a;	}		static int bar() {		int a= 10; // Exception on extracting to method		return a;	}}"
406805,4/29/2013 11:08,shankhba,"[1.8] Parameter names for enum constructor not available The following test fails with a JavaModelException (does not exist) on #getParameterNames for binary types:ASTParser parser = ASTParser.newParser(AST.JLS3);parser.setIgnoreMethodBodies(true);parser.setProject(javaProject);IType type = javaProject.findType(""TestEnum"");IBinding[] bindings = parser.createBindings(new IJavaElement[] { type } null);ITypeBinding typeBinding = (ITypeBinding) bindings[0];IMethodBinding[] methods = typeBinding.getDeclaredMethods();for(IMethodBinding method: methods) {	if (method.isConstructor()) {		IMethod element = (IMethod) method.getJavaElement();		String[] parameterNames = element.getParameterNames();		// BOOM	}}The enum declaration:public enum TestEnum {	FirstValue(""Zonk"") {		@Override		public String toString() {			return super.toString();		}	}	SecondValue(""Bla"");		String string;		TestEnum(String string) {		this.string = string;	}}I can apply a local fix by using a handcrafted BinaryKey to obtain the enum constructor e.g. use String[] parameterTypes = Signature.getParameterTypes( new BindingKey(""Lx;.x(Ljava/lang/String;ILjava/lang/String;)"").toSignature());IMethod constructor = type.getMethod(name parameterTypes);The parameter types cannot be obtained from the BinaryMethod afterwards since BinaryMethod.getParameterNames uses // let's see if we can retrieve them from the debug infoschar[][] argumentNames = info.getArgumentNames();if (argumentNames != null && argumentNames.length == paramCount) { String[] names = new String[paramCount]; for (int i = 0; i < paramCount; i++) { names[i] = new String(argumentNames[i]); } return this.parameterNames = names;}to read the param names from the debug information. The number of arguments in the info object is different from the number of arguments in the key. The paramCount == 3 but the argumentNames contain only a single entry ['string'] which is correct but fails to fulfil the condition."
407056,5/2/2013 5:53,manju656,[1.8] Support PackageQualifiedType AST node Support the new PackageQualifiedType AST node from bug 404489 in JDT UI.The node occurs when a type-use annotation is added to a package-qualified type. Before such types were represented as SimpleType(QualifiedName).See the explanations in the Javadoc of QualifiedType in BETA_JAVA8.
407106,5/2/2013 15:26,srikanth_sankaran,"[1.8][code assist] Code assist failing for lambda expression with parameter of function call body interface Foo { 	void run1(int s1 int s2);}interface X extends Foo{	 static Foo f = (first second) -> System.out.print(firs<ctrl-space>); 		}Code assist not making suggestion."
407131,5/2/2013 21:00,manpalat,[1.8][dom ast]ASTRewrite support for ReferenceExpression nodes family
407281,5/6/2013 7:04,noopur_gupta,[content assist] Proposals like {@code} not available after typing 1. In a Javadoc comment type '@' and press Ctrl+Space. We can see tags like {@code} {@link} etc in Default proposals.2. Type a letter say 'a'. 3. Press Backspace key to delete 'a'.We get the Default proposals but tags like {@code} are missing.
407297,5/6/2013 9:40,jesper,[1.8][compiler] Control generation of parameter names by option (like 'javac -parameters') Although not documented in the JEP the current EA javac supports generation of parameter names by option '-options' in javac.ECJ should follow this lead for now. There should be a distinct Java Code Generation option for this in the UI too.
407759,5/10/2013 12:03,markus.kell.r,"Sort Members causes IAE: Comparison method violates its general contract! Created attachment 230786Source file that causes error when cleanup is appliedGreetings. The stack trace reproduced below is generated when I try to run a cleanup operation on the attached source file. My cleanup function is configured to run these operations:Change non static accesses to static members using declaring typeChange indirect accesses to static members to direct accesses (accesses through subtypes)Convert control statement bodies to blockConvert 'for' loops to enhanced 'for' loopsAdd final modifier to private fieldsAdd final modifier to local variablesRemove unused importsAdd missing '@Override' annotationsAdd missing '@Override' annotations to implementations of interface methodsAdd missing '@Deprecated' annotationsRemove unnecessary castsRemove unnecessary '$NON-NLS$' tagsSort members excluding fields enum constants and initializersOrganize importsFormat source codeRemove trailing white spaces on all linesCorrect indentationeclipse.buildId=4.3.0.I20130314-1330java.version=1.7.0_21java.vendor=Oracle CorporationBootLoader constants: OS=linux ARCH=x86_64 WS=gtk NL=en_USFramework arguments: -product org.eclipse.epp.package.classic.productCommand-line arguments: -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.classic.productErrorThu May 09 17:03:12 PDT 2013Internal Errorjava.lang.reflect.InvocationTargetException	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:421)	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1028)	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:663)	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:502)	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:74)	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:114)	at org.eclipse.jdt.internal.ui.fix.CleanUpRefactoringWizard$CleanUpConfigurationPage.getNextPage(CleanUpRefactoringWizard.java:456)	at org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:908)	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:428)	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:628)	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1392)	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3717)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3338)	at org.eclipse.jface.window.Window.runEventLoop(Window.java:826)	at org.eclipse.jface.window.Window.open(Window.java:802)	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:187)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:202)	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:122)	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:38)	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startCleanupRefactoring(RefactoringExecutionStarter.java:251)	at org.eclipse.jdt.internal.ui.actions.AllCleanUpsAction.performRefactoring(AllCleanUpsAction.java:78)	at org.eclipse.jdt.internal.ui.actions.CleanUpAction.run(CleanUpAction.java:176)	at org.eclipse.jdt.internal.ui.actions.CleanUpAction.run(CleanUpAction.java:108)	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:275)	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251)	at org.eclipse.jface.action.Action.runWithEvent(Action.java:499)	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:584)	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:501)	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:411)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1392)	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3717)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3338)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1108)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:992)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:137)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:600)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:555)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:601)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)	at org.eclipse.equinox.launcher.Main.run(Main.java:1450)	at org.eclipse.equinox.launcher.Main.main(Main.java:1426)Caused by: java.lang.IllegalArgumentException: Comparison method violates its general contract!	at java.util.TimSort.mergeHi(TimSort.java:868)	at java.util.TimSort.mergeAt(TimSort.java:485)	at java.util.TimSort.mergeForceCollapse(TimSort.java:426)	at java.util.TimSort.sort(TimSort.java:223)	at java.util.TimSort.sort(TimSort.java:173)	at java.util.Arrays.sort(Arrays.java:659)	at java.util.Collections.sort(Collections.java:217)	at org.eclipse.jdt.internal.core.SortElementsOperation$2.sortElements(SortElementsOperation.java:258)	at org.eclipse.jdt.internal.core.SortElementsOperation$2.visit(SortElementsOperation.java:302)	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:467)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514)	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2585)	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:219)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514)	at org.eclipse.jdt.internal.core.SortElementsOperation.sortCompilationUnit(SortElementsOperation.java:250)	at org.eclipse.jdt.internal.core.SortElementsOperation.calculateEdit(SortElementsOperation.java:134)	at org.eclipse.jdt.core.util.CompilationUnitSorter.sort(CompilationUnitSorter.java:455)	at org.eclipse.jdt.internal.corext.fix.SortMembersFix.createCleanUp(SortMembersFix.java:41)	at org.eclipse.jdt.internal.ui.fix.SortMembersCleanUp.createFix(SortMembersCleanUp.java:66)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.calculateChange(CleanUpRefactoring.java:807)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.calculateSolutions(CleanUpRefactoring.java:305)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.acceptAST(CleanUpRefactoring.java:283)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:892)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:581)	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:894)	at org.eclipse.jdt.internal.corext.dom.ASTBatchParser.createASTs(ASTBatchParser.java:100)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpFixpointIterator.next(CleanUpRefactoring.java:406)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.cleanUpProject(CleanUpRefactoring.java:718)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.checkFinalConditions(CleanUpRefactoring.java:674)	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345)	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)Root exception:java.lang.IllegalArgumentException: Comparison method violates its general contract!	at java.util.TimSort.mergeHi(TimSort.java:868)	at java.util.TimSort.mergeAt(TimSort.java:485)	at java.util.TimSort.mergeForceCollapse(TimSort.java:426)	at java.util.TimSort.sort(TimSort.java:223)	at java.util.TimSort.sort(TimSort.java:173)	at java.util.Arrays.sort(Arrays.java:659)	at java.util.Collections.sort(Collections.java:217)	at org.eclipse.jdt.internal.core.SortElementsOperation$2.sortElements(SortElementsOperation.java:258)	at org.eclipse.jdt.internal.core.SortElementsOperation$2.visit(SortElementsOperation.java:302)	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:467)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514)	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2585)	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:219)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2514)	at org.eclipse.jdt.internal.core.SortElementsOperation.sortCompilationUnit(SortElementsOperation.java:250)	at org.eclipse.jdt.internal.core.SortElementsOperation.calculateEdit(SortElementsOperation.java:134)	at org.eclipse.jdt.core.util.CompilationUnitSorter.sort(CompilationUnitSorter.java:455)	at org.eclipse.jdt.internal.corext.fix.SortMembersFix.createCleanUp(SortMembersFix.java:41)	at org.eclipse.jdt.internal.ui.fix.SortMembersCleanUp.createFix(SortMembersCleanUp.java:66)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.calculateChange(CleanUpRefactoring.java:807)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.calculateSolutions(CleanUpRefactoring.java:305)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.acceptAST(CleanUpRefactoring.java:283)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:892)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:581)	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:894)	at org.eclipse.jdt.internal.corext.dom.ASTBatchParser.createASTs(ASTBatchParser.java:100)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpFixpointIterator.next(CleanUpRefactoring.java:406)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.cleanUpProject(CleanUpRefactoring.java:718)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.checkFinalConditions(CleanUpRefactoring.java:674)	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345)	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)"
407841,5/13/2013 1:56,jarthana,Compiler ignores the compilation units marked as isImplicitUnit when compiled in multiple batches And this results in problems especially while processing annotations. Refer to bug 386901 for more details. The cause and the possible fix are discussed from bug 386901 comment #27 on.
407864,5/13/2013 6:45,jesper,[1.8][compiler] Add support for JEP120 (Repeating annotations) We need to add support for Java 8.A starting point:http://mail.openjdk.java.net/mailman/listinfo/enhanced-metadata-spec-discuss
407985,5/14/2013 5:16,noopur_gupta,"[1.8][extract method] Extract Method refactoring from Lambda Expressions Consider the following having lambda expressions: Class X and Interface I2.We get exception or incorrect refactoring by performing ""Extract Method"" refactoring on the lines with comments.It should be possible to extract methods from a lambda expression which would be created in its enclosing type.@FunctionalInterfacepublic interface I1 {	int foo(int a);}// Error: Extracted to m1() and placed in enclosing type. // But replaced with ""m1();"" instead of ""int b= m1();""class X {	I1 i1= (int a) -> {		int b= 10; // Error		return a + b;	};		class Y {		I1 i1= (int a) -> {			int b= 10; // Error			return a + b;		};	}		void foo() {		I1 i1= (int a) -> {			int b= 10; // Error			return a + b;		};	}		void bar() {		Runnable r= new Runnable() {			I1 i1= (int a) -> {				int b= 10; // Error				return a + b;			};						@Override			public void run() {				I1 i1= (int a) -> {					int b= 10; // Error					return a + b;				};							}		};	}}// see bug 406786 for Extract Method from lambda expr in interfacesinterface I2 {		I1 i1= (int a) -> {		int b= 10; // Exception on extracting to method		return a + b;	};	}"
408009,5/14/2013 8:48,noopur_gupta,"[1.8][extract method] Unable to extract lambda expression to method Consider the example below:@FunctionalInterfacepublic interface I1 {	int foo(int a);}class X {		void foo() {			I1 i1= (int a) -> {return 10;}; // Extract lambda expr				I1 i2= (a) -> {return 10;}; // Extract lambda expr		bar(a -> 10); // Extract lambda expr	}		void bar(I1 i) {	}	// expected method after extraction	I1 m() {		return (int a) -> {return 10;};	}}Try to extract only the lambda expr from the lines with comments to a method using Alt+Shift+M. We get different error messages in above cases and it is not possible to extract the lambda expr to a method as shown in the expected method above."
408114,5/15/2013 7:59,noopur_gupta,"[1.8][extract local] Unable to extract local variable within lambda expression's body Since a lambda expression is like a method it should be possible to extract local variables within its body.Consider the following example and try to extract a local variable from the lines with comments we get different error messages:@FunctionalInterfaceinterface FI {	int foo(int a);}public class TestExtractLocalVariable {	FI fi1= (a) -> a + 10;	// Error		FI fi2= (int a) -> {			int b= a + 10; // Error		return b;	};		void bar(FI fi) {	 FI fi1= (a) -> a + 10; // Error not extracted within lambda body			 FI fi2= (a) -> {			 int b= a + 10; // Works here		 return b;	 };			}	}"
408230,5/16/2013 8:33,anchakrk,"[1.8][hovering] NPE on hovering over a type inferred parameter in lambda expression Consider the following example and hover on ""a"" as mentioned in the comments:public class C1 {		FI i1= (a) -> a++; // [1] Hover on ""a"" in ""a++""	void foo() {		FI i2= (a) -> {			return a; // [2] Hover on ""a""		};	}}interface FI {	int f1(int a);}We get these exceptions:[1]java.lang.NullPointerException	at org.eclipse.jdt.internal.core.util.Util.typeSignature(Util.java:2685)	at org.eclipse.jdt.internal.core.SelectionRequestor.acceptLocalVariable(SelectionRequestor.java:454)	at org.eclipse.jdt.internal.codeassist.SelectionEngine.selectFrom(SelectionEngine.java:1229)[2]java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:187)	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:114)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:594)"
408334,5/17/2013 7:53,markus.kell.r,"[extract interface] AFE on selecting next change in refactoring Preview public class Test {}Right click and select 'Refactor > Extract Interface' for the above class.Give some name for interface and click ""Preview"".Use down arrow button i.e. ""Select Next Change"". It expands the 1st change node and ""Add super interface"" is selected.No input in the details page.Error is logged in the Error Log view:org.eclipse.core.runtime.AssertionFailedException: assertion failed: 	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:110)	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:96)	at org.eclipse.ltk.core.refactoring.TextChange.getCurrentContent(TextChange.java:334)	at org.eclipse.ltk.internal.ui.refactoring.TextEditChangePreviewViewer.setInput(TextEditChangePreviewViewer.java:192)..."
408653,5/21/2013 23:43,manpalat,provide a manpage for distributions that ship a standalone ecj binary Created attachment 231289Proposed ecj manpageMany distributions package JDT core libraries with an independent executable for ecj. Each of these must currently maintain a manpage if they want one. Since it is unlikely that the documentation for ecj would differ widely across distributions it would be great if this could instead be maintained upstream.Attached is proposed first cut based on most current debian release but updated to reflect the output of -help (ie usage message) from eclipse compiler as of 4.2.1.
408937,5/24/2013 4:29,manju656,"[1.8][rename] Unable to rename variables in lambda expression field Consider the following example and try to rename the variables mentioned in comments using ""Alt+Shift+R"":@FunctionalInterfaceinterface I {	int foo (int x);}public class C1 {	I i= (int x) -> { // Unable to Rename ""x""		int p= 10; // Unable to Rename ""p""		I ii= (int a) -> a+100; // Unable to Rename ""ii"" ""a""		return ii.foo(x) + p;	};	void foo() {		I i= (int x) -> x; // works here	}	}We get the error ""Only local variables declared in methods and initializers can be renamed"". However it should be possible to rename variables in any type of lambda expr also."
408966,5/24/2013 8:01,noopur_gupta,"[1.8][inline] Invalid inline constant and inline temp refactorings using lambda expressions Consider the following example and perform Refactor > Inline as per the comments:@FunctionalInterfaceinterface I1 {	int foo(int x);	}public class X {	public static final I1 a= (int x) -> x;		void fun1() {		int n = a.foo(0); // [1] Inline ""a"" => AFE					I1 i= (int x) -> { return x; }; // [2] Inline ""i""		I1 i1= x -> i.foo(x); // => Invalid inlining of ""i""		fun2(i); // => Valid inlining of ""i""	}		void fun2(I1 i) {}}[1] => java.lang.reflect.InvocationTargetException...Caused by: org.eclipse.core.runtime.AssertionFailedException: assertion failed: 	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:110)	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:96)	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentFactory.setFragment(ASTFragmentFactory.java:194)	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentForFullSubtreeFactory.visit(ASTFragmentFactory.java:133)	at org.eclipse.jdt.internal.corext.dom.HierarchicalASTVisitor.visit(HierarchicalASTVisitor.java:547)	at org.eclipse.jdt.internal.corext.dom.HierarchicalASTVisitor.visit(HierarchicalASTVisitor.java:566)	at org.eclipse.jdt.core.dom.SimpleName.accept0(SimpleName.java:149)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2670)	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2718)	at org.eclipse.jdt.core.dom.LambdaExpression.accept0(LambdaExpression.java:215)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2670)	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentFactory.createFragment(ASTFragmentFactory.java:186)	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentForFullSubtreeFactory.createFragmentFor(ASTFragmentFactory.java:115)	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory.createFragmentForFullSubtree(ASTFragmentFactory.java:56)	at org.eclipse.jdt.internal.corext.refactoring.code.InlineConstantRefactoring.checkInitializer(InlineConstantRefactoring.java:789)	at org.eclipse.jdt.internal.corext.refactoring.code.InlineConstantRefactoring.checkInitialConditions(InlineConstantRefactoring.java:736)	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:83)...[2] => Results in:I1 i1= x -> (int x) -> { return x; }.foo(x); // => Invalid inlining of ""i""fun2((int x) -> { return x; }); // => Valid inlining of ""i"""
408979,5/24/2013 9:04,manju656,"[1.8][quick fix] NPE and incorrect result from ""Add return statement"" quick fix on lambda expression Consider the following example and apply the quick fix ""Add return statement"" on the lines with comments:@FunctionalInterfaceinterface I {	int foo(int x);	}public class A {	void fun1() {		I i= (int x) -> { // [1] NPE on applying quick fix			x++;		};			}		void fun2() {		I i= (int x) -> { // [2] Incorrect result from quick fix			x++;		};				fun1();	}}[1] =>java.lang.NullPointerException	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:132)	at org.eclipse.jdt.internal.ui.text.correction.proposals.MissingReturnTypeCorrectionProposal.evaluateReturnExpressions(MissingReturnTypeCorrectionProposal.java:154)	at org.eclipse.jdt.internal.ui.text.correction.proposals.MissingReturnTypeCorrectionProposal.getRewrite(MissingReturnTypeCorrectionProposal.java:113)	at org.eclipse.jdt.ui.text.java.correction.ASTRewriteCorrectionProposal.addEdits(ASTRewriteCorrectionProposal.java:113)	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createTextChange(CUCorrectionProposal.java:234)...[2] => Adds return statement to method fun2() instead of the lambda expression. Results in:	void fun2() {		I i= (int x) -> { 			x++;		};				return fun1(); // Incorrect result	}"
409023,5/24/2013 13:48,Michael_Rennie,"HCR drops too many frames from local type Created attachment 231493fixFUP to bug 403475 if you have a local type defined that executes a method with the same name as the enclosing method HCR drops to the enclosing method.Run the following snippet add a change to LocalClass#run save and notice two frames are popped. We shold be popping the top frame annd be back in LocalClass#run instead we end up in TestHCR#run (the enclosing method).package a.b.c;public class TestHCR {		public void run() {		System.out.println(""LocalHCR#run()"");				class LocalClass {			public void run() {				System.out.println(""LocalClass#run()""); //BP here			}		}		new LocalClass().run();	}	static class InnerClass {		public void run() {			System.out.println(""InnerClass#run()"");			new TestHCR().run();		}	}	public static void main(String[] args) {		System.out.println(""TestHCR#main()"");		new InnerClass().run();	}}"
409586,5/31/2013 9:23,jarthana,[1.8][dom ast] Cannot identify TYPE_USE annotation from ITypeBinding Up to Java 7 every reference to a type had the same ITypeBinding and the annotations could only come from the type's declaration. Now reference type bindings can carry different TYPE_USE annotations but this is not reflected in the ITypeBinding API.We need to find the right solution to identify TYPE_USE annotation from ITypeBinding.
409596,5/31/2013 10:16,jdt-ui-inbox,"[1.8][refactoring] UI refactorings affected by lack of TYPE_USE annotations in ITypeBindings Below are the UI refactorings affected by bug 409586.1 => Move Method refactoringStep 1: Consider the method:public void foo(java.io.@NonNull FileNotFoundException arg AnnotatedType type)			throws java.io.@NonNull EOFException {}Step 2: Invoke Refactoring> Move on foo. Resultant method is shown below:public void foo(FileNotFoundException arg)			throws java.io.@NonNull EOFException {}Note that the method argument after move is just a SimpleType and not a PackageQualifiedType. This is because in MoveInstanceMethodProcessor#createMethodArguments(...)#getArgumentNode(...) we create a SimpleType from the TypeBinding. Here we need a mechanism to identify PackageQualifiedType/SimpleType from the given TypeBinding.2 => Change Method Signature refactoringStep 1: Consider the method:public void foo(java.io.@NonNull FileNotFoundException arg AnnotatedType type)			throws java.io.@NonNull EOFException {}Step 2: Invoke Refactoring> Change Method Signature on foo. In the first page of the 'Change Method Signature' wizard the 'Method signature preview:' shows the method arguments and the throws clause as SimpleType and not PackageQualifiedType as shown below:public void foo(FileNotFoundException arg AnnotatedType type) throws EOFExceptionWe will update this bug as and when new issues with TYPE_USE annotation in the context of ITypeBinding is encountered in UI."
409707,6/3/2013 5:48,markus.kell.r,PropertiesFileQuickAssistTest.testRemoveProperty3 and testRemoveProperty4 failed I20130531-2000.PropertiesFileQuickAssistTest.testRemoveProperty3 and testRemoveProperty4 failed.http://download.eclipse.org/eclipse/downloads/drops4/I20130531-2000/testresults/html/org.eclipse.jdt.ui.tests_macosx.cocoa.x86_5.0.htmlnls file expected:<... static String Test_[]2; } > but was:<... static String Test_[1; public static String Test_]2; } >junit.framework.ComparisonFailure: nls file expected:<... static String Test_[]2;}> but was:<... static String Test_[1;public static String Test_]2;}>at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.assertEqualLines(PropertiesFileQuickAssistTest.java:153)at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.checkContentOfCu(PropertiesFileQuickAssistTest.java:124)at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.testRemoveProperty3(PropertiesFileQuickAssistTest.java:641)at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23)at junit.extensions.TestSetup$1.protect(TestSetup.java:23)at junit.extensions.TestSetup.run(TestSetup.java:27)at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23)at junit.extensions.TestSetup$1.protect(TestSetup.java:23)at junit.extensions.TestSetup.run(TestSetup.java:27)at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23)at junit.extensions.TestSetup$1.protect(TestSetup.java:23)at junit.extensions.TestSetup.run(TestSetup.java:27)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310)at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197)at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3976)at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3653)at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113)at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997)at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138)at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610)at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567)at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140)at org.eclipse.test.UITestApplication.run(UITestApplication.java:62)at org.eclipse.test.UITestApplication.start(UITestApplication.java:212)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)at org.eclipse.equinox.launcher.Main.run(Main.java:1450)at org.eclipse.equinox.launcher.Main.main(Main.java:1426)at org.eclipse.core.launcher.Main.main(Main.java:34)nls file expected:<... static String Test_[]5; public static...> but was:<... static String Test_[3; public static String Test_4; public static String Test_]5; public static...>junit.framework.ComparisonFailure: nls file expected:<... static String Test_[]5;public static...> but was:<... static String Test_[3;public static String Test_4;public static String Test_]5;public static...>at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.assertEqualLines(PropertiesFileQuickAssistTest.java:153)at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.checkContentOfCu(PropertiesFileQuickAssistTest.java:124)at org.eclipse.jdt.ui.tests.quickfix.PropertiesFileQuickAssistTest.testRemoveProperty4(PropertiesFileQuickAssistTest.java:709)at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23)at junit.extensions.TestSetup$1.protect(TestSetup.java:23)at junit.extensions.TestSetup.run(TestSetup.java:27)at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23)at junit.extensions.TestSetup$1.protect(TestSetup.java:23)at junit.extensions.TestSetup.run(TestSetup.java:27)at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23)at junit.extensions.TestSetup$1.protect(TestSetup.java:23)at junit.extensions.TestSetup.run(TestSetup.java:27)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:655)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310)at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197)at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3976)at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3653)at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113)at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997)at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138)at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610)at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567)at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140)at org.eclipse.test.UITestApplication.run(UITestApplication.java:62)at org.eclipse.test.UITestApplication.start(UITestApplication.java:212)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)at org.eclipse.equinox.launcher.Main.run(Main.java:1450)at org.eclipse.equinox.launcher.Main.main(Main.java:1426)at org.eclipse.core.launcher.Main.main(Main.java:34)
409719,6/3/2013 8:41,noopur_gupta,[1.8][refactoring] Incorrect Method signature preview for default methods Created attachment 231869ScreenshotIn Refactoring wizards like Change Method Signature and Introduce Parameter Object the Method signature preview for default methods does not show the default modifier. Attached the screenshot.
409723,6/3/2013 9:03,noopur_gupta,"[1.8][introduce indirection] Unable to introduce indirection on methods in an interface Created attachment 231871ScreenshotRefactor > Introduce Indirection on default and static methods in an interface gives the error ""Cannot place new method on an interface."" as shown in the attached screenshot.Expected result for the default method is shown below: public interface I {	public static void foo(I i) {		i.foo();	}	default void foo() {	}}"
409832,6/4/2013 7:17,markus.kell.r,"[content assist] typing comma () within a string jumps to the next argument Created attachment 231928Video of the problem with autocompletionIf you have a method signature like this:StringTools.concatenateWithSeparator(String sep String... input)Typing """" as seperator will not work as expected.When you have typed "" it will not write the comma out but jump to next field.It also happens if you first type """" and then later want to add comma inside the String. It will not write comma out but jump to next field.However sometimes when you try it the second time it seems to work.I have attached video of the problemWhat it should do: When you are inside String delimiters do not jump to next field on comma"
409906,6/5/2013 2:43,noopur_gupta,"[1.8][move static members] Error in Preview while moving static method to interface Created attachment 231968ScreenshotConsider the following example:public interface I {}class X {	static int get() { // Move 'get'		return 0;	}}Refactor > Move on get(). We get Move Static Members wizard. Select Destination type for get() as the interface I.Click Preview -> Error is shown as in the attached screenshot.Click Continue and then OK. Refactoring is completed without any compilation error.The error in the Preview should not be shown."
410056,6/6/2013 7:21,manju656,"[1.8][move method] Moving default method brings up Textual Move wizard public interface I { default void foo(XYZ xyz) {		}}class XYZ {}Refactor > Move on method ""foo(XYZ)"".It brings up the ""Textual Move"" wizard.Moving a default method is like moving an instance method so Move Instance Method refactoring should be adjusted to handle it. Default methods can be with/without a valid target type and we will have to retain or remove 'default' depending on the target type."
410170,6/7/2013 7:53,manju656,"[1.8][quick fix] Remove invalid modifier on static and default interface methods interface I {	private static void foo() { // Error [1]	}		private default void bar() { // Error [2]	}	}[1] 'Remove invalid modifier' quick fix removes 'static' modifier also along with 'private'. [2] No quick fix is available.The quick fix should be updated to handle static and default interface methods at ModifierCorrectionSubProcessor.addRemoveInvalidModifiersProposal(..)."
410207,6/7/2013 11:34,sptaszkiewicz,"Compiler incorrectly reports error message ""X cannot be resolved. It is indirectly referenced from required .class files"" Created attachment 232112Reduced Test CaseI know there other bugs related to this message (ie. 239639 320965 391528) but this issue deals with backward compatibility with JDK 1.4 'built' jars.Steps to reproduce the problem: 1. Import the two projects from the attached zipJ14 (1.4 level)J16 (1.6 level)2. Export J14 as a jar3. Bring up the properties for J16 and add the jar to its Java build path.4. Open the Main class in J16 using the Java Editor--> You will see the errror message5. If you run the Main class as a Java Application it works as expected. This shows backward compatibility of 1.4 level jars. The error message is misleading because the type/class is actually present in the jar."
410371,6/10/2013 13:41,markus.kell.r,"[generalize type] Generalize Type adds import that changes semantics of existing simple names Created attachment 232190Fix4.3 RC4In BETA_JAVA8 in org.eclipse.jdt.core.dom.ASTConverter I tried to generalize a type reference ""org.eclipse.jdt.internal.compiler.ast.LambdaExpression"" to ""org.eclipse.jdt.internal.compiler.ast.Expression"".The refactoring added an import for ""Expression"" although a homonym from the enclosing package org.eclipse.jdt.core.dom was already in use."
410650,6/12/2013 15:05,noopur_gupta,"[hovering] ""else if"" closing bracket hover should include all preceding ifs The closing bracket hover after an ""else if"" should include all preceding ifs.Example:		if (i == 1) {			int i1;			int i2;			int i3;			int i4;		} else if (i == 2) {			new I1();			new I2();			new I3();			new I4();		} else { // hover on ""}"" only shows one if not both			test1();			test2();			test3();			test4();		} // hover on ""}"" shows all ifs After bug 377141 the hover on the ""}"" of an ""else"" branch now shows all preceding ""if"" expressions. The same should be implemented for the ""}"" of an ""else if"" branch in the same ""if"" (... ""else if"")+ (... ""else"")? structure."
410892,6/16/2013 16:19,Olivier_Thomann,I've run into an old bug 241044 (info cannot be null - somewhere in the incremental compiler) The error message appeared when I used a switch (java.lang.String) construct.It went away when I replaced the switch with a series of if (.equals) statements.Don't know if this helps.
410989,6/18/2013 4:13,noopur_gupta,"[1.8][organize imports] Removes required import for TYPE_USE annotation - Create a package com.p1 and add the following annotation type in it:package com.p1;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.TYPE_USE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface TypeUse {}- Create another package com.p2 and add the following class in it:package com.p2;import java.util.ArrayList;import com.p1.TypeUse;public class C1 {		ArrayList<@TypeUse String> list;}- Perform: Source > Organize Imports (Ctrl+Shift+O) on the class.import com.p1.TypeUse; is removed and we get compilation error on @TypeUse in the class."
411771,6/27/2013 9:13,shankhba,[compiler][null] Enum constants not recognised as being NonNull. This is pretty similar to bug 380896 but the test case is slightly different -- the enum is declared in a separate file.// file TestEnum.javaenum TestEnum { FOO; }// file NullTest.javapublic class NullTest { public static TestEnum bla() { @javax.annotation.Nonnull final TestEnum t = TestEnum.FOO; // Null type safety: The expression of type TestEnum needs unchecked conversion to conform to '@Nonnull TestEnum' return t; }}Eclipse is configured to use 'javax.annotation.CheckForNull' for 'Nullable' annotation 'javax.annotation.Nonnull' for 'NonNull' and the 'NonNullByDefault' is left unchanged. The annotations are as downloaded from http://code.google.com/p/jsr-305/ SVN.Strangely enough moving TestEnum to the same file as NullTest (as in the test case in bug 380896) makes the issue go away.Eclipse SDKVersion: 4.3.0Build id: I20130605-2000
412119,7/2/2013 11:19,shankhba,Optional warning for unused throwable variable in catch block I would like to be able to make it a warning if the throwable that is caught is not used in the surrounding block.e.g. This would be a warningtry{ somethingDangerous();}catch(Exception e){ throw new RuntimeException();}but this would nottry{ somethingDangerous();}catch(Exception e){ throw new RuntimeException(e);}I have encountered many instances where they fail to pass in the exception as a cause or fail to log it appropriately which makes debugging a headache. If it were an optional warning I would certainly have it enabled.
412139,7/2/2013 15:23,markus.kell.r,"[hovering] Links in Javadoc hover/view headers don't resolve fully-qualified types correctly Links in Javadoc hover/view headers don't resolve fully-qualified types correctly.Many examples can be found in org.eclipse.jdt.core.dom.ASTConverter e.g. recordNodes(ASTNode node org.eclipse.jdt.internal.compiler.ast.ASTNode oldASTNode).The Javadoc tool generates title attributes like ""class or interface in org.eclipse.jdt.internal.compiler.ast"" for links to types. We could also generate titles but we better just use ""in <package>"" syntax."
412400,7/5/2013 9:07,sptaszkiewicz,"AbstractJavaModelTests.createJavaProject(*) ignores 1.6 compliance Created attachment 233126FixWhile working on a regression test for bug 410207 I was puzzled why my test fails when I set compliance to 1.5 (expected without fix for bug 410207) but then surprisingly passes without any problem when I set compliance to 1.6. It turned out that ""1.6"" is not correctly transformed into compiler options inside AbstractJavaModelTests.createJavaProject(*). Unless there is a reason to ignore ""1.6"" it seems that all tests that use these helper methods with compliance ""1.6"" are tested with bad compiler options."
412664,7/10/2013 7:06,mistria,Tests including directly NULL character Tests in MatchingRegionsTest directly include the NULL character (0) which causes issues with other programs reading the source (mainly those implemeted in C and family where \0 is the end-of-string character). This includes CGit and PostgreSQL.Discussion started here: http://dev.eclipse.org/mhonarc/lists/platform-dev/msg00964.html
412882,7/12/2013 14:47,jarthana,Unnecessary validation of optional library classpath entries. During the classpath validation first all the classpath entries are validated and then the validation status is not reported for the optional entries. Due to that when large number of optional entries existed on classpath a majority of portion is spent on their validation which is of no use.In a project with 12000+ optional library jars setRawclaasspath is spending more than 90% of time on this unnecessary validation. Here is the call tree captured with a profiler ...- 21925 ms org.eclipse.jdt.internal.core.JavaProject.setRawClasspath - 21925 ms org.eclipse.jdt.internal.core.JavaProject.setRawClasspath - 21925 ms org.eclipse.jdt.internal.core.JavaModelOperation.runOperation - 21675 ms org.eclipse.core.internal.resources.Workspace.run - 21675 ms org.eclipse.jdt.internal.core.JavaModelOperation.run - 21675 ms org.eclipse.jdt.internal.core.SetClasspathOperation.executeOperation - 20500 ms org.eclipse.jdt.internal.core.ChangeClasspathOperation.classpathChanged - 20376 ms org.eclipse.jdt.internal.core.ClasspathValidation.validate - 20214 ms org.eclipse.jdt.internal.core.ClasspathEntry.validateClasspathEntry - 20214 ms org.eclipse.jdt.internal.core.ClasspathEntry.validateClasspathEntry - 19978 ms org.eclipse.jdt.internal.core.ClasspathEntry.validateLibraryEntry - 13461 ms org.eclipse.jdt.internal.core.ClasspathEntry.validateLibraryContents - 13461 ms org.eclipse.jdt.internal.core.JavaModelManager.verifyArchiveContent - 12023 ms org.eclipse.jdt.internal.core.JavaModelManager.getZipFile - 12006 ms java.util.zip.ZipFile.<init> - 5511 ??s org.eclipse.core.internal.resources.Workspace.getRoot - 5439 ??s org.eclipse.core.runtime.Path.toFile - 1438 ms org.eclipse.jdt.internal.core.JavaModelManager.closeZipFileI am working on a patch to avoid this unncessery validation and will send it across soon.
412929,7/14/2013 23:22,eclipse,"[organize import] Adding a type results in adding a package and later does not honor order Currently as document described (http://help.eclipse.org/kepler/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fpreferences%2Fjava%2Fcodestyle%2Fref-preferences-organize-imports.htm) the organize import feature does only match the prefix of imports but not the qualified class name.If I want to make some class always be the first import in the file like the android's ""R"" class it is not possible.I hope the organize import feature can handle the exact class and put them to the position I set."
413419,7/22/2013 5:01,markus.kell.r,"[regression] No (more) way to specify empty program argument under windows There is no (more) way ""to create a Run/Debug Configuration for a Java Project which contains ""empty"" Program Parameters."" under windows.From the commandline/shell (windows/linux) the parameter '""""' would be parsed into an empty string as expected.Using the same argument in a Run/Debug Configuration (under Windows) you now get two double-quotes.Maybe this bug(fix):https://bugs.eclipse.org/bugs/show_bug.cgi?id=387504... reintroduced two old bugs:https://bugs.eclipse.org/bugs/show_bug.cgi?id=24260https://bugs.eclipse.org/bugs/show_bug.cgi?id=70955"
413569,7/23/2013 15:22,manpalat,"[1.8][dom ast] AST for annotated multi-dimensional array type is not well-formed The AST for a multi-dimensional array type with annotations on the array dimensions is not well-formed. The problem is that for ArrayType nodes the linearization of the AST (i.e. the source order of AST nodes) doesn't correspond to the language model. This is a new problem not bug 403834 or bug 391894 comment 4.Example:import java.lang.annotation.*;@Target(ElementType.TYPE_USE)@Retention(RetentionPolicy.RUNTIME)@Documented@interface A {	int value() default 0;}public class TestArrayAnnotations {	@A(3) String @A(1)[] @A(2)[] arr =			new @A(3) String @A(1)[11] @A(2)[12];}The AST node for the type of field 'arr' is:ASTNode type/property Source range--------------------- ---------------------------------ArrayType String @A(1)[] @A(2)[]+annotations @A(2)+componentType String @A(1)[] +annotations @A(1) +componentType String +name StringThe problem is that this componentType is just a parsing artifact but it doesn't make sense from a semantic point of view. As http://types.cs.washington.edu/jsr308/specification/java-annotation-design.html#array-syntax explains the type nesting in the language model is actually going like this:ArrayType @A(3) String @A(1)[] @A(2)[]+annotations @A(1)+componentType @A(3) String @A(2)[] +annotations @A(2) +componentType @A(3) String +annotations @A(3) +name StringAs long as nobody could actually distinguish the different array brackets we could live with that. I.e. it usually doesn't matter whether the component type of String[][] is String[] with the first or with the second set of brackets.But as soon as we add annotations the picture changes. With the current AST node structure it's e.g. impossible to implement bug 409586 correctly because the top-level ArrayType's annotation is ""@A(2)"" but the binding of the top-level ArrayType must have annotation ""@A(1)"" because that's the annotation on the outermost array brackets.The type ""String @A(1)[]"" doesn't exist from a language point of view because the annotation ""@A(1)"" annotates the type String[][] not a String[].The only way I see how we could reconcile AST nodes and bindings would be to replace the nestable ArrayType by a FlatArrayType node with these properties:+componentType: Type (cannot be another FlatArrayType)+dimensions: List<ExtraDimension>Then the binding of the FlatArrayType would be identical to the binding of the leftmost dimension."
413583,7/23/2013 18:39,markus.kell.r,"Setup of null annotations in plug-in project does not work with headless PDE/Build Bug 366014 added support for automatically configuring projects for the use ofnull annotations. For plug-in projects it inserts an additional.bundles stanzainto build.properties.I never fully understood the effect but today I ran my first headless PDE-buildon a bundle with null annotations which failed due to bug 354724.If I understand that bug correctly it is actually a ""works-as-designed"": ""The fact that PDE Build does not consider the additional.bundles property can lead to a slightly different issue. The property is not intended to add anything to the build classpath but instead allow the workspace to build when there are indirect dependencies. Another bundle should be adding the additional bundle as a real (manifest) dependency.""Thus I propose to change the mechanism from bug 366014 (and the documentation)to use an optional import instead (I tried Require-Bundle which worked not sureif Import-Package would work and be more appropriate or not).As an extra data point I may want to check if/how tycho interprets these settings ..."
414038,7/30/2013 12:41,srikanth_sankaran,"[1.8][compiler] CCE in resolveAnnotations Created attachment 233952Test case to reproduce the issueStack Trace:java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.ast.Annotation$TypeUseBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.FieldBinding	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:713)	at org.eclipse.jdt.internal.compiler.lookup.FieldBinding.getAnnotationTagBits(FieldBinding.java:281)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypeFor(SourceTypeBinding.java:1474)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.fields(SourceTypeBinding.java:775)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:753)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:757)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:424)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1200)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
414084,7/31/2013 0:39,manju656,"[1.8][quick fix] Add more quick fix proposals for implicit abstract method with body in interface Consider the below code:	interface test{		public void m1(){	}For m1() currently user is provided with a single Quick Fix proposal which will remove the body of the method. Ideally from Java 1.8 the method can be either default or static hence we need to provide 2 new proposals here.The Quick Fix proposals will be:1. Remove method body2. Add 'default' modifier3. Add 'static' modifier"
414100,7/31/2013 4:31,noopur_gupta,"[1.8][quick fix] Change modifier to static for default and abstract methods interface A_test109 {	int i = foo(); // Error	default int foo() {}}The quick fix: ""Change modifier of 'foo()' to 'static'"" in the above example for compilation error: ""Cannot make a static reference to the non-static method foo() from the type A_test109"" produces the following result:interface A_test109 {	int i = foo();	default static int foo() {}}The 'default' modifier should be replaced with 'static'."
414113,7/31/2013 6:11,srikanth_sankaran,"[1.8] Method Binding for default method has abstract modifier instead of default interface A_test109 {	int i = foo(); // Error	default int foo() {		return 0;	}}Add a breakpoint in method: org.eclipse.jdt.internal.ui.text.correction.ModifierCorrectionSubProcessor#addNonAccessibleReferenceProposal(..)Hover on the error in the above example.The method binding for 'selectedNode' (case: ASTNode.SIMPLE_NAME) contains 'abstract' modifier instead of 'default'."
414122,7/31/2013 8:02,noopur_gupta,"[1.8][quick fix] 'Create method' quick fix with interface members public interface A_test1 { // creates default methods without body	int i= aaa(); 		default void defaultM() {		int a= bbb();	}		static void staticM() {		int x= ccc();	}}interface A_test2 { // creates static method without body	int i = foo1();	static int foo() {return 0;}}interface A_test3 { // creates abstract method	int i = foo2();}-------------------------------------------------------------In the above example 'Create method' quick fix creates incorrect methods as given below:public interface A_test1 {	// creates default methods without body	int i= aaa(); 		default void defaultM() {		int a= bbb();	}		default int bbb();	default int aaa();	static void staticM() {		int x= ccc();	}	default int ccc();}interface A_test2 { // creates static method without body	int i = foo1();	static int foo() {return 0;}	static int foo1();}interface A_test3 { // creates abstract method	int i = foo2();	int foo2();}-------------------------------------------------------------It should not create an abstract method in any case.Also we should check if a default or a static method has to be created and create the correct method with body accordingly."
414285,8/2/2013 6:29,Michael_Rennie,"On systems with large RAM evaluateSystemProperties and generateLibraryInfo fail for 64-bit JREs On a system with large RAM the following error is logged when I start a 64-bit Eclipse using a 64-bit JRE and open the ""Plug-in development"" perspective.> Error> Fri Aug 02 10:44:03 CEST 2013> Failed to retrieve default libraries for /proj/CoolTools/app/JRE/jre-7u25-linux-x64This error is logged by org.eclipse.jdt.internal.launching.StandardVMType.generateLibraryInfo method which starts a native process in order to obtain JVM properties. Using strace I was able to find out that it runs the following command:> /proj/CoolTools/app/JRE/jre64/bin/java -classpath /home/ekalmik/.eclipse/org.eclipse.platform_4.3.0_1947859192_linux_gtk_x86_64/configuration/org.eclipse.osgi/bundles/262/1/.cp/lib/launchingsupport.jar org.eclipse.jdt.internal.launching.support.LibraryDetector... and gets the following results:> Error occurred during initialization of VM> Could not reserve enough space for object heap> Error: Could not create the Java Virtual Machine.> Error: A fatal exception has occurred. Program will exit.Indeed when I run the same command in shell I observe the same behaviour. However if I add -Xmx64m directly after the name of executable I get correct data.> 1.7.0_25|/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/resources.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/rt.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/sunrsasign.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/jsse.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/jce.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/charsets.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/jfr.jar:/proj/CoolTools/app/JRE/jre-7u25-linux-x64/classes|/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/ext:/usr/java/packages/lib/ext|/proj/CoolTools/app/JRE/jre-7u25-linux-x64/lib/endorsedI've also verified that if I start the same Eclipse using a 32-bit JRE on the same system no errors are printed. Of course running the command above using a 32-bit JRE without specifying -Xmx works fine too.According to [1] a 64-bit server-class JRE would allocate 1/4th of physical RAM if no -Xmx is given. The system I'm on has 250GB of RAM and according to strace java has tried allocating 30GB of RAM in order to run LibraryDetector which is ridiculous.-> cat /proc/meminfo | grep MemMemTotal: 264118168 kBMemFree: 173739052 kBA temporary workaround I employed is to set _JAVA_OPTIONS environment variable to -Xmx384m. Unfortunately this trick overrides vmargs provided to Eclipse and therefore I cannot set it lower. A proper solution would be to always specify -Xmx when starting a JVM in a subprocess. I've tried LibraryDetector with -Xmx2m and it worked fine.* References *[1] http://docs.oracle.com/javase/6/docs/technotes/guides/vm/gc-ergonomics.html* System info *-> lsb_release -dDescription:	Red Hat Enterprise Linux Server release 6.2 (Santiago)-> cat /proc/cpuinfo | grep processor | wc -l32-> cat /proc/meminfo | grep MemTotalMemTotal: 264118168 kB-> /proj/CoolTools/app/JRE/jre32/bin/java -versionjava version ""1.7.0_25""Java(TM) SE Runtime Environment (build 1.7.0_25-b15)Java HotSpot(TM) Server VM (build 23.25-b01 mixed mode)-> /proj/CoolTools/app/JRE/jre64/bin/java -Xmx2m -versionjava version ""1.7.0_25""Java(TM) SE Runtime Environment (build 1.7.0_25-b15)Java HotSpot(TM) 64-Bit Server VM (build 23.25-b01 mixed mode)* Eclipse info *BootLoader constants: OS=linux ARCH=x86_64 WS=gtk NL=en_USCommand-line arguments: -os linux -ws gtk -arch x86_64The installation I've used to get above info with was created with p2 director from Kepler repository and based on SR0.> org.eclipse.platform_4.3.0_1947859193_linux_gtk_x86_64> org.eclipse.jdt.debug_3.8.0.v20130514-0841> org.eclipse.jdt.launching_3.7.0.v20130515-1451.jarHowever I've also verified that the same error is present in another installation created from Juno repository and based on SR2."
414653,8/8/2013 6:39,jarthana,"[test] intermittent failures in SwitchTest When I run RunJDTCoreTest locally most the time I get one random failure inSwitchTest re-running that particular test always passes.By instrumenting VerifyTests I see the following pattern:- VM is launched for testMarysLamb()- this test runs fine socket is working- the log file created for this VM reports only this one test.- next VM is launched for testNestedSwitches()- between testMarysLamb() and testNestedSwitches() we have two tests: - testBreakOut() -> pass - testMultipleSwitches() -> fail unexpectedly empty output Why are those missing from the log?In the console I find:java.io.EOFException	at java.io.DataInputStream.readBoolean(DataInputStream.java:244)	at org.eclipse.jdt.core.tests.util.TestVerifier.loadAndRun(TestVerifier.java:583)	at org.eclipse.jdt.core.tests.util.TestVerifier.verifyClassFiles(TestVerifier.java:643)	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2516)	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2317)	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runConformTest(AbstractRegressionTest.java:1361)	at org.eclipse.jdt.core.tests.compiler.regression.SwitchTest.testBreakOut(SwitchTest.java:1859)I see this for several tests incl. both ""missing"" tests but *not* for testMarysLamb()My guess that the socket was unexpectedly closed has not yet been confirmed by logging.I may need to do more flushing to see if the missing log output is lost pendingin some buffer."
415066,8/14/2013 10:11,manpalat,"ASTParser could not createAST(...) for java files with classes package private access when we use setSource(char[] source) but do not use setProject(..) It is when you used parser outside IDE and does not have got access to JavaProject. You will provide properly all data to parser but it fails on case like:File A:-------public class A { }class B {}-------File C:-------public class C extends B {}-------Goal: We want createAST() for file C.It is caused that method findType() is broken in NameEnvironmentWithProgress See: class CompilationUnitResolvermethod 	public static void resolve(...)line: environment = new NameEnvironmentWithProgress(allEntries null monitor);Method findType in this NameEnvironmentWithProgress could better support this case.In findType going down few stepsNameEnvironmentAnswer.findClass() this is place where is a bug in this case:If class is on the class path then it is ok but in our case. Both classes are on one file with source code and second class is not in classpath and you have not got binaries. You do not want build it. You just want create AST then this aproach where you are searching for binary .class file names are completely fails. This will back you class not found and compile error when everything is fine.Quick fix could be looks something like that: @Override public NameEnvironmentAnswer findType(final char[] aTypeName final char[][] aaPackageName) { NameEnvironmentAnswer findType = super.findType(aTypeName aaPackageName); // invoked actual version of findType() if ((findType == null) && (_packagePrivateClasses != null) && CharOperation.equals(aaPackageName _sOriginalPackage)) { // if we could not find this type it means that could be package private type declared in another .java file. We should inspect all .java files in this // package to discover it final String string = getContainingJavaFileForType(CharOperation.charToString(aTypeName)); if (UString.isNonEmptyString(string)) { findType = super.findType(string.toCharArray() aaPackageName); } } return findType; }If you need more details to reproduce this bug on for ideas how to fix it please do not hesitate to contact me :)"
415274,8/17/2013 0:32,het,"Annotation processing throws a NPE in getElementsAnnotatedWith() We annotate some of our classes with the org.mangosdk.spi.ProviderFor annotation. We have a setup where one of the projects in the workspace creates an annotation jar (foo-anno.jar) that is used by other dependent projects in the workspace. When eclipse is 1st started up then all is well and annotation proceeds without error. However if our own foo-anno.jar gets rebuilt while eclipse is up then more often than not annotation processing will start throwing the following stacktrace in the Error log.java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundEnvImpl.getElementsAnnotatedWith(RoundEnvImpl.java:127)	at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundEnvImpl.getElementsAnnotatedWith(RoundEnvImpl.java:195)	at org.mangosdk.spi.processor.SpiProcessor.handleAnnotations(SpiProcessor.java:138)	at org.mangosdk.spi.processor.SpiProcessor.process(SpiProcessor.java:105)	at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundDispatcher.handleProcessor(RoundDispatcher.java:139)	at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundDispatcher.round(RoundDispatcher.java:110)	at org.eclipse.jdt.internal.compiler.apt.dispatch.BaseAnnotationProcessorManager.processAnnotations(BaseAnnotationProcessorManager.java:159)	at org.eclipse.jdt.internal.apt.pluggable.core.dispatch.IdeAnnotationProcessorManager.processAnnotations(IdeAnnotationProcessorManager.java:134)	at org.eclipse.jdt.internal.compiler.Compiler.processAnnotations(Compiler.java:846)	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:434)	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:366)	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:178)	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:303)	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:60)	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:254)	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:173)	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:726)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:199)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:239)	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:292)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:295)	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:351)	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:374)	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)The NPE is because line 195 in RoundEnvImpl.java passes a null argument to the getElementsAnnotatedWith() method on line 127. That method doesn't check for null and tries to use the parameter. The solution is to add the following to the start of the getElementsAnnotatedWith() method at line 127.	if (a == null) {		return Collections.emptySet();	}This bug affects 4.3 as well as 4.4M1."
415630,8/21/2013 15:47,mateusz.matela,"[formatter] Command-line execution doesn't honor ""never indent comments"" options Created attachment 234630A small syntactically correct Java file that can be used to demonstrate the problemThe ""Never indent line comments on first column"" and ""Never indent block comments on first column"" work great when used interactively from the full IDE but they don't work when invoked from the command-line using the instructions athttp://help.eclipse.org/juno/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Ftasks%2Ftasks-231.htm&cp=1_3_10_0Steps to Reproduce:1) Go to Window - Preferences.2) Navigate to Java/Code Style/Formatter3) Create a new profile (or edit your current one) such it has the following options checked [Comments] Never indent line comments on first column [Comments] Never indent block comments on first column4) Create a file named BadStyle.java that looks like this (or download the attachment)""""""public class BadStyle {/* This is a block comment on the first column */// This is a line comment on the first column void DoNothing() { } }""""""5) Confirm that if you format the file with Ctrl+Shift+F the comments don't move.6) Export the current preferences to a .prefs file following the instructions onhttp://help.eclipse.org/juno/topic/org.eclipse.jdt.doc.user/tasks/tasks-232.htm?cp=1_3_10_1or download the attached ""org.eclipse.jdt.core.prefs"" file7) Confirm that you exported the settings by looking for these lines in the resulting <project>/.settings/org.eclipse.jdt.core.prefsorg.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column=trueorg.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column=true8) Format the file from the command lineeclipse -verbose -noSplash -application org.eclipse.jdt.core.JavaCodeFormatter -config org.eclipse.jdt.core.prefs BadStyle.javaWhat Happens:The comments in BadStyle.java were indented 4 spaces.Expected Result:The comments in BadStyle.java remain on the first column.User Impact:My organization uses Eclipse exclusively for all Java development and enforces coding conventions using the built-in formatter. Each developer is supposed to configure their formatter the same way and the formatting should be applied as a Java Save Action. A nightly cron job runs which will restyle all checked in code from the command line and report any discrepancy to owner. Because the formatting from the command-line doesn't support these two options our team cannot use them (""cannot"" may be too strong but the only reason we're not using is that the command-line formatter doesn't support them).Other Information:The prefs file has an option named org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column that might be related but changing its value or removing it doesn't seem to fix the problem.Version: Juno Service Release 2Build id: 20130225-0426"
415846,8/26/2013 3:59,manju656,[1.8] UI option to control generation of MethodParameters attribute in class files BETA_JAVA8:JEP 118 provides for storing of method parameter names flags and such ina new attribute called MethodParameters. This is to be generated only whena programmer opts in for it.https://bugs.eclipse.org/bugs/show_bug.cgi?id=407297 has implemented theCore changes for this option. See the javadoc for org.eclipse.jdt.core.JavaCore.COMPILER_CODEGEN_METHOD_PARAMETERS_ATTRECJ implements -parameters command line option for this purpose.We need support in the UI for enabling this. TIA.
415943,8/27/2013 7:08,daniel_megert,"Set 'code.ignoredWarnings' for test bundles in order to use global build settings Set 'code.ignoredWarnings' for test bundles in order to use the global build settings and reduce the discouraged access warnings in the official build.The easiest way to do this is:1. in the repository root add a folder 'tests-pom'2. into the new folder add the following pom.xml: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/plain/tests-pom/pom.xml3. adjust the parent group and artifact id in that file4. in each test bundle modify the pom.xml as follows: a) replace the parent artifact id with ""tests-pom"" b) add this to the parent declaration: <relativePath>../tests-pom/</relativePath>As a template you can use e.g. http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/"
415997,8/27/2013 22:21,anchakrk,"java.lang.VerifyError: Expecting a stackmap frame at branch target The following code:public class Bug {	public static void main(String[] args) throws Exception {		System.out.println(ParseExpr11());	}	static final public Object ParseExpr11() throws Exception {		Object expr;		Object op = null;		expr = ParseVarExpr();		if (op == null) {			if (true)				return expr;		}		{			throw new Exception(""++/-- not supported in TUD Bantam Java."");		}	}	private static Object ParseVarExpr() {		// TODO Auto-generated method stub		return ""test"";	}}throws Exception in thread ""main"" java.lang.VerifyError: Expecting a stackmap frame at branch target 12 in method Bug.ParseExpr11()Ljava/lang/Object; at offset 7	at java.lang.Class.getDeclaredMethods0(Native Method)	at java.lang.Class.privateGetDeclaredMethods(Class.java:2451)	at java.lang.Class.getMethod0(Class.java:2694)	at java.lang.Class.getMethod(Class.java:1622)	at sun.launcher.LauncherHelper.getMainMethod(LauncherHelper.java:494)	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:486)Expected: ""test""It is generated by JavaCC which is why the formatting/syntax sucks.Works fine with javac.-- Configuration Details --Product: Eclipse 1.5.2.20130110-1126 (org.eclipse.epp.package.jee.product)Installed Features: org.eclipse.jdt 3.8.2.v20130116-090414-8-8nFu3FNOfwKLRuqgXKIy9z0I83"
416027,8/28/2013 6:28,jarthana,[1.8] Enable reflected parameter names during annotation processing The compile side of work for JEP118 (Runtime method parameter name access) wasaccomplished via bug 406966 and its children. APT should respond to the modelAPI changes mandated by the JEP.The current bug is to track that.
416107,8/29/2013 3:14,anchakrk,"Incomplete error message for member interface and annotation public class A {	class B {		interface I { // Error					}	}}-------------------------public class A {	class B {		@interface I { // Error					}	}}-------------------------The error message says:""The member interface/annotation I can *only* be defined inside a top-level class or interface"".However these can also be defined inside a static member type which is not reflected in the error message."
416198,8/29/2013 21:33,manju656,"[Inline] Inline method refactoring fails to update method reference as of enum constructor call's argument Here is the code snippet before applying inline refactoring:public class A {	public static int i;	public static int getI() { // APPLY INLINE HERE		return i;	}}public enum B {	m(A.getI());		B(int j){			}}Applying inline refactoring to getI() cannot update A.getI() that is a parameter of enum constructor call:public class A {	public static int i;}public enum B {	m(A.getI()); // ERROR		B(int j){			}}"
416380,9/2/2013 17:33,jarthana,"[compiler] better error message for illegal use of regular type as an annotation Consider this example: import java.lang.annotation.*; ... <T extends Annotation> String foo(@T String s) { return null; }ecj will answer: <T extends Annotation> String foo(@T String s) { return null; } ^ Type mismatch: cannot convert from T to AnnotationMh that's the wrong error to show T *is* compatible to Annotation.Looking at JLS 9.6: ""A consequence of the fact that an annotation type cannot explicitly declare a superclass or superinterface is that a subclass or subinterface of an annotation type is never itself an annotation type.""subtyping isn't actually the issue we're interested in. The thing *must be an annotation type* and that's what ecj should complain about(and its how the check is already implemented ...)Not marking [1.8] since the problem already exists in master although this is even more fun with JSR 308 :)"
416480,9/3/2013 18:00,srikanth_sankaran,Error in bytecode generated by ECJ compiler leads to IncompatibleClassChangeError Created attachment 235123SneakyCaster.javaTo reproduce compile (and then run) the attached SneakyCaster.java using both javac and ECJ.ECJ misses the checkcast instruction at the end of the cast() method. This allows assignment of an Object to a Runnable variable. Eventually the JVM throws an IncompatibleClassChangeError but clearly as there is only one .class file that's not right.javac correctly includes the checkcast instruction and a ClassCastException is thrown before the invalid assignment could ever be made.
416559,9/4/2013 14:07,shankhba,[1.8][dom ast] variable binding for LambdaExpression parameter has non-unique key The IVariableBinding for a LambdaExpression parameter has a non-unique key: IntPredicate f = (i) -> i == 1; IntPredicate g = (i) -> i != 2;Key for both variables 'i' is just '#i'. Should be prefixed with the LambdaExpression's method binding key.
416560,9/4/2013 14:09,manpalat,"[1.8] Incorrect source range for lambda expression's parameter Created attachment 235166Screenshotpackage misc.test;interface FI {	int foo(int s1 int s2);}class Test {	FI fi= /*a*/ (int n1 int n2) -> n1 * n2;}--------------------------Steps:1. To get the JLS8 AST set org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.SHARED_AST_LEVEL to AST.JLS8.2. Add a breakpoint in org.eclipse.jdt.internal.core.CompilationUnit.reconcile(int astLevel int reconcileFlags WorkingCopyOwner workingCopyOwner IProgressMonitor monitor).3. Paste the above example in package explorer of the runtime workbench.4. Edit the file and check the AST created in #reconcile(..) for the lambda parameter ""int n1"". The startPosition and length are wrong as shown in the attached screenshot.(Example: length is 13 instead of 6. It includes the comment /*a*/ also along with ""int n1"")"
416579,9/4/2013 19:04,markus.kell.r,"Strange range definition in org.eclipse.jdt.core.tests.compiler (in BETA8) The MANIFEST.MF holds:org.eclipse.jdt.annotation;bundle-version=""[1.1.02.0.0)""org.eclipse.jdt.annotation;bundle-version=""[2.0.03.0.0)""which looks strange to me why not directly setting org.eclipse.jdt.annotation;bundle-version=""[1.1.03.0.0)""the CBI builds fails with the current definition"
416586,9/4/2013 22:13,jarthana,The doc for TagElement#fragments is confusing While generifying API tools I came across some use of TagElement#fragments and while trying to update our code I realized IDocElement is not an API (or even visible) class - which is mentioned in the API docs as the list type:* @return the live list of doc elements in this tag element* (element type: {@link IDocElement})*/public List fragments() {...}The doc does mention what kinds of nodes (implementations of IDocElement) can appear in the list but it does not make sense to mention a private class in the API docs. Consumers basically have to do the following:List<ASTNode> fragments = tagelement.fragments();when they are expecting to be able to do (according to the docs):List<IDocElement> fragments = tagelement.fragments();
416780,9/7/2013 6:50,jarthana,in 3.9.1 the batch compiler still identifies itself as 3.9.0 Shouldn't we update http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/tree/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.properties?h=R4_3_maintenance to say 3.9.1 in compiler.version?
416911,9/10/2013 8:13,mistria,"Get rid of nested jars for tests +++ This bug was initially created as a clone of Bug #416740 +++In order to be able to use the tycho-surefire-plugin it would be nice to get rid of the nested jars in test bundles which confuse surefire.Why are there some nested jars? Here is the answer from Dani (Megert):""""""Almost all our (Platform JDT PDE) test bundles have their class files inside a JAR that's inside the JARed bundle. This is simply for historical reasons: back in the old days each bundle was in a directory with a JAR that contained the class files. When we started to JAR most of our bundles we converted them to have the class files directly in the bundle JAR. We did not do this for the test bundles just because there was neither a reason nor a benefit. We can accept patches that fix this but each patch must fix all test projects inside the same repository for consistency and of course you must verify that all tests are still green before submitting the patch. """"""Cf http://dev.eclipse.org/mhonarc/lists/platform-releng-dev/msg21603.htmlProposed Gerrit patch: https://git.eclipse.org/r/#/c/16265/"
416912,9/10/2013 8:14,mistria,"Allow to run tests with tycho-surefire-plugin +++ This bug was initially created as a clone of Bug #416904 +++In order to lower entry barrier for contribution and execution of unit tests it would be quite helpful to make it possible to run tests with tycho-surefire-plugin and a simple ""mvn clean verify"".Gerrit patch: https://git.eclipse.org/r/#/c/16276/"
416915,9/10/2013 8:22,markus.kell.r,"Allow to run tests with tycho-surefire-plugin +++ This bug was initially created as a clone of Bug #416904 +++In order to lower entry barrier for contribution and execution of unit tests it would be quite helpful to make it possible to run tests with tycho-surefire-plugin and a simple ""mvn clean verify""."
416935,9/10/2013 10:43,mistria,"[JUnit] Initialize JUnit container & JUNIT_HOME doesn't work when there is no bundle.info In the context of running JDT tests with Tycho I noticed that the implementation of JUnitHomeInitializer relies on SimpleConfigurator and assumes that the product uses a bundles.info file to work.However it's not the case with Tycho Surefire tests bundles are instead passed in the config.ini file using the ""osgi.bundles"" property.So it seems like current implementation is based on the wrong assumption that all RCP products use a bundles.info.Instead it should leverage the OSGi APIs as we can more safely assume that any application using JDT is started in an OSGi container."
416992,9/11/2013 5:47,noopur_gupta,"[1.8][quick assist] Convert to 'if-!-return' not offered in lambda expression The quick assist (Convert to 'if-!-return') is not offered in a lambda body at valid 'if' locations. Examples:package misc.test;@FunctionalInterfaceinterface A {	void run(int n);}@FunctionalInterfaceinterface B {	A foo(int x);}public class Test {	A fi0 = (n) -> {		if (n == 0) {	// [1]			System.out.println(n);			return;		}	};		int fun1(int a int b) {		A fi2 = (n) -> {			if (a == b) {	// [2]				System.out.println(n);				return;			}		};		return a + b;	}	A fun2(int a int b) {		return (n) -> {			if (a == b) {	// [3]				System.out.println(n);				return;			}		};	}	int fun3(int a int b) {		B fi3 = (x) -> (n) -> {			if (a == b) {	// [4]				System.out.println(a);				return;			}		};		return a + b;	}}"
416998,9/11/2013 7:04,noopur_gupta,[1.8] Update callers of ASTNodes#getType(VariableDeclaration) to handle 'null' for type inferred lambda parameter After ASTNodes#getType(VariableDeclaration) method is updated to return 'null' for a type inferred lambda parameter callers of the method need to be fixed iff there's a possibility that the given VariableDeclaration is a type inferred lambda parameter.Patch to update ASTNodes#getType(VariableDeclaration) to return 'null' is attached in bug 407985 comment #3.
417072,9/12/2013 6:59,jarthana,compiler.version should not have to be manually set 4.3 and 4.3.1.Currently the 'compiler.version' in /org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/messages.propertieshas to be updated manually when the version changes. Only the qualifier is a variable. This can lead to mismatches (see e.g. bug 416780). We should use (create if not yet there) bundle_version instead i.e.compiler.version = bundle_version
417659,9/19/2013 22:23,manpalat,[dom][ast][1.8] test failures - ast structure - when debug tracing is on Following tests fail when the following debug options are on:org.eclipse.jdt.core/debug/dom/ast=trueorg.eclipse.jdt.core/debug/dom/ast/throw= trueorg.eclipse.jdt.core/debug/dom/ast/rewrite = trueThe failures are listed below:TypeAnnotationsConverterTests : test0003 test0004 test0005 test0008.ASTConverter18Test : test0004 test0006 test0015 test399794.ASTRewritingMethodDeclTest: testListInserts(JLS8) TestMethodReturnTypeChanges2_only_2(JLS2)TestMethodReturnTypeChanges_only_2 (JLS2).ASTRewritingTypeAnnotationsTest: testClassInheritenceAnnotations(JLS8).ASTRewritingReferenceExpressionsTest:4 failures testRE_test00{1345}_since_8This may be converted to an umbrella bug for better tracking if the patches are grouped for particular sets.
417765,9/21/2013 16:17,daniel_megert,ImageDescriptorRegistry.hookDisplay() causes SWT Invalid thread access Eclipse KeplerThere appears to be a case where NewJavaProjectWizardPageTwo causes an SWT Invalid Thread Access when using Bndtools. This problem has been reproduced by others.To reproduce create a new workspace switch to the Bndtools perspective create a new Bndtools OSGi project. You should get the Invalid Thread Access.The workaround is to delete the project you just created and create it again.I believe the key here is that you have a brand new workspace.Here is the stack trace.org.eclipse.swt.SWTException: Invalid thread access at org.eclipse.swt.SWT.error(SWT.java:4397) at org.eclipse.swt.SWT.error(SWT.java:4312) at org.eclipse.swt.SWT.error(SWT.java:4283) at org.eclipse.swt.widgets.Display.error(Display.java:1204) at org.eclipse.swt.widgets.Display.checkDevice(Display.java:759) at org.eclipse.swt.widgets.Display.disposeExec(Display.java:1181) at org.eclipse.jdt.internal.ui.viewsupport.ImageDescriptorRegistry.hookDisplay(ImageDescriptorRegistry.java:77) at org.eclipse.jdt.internal.ui.viewsupport.ImageDescriptorRegistry.<init>(ImageDescriptorRegistry.java:40) at org.eclipse.jdt.internal.ui.JavaPlugin.internalGetImageDescriptorRegistry(JavaPlugin.java:954) at org.eclipse.jdt.internal.ui.JavaPlugin.getImageDescriptorRegistry(JavaPlugin.java:347) at org.eclipse.jdt.internal.ui.wizards.buildpaths.CPListLabelProvider.<init>(CPListLabelProvider.java:68) at org.eclipse.jdt.internal.ui.wizards.buildpaths.BuildPathsBlock.<init>(BuildPathsBlock.java:189) at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.getBuildPathsBlock(JavaCapabilityConfigurationPage.java:95) at org.eclipse.jdt.ui.wizards.JavaCapabilityConfigurationPage.init(JavaCapabilityConfigurationPage.java:151) at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.initializeBuildPath(NewJavaProjectWizardPageTwo.java:318) at bndtools.wizards.project.NewBndProjectWizardPageTwo.initializeBuildPath(NewBndProjectWizardPageTwo.java:106) at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.updateProject(NewJavaProjectWizardPageTwo.java:252) at org.eclipse.jdt.ui.wizards.NewJavaProjectWizardPageTwo.performFinish(NewJavaProjectWizardPageTwo.java:484) at org.eclipse.jdt.internal.ui.wizards.JavaProjectWizard.finishPage(JavaProjectWizard.java:82) at org.eclipse.jdt.internal.ui.wizards.NewElementWizard$2.run(NewElementWizard.java:118) at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39) at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345) at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5331) at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106) at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)
417801,9/23/2013 6:36,noopur_gupta,[1.8][quick assist] Infer lambda parameters A quick assist can be added to infer lambda parameters in a lambda expression which has type inferred (type-less) parameters. It would be useful to know the types of the lambda parameters explicitly in cases where the functional interface is not in the same class or project.Example: Invoking infer lambda parameters quick assist on the lambda expression: Button button = new Button();button.addActionListener(e -> foo());should result in:Button button = new Button();button.addActionListener((ActionEvent e) -> foo());
417803,9/23/2013 6:52,shankhba,[internal] Build a build environment compiler to warn on TypeBinding comparisons BETA_JAVA8: With the deep encoding of type annotations most subsystems of the compilershould stop using == and != for binding comparisons and use TypeBinding.equalsEquals and its counterpart.We need an automated way to catch these places. I propose that we build aspecial build environment compiler that would warn on type binding comparisons.Once it is operational we may want to allow a mechanism to tolerate == and!= comparisons on specially tagged situations like the FALL-THROUGH tag forswitch cases without breaks.
417923,9/24/2013 10:00,manpalat,[1.8][dom ast] white space requirements for ArrayType NASTFlattener and ASTRFlattener In the ArrayType implementation specify the white space requirementsRef bug 413569 comment 18 last two items (reproduced below)- ASTRewritingStatementsTest file testBug400568_a_since_8 has two additional white spaced after removal of annotations on dimensions. To be changed?- TypeAnnotationsConverterTest - String [] [] [] [] - do we need these spaces if there are no annotations on dimensions?
417935,9/24/2013 11:21,srikanth_sankaran,"[1.8][code select] ICU#codeSelect doesn't work on reference to lambda parameter import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Comparator;public class Snippet {	void foo() {		Collections.sort(new ArrayList<String>(Arrays.asList(""c"" ""b"" ""a""))				new Comparator<String>() {					@Override					public int compare(String o1 String o2) {						return o1.compareTo(o2); //[1]					}				});		Collections.sort(new ArrayList<String>(Arrays.asList(""c"" ""b"" ""a""))				(String o1 String o2) -> o1.compareTo(o2)); //[2]	}}-------------------------Hover over #compareTo at the specified locations [1] and [2].Javadoc is shown on hover only at [1] and not at [2]."
417937,9/24/2013 11:35,manpalat,[1.8] ImportRewrite#addImport(ITypeBinding ...) drops TYPE_USE annotations Consider the below method:public void foo(java.io.@TypeUse FileNotFoundException arg A type){}When 'move' refactoring is invoked on #foo:ImportRewrite#addImport(ITypeBinding binding AST ast ImportRewriteContext context) is invoked with the VariableBinding corresponding to <java.io.@TypeUse FileNotFoundException arg> where it is expected to return a PackageQualifiedType which contains the TYPE_USE annotation details as well. This is not currently handled in #addImport(...)and the method returns a SimpleType and the TYPE_USE annotation details are missing.
418011,9/25/2013 8:32,anchakrk,"[code assist] NPE in code assist package org.eclipse.jdt.demo;class Math {	public static int max(int a int b) {		if (a > b) return a;		return b;	}	public static int min(int a int b) {		if (a < b) return a;		return b;	}	// ...}interface BinaryOperator<T> {	T evaluate(T left T right);}class Calc {	BinaryOperator<Integer> max1 = (a b) -> Math.max(a b);	BinaryOperator<Integer> max1 = Math.max|}Ctrl+Space at the specified location ""|"" after Math.max results in NPE:org.eclipse.e4.core.di.InjectionException: org.eclipse.core.commands.ExecutionException: While executing the action an exception occurred	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:63)......Caused by: org.eclipse.core.commands.ExecutionException: While executing the action an exception occurred	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:125)......Caused by: java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.util.ObjectVector.contains(ObjectVector.java:75)	at org.eclipse.jdt.internal.codeassist.InternalExtendedCompletionContext.computeVisibleElementBindings(InternalExtendedCompletionContext.java:224)	at org.eclipse.jdt.internal.codeassist.InternalExtendedCompletionContext.getVisibleElements(InternalExtendedCompletionContext.java:376)	at org.eclipse.jdt.internal.codeassist.InternalCompletionContext.getVisibleElements(InternalCompletionContext.java:324)	at org.eclipse.jdt.internal.ui.text.java.ParameterGuessingProposal.getAssignableElements(ParameterGuessingProposal.java:113)	at org.eclipse.jdt.internal.ui.text.java.ParameterGuessingProposal.guessParameters(ParameterGuessingProposal.java:322)	at org.eclipse.jdt.internal.ui.text.java.ParameterGuessingProposal.computeGuessingCompletion(ParameterGuessingProposal.java:254)	at org.eclipse.jdt.internal.ui.text.java.ParameterGuessingProposal.computeReplacementString(ParameterGuessingProposal.java:220)	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.getReplacementString(LazyJavaCompletionProposal.java:331)..."
418092,9/26/2013 8:38,jarthana,"ArrayOutOfBoundException while autocompleting a jar library with attached javadoc Fresh install of Eclipse 4.3 with a new workspace.Create a new maven based projects based on the quickstart archetype.Add a dependency on org.jooq:jooq:3.1 (http://www.jooq.org/)Create a new class with a main method.In the method type: DSLContext ctx=DSL.using(SQLDialect.ORACLE); ctx. <- autocompletion pops up herePress 's' (to look for 'select' method)Autocompletion stops working and the following exception is logged in the error.log:Message: Unhandled event loop exceptionStack trace: org.eclipse.swt.SWTException: Failed to execute runnable (java.lang.ArrayIndexOutOfBoundsException: 1)	at org.eclipse.swt.SWT.error(SWT.java:4397)	at org.eclipse.swt.SWT.error(SWT.java:4312)	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:138)	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3717)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3366)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:606)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)	at org.eclipse.equinox.launcher.Main.run(Main.java:1450)	at org.eclipse.equinox.launcher.Main.main(Main.java:1426)Caused by: java.lang.ArrayIndexOutOfBoundsException: 1	at org.eclipse.jdt.internal.codeassist.InternalCompletionProposal.findMethodParameterNames(InternalCompletionProposal.java:314)	at org.eclipse.jdt.internal.codeassist.InternalCompletionProposal.findParameterNames(InternalCompletionProposal.java:1440)	at org.eclipse.jdt.ui.text.java.CompletionProposalLabelProvider.appendUnboundedParameterList(CompletionProposalLabelProvider.java:113)	at org.eclipse.jdt.ui.text.java.CompletionProposalLabelProvider.createMethodProposalLabel(CompletionProposalLabelProvider.java:272)	at org.eclipse.jdt.ui.text.java.CompletionProposalLabelProvider.createStyledLabel(CompletionProposalLabelProvider.java:570)	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.computeDisplayString(LazyJavaCompletionProposal.java:263)	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.getDisplayString(LazyJavaCompletionProposal.java:246)	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.isValidPrefix(AbstractJavaCompletionProposal.java:802)	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.isValidPrefix(LazyJavaCompletionProposal.java:378)	at org.eclipse.jdt.internal.ui.text.java.JavaMethodCompletionProposal.isValidPrefix(JavaMethodCompletionProposal.java:289)	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.validate(AbstractJavaCompletionProposal.java:754)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeFilteredProposals(CompletionProposalPopup.java:1486)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$4(CompletionProposalPopup.java:1449)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$1.run(CompletionProposalPopup.java:375)	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)	... 24 moreGoogling for a solution I've also found the same issue reported in the following bug report on a different library:https://code.google.com/p/projectlombok/issues/detail?id=545Session data:eclipse.buildId=4.3.0.I20130605-2000java.version=1.7.0_25java.vendor=Oracle CorporationBootLoader constants: OS=linux ARCH=x86_64 WS=gtk NL=it_ITFramework arguments: -product org.eclipse.epp.package.jee.productCommand-line arguments: -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.jee.product"
418473,10/2/2013 4:44,Michael_Rennie,"NullPointerException when starting unit test The following NPE ensures I don't get any work done.java.lang.NullPointerException	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.getEnclosingReferenceTypeName(JavaBreakpoint.java:242)	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.createRequests(JavaBreakpoint.java:595)	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.addToTarget(JavaBreakpoint.java:584)	at org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.addToTarget(JavaLineBreakpoint.java:172)	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.breakpointAdded(JDIDebugTarget.java:1287)	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.initializeBreakpoints(JDIDebugTarget.java:522)	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.initialize(JDIDebugTarget.java:448)	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.<init>(JDIDebugTarget.java:315)	at org.eclipse.jdt.debug.core.JDIDebugModel$1.run(JDIDebugModel.java:183)	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2345)	at org.eclipse.jdt.debug.core.JDIDebugModel.newDebugTarget(JDIDebugModel.java:187)	at org.eclipse.jdt.internal.launching.StandardVMDebugger.createDebugTarget(StandardVMDebugger.java:471)	at org.eclipse.jdt.internal.launching.StandardVMDebugger.run(StandardVMDebugger.java:347)	at org.eclipse.jdt.junit.launcher.JUnitLaunchConfigurationDelegate.launch(JUnitLaunchConfigurationDelegate.java:174)	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:858)	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:707)	at org.eclipse.debug.internal.ui.DebugUIPlugin.buildAndLaunch(DebugUIPlugin.java:1018)	at org.eclipse.debug.internal.ui.DebugUIPlugin$8.run(DebugUIPlugin.java:1222)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
418580,10/3/2013 7:27,jarthana,"Asynchronous access to BindingTables infinite loop on HashMap.getEntry #####Bug explanation#####Usage of ASTParser.createASTs(String[] sourceFilePaths String[] encodings String[]bindingKeys FileASTRequestor requestor IProgressMonitor monitor)with optionASTParser.setResolveBindings( true )produce many org.eclipse.jdt.core.dom.CompilationUnit objects.Each of them contains its own AST object with own DefaultBindingResolver object which shares SINGLE DefaultBindingResolver.BindingTableswith every other DefaultBindingResolver (and so AST and CompilationUnit objects) created during single ""createASTs"" batch parsing call.DefaultBindinResolver Javadoc says:""* IMPORTANT: The methods on this class are synchronized. This is required * because there may be multiple clients in separate threads concurrently * reading an AST and asking for bindings for its nodes. These requests all * end up invoking instance methods on this class. There are various internal * tables and caches which are built and maintained in the course of looking * up bindings. To ensure that they remain coherent in the presence of multiple * threads the methods are synchronized on the DefaultBindingResolver instance.""Unfortunately parsing (performed as described above) creates many DefaultBindingResolvers with shared single BindingTables objectso all those synchronisations on methods do nothing to prevent asynchronousmodifications of this maps. Such events do happen during any of various""resolveBinding()""-like method calls performed by multiple threads.########Errors the bug causes########In case of our project the bug often cause a damage ofDefaultBindingResolver.BindingTables.compilerBindingsToASTBindings HashMapwhich makes our threads constantly running on HashMap.getEntry on INFINITE LOOP which looks like following:java.lang.Thread.State: RUNNABLEat java.util.HashMap.getEntry(HashMap.java:446)at java.util.HashMap.get(HashMap.java:405)at org.eclipse.jdt.core.dom.DefaultBindingResolver.getTypeBinding(DefaultBindingResolver.java:526)- locked <0x00000000b6da8bb0> (a org.eclipse.jdt.core.dom.DefaultBindingResolver)at org.eclipse.jdt.core.dom.MethodBinding.getDeclaringClass(MethodBinding.java:131)...We use ASTParser.createASTs(..) instead of multiple ASTParser.createAST(..) because the amount of used memory drop is quite significant (we had to storepart of IBinding objects in memory).########Proposed solution########The solution may be as simple as using ConcurrentHashMap in DefaultBindingResolver.BindingTables."
418646,10/4/2013 2:32,david_williams,"org.eclipse.jdt.core does not provide an artifact with classifier 'antadapter' This will take some study ... but in local builds I was experimenting with changing comparator's configuration<baselineReplace>common</baselineReplace>to the recommended <baselineReplace>all</baselineReplace>I was doing this in preparation of fixing bug 405911 and bug 418635. But first bug I hit instead of the expected ""source"" problem in bug 405911 was this error: [ERROR] Failed to execute goal org.eclipse.tycho:tycho-packaging-plugin:0.18.1:package-feature (default-package-feature) on project org.eclipse.pde.build.feature: Execution default-package-feature of goal org.eclipse.tycho:tycho-packaging-plugin:0.18.1:package-feature failed: org.eclipse.jdt:org.eclipse.jdt.core:eclipse-plugin:3.10.0-SNAPSHOT does not provide an artifact with classifier 'antadapter' This has always showed up in ""warnings"" (part of the reason ""jdt"" is given its own ""comparator log"") such as see (near bottom) of http://download.eclipse.org/eclipse/downloads/drops4/I20131001-0800/buildlogs/comparatorlogs/buildtimeComparatorJDTCore.log.txtIn essence this is saying we produce a bundle of type ""antadapter"" during build but it is not in the repository we use for comparison. (I think because we ""copy it into"" another bundle as a simple jar? I'll have to study poms much more to figure out how to avoid the comparator in this case ... well as one possible solution ... there might be others."
418825,10/7/2013 10:53,anchakrk,Code assist fails when including project on class path that contains multiple class in a single file
418919,10/8/2013 9:34,srikanth_sankaran,"[1.8][compiler][internal] Remove boolean forcing creation of annotated bindings. BETA_JAVA8:In LookupEnvironment::LookupEnvironment we have this code:boolean stillTesting = true;if (this.globalOptions.sourceLevel >= ClassFileConstants.JDK1_8 && (stillTesting || this.globalOptions.storeAnnotations)) {		this.typeSystem = new AnnotatableTypeSystem(this);	} else {		this.typeSystem = new UnannotatedTypeSystem(this);	}At some suitable point we should remove the boolean and let the other gatingconditions decide whether bindings should carry annotations or not.Raising this defect so we don't drop this ball."
418920,10/8/2013 9:37,shankhba,"[1.8] Failing tests with JRE8 From https://bugs.eclipse.org/bugs/show_bug.cgi?id=413613#c24:That leaves us with 3 old failures. These are in two buckets:(1) testTypesWithSystemCompiler and testTypesWithEclipseCompilerare due to the same problem. In JRE8 the class HashMap#HashIteratoris not generic. I believe it was previously generic (JRE7 ?)I suspect this class is not standard API since it is missing inIBM JREs (See also https://bugs.eclipse.org/bugs/show_bug.cgi?id=258906)Tests should be rewritten to avoid using non-standard classes.(2) The other bug is due to as Jay mentioned how the javadoc is differentlyformatted. I see this comment in ElementsImpl#formatJavadoc:/**	 * Strip the comment characters from a javadoc comment. Assume the comment is already	 * missing its closing delimiter.	 *	 * Javac's behavior with regard to tab expansion and trimming of whitespace and	 * asterisks is bizarre and undocumented. We do our best here to emulate it.	 */So the tests should be rewritten to convert all tabs to spaces strip out allnon-significant white spaces before comparing."
418924,10/8/2013 10:24,markus.kell.r,[dom ast] ASTRewrite should allow removing left and right operands of infix expression ASTRewrite should allow removing the left and right operands of an infix expression. We need this for a clean fix for bug 406347. Fix is already ready.<rant>The design of InfixExpression is flawed. We should not have created separate properties for the first two operands. We can't change that now but we should keep this in mind for future AST nodes.</rant>
419057,10/9/2013 12:37,anchakrk,"ITypeBinding#getModifiers() misses implicit ""static"" for class member interface master and BETA_JAVA8ITypeBinding#getModifiers() misses the implicit ""static"" modifier for member interfaces of a class:public class C {	interface IC {} // implicitly static see JLS7 8.5.1}(If you wonder about the reference to JLS7 8.5.1 then you may have an old version of JLS7 that contains a section 8.5.2 and a bogus 8.5.1 that said IC would be implicitly public -- that part has been removed again)."
419209,10/11/2013 6:07,jesper,[1.8] Repeating container annotations should be rejected in the presence of annotation it contains The spec says:It is a compile-time error if a declaration is annotated with any annotations ofa repeatable annotation type T and more than one annotation of the containingannotation type of T.Assuming FooContainer is itself a repeatable annotation type with a containingannotation type of FooContainerContainer one might expect the following code to be legal:@Foo(1) @FooContainer({@Foo(2)}) @FooContainer({@Foo(3)}) class A {}But this code is allowed by eclipse compiler.
419219,10/11/2013 7:50,jarthana,"JavaCorePreferenceModifyListener pollutes exported preferences The implementation of JavaCorePreferenceModifyListener#preApply may cause unexpected removal of Java preferences. The issue was reported initially in bug 418046 and this bug will focus on changes required to fix the jdt.core part.The node passed as an argument to the preApply method is always an IExportedPreferences node which means it is a ""delta"" that will be applied to the global hierarchy. If a listener modifies this delta by creating an empty node then all preferences of this node will be removed in the global hierarchy.Reproducible scenario:1. Download the plugin from https://bugs.eclipse.org/bugs/attachment.cgi?id=2358172. Import it to your workspace.3. Start self-hosted Eclipse.4. Modify one of Java preferences in Window > Preferences > Java > Compiler e.g. change compiler compliance to ""1.3"". Click OK.5. Restart the inner Eclipse.=> Check that compiler compliance is set back to the default and our ""1.3"" is lost."
419315,10/12/2013 13:45,srikanth_sankaran,"[1.8] Type inference needs some information from overload resolution In my current understanding of JSR 335 spec 0.6.3 type inference needs the following bits of information which should probably be computed and stored during overload resolution:- strict / loose / variable-arity invocation- ""pertinent to applicability""Both are produced by: 15.12.2.2-4 consumed by: 18.5.1 (and .2)"
419331,10/13/2013 22:06,srikanth_sankaran,[1.8][compiler] Weird error on forward reference to type annotations from type parameter declarations BETA_JAVA8:The following program fails to compile. We get:Type mismatch: cannot convert from Class<TC> to Class<? extends Annotation>// --import java.lang.annotation.Annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Target;@R(TC.class)@Target(ElementType.TYPE_PARAMETER)@interface T {}interface I<@T K> {}@Deprecated@interface TC {}@Target(ElementType.ANNOTATION_TYPE)@interface R { Class<? extends Annotation> value();}I have released a test TypeAnnotationTest.testForwardReference() encodingthe wrong behavior - The test needs to fixed along with the problem.
419351,10/14/2013 7:36,jarthana,org.eclipse.jdt.internal.compiler.batch.Main mixes up JVM and endorsed libraries in classpath ordering Created attachment 236449Patch changing the ordering of boot and endorsed libsThe org.eclipse.jdt.internal.compiler.batch.Main used in a standalone environment has problems with initializing the classpath in the correct ordering. The relevant elements are:* The bootclasspaths containing the JVM libraries* The endorsedDirClasspaths containing the endorsed libs (http://docs.oracle.com/javase/6/docs/technotes/guides/standards/)The endorsed libs need to overrule the JVM bootclasspath to fulfill it's purpose. In the current implementation the bootclasspath is added first and the endorsed are added later. This causes that the compiler loads the JVM classes prior the classes contained in endorsed directory which makes them useless.The wrong ordering is initialized in the setPaths(..) method of the org.eclipse.jdt.internal.compiler.batch.Main class. In line 4533 the assembling of the final classpath starts with the bootclasspaths and adds the endorsedDirClasspaths in the first step which causes the wrong ordering. A attached a patch which corrects the ordering.
419692,10/17/2013 7:36,daniel_megert,Java Type Indicator decorator causes image leak This bug was reported in bug 402983 comment 21https://bugs.eclipse.org/bugs/show_bug.cgi?id=402983#c21
419748,10/17/2013 13:09,markus.kell.r,"[1.8][dom ast] MethodDeclaration's receiverType cannot be AnnotatableType MethodDeclaration's receiverType cannot be an AnnotatableType since ParameterizedType is not an AnnotatableType. Example:package jsr335.invalid;public class C { class A<T> { class Inner { public Inner(A<T> A.this) { } } }}java.lang.ClassCastException: org.eclipse.jdt.core.dom.ParameterizedType cannot be cast to org.eclipse.jdt.core.dom.AnnotatableType	at org.eclipse.jdt.core.dom.ASTConverter.convertAndSetReceiver(ASTConverter.java:888)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:543)	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2956)	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:206)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2956)	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:206)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2956)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1212)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)"
419769,10/17/2013 16:44,jarthana,"Error Messages createdby an annotation processor are not shown when inheriting from a generated class Helloat http://docs.oracle.com/javase/6/docs/api/javax/annotation/processing/Filer.html it is suggested to inherit from classes generated by annotation processors: ""Instead of modifying a class directly the class is designed so that either its superclass is generated by annotation processing or ...""I tried that approach and regognized the following: Eclipse APT seems to ""forget"" any error messages that are reported by an annotation processor as soon as the user creates a subclass of a generated class.To reproduce I have created a very simple processor the always creates an error message and a single class called GeneratedClass. At first the error message is shown as expected (for annotated class called ""ExampleAnnotatedClass""). As soon as a subclass of GeneratedClass is added the error message disappears.With maven the error message is shown in both cases.Steps to reproduce:1.) unzip attachement2.) for project eclipse-bug-processor call ""mvn install"" to create the processor3.) import project ""eclipse-bug-test"" as maven project into eclipse4.) Either install the m2e-apt connector as suggested. (if not done before) Make sure the m2e-option ""Automatically configure JDT APT is selected""5.) There is no APT error reported!6.) Delete the class test.InheritedClass which extends GeneratedClass 7.) Clean / build the project8.) Now the error ""Some Error Message"" appears for ExampleAnnotatedClass.(Note: I just use m2e-apt for easier configuration of the project. The bug also is there without maven... I have also attached the jar of the annotation processor. So you don't have to use maven at all to reproduce.)"
419827,10/18/2013 6:33,shankhba,"[1.8] Annotation with TYPE_USE as target is not allowed to use container with target TYPE The code:@Target({ElementType.TYPE_USE})@Repeatable(FooContainer.class)@interface Foo {}@Target({ElementType.TYPE ElementType.TYPE_USE})@interface FooContainer {	Foo[] value();}Produces an error:The container annotation type @FooContainer is allowed at targets where the repeatable annotation type @Foo is not: TYPEThe spec seems to mention something in the lines:""If Foo has an @Target meta-annotation then in the judgment of the designers of the Java programming language FooContainer must be declared with knowledge of theFoo's applicability. Specifically the kind of program element where FooContainermay appear must be the same as or a subset of Foo's kinds.""But not very specific. This bug is to discuss this further and take it to the EG if required.Also note that the following code is allowed after removing TYPE from @Target of FooContainer:@FooContainer({@Foo @Foo})public class X {}"
419845,10/18/2013 9:17,jarthana,jdt.core needs to increase bundle version for SR2
419906,10/19/2013 9:50,daniel_megert,"[JUnit] JUnit View fails to refresh decorations M2: (This is probably a platform bug but ...)Normally the JUnit view updates each test with a pass/fail decoration as the tests progress.With M2 I am quite frequently seeing that some of the icon decoration updates have got lost. For instance I can open a test suite that reports that it and its predecessors are still to do but discover that the tests have actually run (the per-test decorations are correct).The ""Runs"" counts seem to update correctly so the problem seems to be just one of decorator refresh."
419918,10/19/2013 21:00,srikanth_sankaran,[1.8][compiler] Annotations are not restored from class files in a few situations BETA_JAVA8:BinaryTypeBinding:655 reads:// Note(stephan): currently the compiler is not interested in retrieving receiver annotations here is how we would do it:// IBinaryAnnotation[] receiverAnnotations = walker.toReceiver().getAnnotationsAtCursor();Apart from this action we also need to create an annotated type instancefor the declaring class and store it in org.eclipse.jdt.internal.compiler.lookup.MethodBinding.receiver.javax.lang.model.element.ExecutableElement.getReceiverType() andjavax.lang.model.type.ExecutableType.getReceiverType() should answer theannotated type.
419944,10/21/2013 2:09,srikanth_sankaran,[1.8][APT] Element.getAnnotation and Element.getAnnotationsByType are ignoring inherited annotations BETA_JAVA8:Element.getAnnotation() should return the annotations present on an element.An annotation A is present on a construct C if either:??? A is directly present on C; or??? No annotation of A's type is directly present on C and C is a class and A's type is inheritable (??9.6.3.3) and A is present on the superclass of C.Element.getAnnotationsByType() should return all annotations associated withan element:An annotation A is associated with a construct C if either:??? A is directly or indirectly present on C; or??? No annotation of A's type is directly or indirectly present on C and C is a class and A's type is inheritable (??9.6.3.3) and A is associated with the superclass of C.
419971,10/21/2013 9:23,manpalat,[1.8][compiler] Regression in org.eclipse.jdt.core.tests.dom.ASTConverter15JLS8Test A recent commit that addressed the need for hashCode and equals method to be defined for AnnotationBinding is causing a failure in this test which hasbeen temporarily disabled.org.eclipse.jdt.core.tests.dom.ASTConverter15JLS8Test._test0276The state is restored somewhat to what it was before https://bugs.eclipse.org/bugs/show_bug.cgi?id=192774.Needs investigation.
420004,10/21/2013 12:55,srikanth_sankaran,[1.8][compiler] @Target meta annotations not restored properly on binary annotation types. BETA_JAVA8:When calling getAnnotations() on an annotation type I don't see TYPE_USEand TYPE_PARAMETER targets being restored properly.Patch will follow shortly.
420038,10/21/2013 23:04,srikanth_sankaran,"[1.8][compiler] Tolerate illegal type annotations on array dimensions of class literals for now for compatibility. BETA_JAVA8:The following program is tolerated by javac 8b108;// --import java.lang.annotation.ElementType;import java.lang.annotation.Target; @Target(ElementType.TYPE_USE)@interface T {}public class X {	public static void main(String[] args) {		Class<?> c = int @T [].class; 	}} I believe oracle compiler is definitely at fault - this issue has been reportedto them until we hear confirmtion we should turn our error into warning for now."
420041,10/22/2013 1:16,srikanth_sankaran,"[1.8] @Deprecated on an annotation type not preserved in generated class file 1. Have an annotation and it's container as below in a project let's say A:@Deprecatedpublic @interface FooContainer {	Foo[] value();}@Repeatable(FooContainer.class)public @interface Foo {}2. In the same project have this in another unit:@FooContainer({@Foo() @Foo()})public class Main {}You see the deprecated warning about FooContainer.3. Create another project whose build path includes the bin folder of project 'A'4. Create a similar class in the new project as step 2.5. Notice no warning about FooContainer being deprecated."
420084,10/22/2013 10:46,srikanth_sankaran,"[1.8] static interface method cannot be resolved without receiver when imported statically This is already allowed for static method imports from classes and the same should be allowed from interfaces too. Consider these two units:--------------------package a.b;public interface J {	static int foo(){return 0;}}--------------------package a;import static a.b.J.foo;public interface I {	static int call() {		return foo();	}} --------------------Invocation of foo() is rejected with the following error but should not be: This static method of interface J can only be accessed as J.foo"
420087,10/22/2013 11:19,thanh.ha,"Dirty working tree: about.mappings (JDT) Created attachment 236772jdt.patchThis patch is for the repo eclipse.jdt.I've been informed by David Williams that ""... it will be discussed at Wednesday's (10/23) status meeting if to apply for M3 or to wait until after M3. See http://wiki.eclipse.org/Eclipse/Status_meetings/Minutes."""
420116,10/22/2013 16:40,manju656,"[1.8] Add implemented methods should consider type annotations Preparing to speak about JSR 308 at ECE I see that ""Add implemented methods"" nicely copies old annotations but ignores type annotations.While the implementation looks straight-forward I'm not sure what's the plan regarding ASTProvider.SHARED_AST_LEVEL. Is it still at JLS4 because some operations are still used that only exist below JLS8?"
420188,10/23/2013 10:47,markus.kell.r,Bindings.containsTypeVariables(ITypeBinding type) contains unused code org.eclipse.jdt.internal.corext.dom.Bindings.containsTypeVariables(ITypeBinding type)This method consists of 6 if statements in a row. The 1st and 5th if statement are the same. Therefore the 5th one is never going to get executed because the first on returns.
420283,10/24/2013 10:34,srikanth_sankaran,"[1.8] Wrong error ""Type is not visible"" for cast to intersection type BETA_JAVA8package pack;import java.io.Serializable;import java.util.List;class C { void foo(List<Integer> l) { Integer i = (Integer & Serializable) l.get(0); }}On ""l.get(0)"" I get a wrong compile error:""The type Integer & Serializable is not visible""."
420284,10/24/2013 10:39,srikanth_sankaran,"[1.8][compiler] IllegalStateException from TypeSystem.cacheDerivedType !ENTRY org.eclipse.jdt.core 4 4 2013-10-24 16:35:49.414!MESSAGE Exception occurred during problem detection:----------------------------------- SOURCE BEGIN -------------------------------------package jsr308.myex;import java.io.Serializable;import java.util.List;class En { void foo(Object o) { Integer i = (Integer & Serializable) o; List<@NonNull Integer> l; }}----------------------------------- SOURCE END -------------------------------------!STACK 0java.lang.IllegalStateException	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.cacheDerivedType(TypeSystem.java:269)	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.cacheDerivedType(TypeSystem.java:299)	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:349)	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:266)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createAnnotatedType(LookupEnvironment.java:951)	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:894)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveAnnotations(TypeReference.java:588)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:495)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:546)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveTypeArgument(TypeReference.java:554)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveLeafType(ParameterizedSingleTypeReference.java:238)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:146)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveType(ParameterizedSingleTypeReference.java:359)	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:191)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:568)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:920)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:196)	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:195)	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521)	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
420320,10/24/2013 15:25,srikanth_sankaran,"[1.8] Bad AST recovery with type annotation and a syntax error in secondary type BETA_JAVA8Bad AST recovery with a type annotation in a ParameterizedType and an unrelated syntax error in a secondary type.The method En#bar() is missing a ; or a {}. This syntax error in the secondary class apparently turns the @NonNull annotation into a modifier of the FieldDeclaration for MyExamples#list2.!ENTRY org.eclipse.jdt.core 4 4 2013-10-24 21:18:29.919!MESSAGE Bad AST node structure:- parent [52 80] org.eclipse.jdt.core.dom.FieldDeclaration previous [57 65] org.eclipse.jdt.core.dom.MarkerAnnotation type [52 73] org.eclipse.jdt.core.dom.ParameterizedType----------------------------------- SOURCE BEGIN -------------------------------------package jsr308.myex;public class MyExamples {	List<@NonNull String> list2;}class En { void bar() void foo() { }}----------------------------------- SOURCE END -------------------------------------!STACK 0java.lang.IllegalStateException: Bad AST node structure	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1419)"
420388,10/25/2013 10:09,jarthana,org.eclipse.jdt.core.tests.compiler does not export all its packages Missing: org.eclipse.jdt.core.tests.dom
420413,10/25/2013 13:58,markus.kell.r,[1.8][dom ast] AST#newArrayType(Type int) should allow to create zero-dimension array BETA_JAVA8AST#newArrayType(Type int) should allow to create zero-dimension arrays. Otherwise a client who already has Dimension nodes has to remove the auto-created first dimension.
420446,10/27/2013 3:35,jarthana,"APT tests don't run Caused by fix for bug 416911.Class not found ""org.eclipse.jdt.apt.tests.TestAll cannot be found by osgi.identity; osgi.identity=""org.eclipse.jdt.apt.tests""; type=""osgi.bundle""; version:Version=""3.3.401.N20131026-1500""; singleton:=""true""""org.eclipse.test.EclipseTestRunner$TestFailedException: Class not found ""org.eclipse.jdt.apt.tests.TestAll cannot be found by osgi.identity; osgi.identity=""org.eclipse.jdt.apt.tests""; type=""osgi.bundle""; version:Version=""3.3.401.N20131026-1500""; singleton:=""true""""at org.eclipse.test.EclipseTestRunner.runFailed(EclipseTestRunner.java:582)at org.eclipse.test.EclipseTestRunner.getTest(EclipseTestRunner.java:521)at org.eclipse.test.EclipseTestRunner.<init>(EclipseTestRunner.java:496)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:308)at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36)at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32)at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:109)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:80)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:372)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:226)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)at org.eclipse.equinox.launcher.Main.run(Main.java:1450)at org.eclipse.equinox.launcher.Main.main(Main.java:1426)at org.eclipse.core.launcher.Main.main(Main.java:34)"
420456,10/27/2013 12:31,srikanth_sankaran,"[1.8][null] AIOOB in null analysis code. BETA_JAVA8:The following program generates an AIOOB exception:// --import java.util.Arrays;public class X {	public static void main(String [] args) {		Integer [] array = new Integer[10];		Arrays.sort(array Integer::compare);	}}"
420458,10/27/2013 13:57,manpalat,[1.8][dom ast] JLS8 ASTParser gives up on multi-dimensional array reference in Javadoc BETA_JAVA8For JLS8 the ASTParser gives up on multi-dimensional array references in a MethodRefParameter and leaves the whole Javadoc node without any children. Still Works fine for JLS4./** * Hello. * @see #foo(Object[][][]) */
420482,10/28/2013 6:45,srikanth_sankaran,[1.8] ExecutableTypeImpl#getParameterTypes() does not include type annotation from type parameter Created attachment 236948Test caseThe attachment is a patch of a testcase in Java8ElementProcessor and it fails when Java8ElementTests are run.The code is:public <T> Z(@Type T t){}When ExecutableTypeImpl#getParameterTypes() is invoked with the above code we look at the MethodBinding#parameters to create the TypeMirror. But the parameters contains a TypeVariableBinding but the binding doesn't contain the annotations.
420580,10/29/2013 0:31,srikanth_sankaran,"[1.8][compiler] ReferenceExpression drops explicit type arguments BETA_JAVA8: The following program should not compile but does since RE drops theexplicit type argument <String>.// --interface I {	void sam(X t Integer s);}public class X {	<T> void function(T t) {}	public static void main(String [] args) {		I i = X::<String>function;		i = X::function;		i = X::<Integer>function;	}}Fix is trivial and will follow shortly."
420582,10/29/2013 1:10,srikanth_sankaran,"[1.8][compiler] Compiler should allow creation of generic array creation with unbounded wildcard type arguments BETA_JAVA8:// --interface I {	X<? ? ?>[] makeArray(int i);}public class X<T U V> {	public static void main(String [] args) {		I i = X<? ? ?>[]::new; // OK.		i = X<String Integer ?>[]::new; // ! OK		X<? ? ?> [] a = new X<? ? ?>[10]; // OK		a = new X<String Integer ?>[10]; // ! OK		System.out.println(i.makeArray(1024).length);	}}We reject the first line tagged as OK we should allow it.Fix is trivial will follow shortly."
420598,10/29/2013 5:48,srikanth_sankaran,"[1.8][compiler] Incorrect error about intersection cast type not being a functional interface. BETA_JAVA8:The following program triggers an incorrect error message: The target type of this expression is not a functional interface: more than one of the intersecting interfaces are functionalThe intersection should collapse to the most specific type when there is asupertype - subtype relationship between two constituents.// --import java.io.Serializable;interface I {	void foo();}interface J extends I {	void foo();}interface K {}public class X {	public static void main(String[] args) {		I i = (I & Serializable) () -> {};		i = (I & J & K) () -> {};		i = (J & I & K) () -> {}; 	}}"
420660,10/29/2013 14:43,jarthana,"[1.8][api] Make ""effectively final"" state of local variables available Make the ""effectively final"" state of local variables available. Should be easy to do in IVariableBinding. Would also be very handy in ILocalVariable if possible.We could sneak this into getModifiers()/getFlags() with an internal flag but I guess it's better to add a boolean isEffectivelyFinal() API instead."
421017,11/4/2013 14:55,jarthana,Change jdt.core execution environment to JavaSE-1.6 Change the minimum execution environment for org.eclipse.jdt.core from J2SE-1.4 to JavaSE-1.6. This will allow the use of Java 1.5 and 1.6 language features in ongoing development and in the refactoring of internal jdt.core classes.Note that this bug neither requires nor suggests any changes to public API classes of jdt.core or migration of existing jdt.core code; it is assumed that those things would be proposed and tracked separately if and when they were deemed appropriate.This bug simply allows the use of generics enums and other language features introduced since 1.4 to facilitate development and avoid the accumulation of technical debt within internal jdt.core code.
421040,11/5/2013 0:12,shankhba,"[dom] TypeBinding.getDeclaredModifiers simply delegates to getModifiers() Per Javadoc ITypeBinding.getDeclaredModifiers() is supposed to return""the modifiers ... as specified in the original source declaration of the class orinterface"". In the present implementation it simply delegates to getModifiers()which is wrong."
421148,11/6/2013 6:22,srikanth_sankaran,"[1.8][compiler] Verify error with annotated casts and unused locals. BETA_JAVA8:The following program triggers an operand stack underflow error:// --import java.lang.annotation.ElementType;import java.lang.annotation.Target;@Target(ElementType.TYPE_USE) @interface T {}public class X {	public static void main(String argv[]) {		Object o = (@T Object) new Object(); 	}}Fix will follow shortly. To reproduce the option ""preserved unused locals""must be turned off at the project level.Fix is trivial will follow shortly."
421156,11/6/2013 8:30,jarthana,[1.8] APT should support 'default' modifier A new enum (Modifier#DEFAULT) has been added in SE 1.8 and APT should start supporting this modifier for default interface methods. At the moment it's not very clear what's the right way - to move the project to 1.8 compliance level or use reflection or some other means to include DEFAULT.
421160,11/6/2013 9:41,marcel.bruch,[content assist] Make constructor of ParameterGuessingProposal public We'd like to subclass ParameterGuessingProposal but can't since the constructor is private. Opening it would allow us to get rid of quite a few lines of duplicated code on recommenders side.It would be nice if this change could be merged into 4.3.2 too.A change-set is available in gerrit [1].[1] https://git.eclipse.org/r/#/c/17938/
421165,11/6/2013 10:32,jarthana,"[performance] Low hit rates in JavaModel caches By analyzing UI delays logged using the (new in Luna) UI Performance Monitoring API we saw that ~50% of all JDT-related UI delays greater than 500ms are attributed to low hit rates in the JavaModel caches which are currently evicted on every Java-related resource change and every Java build.The JavaModel existingExternalFiles and existingExternalCommittedFiles caches cache the return value of java.io.File.isFile() and are used heavily by JavaProject.findPackageFragmentRoots() and related calls. By giving the DeltaProcessor class the sole responsibility of updating these caches we see a speedup of ~56x in calculating JavaProject.findPackageFragmentRoots for a project with ~4200 jars (see below for more details).The changes to improve the caching include:* Remove the JavaModel existingExternalFiles and existingExternalCommittedFiles caches replacing them with an updated JavaModelManager externalFiles cache and a new assumedExternalFiles cache.* Make the DeltaProcessor fully responsible for updating the cached values with current file system state. This is triggered only by calls to DeltaProcessor .refreshExternalArchives() and PRE_REFRESH events in the DeltaProcessor's IResourceChangeListener. The previous JavaModel caches were invalidated on every incremental build and Java file resource change.* In addition evict the cache if a Java project has multiple builders and the first builder is not the Java builder since previous builders may create jar artifacts that are consumed by the Java builder.* Looking at the two JavaModel caches both are populated using the same criteria and evicted at the same time so there really never was a need for two separate caches. See http://bugs.eclipse/org/83750 ""[perf] Excessive File.isFile calls for clients of JavaModel.getTarget(...)"" for the history of the existingExternalCommittedFiles cache.* Add a performance test for this change. When with on our patched Eclipse 4.3.1 release which adds the Google-supplied performance patches that have already been applied to Luna we get the following results for a classpath containing 100 jars: Unpatched local file system: 18ms Patched local file system: 18ms Unpatched NFS file system: 43ms Patched NFS file system: 18msIn addition we used JProfiler to profile patched and unpatched versions of Eclipse on a project with ~4200 jars where the jars are stored on a file system with performance similar to NFS using the following test:1) Open Java editor tabs for a file in each of projects A and B2) Disable Project > Build Automatically3) Turn on 'Link with Editor' in the Package Explorer4) Collapse all in the Package Explorer5) Select project A's Java editor tab edit and save the file6) Start profiling7) Select project B's editor tab wait for the Package Explorer to populate expand and select the file8) Stop profilingAbstractTreeViewer.internalExpand is the entry point for the work of populatingthe Package Explorer tree view.In the unpatched version profiling showed thatAbstractTreeViewer.internalExpand execution times were dominated by I/Oin JavaProject.findPackageFragmentRoots. The average of 5 runs showedJavaProject.findPackageFragmentRoots taking ~3.0 seconds(3.2 2.6 3.2 3.5 2.8).In the patched version JavaProject.findPackageFragmentRoots goes from ~3.0seconds to ~.053 seconds (.050 .058 .056 .040 .059). That is a ~56x speedup.Total AbstractTreeViewer.internalExpand time took on average ~.0283 secondsthrowing out one run where DecoratingStyledCellLabelProvider.getImage made agtk call that took over a second to return. Of the five runs no singlefunction took a dominant amount of time unlike the unpatched Eclipse where I/O to repopulate the JavaModel caches was completely dominant."
421469,11/11/2013 11:58,srikanth_sankaran,"[1.8][code assist] NPE in LocalDeclaration.resolve with anonymous class in lambda body BETA_JAVA8NPE in LocalDeclaration.resolve when performing content assist with an anonymous class in a lambda body. Same problem with a local class.package jsr335;import java.util.function.IntFunction;public class Snippet { void foo() { IntFunction<String> toString = i -> { //<-- Ctrl+Space here new Runnable() { @Override public void run() { //<-- Ctrl+Space here } }.run(); return Integer.toString(i); }; }}java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:191)	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:114)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:568)	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1896)	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:130)	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:357)	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:345)	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.internalComputeCompletionProposals(JavaCompletionProposalComputer.java:244)Stacktrace in bug 383096 looks similar but that bug is about code with a syntax error."
421473,11/11/2013 13:09,srikanth_sankaran,[1.8][compiler] Delayed assignment of declaring scope for arguments creates a race condition. BETA_JAVA8:Staring at LocalVariableBinding.getAnnotations() I see that there is a potentialrace condition there: The setting of declaringScope happens far away from thecreation of LVB and if there are calls in between to getAnnotations() we can'tretrieve it from the annotation holder since this requires a handle to enclosingsource type which is obtainable only from a scope. To circumvent this there is a block of code in this method that manufacturesan array of annotation bindings and returns it without going to the holder.However this is problematic since with Java 8 some of the annotations couldactually be type annotations which should be detached from the parameters.This block of code itself cannot filter the type annotations because there areclients that need to see all the annotations to transfer the type annotations to type.I think the solution is to set the declaring scope eagerly. At least for argumentsI don't know what side effects ensue for doing this for all locals.Patch will follow shortly.
421477,11/11/2013 14:04,shankhba,[1.8][compiler] strange error message for default method in class For this class declaration ecj emits an error with a strange message and source range:public class Snippet { public default String getName() { return null; }}Error message:Default methods are allowed only in interfaces with source level 1.8 or greater.- For source level >= 1.8 I'd expect:Message: Default methods are allowed only in interfacesRange: 'getName()'- For source level < 1.8 I'd expect either a syntax error or the same error as I get for this example:public class Snippet { public volatile String getName() { return null; }}
421536,11/12/2013 9:20,srikanth_sankaran,"[1.8][compiler] Verify error with small program when preserved unused variables is off. BETA_JAVA8:The following program triggers a verify error: Inconsistent stackmap frames at branch target 9 Current frame's stack size doesn't match stackmap.// --interface I {	I foo();}public class X {	public static void main(String[] args) {		try {			I i = () -> null;		} catch (NullPointerException npe) {}	}}// --The try/catch blocks seem to be required to reproduce."
421607,11/13/2013 6:35,srikanth_sankaran,"[1.8][compiler] Verify Error with intersection casts This program when compiled with ECJ and run produces a verify error:interface I {	public void foo();}class C implements I {	public void foo() {		System.out.println(""You won't get here"");	}}public class X {	public static void main(String[] args) {		((C & I) (I) new C()).foo();	}}I am not sure if this is a valid program but the code is compiled without any errors. When run an exception with the following reason is thrown:Reason: Type 'I' (current frame stack[0]) is not assignable to 'C' Current Frame: bci: @13 flags: { } locals: { '[Ljava/lang/String;' } stack: { 'I' }"
421620,11/13/2013 9:26,srikanth_sankaran,[1.8][compiler] wrong compile error with TYPE_USE annotation on exception BETA_JAVA8Wrong compile error if a throws declaration doesn't use the same TYPE_USE annotations as a declared variable of the thrown exception's type. If I remove the declaration of field 'e1' then the code compiles.class E1 extends Exception { private static final long serialVersionUID = 1L;}@Target(ElementType.TYPE_USE)@Retention(RetentionPolicy.RUNTIME)@Documented@interface NonCritical { }public class Exceptions { @NonCritical E1 e1; // looks like this field's type binding is reused //wrong error://Cannot use the parameterized type E1 either in catch block or throws clause void f1 (int a) throws /*@NonCritical*/ E1 { throw new E1(); } void foo() { try { f1(0);//wrong error: Unreachable catch block for E1.// This exception is never thrown from the try statement body } catch (@NonCritical final RuntimeException | @NonCritical E1 ex) { System.out.println(ex); } }}
421628,11/13/2013 9:58,markus.kell.r,[1.8][dom ast][api] document new rules for ITypeBinding equality Document the new rules for ITypeBinding equality that have been established by bug 409586.Javadocs of IBinding#equals(..) #isEqualTo(..) and #getKey() need updates. You may want to keep the general IBindings APIs and just add a reference to the ITypeBinding APIs where the special rules for ITypeBindings can be explained at the level they apply to.There's no need to special-case pre-JLS8 AST levels. The behavior for such ASTs is unchanged and the special rules collapse to the old rules as soon as type annotations are out of the picture.
421711,11/14/2013 4:26,srikanth_sankaran,[1.8][compiler] '_' as identifier for a lambda parameter should be rejected At the moment we issue a warning. Javac does it too but when the identifier is for a lambda parameter Javac rejects the code. This bug is to discuss this behavioral difference between ECJ and Javac.
421712,11/14/2013 4:36,srikanth_sankaran,"[1.8][compiler] java.lang.NoSuchMethodError with lambda expression in interface default method. BETA_JAVA8:// --interface F {	void foo();}interface I {	default void foo() {		F f = () -> {		};	}}public class X implements I {	public static void main(String argv[]) {		X x = new X();		x.foo();	}}This program triggers a NoSuchMethodError because we emit invokeInterface insteadof invokestatic - fix is trivial will follow shortly."
421717,11/14/2013 5:59,daniel_megert,[quick fix] Remove unused local variable keep assignments with side effects removes side effect Created attachment 237464Sample test setup with unused local variableWhen the right hand side of the assignment expression is a call to a super class method with explicit use of the super keyword then the quick fix will remove the whole assignment.public class Sub extends Super{ int callMethodWithSideEffectViaSuper() { int unused = super.methodWithSideEffect(); return state - 1; }}after the quick fix:public class Sub extends Super{ int callMethodWithSideEffectViaSuper() { return state - 1; }}Same effect if you run into this as part of a source cleanup i.e. [Window|Preferences|Java Code Style|Clean Up|Unnecessary Code|Remove unused local variables] is checked.
421736,11/14/2013 9:04,markus.kell.r,org.eclipse.jdt.core.tests.eval is only run on Windows The whole org.eclipse.jdt.core.tests.eval suite is only run on Windows since: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=4ebeb381c4e8c6974f665730420b70c72062bb00I didn't find an explanation why exactly it failed back in 2003 so I think we should just try to run it on Linux and if it passes locally then we can remove the onWin32 condition.
421791,11/14/2013 20:45,shankhba,"[1.8][compiler] TYPE_USE annotations should be allowed on annotation type declarations. BETA_JAVA8:The following program is rejected by ECJ but is accepted by javac.// --import java.lang.annotation.ElementType;import java.lang.annotation.Target;@Target(ElementType.TYPE_USE)@interface T {	}@T@interface T2 {	}For compatibility sakes we should tolerate this."
421797,11/15/2013 1:35,srikanth_sankaran,"[1.8][compiler] ClassFormatError with default methods & I.super::foo syntax BETA_JAVA8 Tested with 8b115:// --interface I {	int m();	public default int foo() { return 0; }}interface T extends I {	public default int m() { 		I i = I.super::foo; 		return i.foo();	}}public class X {	public static void main(String argv[]) {		new T(){}.m();	}}triggers an class format error. JVM does not like the synthetic beinga static method."
421806,11/15/2013 3:47,jesper,[1.8] Debug support for Java 8. BETA_JAVA8:This bug is to track the work in the JDT debugger for supporting Java 8.Please treat this as the top level umbrella ER and raise unit level tasksas separate CR/ERs and link them to this as blockers.At the outset it would appear that the task is two folds: 1. Against a recent JRE (8b115 as of today) verify/ensure that allexisting debugger tests are green. 2. Add support for debugging Java 8 constructs. I don't see 308 269JEP120 having any effect on the debugger - other than to perhaps verify thatthey are properly tolerated in snippets. For JSR335 we need to ensure thatstepping through breakpoints inspection of values etc work as expected.For JEP118 verify that the debugger is able to avail and expose the parameternames.
421897,11/16/2013 22:52,srikanth_sankaran,"[1.8][compiler] Errors in lambda body should not influence overload resolution. BETA_JAVA8----------An earlier draft of JSR 335 required the compiler to eliminate overloadedmethod candidates based on whether the choice of that method would triggererrors in lambda body.The latest draft has eliminated this requirement. As a result the followingprogram is no longer legal and should be flagged with an ambiguous methodinvocation error: 8b115 correctly exhibits this behavior while eclipse compilesit fine and resolves the call to foo(I).// --interface I {	int foo(int [] a);}interface J {	int foo(int a);}public class X {	public static void main(String[] args) {		System.out.println(foo((a)->a.length));	}	static String foo(I i) {		return(""foo(I)"");	}	static String foo(J j) {		return(""foo(J)"");	}}"
421898,11/17/2013 0:37,srikanth_sankaran,[1.8][compiler] Implement shape analysis as a preliminary pass. BETA_JAVA8: Earlier drafts of JSR335 required the lambda body to be type checked and analysedover and over for every potentially applicable method. The latest draft has doneaway with this requirement but we still need some information about the lambdaeven in the absence of target type in invocation contexts. - Is a lambda value-compatible or void compatible or both ? - Is a lambda explicitly typed or not ? If the former what are its parameter types ? - What are the return expressions of the lambda ? Is one or more of them pertinent to applicability ?For reference expressions - Is a reference expression an exact one or an inexact one.This ER is to implement a preprocess step in INVOCATION_CONTEXT's togather this information.As part of this we should be able to reenable the two tests that weredisabled namely:NegativeLambdaExpressionsTest._test401610hNegativeLambdaExpressionsTest._test401610i
421901,11/17/2013 4:55,srikanth_sankaran,"[1.8][compiler] Incorrect error message : ""Cannot return void result"" BETA_JAVA8:// --interface I {	void foo();}interface J {	int foo();}public class X {	static void goo(I i) {		System.out.println(""goo(I)"");	}	static void goo(J j) {		System.out.println(""goo(J)"");	}	public static void main(String[] args) {		final boolean x = true;		goo(()-> goo((I)null));	}	int f() {		final boolean x = true;		while (x);	}}This program is incorrectly rejected with an error message cannot returnvoid result. This is because we incorrectly tag the lambda as being valuecompatible."
421902,11/17/2013 5:01,srikanth_sankaran,"[1.8][reconciler] Deleting an interface declaration shows no errors on uses of the interface BETA_JAVA8:Start with the following program in the editor:interface I {	void foo();}interface J {	int foo();}public class X {	static void goo(I i) {		System.out.println(""goo(I)"");	}	static void goo(J j) {		System.out.println(""goo(J)"");	}	public static void main(String[] args) {		final boolean x = true;//		goo(()-> goo((J)null));	}		int f() {		final boolean x = true;		while (x);	}}Delete the first three lines of code - until you save or otherwise modifythe buffer you don't get to see errors on the use of I."
421903,11/17/2013 5:05,srikanth_sankaran,"[1.8][compiler] Incorrect shape analysis leads to being program being rejected. BETA_JAVA8:The following should compile but does not at the moment:// --interface J {	int foo();}public class X {	static void goo(J j) {		System.out.println(""goo(J)"");	}	public static void main(String[] args) {		final boolean x = true;		goo(()-> { 			final boolean y = true;			while (y); 			});		goo(()-> { 			while (x); 			});	}}"
421926,11/17/2013 22:43,srikanth_sankaran,"[1.8][compiler] Compiler tolerates illegal forward reference from lambda in initializer BETA_JAVA8:-----------The following program compiles with ECJ but fails to compile with8b115.It appears ECJ behavior is incorrect.// --interface I { 	int run(int s1 int s2); }class X {	 static int f = ((I) (int x5 int x2) -> x1).run(10 20); static int x1 = 2;}"
421927,11/17/2013 22:51,srikanth_sankaran,"[1.8][compiler] Bad diagnostic: Unnecessary cast from I to I for lambdas. BETA_JAVA8:// -interface I { 	int run(int s1 int s2); }class X {	 static int f = ((I) (int x5 int x2) -> x1).run(10 20); static int x1 = 2;}The cast is very much necessary as otherwise the lambda's target type willbe missing."
421938,11/18/2013 3:46,jesper,[1.8] ExecutionEnvironmentDescription#getVMArguments does not preserve VM arguments ExecutionEnvironmentDescription doesn't preserve the order of VM arguments provided in a .ee file (since it uses a plain HashMap) and the test org.eclipse.jdt.debug.tests.core.EEDefinitionTests.testVMArguments() happens to test a combination of VM arguments which under 1.7 just happens to hash in the tested order.Under 1.8 this false positive doesn't happen.I'm supplying a patch which rectifies this.
421993,11/18/2013 11:21,jarthana,[1.8] Process problem: Wrong bundle ids in BETA_JAVA8 (Everybody: You have to install the Eclipse Releng Tools and then enable the POM Version Tool in the preferences).The JDT Core process of cherry picking changes from master to BETA_JAVA8 is problematic.I now see POM version problems in BETA_JAVA8 of /org.eclipse.jdt.core.tests.model/pom.xml and /org.eclipse.jdt.core.tests.compiler/pom.xml. The actual reason is not a wrong version in the POM but a wrong version the MANIFEST.MF.Even worse http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=5bf3b69e14807223b9c4f6e1446af8918e21aef4 tells me that this bug was introduced by bug 416740 and authored/signed-off-by by Mickael Istria. But I don't see what Mickael's contribution https://git.eclipse.org/r/#/c/17679/ should have done wrong -- it doesn't even touch the version number!I really think the JDT Core team should stop using a manual cherry-picking process and should instead use the normal Git workflows. While we're working on BETA_JAVA8 you should periodically select origin/master and merge it into BETA_JAVA8. That way you only have to deal with version number updates in master once: On the first merge after an update you have to revert the version number updates in BETA_JAVA8 once. After that Git won't try to update versions in BETA_JAVA8 any more since that change has already been merged.
422016,11/18/2013 19:34,jesper,[1.8] Having reference expressions or lambdas in file triggers warning for missing line numbers If I add lambdas to the simplest of classes and tries to debug it I will get soemthing like the following error text:--------------------------------------------------Unable to install breakpoint in demo.LambdaMain$$Lambda$1.380936215 due to missing line number attributes. Modify compiler options to generate line number attributes.Reason:Absent Line Number Information[ ] Don??t tell me again--------------------------------------------------I don't know why the warning is shown as I haven't tried to set the breakpoints in the function objects themselves. The function object classes are synthetic even if the classes aren't marked as such (but that's inferred from the class isn't it?) so perhaps that could be used to detect whether or not to show this warning.
422029,11/19/2013 3:44,jesper,"[1.8] Enable debug evaluation support for default methods Evaluation uses it's own method lookup logic which seems not to support default methods. Example:Create a conditional breakpoint or watch expression is this form:java.util.Arrays.asList(""A""""B"").stream().count() == 2You'll get the error: ""Method ""stream"" with signature ""()Ljava/util/stream/Stream;"" is not applicable on this object""This comes from JDIObjectValue.sendMessageI wonder if there's a similar issue for static methods."
422050,11/19/2013 6:51,srikanth_sankaran,"[1.8][compiler] Overloaded method call with poly-conditional expression rejected by the compiler BETA_JAVA8: The following program triggers an ambiguity.// --interface I { 	int foo(); }interface J { 	double foo(); }public class X {	static int foo(I i) {		return 0;	}	static int foo(J j) {		return 1;	}	public static void main(String argv[]) {		System.out.println(foo (() -> true ? 0 : 1));	}}"
422064,11/19/2013 9:53,manpalat,[1.8][tests] errors compiler.regression tests when run with run.javac Running TestAll of compiler.regression with -Drun.javac and -Djdk.root pointing to 8b115 I get errors in two suites:EnumTest.test180 / test180a throw NPE in AbstractRegressionTest.runJavac()BatchCompilerTest: - test230_sourcepath_vs_classpath - test236_classpath - test238_classpathAll through StringIndexOutOfBoundsExceptionI'm not sure whether this is specific to BETA_JAVA8.
422107,11/20/2013 0:44,srikanth_sankaran,[1.8][code assist] Invoking code assist just before and after a variable initialized using lambda gives different result Consider the below code snippet:import java.io.Serializable;interface I { void doit();}public class X { // Invoke code assist<Ctrl+space> in this location gives 20+ suggestions Object o = (I & Serializable) () -> {};// Invoke code assist<Ctrl+space> in this location gives just 4 template proposals }Invoking code assist just before and after a variable initialized using lambda gives different result.
422134,11/20/2013 8:14,srikanth_sankaran,"[1.8] NPE in NullAnnotationMatching with inlined lambda expression used with a raw type package test;import java.util.ArrayList;import java.util.Collections;class Z {	private void foo() {		Collections.sort(new ArrayList() (o1 o2) -> {			return o1.compareToIgnoreCase(o1);		});	}}-----------------------------------In the above example edit something. We get the following exception:java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:123)	at org.eclipse.jdt.internal.compiler.ast.Statement.checkAgainstNullTypeAnnotation(Statement.java:151)	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.checkAgainstNullAnnotation(ReturnStatement.java:177)	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.analyseCode(ReturnStatement.java:76)	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.doesNotCompleteNormally(LambdaExpression.java:297)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:491)	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4355)	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4331)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:678)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:620)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1508)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2540)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:674)	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1011)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:920)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:196)	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:195)	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521)	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)..."
422259,11/21/2013 10:20,manpalat,[1.8][dom ast] AST Formatter removes blanks around annotations int[] @Annot1 [] = new int[1] @Annot1 [2]; gets reduced toint[]@Annot1[] = new int[1]@Annot1[2];
422307,11/22/2013 1:53,noopur_gupta,"[inline] NPE in preview of inline constant refactoring package com.test;class TestNPE {	public static final C c = new C(); // Inline all references of 'c'	private void test1() {		int n = c.foo(0);		test2(c);	}	private void test2(C m) {}}class C {	int foo(int x) {		return x;	}}---------------------------------------------------------------Inline all references of 'c' at the line with comment in the above example.In the 'Inline Constant' dialog click 'Preview' click 'Back' and click 'Preview' again. We get the following exception:java.lang.reflect.InvocationTargetException	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:422)	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:331)	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:663)......Caused by: java.lang.NullPointerException	at org.eclipse.jdt.internal.corext.refactoring.code.InlineConstantRefactoring.getInitializer(InlineConstantRefactoring.java:800)	at org.eclipse.jdt.internal.corext.refactoring.code.InlineConstantRefactoring.checkFinalConditions(InlineConstantRefactoring.java:815)	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)..."
422468,11/25/2013 7:20,srikanth_sankaran,"[1.8][assist] Code assist issues with type elided lambda parameters BETA_JAVA8:At present there are a set of problems in the way type elided lambda parametersare handled by SelectionEngine/SelectionParser. Similar but different issues exist with CompletionEngine/CompletionParser too.Given:// --interface I {	String foo(String x Integer y);}public class X {	static void foo(I i) {}	public static void main(String[] args) {		foo((x y) -> x + y);	}} (1) if you hover on either of x or y in x + y we claim those are of typeObject - this is blatantly wrong but happens because the selection parserbuilds minimal parse trees in which a good bit of the pertinent contextualinformation is lost.The flattened parse tree for the method looks like:public static void main(String[] args) { (<no type> x <no type> y) -> <SelectOnName:y>;}See that the fact about lambda being a method parameter is completelylost.I see this as requiring good amount of work to get correctly. Becauselambda's can occur is deeply nested subexpressions involving numerousnode types this is not going to be easy solution to ""enhance"" theselection/completion parser(2) If you hover on the parameter declaration you get nothing. This isproblematic as users will identify this as a classic situation where theIDE should help clarify things for them.(3) The hover on the use actually claims: Object y - X.main(String[])This could perhaps be due to bug 416559 ? // --Discussions welcome on how to go about solving this or alternate strategies."
422489,11/25/2013 11:21,srikanth_sankaran,"[1.8][compiler] NPE in CompoundAssignment.analyseCode when creating AST for java.util.stream.Collectors BETA_JAVA8 JDK 1.8.0-ea-b115Open java.util.stream.Collectors and try to create an AST for it.java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.CompoundAssignment.analyseCode(CompoundAssignment.java:52)	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.doesNotCompleteNormally(LambdaExpression.java:309)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:506)	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4435)	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4404)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:678)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:620)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getStaticFactory(Scope.java:4616)	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.inferElidedTypes(AllocationExpression.java:501)	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:437)	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve(ReturnStatement.java:321)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548)"
422506,11/25/2013 13:40,markus.kell.r,"[1.8][render] Abstract method from interface should show ""A"" adornment Created attachment 237697FixBETA_JAVA8An abstract method from an interface should show an ""A"" adornment like an abstract method from a class. AFAIK we didn't add the ""A"" in the past since the outline of an interface looks a bit ""crowded"" when every method has an ""A"".However the missing ""A"" is already problematic in other views like Search Type Hierarchy and in Quick Outline/Hierarchy since the abstractness of a method cannot be seen without additional knowledge about the declaring type.With static and default methods in interfaces this got even worse since those methods now identify themselves as having an implementation but abstract methods still look like regular instance methods.Does anybody disagree with this change or have a better solution?"
422515,11/25/2013 14:53,srikanth_sankaran,"[1.8][compiler] ""Missing code implementation in the compiler"" when lambda body accesses array variable ""Missing code implementation in the compiler"" compile error when a lambda body accesses an array-typed variable:package jsr335;public class LambdaAccessArray { public static void main(String[] args) throws InterruptedException { final int[] result= { 0 }; Thread t = new Thread(() -> { result[0]= 42; }); t.start(); t.join(); System.out.println(result[0]); }}The error doesn't occur when the lambda body is just an expression like this: Thread t = new Thread(() -> result[0]= 42);The problem is reported here: org.eclipse.jdt.internal.compiler.problem.ProblemReporter.needImplementation(ProblemReporter.java:6178)	at org.eclipse.jdt.internal.compiler.codegen.CodeStream.generateOuterAccess(CodeStream.java:2286)	at org.eclipse.jdt.internal.compiler.codegen.StackMapFrameCodeStream.generateOuterAccess(StackMapFrameCodeStream.java:364)	at org.eclipse.jdt.internal.compiler.ast.SingleNameReference.generateCode(SingleNameReference.java:487)	at org.eclipse.jdt.internal.compiler.ast.ArrayReference.generatePostIncrement(ArrayReference.java:166)	at org.eclipse.jdt.internal.compiler.ast.PostfixExpression.generateCode(PostfixExpression.java:40)	at org.eclipse.jdt.internal.compiler.ast.Expression.generateCode(Expression.java:695)	at org.eclipse.jdt.internal.compiler.ast.Block.generateCode(Block.java:75)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.generateCode(LambdaExpression.java:751)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.generateCode(LambdaExpression.java:702)	at org.eclipse.jdt.internal.compiler.ClassFile.addSpecialMethods(ClassFile.java:923)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:573)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:638)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:369)	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:781)	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137)"
422516,11/25/2013 14:54,srikanth_sankaran,"[1.8][compiler] NPE in ArrayReference.analyseAssignment This happened while I was trying to create an example for bug 422515. The code has compile errors but there shouldn't be an NPE.!ENTRY org.eclipse.jdt.core 4 4 2013-11-25 20:47:34.680!MESSAGE Exception occurred during problem detection:----------------------------------- SOURCE BEGIN -------------------------------------package jsr335;public class LambdaAccessArray { public static void main(String[] args) throws InterruptedException { final int[] result= { 0 }; Thread t = new Thread(() -> { sysoresult[0]= 42; }); t.start(); t.join(); System.out.println(result[0]); }}----------------------------------- SOURCE END -------------------------------------!STACK 0java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.ArrayReference.analyseAssignment(ArrayReference.java:57)	at org.eclipse.jdt.internal.compiler.ast.Assignment.analyseCode(Assignment.java:80)	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.doesNotCompleteNormally(LambdaExpression.java:309)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:506)	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4435)	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4404)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:678)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:620)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor(Scope.java:2172)	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:446)	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:244)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:920)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:196)	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:195)	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:258)	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:521)	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:170)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)"
422685,11/27/2013 11:16,daniel_megert,APT Tests does not export all packages By default this causes a warning and in my setup I get an error since I've increased the severity.
422687,11/27/2013 11:19,daniel_megert,"APT Tests uses @suppressWarnings(""local"") but does not set the compiler severity to 'Warning' APT Tests uses @suppressWarnings(""local"") but does not set the compiler severity to 'Warning'. This can cause error or warnings in workspace that changed the setting for unused local variables."
422739,11/28/2013 3:30,daniel_megert,'org.eclipse.jdt.core.tests.model' does not export all packages By default this causes a warning and in my setup I get an error since I've increased the severity.
422743,11/28/2013 4:25,daniel_megert,"JDT APT tests don't run in official build N20131127-2000.Class not found ""org.eclipse.jdt.apt.tests.TestAll cannot be found by osgi.identity; osgi.identity=""org.eclipse.jdt.apt.tests""; type=""osgi.bundle""; version:Version=""3.3.401.N20131127-2000""; singleton:=""true""""org.eclipse.test.EclipseTestRunner$TestFailedException: Class not found ""org.eclipse.jdt.apt.tests.TestAll cannot be found by osgi.identity; osgi.identity=""org.eclipse.jdt.apt.tests""; type=""osgi.bundle""; version:Version=""3.3.401.N20131127-2000""; singleton:=""true""""at org.eclipse.test.EclipseTestRunner.runFailed(EclipseTestRunner.java:582)at org.eclipse.test.EclipseTestRunner.getTest(EclipseTestRunner.java:521)at org.eclipse.test.EclipseTestRunner.<init>(EclipseTestRunner.java:496)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:308)at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36)at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32)at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:109)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:80)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:372)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:226)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)at org.eclipse.equinox.launcher.Main.run(Main.java:1450)at org.eclipse.equinox.launcher.Main.main(Main.java:1426)at org.eclipse.core.launcher.Main.main(Main.java:34)"
422792,11/28/2013 13:17,markus.kell.r,"[quick assist] ""Convert to 'for' loop using Iterator"" on raw collection ""Convert to 'for' loop using Iterator"" should also work on a raw collection."
422800,11/28/2013 14:28,srikanth_sankaran,"[1.8][compiler] ""Missing code implementation in the compiler"" 2 Follow-up to bug 422515. This time I won't guess a reason...package jsr335;public class LambdaAccess2 { private String fField; // must be here; can be used or unused public void foo(Integer arg) { new Thread(() -> { // at ""arg"": Missing code implementation in the compiler arg.intValue(); }); }}"
422801,11/28/2013 14:34,srikanth_sankaran,"[1.8][compiler] NPE in MessageSend.analyseCode in lambda body with missing import The missing import seems to be a big deal:package jsr335;//import java.util.Random;public class LambdaAccess2 { public void foo(Random arg) { new Thread(() -> { arg.intValue(); }); }}java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:103)	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:43)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.doesNotCompleteNormally(LambdaExpression.java:317)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:543)	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4435)	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4404)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:678)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:620)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor(Scope.java:2172)	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:446)	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1011)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548)"
422809,11/28/2013 22:30,srikanth_sankaran,[1.8][compiler] Build heuristics based shape discovery capability as fall back. In the normal compiler workflow data/control flow analysis is not undertaken if resolution phase has errors. For lambda expressions we need information from flow analysis right during resolution stage. https://bugs.eclipse.org/bugs/show_bug.cgi?id=422801 and https://bugs.eclipse.org/bugs/show_bug.cgi?id=422489exposed problems in our analyzeCode infrastructure's ability to deal withhandling bad data handed to them. I suspect the problem is pervasive and thesebugs are just a few instances of the systemtic problem.At the moment I have disabled shape discovery if there are resolution errorseither in the lambda or its enclosing scopes. This is perfectly OK and will nothave any material effect - other than some spurious *secondary* errors that mayshow up during compilation: We may claim a certain method call is ambiguous whileit is not or that no applicable method is found when such is not the case.This ER is to build a fall back mechanism using ASTVisitor to discover shape.While the general problem is not amenable to being solved using ASTVisitor severalcommon cases can be solved leaving only pathological cases unanalyzed.This problem is only for lambdas with block bodies. We already to use heuristicsto some extent: for example if we have seen a return statement without anexpression (during resolve) then we can declare the lambda as being NOT valuecompatible - without control flow analysis.Likewise if we don't see any loops any throws etc we can draw some conclusions that could suffice for the vast majority of the cases.This is not a correctness issue but could lead to better programmer experience.
422810,11/28/2013 22:48,srikanth_sankaran,"[1.8][compiler] Incorrect ambiguous call error BETA_JAVA8:The following program triggers an ambiguous call error from javac 8b115. ATMI have adjusted the behavior of eclipse to match. But this is most certainlywrong - I have asked for clarifications from the EG and once confirmed we should fix accordingly.// -- interface I { String foo(String [] x String y); } interface J { void foo(int x int y); } public class X { static void goo(J j) { System.out.println(""goo(J)""); } static void goo(I i) { System.out.println(""goo(I)""); } public static void main(String[] args) throws InterruptedException { goo((x y) -> { return x[0] += 1; }); } }"
422822,11/29/2013 3:49,jarthana,Fix the Generics related warnings in official build Ref to bug 421017 which introduces generics to jdt.core project via compliance level 1_6. Even though we had disabled the warnings in the pref file the official build still enables them as a result of which we get warnings in the build:http://download.eclipse.org/eclipse/downloads/drops4/N20131128-2000/compilelogs/plugins/org.eclipse.jdt.core_3.10.0.N20131128-2000/@dot.htmlWe have to generify them where ever possible or suppress otherwise. For all APIs we will suppress the warnings and other cases need to be looked at case-by-case.
422832,11/29/2013 4:51,shankhba,Class file triggers StackOverflowError when creating type hierarchy Created attachment 237840Example project to reproduce the StackOverflowWhen I add the Aspose PDF library to my build path and I declare a class that extends one of the classes contained in the Aspose PDF JAR I get a Stackoverflow error. The same problem occurrs when I create a type hierarchy.I stripped the Aspose library down to one class and removed all methods and fields. The problem is caused by the type signature. I think class A is declared to implement itself which is strange as one cannot implement classes but interfaces only. However the code obfuscator used by Aspose has somehow managed to create such a class file.I know the class file is seriously damaged but nonetheless Eclipse should not crash when dealing with such class files.I'll attach an example project to repoduce the behavior.The stack overflow contains these two methods:org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.superInterfaces(BinaryTypeBinding.java:1384)org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.superInterfaces(ParameterizedTypeBinding.java:1008)
422901,11/30/2013 19:54,srikanth_sankaran,"[1.8][code assist] Code assistant sensitive to scope.referenceContext type identity. BETA_JAVA8:There are a bunch of checks in SelectionEngine + CompletionEngine that looklike the following: if (scope.referenceContext instanceof AbstractMethodDeclaration) { // ... }All these places need to upgrade to LambdaExpression as a potential referencecontext.Example that breaks:interface I {	void foo();}public class X {	public static void main(String[] args) {				I i = () -> {			syso| // no proposals here.		};			}}"
422908,12/1/2013 13:17,noopur_gupta,[organize imports] Add 'Skip' to Organize Import dialog Add to Organize Import dialog dialog the skip button which will preserve wrong import.Now the Organize Import dialog ask for each type that it can't resolve automatically and I must select the type or cancel the WHOLE operation. Sometime I prefer to resolve it manually after import organisation realy.
423122,12/3/2013 20:15,srikanth_sankaran,[1.8] Missing incremental build dependency from lambda expression to functional interface The incremental build misses a dependency from a lambda expression to its functional interface: When the signature of the interface method is changed the Lambda expression must be recompiled even if there's no explicit reference in source code.package test1;public interface I { int method(int a); // change argument type to Object}package test1;public class E { void take(I i) { }}package test1;public class Ref { void foo(E e) { e.take((x) -> x+2); // not recompiled when I#method signature changed }}
423254,12/4/2013 18:50,het,There is no way to tell if a project's factory path is different from the workspace default There is no way to check in code that the factory path for a project is equal to the workspace default factory path (which is needed to check if the user has done any manual modification of the factory path). The 2 closest things you can do are:1) Ask if a project has a project specific factory path with AptConfig.hasProjectSpecificFactoryPath() but this ONLY checks whether or not the project has saved a factory path file it doesn't check that the factory path of the project is actually different from the workspace default.2) Ask for the workspace default factory path with AptConfig.getDefaultFactoryPath() and then ask if it is equals() to the project's factory path this does not work because factory paths do not implement equals() so it is using (==).I propose implementing equals() for FactoryPath and making AptConfig.hasProjectSpecificFactoryPath() compare the project's factory path with the workspace default if it is found that the project has set a factory path.I can write it up and send a patch just let me know if you see anything wrong with the proposal.
423409,12/6/2013 4:58,manpalat,"[search] Search shows references to fields as potential matches Created attachment 238107Test project- Import the attached project in your workspace.- Find references of the constant field 'fi' of class Test2 via Ctrl+Shift+G.=> Search view shows the references as potential matches instead of accurate matches.(As a result in inline refactoring: - Press Alt+Shift+I on 'fi' declaration to inline all of its references and choose to delete the constant declaration.- Click OK : We get the message ""Inaccurate matches have been found..."".- Continuing deletes the declaration but the references are not inlined and we get compilation errors.)"
423439,12/6/2013 10:14,noopur_gupta,"[1.8][clean up][quick assist] ""Convert anonymous to lambda"" needs to consider ambiguous target types ""Convert anonymous to lambda"" needs to consider ambiguous target types see example in bug 403749 comment 22.This is essentially the same problem as bug 408966 and should be solved with common infrastructure."
423467,12/6/2013 13:01,srikanth_sankaran,"[1.8][compiler] wrong error for functional interface with @Override default method ecj reports a wrong compile error for a functional interface with an ""@Override default"" method that implements an abstract method from a superclass:package jsr335.funint4;@FunctionalInterfaceinterface I { int foo(String s);}@FunctionalInterfaceinterface A extends I { // wrong compile error (A *is* a functional interface) @Override default int foo(String s) { return -1; } Integer foo(java.io.Serializable s);}@FunctionalInterfaceinterface B { // OK default int foo(String s) { return -1; } Integer foo(java.io.Serializable s);}"
423582,12/9/2013 7:04,srikanth_sankaran,"[1.8] CCE in TypeBinding.isCastCompatible for PolyTypeBinding CCE when hovering over the reference to 'goo'. Note that 'I' is not a functional interface and the compiler correctly reports errors for that.interface I { }public class X { static void goo(I i) { System.out.println(""goo(I)""); } public static void main(String[] args) { goo(s -> 0); // hover over 'goo' -> CCE }}java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding	at org.eclipse.jdt.internal.compiler.ast.Expression.checkCastTypesCompatibility(Expression.java:504)	at org.eclipse.jdt.core.dom.TypeBinding.isCastCompatible(TypeBinding.java:1056)	at org.eclipse.jdt.internal.ui.text.correction.UnresolvedElementsSubProcessor.doEqualNumberOfParameters(UnresolvedElementsSubProcessor.java:1599)	at org.eclipse.jdt.internal.ui.text.correction.UnresolvedElementsSubProcessor.addParameterMissmatchProposals(UnresolvedElementsSubProcessor.java:1336)	at org.eclipse.jdt.internal.ui.text.correction.UnresolvedElementsSubProcessor.getMethodProposals(UnresolvedElementsSubProcessor.java:1109)	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.process(QuickFixProcessor.java:337)	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.getCorrections(QuickFixProcessor.java:300)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:378)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:339)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:335)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:468)	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:225)	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:199)	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:285)	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135)	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4145)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3762)"
423584,12/9/2013 7:11,srikanth_sankaran,"[1.8][dom ast] NPE in LambdaExpression#getMethodBinding() for lambda with unresolved type NPE in LambdaExpression#getMethodBinding() for lambda with unresolved type.The example is the same as in bug 423582.interface I { }public class X { static void goo(I i) { System.out.println(""goo(I)""); } public static void main(String[] args) { goo(s -> 0); }}java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.getMethodBinding(LambdaExpression.java:912)	at org.eclipse.jdt.core.dom.DefaultBindingResolver.resolveMethod(DefaultBindingResolver.java:886)	at org.eclipse.jdt.core.dom.LambdaExpression.resolveMethodBinding(LambdaExpression.java:319)	at org.eclipse.jdt.astview.views.ASTViewContentProvider.getNodeChildren(ASTViewContentProvider.java:149)"
423648,12/9/2013 19:22,daniel_megert,Treat unrecognized future JDKs as source code compatible with the latest known JDK version To improve user experience when people try a new version of Eclipse with Java 8 Early Access JDKs an unknown JDK version should be assumed capable of working with the latest known JDK version in terms of source code compatibility. This is especially important when existing projects using workspace default JRE are imported to a new workspace managed by an Eclipse installation running on Java 8 EA VM. Currently projects that compiled without problems under a previous Eclipse-Java combination encounter build errors that are not solved by simply adding a Java 7 JRE to the installation. The 'trick' needed to solve the situation is not obvious: after adding the JRE one needs to open Preferences->Java->Compiler page and click OK even if the page already claims that compliance level is set to 7.The fix is simply to treat unknown JDK version strings as meaning compiler compliance 7.
423655,12/9/2013 23:30,srikanth_sankaran,"[1.8][compiler] Problems running ECJ Mea culpa !org.eclipse.jdt.internal.compiler.parser.Parser.consumeNestedLambda()has this line of code: LambdaExpression lambda = new LambdaExpression(this.compilationUnit.compilationResult this instanceof AssistParser);that breaks ECJ runs with a ClassDefNotFound error.Fix is simple - to introduce a level of indirection using a virtual call.(A lambda needs to know if it was created by the assist parser so it canapply less strict rules for compatibility. Code is being written ""just now""if we apply strict rules we would often reject overloaded calls thatwould be resolved correctly once the completion which was the raison d'etrefor the lambda is done.)(There are also some interesting chicken and egg situations here. The programmercould be completing return statements which influence the overload resolutionwhich would influence the target type which would influence the return typecompletion ...)"
423684,12/10/2013 6:32,srikanth_sankaran,"[1.8][compiler] IllegalAccessError using functional consumer calling inherited method I previously reported this to the openjdk but it turns out it works correctly when compiled with javac: https://bugs.openjdk.java.net/browse/JDK-8029707The problem exists only with Eclipse compiled classes:Eclipse Version: 4.3.1Build id: M20130911-1000Ubuntu 12.10 32bitsJava(TM) SE Runtime Environment (build 1.8.0-ea-b118)Given a package private class with a public method and a public subclass that inherits the public method if we try to use the inherited public method using a lambda expression like:c.forEach(subclass::inheritedMethod);we get an java.lang.IllegalAccessErrorSTEPS TO FOLLOW TO REPRODUCE THE PROBLEM :Considering the following scenario:A package 'mypackage' containing a package private class called MyPackagePrivateBaseClass:class MyPackagePrivateBaseClass { public void doSomething(String input) { System.out.println(input); }}and a public subclass called MyPublicClass:public class MyPublicClass extends MyPackagePrivateBaseClass {}If I try to access the inherited public method 'doSomething' from a class in a different package using a lambda expression I get a Exception in thread ""main"" java.lang.IllegalAccessError: tried to access class mypackage.MyPackagePrivateBaseClass from class Test	at Test.doesNotWork(Test.java:37)	at Test.main(Test.java:31)public class Test { public static void main(String[] args) { doesWork(); doesNotWork(); } public static void doesNotWork() { MyPublicClass victim = new MyPublicClass(); List<String> items = Arrays.asList(""first"" ""second"" ""third""); items.forEach(victim::doSomething); //illegal access error here } public static void doesWork() { MyPublicClass victim = new MyPublicClass(); List<String> items = Arrays.asList(""first"" ""second"" ""third""); for (String item : items) { victim.doSomething(item); } }}"
423685,12/10/2013 6:37,srikanth_sankaran,"[1.8] poly conditional expression must not use lub Consider an example like this: class A{/**/} class B extends A {/**/} class G<T> { G<B> gb=null; G<? super A> gsa=null; G<? super B> l = (true)? gsa : gb; }The conditional expression is a poly expression (appears in an assignment context) and hence should apply this rule from 15.25.3:""The type of a poly reference conditional expression is the same as its target type.""ECJ however still seems to use lub computation based on which the assignment is rejected.Avoiding lub in situations like this is important because lub(capture1capture2) doesn't produce good results whereas the new rules are much more permissive."
423689,12/10/2013 7:17,markus.kell.r,"[quick fix] Create 'for' loop for int array creates duplicate local variable package com.test;public class C1 {	private int[] nums;	private void foo() {		nums	}}------------------------------------------In the above example hover over 'nums' in foo() and apply the quick fix ""Create 'for' loop"". It results in the following code:		for (int i = 0; i < nums.length; i++) {			int i = nums[i];					}The local variable 'i' is duplicate and has compilation error."
423803,12/11/2013 8:14,srikanth_sankaran,"[1.8][compiler] No error shown for ambiguous reference to the method package test;class C2 implements C2_Sup { public static final FI fi = x -> x++; public static final FL fl = x -> x++; { bar(x -> x++); // [1] bar(fl); } void bar(FI fi) { }}interface C2_Sup {		default void bar(FL fl) { }}@FunctionalInterfaceinterface FI {	int foo(int x);}@FunctionalInterfaceinterface FL { long foo(long x);}--------------------------------------------------------The above example compiles without any error with ECJ but shows error at [1] with b118."
423828,12/11/2013 10:33,markus.kell.r,org.eclipse.jdt.core.tests.model run out of memory on Hudson under Linux http://download.eclipse.org/eclipse/downloads/drops4/I20131210-2000/testresults/html/org.eclipse.jdt.core.tests.model_linux.gtk.x86_6.0.html is missing the org.eclipse.jdt.core.tests.model tests.http://download.eclipse.org/eclipse/downloads/drops4/I20131210-2000/testresults/html/org.eclipse.jdt.core.tests.model_win32.win32.x86_7.0.html is complete.The consolelog reveals the reason:java-test: [echo] Running org.eclipse.jdt.core.tests.model.AllJavaModelTests. Result file: /opt/users/hudsonbuild/workspace/ep4-unit-lin64/workarea/I20131210-2000/eclipse-testing/results/linux.gtk.x86_6.0/org.eclipse.jdt.core.tests.model.AllJavaModelTests.xml [echo] timout property: 7200000 [echo] frameworkvmargs: -Xms40m -Xmx512m -XX:MaxPermSize=256m[..] [java] java.lang.OutOfMemoryError: Java heap space
423849,12/11/2013 12:46,srikanth_sankaran,"[1.8][compiler] cannot implement java.nio.file.Path because of compiler name clash It is impossible to extend java.nio.file.Path because of a compiler errorThe type MyPath must implement the inherited abstract method Path.register(WatchService WatchEvent.Kind<?>[] WatchEvent.Modifier...)	The method register(WatchService WatchEvent.Kind<?>[] WatchEvent.Modifier...) of type MyPath must override or implement a supertype methodName clash: The method register(WatchService WatchEvent.Kind<?>[] WatchEvent.Modifier...) of type MyPath has the same erasure as register(WatchService WatchEvent.Kind<?>[] WatchEvent.Modifier...) of type Path but does not override itThe following two methods are the culpritWatchKey register(WatchService watcher Kind<?>[] events Modifier... modifiers) throws IOExceptionWatchKey register(WatchService watcher Kind<?>... events) throws IOException---Full Source----public class MyPath implements Path { /** {@inheritDoc} */ @Override public FileSystem getFileSystem() { return null; } /** {@inheritDoc} */ @Override public boolean isAbsolute() { return false; } /** {@inheritDoc} */ @Override public Path getRoot() { return null; } /** {@inheritDoc} */ @Override public Path getFileName() { return null; } /** {@inheritDoc} */ @Override public Path getParent() { return null; } /** {@inheritDoc} */ @Override public int getNameCount() { return 0; } /** {@inheritDoc} */ @Override public Path getName(int index) { return null; } /** {@inheritDoc} */ @Override public Path subpath(int beginIndex int endIndex) { return null; } /** {@inheritDoc} */ @Override public boolean startsWith(Path other) { return false; } /** {@inheritDoc} */ @Override public boolean startsWith(String other) { return false; } /** {@inheritDoc} */ @Override public boolean endsWith(Path other) { return false; } /** {@inheritDoc} */ @Override public boolean endsWith(String other) { return false; } /** {@inheritDoc} */ @Override public Path normalize() { return null; } /** {@inheritDoc} */ @Override public Path resolve(Path other) { return null; } /** {@inheritDoc} */ @Override public Path resolve(String other) { return null; } /** {@inheritDoc} */ @Override public Path resolveSibling(Path other) { return null; } /** {@inheritDoc} */ @Override public Path resolveSibling(String other) { return null; } /** {@inheritDoc} */ @Override public Path relativize(Path other) { return null; } /** {@inheritDoc} */ @Override public URI toUri() { return null; } /** {@inheritDoc} */ @Override public Path toAbsolutePath() { return null; } /** {@inheritDoc} */ @Override public Path toRealPath(LinkOption... options) throws IOException { return null; } /** {@inheritDoc} */ @Override public File toFile() { return null; } /** {@inheritDoc} */ @Override public WatchKey register(WatchService watcher Kind<?>[] events Modifier... modifiers) throws IOException { return null; } /** {@inheritDoc} */ @Override public WatchKey register(WatchService watcher Kind<?>... events) throws IOException { return null; } /** {@inheritDoc} */ @Override public Iterator<Path> iterator() { return null; } /** {@inheritDoc} */ @Override public int compareTo(Path other) { return 0; }}"
423872,12/11/2013 21:28,manpalat,"[1.8][dom] IllegalArgumentException seen while opening Path.class I get the exception below while control-clicking to enter into:8b115's java.nio.file.Path:java.lang.IllegalArgumentException	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2848)	at org.eclipse.jdt.core.dom.ASTConverter.setTypeAnnotationsAndSourceRangeOnArray(ASTConverter.java:3417)	at org.eclipse.jdt.core.dom.ASTConverter.convertToArray(ASTConverter.java:3165)	at org.eclipse.jdt.core.dom.ASTConverter.convertType(ASTConverter.java:3880)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:921)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:554)	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:201)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2957)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:295)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1212)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132)	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:365)	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:347)	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:371)	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:331)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
423885,12/12/2013 5:24,jarthana,JDT's implementation of JSR-199 reports wrong errors with classes generated by Annotation Processing Tool Created attachment 238276Patch + Maven projectWhen using Eclipse compiler through JSR-199 interface (e.g. in IntelliJ IDEA) classes generated with Annotation Processing Tool are reported as missing during main classes compilation.As example I provide a small Maven project in attachment. Compiling it with Maven (using Eclipse compiler) works fine but not with IntelliJ CE.Having looked carefully at the code it appears that batch compiler and JSR-199 do not report errors in the same way. I also provide a patch that fixes it. Feel free to incorporate it in ECJ sour code.Thanks Best regardsGauthier
423987,12/13/2013 2:11,srikanth_sankaran,[1.8][assist] Follow up tasks from Bug 422468 - [1.8][assist] Code assist issues with type elided lambda parameters This CR will collect the follow up tasks found during code review and testing.1. We should/could get rid of the new abstraction CommitRollbackParser bypushing down the APIs into Parser itself.2. CompletionParser.becomeSimpileParser() and restoreAssistParser() needsto be studied to see what effect if any they may have on the new commit-rollbackscheme.3. Stacking of assist nodes can be handled better/cleaner ?4. We could fast forward past the initial identifiers in an identifiercollection leading up to completion point. 5. copyState() could avoid deep copy. Note: Parser state stack must be deepcopied. As well as the place in CompletionParser attachOrphanNode() as thelatter mucks around with expression and ast stacks a bit too much.6. One more round of review of CommitRollbackParser.7. AssistParser.resumedAfterRepair: can be handled better. (?)8. AssistParser.elementStack: do we need lambdas and body kind there - wedon't use it as of now at all.
424071,12/15/2013 8:57,srikanth_sankaran,"[1.8][select] cannot select method invoked on a lambda parameter with inferred type Using the example from bug 419048:import java.util.List;import java.util.Map;import java.util.stream.Collectors;public class Bug419048 {	void test1(List<Person> roster) { Map<String Person> map = roster .stream() .collect( Collectors.toMap( p -> p.getLast() //[1] p -> p //[2] ));	}}Now that type inference is able to find the correct types for the lambda parameters I tried to hover or crtl-click on occurrences of p and specifically the message send ""getLast()"". Some of these currently fail withjava.lang.NullPointerException	at org.eclipse.jdt.internal.core.SelectionRequestor.acceptLocalVariable(SelectionRequestor.java:458)	at org.eclipse.jdt.internal.codeassist.SelectionEngine.selectFrom(SelectionEngine.java:1236)	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:951)	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:162)	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:377)	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:371)Note that hovering over the message receiver ""p"" in ""p.getLast()"" says: ""Object p - Bug419048.test1(List<Person>)"" i.e. the inferred type Person is not known to code select ...Is code select working with information from before the type inference kicks in?"
424080,12/16/2013 1:26,srikanth_sankaran,"[1.8][completion] Workbench hanging on code completion with lambda expression containing anonymous class interface FI {	public static int val = 5;	default int run (String x) { return 1;};	public int run (int x);}public class Test {	FI fi = x -> (new FI() { public int run (int x) {return 2;}}).run("""")val;}Please try to put a dot '.' before the last 'val' in the 2nd last line. See the workbench hanging."
424083,12/16/2013 3:07,markus.kell.r,"[1.8][quick assist] AIOOB exception in Convert to anonymous class creation package com.test;interface F1 {	void foo(int x String s float f);}public class C1 {	F1 f1= () -> {}; // Ctrl+1 on '>'}--------------------------------------------------In the above example place caret on '->' and press Ctrl+1. A warning with AIOOB is logged in the Error log.Select the quick assist 'Convert to anonymous class creation' and press Enter.We get the AIOOB exception:java.lang.ArrayIndexOutOfBoundsException: 0	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility2.createParameters(StubUtility2.java:503)	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility2.createImplementationStub(StubUtility2.java:419)	at org.eclipse.jdt.internal.corext.fix.LambdaExpressionsFix$CreateAnonymousClassCreationOperation.rewriteAST(LambdaExpressionsFix.java:293)	at org.eclipse.jdt.internal.corext.fix.CompilationUnitRewriteOperationsFix.createChange(CompilationUnitRewriteOperationsFix.java:101)	at org.eclipse.jdt.internal.ui.text.correction.proposals.FixCorrectionProposal.createTextChange(FixCorrectionProposal.java:159)	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createChange(CUCorrectionProposal.java:244)..."
424110,12/16/2013 6:20,srikanth_sankaran,"[1.8][hovering] Hover F3 does not work for method reference in method invocation package com.test;public class C2 {	static F f = C2::m; // [1] Works	int i = fun(C2::m); // [2] Does not work	public static int m(int x) {		return x;	}	private int fun(F f) {		return f.foo(0);	}}interface F {	int foo(int x);}---------------------------------------------------------In the above example press F3 or hover over 'm' at [1] and [2].It works at [1] but not at [2]."
424119,12/16/2013 8:08,manpalat,"[1.8][search] CCE in search for references to TYPE_USE annotation on array dimension CCE when trying to search for references to @Annot (a TYPE_USE annotation on an array dimension). Also happens for marker and single-member annotations.package xy;import java.lang.annotation.*;@Target(ElementType.TYPE_USE)@Retention(RetentionPolicy.RUNTIME)@Documented@interface Annot {}public class Try {	{		String tab @Annot() [] = null;	}}!ENTRY org.eclipse.core.jobs 4 2 2013-12-16 14:03:34.616!MESSAGE An internal error occurred during: ""Java Search"".!STACK 0java.lang.ClassCastException: org.eclipse.jdt.internal.core.Initializer cannot be cast to org.eclipse.jdt.core.IAnnotatable	at org.eclipse.jdt.internal.core.search.matching.MemberDeclarationVisitor.storeHandle(MemberDeclarationVisitor.java:145)	at org.eclipse.jdt.internal.core.search.matching.MemberDeclarationVisitor.visit(MemberDeclarationVisitor.java:253)	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.traverse(SingleTypeReference.java:111)	at org.eclipse.jdt.internal.compiler.ast.NormalAnnotation.traverse(NormalAnnotation.java:68)	at org.eclipse.jdt.internal.compiler.ast.ArrayTypeReference.traverse(ArrayTypeReference.java:144)	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.traverse(LocalDeclaration.java:299)	at org.eclipse.jdt.internal.compiler.ast.Block.traverse(Block.java:145)	at org.eclipse.jdt.internal.compiler.ast.Initializer.traverse(Initializer.java:134)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2619)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2773)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2504)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1737)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1147)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1188)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1320)	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:95)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:231)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:515)	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584)	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144)	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
424138,12/16/2013 10:38,manpalat,"[1.8][dom ast] Bad source ranges for qualified TYPE_USE annotation in extends clause BETA_JAVA8Bad source ranges for qualified TYPE_USE annotation in extends clause. BTW: For this specific example javac 1.8.0-ea-b115 has even worse bugs...!ENTRY org.eclipse.jdt.core 4 4 2013-12-16 16:31:25.041!MESSAGE Bad AST node structure:- parent [156 168] org.eclipse.jdt.core.dom.SimpleType annotations [156 194] org.eclipse.jdt.core.dom.MarkerAnnotation- parent [156 168] org.eclipse.jdt.core.dom.SimpleType previous [156 194] org.eclipse.jdt.core.dom.MarkerAnnotation name [164 168] org.eclipse.jdt.core.dom.SimpleName----------------------------------- SOURCE BEGIN -------------------------------------package jsr308.myex;import java.lang.annotation.ElementType;import java.lang.annotation.Target;public class NestedAnnotationTest extends @jsr308.myex.NestedAnnotationTest.Anno Object { // bad AST// @Anno Object { // OK @Target(ElementType.TYPE_USE) public @interface Anno { }}----------------------------------- SOURCE END -------------------------------------!STACK 0java.lang.IllegalStateException: Bad AST node structure	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1419)	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:273)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:206)..."
424154,12/16/2013 12:26,shankhba,"[1.8][compiler] PolyTypeBinding must not render the full lambda body in error messages PolyTypeBindings must not render the full lambda body in error messages.(In reply to Srikanth Sankaran from bug 423584 comment #4)> (2) PolyTypeBinding's are supposed to transient short lived objects that> should not ""escape"" the overload resolution context.I'm not sure if they can be totally avoided if the code contains compile errors.- Example where the lambda has too many arguments:import java.util.List;public class Snippet { void foo(List<Process> list) { list.removeIf((x y) -> { System.out.println(""very""); System.out.println(""long""); System.out.println(""lamda""); System.out.println(""body""); return true; } ""bee""); }}- Error message:The method removeIf(Predicate<? super Process>) in the type Collection<Process> is not applicable for the arguments ((<no type> x <no type> y) -> { System.out.println(""very""); System.out.println(""long""); System.out.println(""lamda""); System.out.println(""body""); return true;} String) => Either PolyTypeBindings never show up in error messages or their rendering must be reduced like e.g. for anonymous type ... list.removeIf(new Runnable() { @Override public void run() { System.out.println(""hi""); } });... the error message is:The method removeIf(Predicate<? super Process>) in the type Collection<Process> is not applicable for the arguments (new Runnable(){})If the argument count is correct then I don't see PolyTypeBindings any more but the error message can show illegal types. E.g. for ... list.removeIf((int x) -> ""yep"");... the error message is:The method removeIf(Predicate<? super Process>) in the type Collection<Process> is not applicable for the arguments (Predicate<int>)=> Predicate<int> gives me a good hint that there's something wrong with the 'int' although the type is not correct Java.I think the best solution would be a custom notation for the type of the lambda that just lists the lambda's parameters followed by '-> {}' e.g.:For the first example:The method removeIf(Predicate<? super Process>) in the type Collection<Process> is not applicable for the arguments ((? x ? y) -> {} String)For 'list.removeIf((int x) -> ""yep"");' :The method removeIf(Predicate<? super Process>) in the type Collection<Process> is not applicable for the arguments ((int x) -> {})"
424172,12/16/2013 14:30,noopur_gupta,[1.8][organize imports] Unused static import for Character::isUpperCase added This program:import java.util.function.IntPredicate;class UnusedStaticImport { boolean value = match(Character::isUpperCase 'A'); public static boolean match(IntPredicate matcher int codePoint) { return matcher.test(codePoint); }}Organize imports adds an unused line leading to a warning:import static java.lang.Character.isUpperCase;This happens when organize imports is executed from save actions clean up or organize imports menu item. Tested with Eclipse R4.3.1+BETA_JAVA8 binaries updated yesterday.
424198,12/16/2013 20:36,srikanth_sankaran,"[1.8][hover] IAE in Signature.createCharArrayTypeSignature when hovering on variable of wildcard type What steps will reproduce the problem?1. Open the test class from attachment in comment 1 and hover mouse over variables indicated with ""NOT OK"".2. Error log view shows new entries per each hover.3. The file contains several variations of code with and without compile errors that may be related.Tested with very recent BETA-JAVA8 binary plugins.-- Error Details --Date: Tue Dec 17 03:11:32 EET 2013Message: Unexpected runtime error while computing a text hoverSeverity: ErrorProduct: Eclipse SDK 4.3.1.v20130911-1000 (org.eclipse.sdk.ide)Plugin: org.eclipse.jface.textSession Data:eclipse.buildId=4.3.0.M20130911-1000java.version=1.8.0-eajava.vendor=Oracle CorporationBootLoader constants: OS=win32 ARCH=x86_64 WS=win32 NL=en_USCommand-line arguments: -os win32 -ws win32 -arch x86_64This is a continuation of log file C:\Users\Timo\workspace\.metadata\.bak_0.logCreated Time: 2013-12-17 01:20:52.886Exception Stack Trace:java.lang.IllegalArgumentException: capture#1-of ? extends java.lang.String	at org.eclipse.jdt.core.Signature.createCharArrayTypeSignature(Signature.java:1076)	at org.eclipse.jdt.core.Signature.createTypeSignature(Signature.java:1235)	at org.eclipse.jdt.internal.core.SelectionRequestor.acceptLocalVariable(SelectionRequestor.java:458)	at org.eclipse.jdt.internal.codeassist.SelectionEngine.selectFrom(SelectionEngine.java:1236)	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:951)	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:162)	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:377)	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:371)	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:118)	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:608)	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:604)	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)"
424223,12/17/2013 6:05,noopur_gupta,"[1.8][quick assist][clean up] convert anonymous to lambda results in code with conflicting variable names package test;interface FIOther {	FIOther run(int x);}public class TestOther {	FIOther fi = x -> {		return new FIOther() {			public FIOther run(int x) { // [1]				return null;			}		};	};}--------------------------------------------------------------Apply clean-up or quick assist to convert the anonymous class to lambda. It results in the following code with compilation error:package test;interface FIOther {	FIOther run(int x);}public class TestOther {	FIOther fi = x -> {		return x -> null; // Error	};}// Error : Lambda expression's parameter x cannot redeclare another local variable defined in an enclosing scope. See also bug 422766."
424226,12/17/2013 6:59,srikanth_sankaran,"[1.8] Cannot use static method from an interface in static method reference package test.one;class C1 {	public void fun1() {		FI fi = I::staticMethod; // [1]	}}@FunctionalInterfaceinterface FI {	void foo();	}interface I {	static FI staticMethod() {		return null;	}}-----------------------------------------------------The above example compiles with b118 but shows error at [1] with ECJ. The error is: The type I does not define staticMethod() that is applicable here"
424227,12/17/2013 7:07,manju656,"[1.8][organize imports] No import added for the type in method reference package test.one;@FunctionalInterfacepublic interface FI {	void foo();}class X {	static FI staticMethod() {		return null;	}}------------------------------------------------package test.two;import test.one.FI;class C1 {	public void fun1() {		FI fi = X::staticMethod; // [1] X cannot be resolved	}}------------------------------------------------Place the above files in 2 separate packages as given.Press Ctrl+Shift+O in class C1 to organize imports.The import for class X in not added."
424242,12/17/2013 10:07,anchakrk,"[1.8][compiler] Lambda expression signature mismatch message should include interface method signature Created attachment 238407FixExample: void foo(java.util.Set<Integer> set) { set.removeIf((a b) -> { }); }See bug 424154 about the first error message.The second error is:	set.removeIf((a b) -> { });	 ^^^^^^^^^Lambda expression's signature does not match the signature of the functional interface methodThis message doesn't contain enough information to quickly fix the problem. It would be good to include the actual functional interface method so that a user (or a quick fix) immediately knows what's expected. Improved message:Lambda expression's signature does not match the signature of the functional interface method test(Integer)"
424273,12/17/2013 14:46,markus.kell.r,[1.8][clean up] Convert lambda to anonymous has problems with wildcards Convert lambda to anonymous has problems with wildcards:package xy;import java.util.*;public class E { void foo(Integer[] ints){ Arrays.sort(ints (i1 i2) -> i1 - i2); Comparator<?> cw = (w1 w2) -> 0; Comparator cr = (r1 r2) -> 0; Comparator<? extends Number> ce = (n1 n2) -> -0; };}
424283,12/17/2013 18:05,jdt-ui-inbox,[1.8][hovering] Support showing Javadoc for JavaFX properties This might sound a bogus request but is something that really happens as part of OracleJDK where you have source code that look like this:/** * Called when there is an external request to close this {@code Window}. * The installed event handler can prevent window closing by consuming the * received event. */ private ObjectProperty<EventHandler<WindowEvent>> onCloseRequest; public final void setOnCloseRequest(EventHandler<WindowEvent> value) { onCloseRequestProperty().set(value); } public final EventHandler<WindowEvent> getOnCloseRequest() { return (onCloseRequest != null) ? onCloseRequest.get() : null; } public final ObjectProperty<EventHandler<WindowEvent>> onCloseRequestProperty() {and generated JavaDoc like this:http://docs.oracle.com/javafx/2/api/javafx/stage/Window.html#setOnCloseRequest%28javafx.event.EventHandler%29 which is implemented through https://bugs.openjdk.java.net/browse/JDK-7112427i'm not sure how to solve this. Possible solutions:* teach JDT the property API - if no docs found search for a variable with the same name* if no javadoc is found on the method - fall back to the HTML-JavaDoc
424290,12/17/2013 21:44,sasikanth.bharadwaj,[1.8] Evaluate alternate options for lambda shape analysis. When applying attachment 238421 from bug 424167 comment 5 OverloadResolutionTest8.test004() starts failing.I believe this is caused by the way how lambda shape analysis surrenders when enclosingScopesHaveErrors().The test contains three almost identical method calls with a lambda as their argument. In all three cases inference wants to detect an incompatibility because the function type returns an int but the lambdas are not value-compatible. However only the first occurrence succeeds to report this because subsequent occurrences will detect the first error in some outer scope and refuse to complete its analysis. IMHO these statements should be fully independent.I know that this area is close to impossible to get right and fully spec-compliant but the result in this test looks wrong.
424331,12/18/2013 8:04,noopur_gupta,"[quick assist] Quick assists available at location with error (In reply to Markus Keller from bug 424083 comment #1)> It's strange that you can get a quick assist there. This should be blocked in> QuickAssistProcessor#getAssists(..) line: 248--------------------------------------------------package com.test;interface F1 {	void foo(int x String s float f);}public class C1 {	F1 f1= () -> {}; // Ctrl+1 on '>'}--------------------------------------------------On pressing Ctrl+1 at '>' we get the following quick assists:- Convert to anonymous class creation- Extract to constantwhich should not appear according to the code at QuickAssistProcessor#getAssists(..) line: 248 since the location has error.If the selection length is > 0 the quick assists are not available.They should also be blocked when the selection length = 0."
424400,12/19/2013 0:09,srikanth_sankaran,"[1.8] Interfaces in the same hierarchy are allowed in an intersection cast with different type argument At the moment I am not sure if this is a bug in ECJ but here's the test case:public class X<T> implements MyComparable<T>{ public static void main(String argv[]) { 	int result = ((Comparable<Integer> & MyComparable) new X()).compareTo(1); } public int compareTo(T o) {		return 0;	}}interface MyComparable<T> extends Comparable<T> {}We allow this code while Javac doesn't. I can't find anywhere in the spec about intersection of types in same hierarchy one with type argument and other without.We reject code like this:int result = ((Comparable<String> & MyComparable<Integer>) new X()).compareTo("""");"
424444,12/19/2013 7:55,srikanth_sankaran,"[1.8] VerifyError when constructor reference used with primitive array This program when run produces a VerifyError:interface Functional<T> { T foo(int size);}public class X { public static void main(String argv[]) { 	Functional<int[]> constr = int[]::new; } }Exception in thread ""main"" java.lang.VerifyError: Bad return typeException Details: Location: javasoft/sqe/tests/lang/lmbd044/lmbd04401m0/X.lambda$0(I)[I @4: areturn Reason: Type '[LI;' (current frame stack[0]) is not assignable to '[I' (from method signature) Current Frame: bci: @4 flags: { } locals: { integer } stack: { '[LI;' } Bytecode: 0000000: 1abd 001c b0"
424500,12/19/2013 16:59,shankhba,[1.8] All poly expressions should avoid reevaluation against the same target type. When debugging examples involving nested structures that require type inference we can see that inference and resolving for the same elements is triggered ridiculously many times.Consider a lambda as an argument to a method with many candidate overloads: for each method the lambda is asked isCompatible against the corresponding method parameter. Consider further a body inside that lambda that requires type inference.Each time isCompatible is invoked we create a copy of the lambda invoke resolveType which may invoke inner inference and all results we compute inside will immediately be discarded.Caching such results not only improves performance but should also make debugging easier :)
424509,12/20/2013 1:11,noopur_gupta,"[1.8][quick assist] 'Convert to anonymous class creation' creates incorrect method in anonymous class package packUp;interface FX {	default int defaultMethod(String x) {		return -1;	}	int foo(int x);}class TestX {	FX fxx = x -> {		return (new FX() {			@Override			public int foo(int x) {				return 0;			}		}).defaultMethod(""a"");	};}--------------------------------------------------------------Invoke Ctrl+1 at '>' and press Enter to select the quick assist 'Convert to anonymous class creation'.The resulting anonymous class overrides the default method as it is and we get compilation error."
424581,12/22/2013 8:04,noopur_gupta,"[1.8][inline] Method creating and returning a lambda that contains a return statement can't be inlined Using this class try to inline the method combine. It fails with error message ""return statement in method declaration interrupts execution flow"". Tested with BETA_JAVA8 binaries updated yesterday.import java.util.function.Function;import java.util.function.Supplier;import java.util.stream.Stream;class Streamer { public static <T R> Supplier<Stream<R>> map(Supplier<Stream<T>> supplierOfT Function<T R> mapperOfTToR) { Supplier<Stream<R>> changed = combine(supplierOfT mapperOfTToR); // Inline method combine here return changed; } private static <T R> Supplier<Stream<R>> combine(Supplier<Stream<T>> supplierOfT Function<T R> mapperOfTToR) { Supplier<Stream<R>> supplierOfR = () -> { return supplierOfT.get().map(mapperOfTToR); }; return supplierOfR; }}"
424589,12/22/2013 14:37,shankhba,"[1.8][compiler] NPE in TypeSystem.getUnannotatedType Using Eclipse Java Development Tools Patch for Java 8 Support (BETA)	1.0.0.v20131222-0103_BETA_JAVA8Steps to reproduce:1 Create empty default 1.8 Java project with wizard2 Copy/paste content of http://docs.oracle.com/javase/tutorial/java/javaOO/examples/MethodReferencesTest.java to the ""src"" folder3 The file can't be compiled due NPE's in TypeSystem.getUnannotatedType see log below.ErrorSun Dec 22 20:29:46 CET 2013Errors running builder 'Java Builder' on project 'Java8Examples'.java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.getUnannotatedType(TypeSystem.java:76)	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.getParameterizedType(TypeSystem.java:146)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createParameterizedType(LookupEnvironment.java:938)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.substituteInferenceVariable(ParameterizedTypeBinding.java:827)	at org.eclipse.jdt.internal.compiler.lookup.ConstraintFormula.applySubstitution(ConstraintFormula.java:70)	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:291)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:95)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:703)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:661)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1559)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2365)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:650)	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:244)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1209)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1319)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570)	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:770)	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137)	at java.lang.Thread.run(Thread.java:744)"
424614,12/23/2013 9:53,noopur_gupta,[1.8][mark occurrances] Selected throws list exception highlights method call inside lambda block When selecting the IOException in the getterMaker1 throws declaration the get() method inside the returned lambda block is highlighted as well.import java.io.IOException;public class ExtraInsideLambda { interface Getter<T> { T get() throws IOException; } /* Place caret in IOException in throws declaration below the method call inside lambda is * highlighted too. The other versions work as expected. */ public static Getter<Long> getterMaker1(Getter<Long> getter) throws IOException { Long value = getter.get(); return () -> value == null ? getter.get() : value; }}Other similar versions work as expected: /* As expected no throws declarations is needed. */ public static Getter<Long> getterMaker2(Getter<Long> getter) { return () -> getter.get(); } /* As expected both throws declarations highlight only one get-method when selected. */ public static Getter<Long> getterMaker3(Getter<Long> getter) throws IOException { Long value = getter.get(); return new Getter<Long>() { @Override public Long get() throws IOException { return value == null ? getter.get() : value; } }; }
424616,12/23/2013 10:09,markus.kell.r,"[1.8][quick fix] Wrong throws declaration produced for wildcard capture exception type Tested with BETA_JAVA8 binaries updated today.What steps will reproduce the problem?1. Add this class:public class AddThrows { interface Getter2<T E extends Exception> { T get() throws E; } public static Long main2(Getter2<Long ?> getter) { Long value = getter == null ? 0l : 1l; /* uncomment next line then press CTRL-1 and * select either ""add throws.."" or ""surround.."" quick fix. */ //value = getter.get(); return value; }}2. Uncomment the value = getter.get(); line.3. Hover mouse over the uncommented line and select ""Add throws declaration"" quick fix.4. The NPE is logged.Selecting ""Surround with try/catch"" also causes the same exception. Pressing CTRL-1 instead of hovering also causes the NPE this time logged as a warning from jface.text.-- Error Details --Date: Mon Dec 23 16:26:41 EET 2013Message: Unhandled event loop exceptionSeverity: ErrorProduct: Eclipse SDK 4.3.1.v20130911-1000 (org.eclipse.sdk.ide)Plugin: org.eclipse.uiSession Data:eclipse.buildId=4.3.0.M20130911-1000java.version=1.8.0-eajava.vendor=Oracle CorporationBootLoader constants: OS=win32 ARCH=x86_64 WS=win32 NL=en_USCommand-line arguments: -os win32 -ws win32 -arch x86_64Exception Stack Trace:java.lang.NullPointerException	at org.eclipse.jdt.internal.corext.dom.ASTNodeFactory.newType(ASTNodeFactory.java:142)	at org.eclipse.jdt.internal.ui.text.correction.proposals.ChangeMethodSignatureProposal.modifyExceptions(ChangeMethodSignatureProposal.java:384)	at org.eclipse.jdt.internal.ui.text.correction.proposals.ChangeMethodSignatureProposal.getRewrite(ChangeMethodSignatureProposal.java:138)	at org.eclipse.jdt.ui.text.java.correction.ASTRewriteCorrectionProposal.addEdits(ASTRewriteCorrectionProposal.java:113)	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createTextChange(CUCorrectionProposal.java:234)	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createChange(CUCorrectionProposal.java:244)	at org.eclipse.jdt.ui.text.java.correction.ChangeCorrectionProposal.getChange(ChangeCorrectionProposal.java:372)	at org.eclipse.jdt.ui.text.java.correction.ChangeCorrectionProposal.performChange(ChangeCorrectionProposal.java:136)	at org.eclipse.jdt.internal.ui.text.correction.proposals.LinkedCorrectionProposal.performChange(LinkedCorrectionProposal.java:150)	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.apply(CUCorrectionProposal.java:184)	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.apply(AbstractAnnotationHover.java:538)	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.access$2(AbstractAnnotationHover.java:515)	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl$5.widgetSelected(AbstractAnnotationHover.java:509)	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)	at org.eclipse.swt.widgets.Widget.sendSelectionEvent(Widget.java:1098)	at org.eclipse.swt.widgets.Link.wmNotifyChild(Link.java:1084)	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5617)	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1935)	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5169)	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4667)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4990)	at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method)	at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:2443)	at org.eclipse.swt.widgets.Link.callWindowProc(Link.java:172)	at org.eclipse.swt.widgets.Widget.wmLButtonUp(Widget.java:2075)	at org.eclipse.swt.widgets.Control.WM_LBUTTONUP(Control.java:4995)	at org.eclipse.swt.widgets.Link.WM_LBUTTONUP(Link.java:922)	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4648)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4977)	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)	at org.eclipse.equinox.launcher.Main.run(Main.java:1450)	at org.eclipse.equinox.launcher.Main.main(Main.java:1426)"
424628,12/24/2013 0:30,srikanth_sankaran,"[1.8][compiler] Multiple method references to inherited method throws LambdaConversionException I'm running:JDK 1.8.0 b120 64-bitEclipse 4.3.1Eclipse Java Development Tools Patch for Java 8 Support (BETA) 1.0.0.v20131223-0103_BETA_JAVA8public class MainTest { public static interface Consumer<T> { void accept(T t); } public static class Base { public void method () {} } public static class Foo extends Base {} public static class Bar extends Base {} public static void main (String[] args) { Consumer<Foo> foo = Foo::method; Consumer<Bar> bar = Bar::method; }}The above class compiles fine with Eclipse but when I go to run it I get the following error:Exception in thread ""main"" java.lang.BootstrapMethodError: call site initialization exception at java.lang.invoke.CallSite.makeSite(CallSite.java:328) at java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:296) at MainTest.main(MainTest.java:19)Caused by: java.lang.invoke.LambdaConversionException: Invalid receiver type class MainTest$Foo; not a subtype of implementation type class MainTest$Bar at java.lang.invoke.AbstractValidatingLambdaMetafactory.validateMetafactoryArgs(AbstractValidatingLambdaMetafactory.java:221) at java.lang.invoke.LambdaMetafactory.metafactory(LambdaMetafactory.java:303) at java.lang.invoke.CallSite.makeSite(CallSite.java:289) ... 2 moreTo get the class to run without an error via Eclipse I can either implement method() in one of the subclasses or change both method references in main to Base::method. However neither of these changes is needed to compile and run using JDK8."
424718,12/28/2013 14:27,shankhba,"[1.8][compiler] API backward compatibility AST.TypeReference There where some API changes for JDK 8 e.g. additional intermal parameters for the language changes.As an example for type annotations in org.eclipse.jdt.internal.compiler.ast.TypeReferencechanged the signature of the method: public static final TypeReference baseTypeReference(int baseType int dim)to public static final TypeReference baseTypeReference(int baseType int dim Annotation [][] dimAnnotations)This breaks for instance the popular compiler extension lombok: http://code.google.com/p/projectlombok/issues/detail?id=597 I suggest to add compatibility functions for this like e.g.:public static final TypeReference baseTypeReference(int baseType int dim) {	// compatibility function	return baseTypeReference(baseType dim null);}This here is just an example. These kind of compatibility functions are very simple and help to prevent the breaking of potentially many external plugins and rise the acceptance for the new eclipse version. I know this is an internal package but you should be well aware that many external plugins around compilers and and languages (quite a popular topic nowadays) directly use your nice compiler APIs especially the AST.I kindly request to add at least this function because lombok is very important and works fine with this additional method ;)"
424745,12/30/2013 7:07,noopur_gupta,"[1.8][inline] Error after inlining constant with static method reference as initializer @FunctionalInterfaceinterface FI {	int foo(int x);}class Test {	public static final FI f= Test::m;		static int m(int x) {		return x++;	}}enum E1 {	E_C1(Test.f); // [1] - Inline 'f' here	E1(FI fi) {	}}-------------------------------------------------------Inline 'f' in the enum constant declaration we get the following code with compilation error:enum E1 {	E_C1(Test::Test.m); // [1] Error	E1(FI fi) {	}}"
424772,12/31/2013 3:33,noopur_gupta,[typing] Correct Indentation for '{' is wrong when declaration isn't on a single line Created attachment 238617Zipped demo projectStarting with Luna M4 I get a very annoying effect in some (not all) Java files. The indentation of some (not all) braces alternates between two different positions whenever I save those files. One position is correct and the other one not. The incorrect one can be fixed with Shift+Ctrl+F but that makes the editor dirty and the next save brings it back to the incorrect brace positions. The alternating behaviour can also be reproduced by adding a space after any line in the file and saving it.I attach a zipped project with a single Java file in it which seems to reproduce it in a fresh workspace. The file is full of compile errors because I stripped down the project but that doesn't impact the problem I describe above.Maybe bug 251824 has caused this regression?
424852,1/3/2014 11:59,markus.kell.r,[create on paste] Respect line delimiter preference when creating new CU Respect the line delimiter preference when creating a new CU by pasting to the Package Explorer.Currently we use the line delimiter from the clipboard which may not be the same as the project preference.
424914,1/6/2014 4:32,srikanth_sankaran,"[1.8][compiler] No error shown for method reference with super enclosed in an interface package com.p1;interface A {	String foo();	default void fun1() {		System.out.println((A) super::toString);	}}----------------------------------------------The above example compiles with ECJ but shows error with b120.(JSR 335 15.28 : If a method reference has the form super :: NonWildTypeArgumentsopt Identifier let T be the type declaration immediately enclosing the method reference. It is a compile-time error if T is the class Object or T is an interface.)"
424920,1/6/2014 5:34,markus.kell.r,[1.8] Replace References to PackageQualifiedType by NameQualifiedType and associated changes as per bug 418979
424977,1/6/2014 23:24,manpalat,"[1.8][compiler] ArrayIndexIndexOutOfBoundException in annotated wrong<> code package test;import java.lang.annotation.*;public class X { test.@A Outer<>.@A Inner<> i; }class Outer<T> {	class Inner<S> {}}@Target (ElementType.TYPE_USE)@interface A{} compilation of the above produces java.lang.ArrayIndexOutOfBoundsException: -2	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:262)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createAnnotatedType(LookupEnvironment.java:946)	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:944)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveAnnotations(TypeReference.java:584)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference.internalResolveType(ParameterizedQualifiedTypeReference.java:176)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedQualifiedTypeReference.resolveType(ParameterizedQualifiedTypeReference.java:427)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypeFor(SourceTypeBinding.java:1695)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.fields(SourceTypeBinding.java:869)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:839)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:424)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1200)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:449)	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:376)	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:330)	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:278)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)	at org.eclipse.jface.action.Action.runWithEvent(Action.java:499)	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:119)	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56)	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:243)	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:224)	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:167)	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:285)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:504)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:555)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:376)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:322)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:84)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1056)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1104)	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1525)	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4723)	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:344)	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4611)	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4977)	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)	at org.eclipse.equinox.launcher.Main.run(Main.java:1450)	at org.eclipse.equinox.launcher.Main.main(Main.java:1426)"
425000,1/7/2014 6:57,srikanth_sankaran,"[1.8] pass information about unchecked conversion from inference into 15.12.2.6 ""Method Invocation Type"" Starting with spec version 0.8.0 we'll record the fact when a type compatibility constraint involves unchecked conversion. The inference side of this will be released soon via Bug 424286.At that point InferenceContext18 will provide: 	public boolean usesUncheckedConversion()This information is to be used in determining the method invocation type (Part F 15.12.2.6)."
425006,1/7/2014 7:59,noopur_gupta,"[1.8][quick assist] 'Convert to anonymous class creation' creates wildcard return type package one.test;interface I<M> {	M run(M x);}class Test {	I<?> li2 = s -> null;}----------------------------------------Convert lambda to anonymous class using the quick assist. We get the following code with compilation error:I<?> li2 = new I<Object>(){@Override public ? run(Object s){return null;}};See also: bug 424273."
425040,1/7/2014 12:09,manpalat,"[1.8][formatter] Add option: ""Insert new line after type annotation"" The formatter should have an option ""Insert new line after type annotation"" which should be disabled by default.E.g. for the following source the formatter should only insert a new line after ""@Deprecated"" but not after any occurrence of @Annot (even if all other ""Insert new line after annotations on ..."" options are enabled):package xy;import java.lang.annotation.*;import java.util.List;public class Try extends@Annot Object { @Deprecated public @Annot int b; public@Annot()int foo(@Annot List<@Annot()Object> a) { return 0; }}@Documented@Target(ElementType.TYPE_USE)@interface Annot {}Bug 401848 / bug 403816 have already discussed the problem that type annotations cannot be distinguished from declaration annotations in all cases e.g.: @Deprecated @Annot boolean hardToDecide() { return true; }I don't think the formatter should resolve types so the next best solution is to rely on a heuristic: In ambiguous cases consider annotations as type annotations iff they appear after the last keyword in a modifier list.This heuristic fails for the hardToDecide() example but that's acceptable (and still way better than the current state where the formatter produces bad results in many more cases)."
425084,1/8/2014 8:54,srikanth_sankaran,[1.8] eclipse freeze while attempting auto-completion with a 'try' pattern in a lambda
425109,1/8/2014 11:35,markus.kell.r,[quick fix] Failures in TypeMismatchQuickFixTests due to new IProblem.ReturnTypeMismatch (In reply to Srikanth Sankaran from bug 422489 comment #3)> Note to UI team: Compiler will not emit IProblem.TypeMismatch any more> for issues with return statement types. Instead expect> IProblem.ReturnTypeMismatch.> Not sure if this will break your test suites and/or quick fix support.This created 4 valid test failures in TypeMismatchQuickFixTests.
425203,1/9/2014 10:58,sasikanth.bharadwaj,"[compiler][1.7][inference] ECJ rejects valid code using bounded wildcards This issue seems similar to https://bugs.eclipse.org/bugs/show_bug.cgi?id=415981 but I'm not sure if it's identical.javac compiles this valid Java code. public interface MyFunction<Input Output> { Output apply(Input input); } public <Input Output> List<Output> wrap(MyFunction<? super Input ? extends Output> function Input input) { return Arrays.asList(function.apply(input)); }ecj rejects it with ""Type mismatch: cannot convert from List<capture#2-of ? extends Output> to List<Output>"""
425216,1/9/2014 13:19,srikanth_sankaran,"[1.8][dom ast] Binding for 'this' should have type annotations when receiver is annotated The binding for 'this' should have type annotations when the corresponding receiver or constructor is annotated.Example that also includes annotated parameters for comparison:package pack2;import java.lang.annotation.*;@Target(ElementType.TYPE_USE)@interface A { int value() default 0;}public class Outer { void foo(@A Outer this @A Outer arg) { this.hashCode();// ^ binding is ""Outer""; expected ""@A Outer"" arg.hashCode();// ^ type binding is ""@A Outer"" (good) } class Inner { public @A(1) Inner( @A Outer Outer.this @A Outer arg2) {// ^ type binding is null; expected ""@A Outer"" Outer r1 = Outer.this;// ^ ^ bindings are ""Outer""; expected ""@A Outer"" Outer r2 = arg2;// ^ binding is ""@A Outer"" (good) Inner i = this;// ^ binding is ""Inner""; expected ""@A(1) Inner"" } }}The receiver qualifier in ""Outer.this"" has no binding. It should have the same binding as a reference to ""Outer.this"" in the constructor body."
425277,1/10/2014 6:39,jdt-ui-inbox,[1.8][actions] AddImportsOperation has bugs with nested/parameterized/annotated types AddImportsOperation has various bugs with nested and parameterized typesExamples:public class Try { java.lang.Thread.State s; java.util.Map m; java.util.Map<String Integer> m2; java.util.Map.Entry e; java.util.Map.Entry<String Object> e2; pack.Outer.Middle.Inner i; pack.Outer.Middle<String>.Inner<Integer> i2;}
425410,1/10/2014 10:08,noopur_gupta,"[1.8][quick assist] Conversion from anonymous class having generic method to lambda expression +++ This bug was initially created as a clone of Bug #424296 +++interface FIOther<T> {	<M> FIOther<T> run (M x);}public class TestOther { FIOther<String> fi1 = new FIOther<String>() {public <M> FIOther<String> run(M x) {return null;}}; }Convert the error free code to lambda expression with quick fix. See the syntax error message :Illegal lambda expression: Method run of type FIOther<String> is generic 	TestOther.java	/_pasted_code_/src	line 6	Java Problem"
425413,1/10/2014 10:09,noopur_gupta,"[1.8][quick assist] Conversion from anonymous class to lambda loses annotations +++ This bug was initially created as a clone of Bug #424296 +++Annotations are lost in this example: // --interface I {	void goo(String ... strings);}public class X {	public static void main(String[] args) {		I i = new I() {			@Override			public void goo(@T String ... k) {										}					};			}}@interface T {	}"
425420,1/10/2014 11:28,shankhba,"NPE exception on standard Java build What steps will reproduce the problem?1. Plain build on eclipse of a project that does build correctly on Junos SR2 and former versions2. 3. -- Error Details --Date: Fri Jan 10 18:22:21 IST 2014Message: Errors running builder 'Java Builder' on project 'Topology'.Severity: ErrorProduct: Eclipse 2.0.1.20130919-0803 (org.eclipse.epp.package.jee.product)Plugin: org.eclipse.jdt.coreSession Data:eclipse.buildId=4.3.0.M20130911-1000java.version=1.7.0_45java.vendor=Oracle CorporationBootLoader constants: OS=win32 ARCH=x86_64 WS=win32 NL=en_USFramework arguments: -product org.eclipse.epp.package.jee.productCommand-line arguments: -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.productException Stack Trace:java.lang.NullPointerException	at java.lang.String.<init>(Unknown Source)	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.conditionalArgumentsIncompatibleTypes(ProblemReporter.java:1445)	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.resolveType(ConditionalExpression.java:600)	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.resolveType(BinaryExpression.java:1802)	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.resolveType(BinaryExpression.java:1799)	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.resolveType(BinaryExpression.java:1799)	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.resolveType(BinaryExpression.java:1799)	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.resolveType(BinaryExpression.java:1799)	at org.eclipse.jdt.internal.compiler.ast.BinaryExpression.resolveType(BinaryExpression.java:1799)	at org.eclipse.jdt.internal.compiler.ast.CombinedBinaryExpression.resolveType(CombinedBinaryExpression.java:344)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:605)	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:970)	at org.eclipse.jdt.internal.compiler.ast.Block.resolveUsing(Block.java:127)	at org.eclipse.jdt.internal.compiler.ast.TryStatement.resolve(TryStatement.java:1100)	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:114)	at org.eclipse.jdt.internal.compiler.ast.WhileStatement.resolve(WhileStatement.java:263)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:510)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:265)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:469)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1185)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1295)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:561)	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:770)	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137)	at java.lang.Thread.run(Unknown Source)"
425462,1/10/2014 20:24,aclement,[1.8] Annotation processor does not find parameter annotations Created attachment 238880contains two projects to show this issueI am using JDT/Eclipse Java 8 Support (version is 1.0.0.v20140110-0104_BETA_JAVA8).I attach two projects.- apt-lib (contains an annotation processor to log this issue)- apt-client (contains processed source code)The log is following:-----eclipse.buildId=4.3.0.M20130911-1000java.version=1.8.0-eajava.vendor=Oracle CorporationBootLoader constants: OS=macosx ARCH=x86_64 WS=cocoa NL=ja_JPFramework arguments: -product org.eclipse.epp.package.standard.product -keyring /Users/nakamura/.eclipse_keyring -showlocationCommand-line arguments: -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.standard.product -keyring /Users/nakamura/.eclipse_keyring -showlocationInfoSat Jan 11 09:55:58 JST 2014class=client.MyInterface method=run param=value annotationSize=0 myParam=null-----This log shows that the type annotation 'lib.MyType' is processed but the parameter annotation 'lib.MyParam' is not found.
425512,1/13/2014 1:22,srikanth_sankaran,[1.8][compiler] Arrays should NOT be allowed in intersection casts We should compile (int [] & Serializable) new int [0];javac doesn't but that is a bug.
425599,1/13/2014 14:24,srikanth_sankaran,"[1.8][compiler] ISE when trying to compile qualified and annotated class instance creation !ENTRY org.eclipse.jdt.core 4 4 2014-01-13 20:21:04.124!MESSAGE Exception occurred during problem detection:----------------------------------- SOURCE BEGIN -------------------------------------package snippet;import java.lang.annotation.ElementType;import java.lang.annotation.Target;public class Snippet { Object ax = new @A Outer().new Middle<String>();}@Target(ElementType.TYPE_USE) @interface A {}class Outer { class Middle<E> {}}----------------------------------- SOURCE END -------------------------------------!STACK 0java.lang.IllegalStateException	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getParameterizedType(AnnotatableTypeSystem.java:105)	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getParameterizedType(AnnotatableTypeSystem.java:135)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createParameterizedType(LookupEnvironment.java:938)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveLeafType(ParameterizedSingleTypeReference.java:287)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:147)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveTypeEnclosing(ParameterizedSingleTypeReference.java:367)	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveTypeForQualifiedAllocationExpression(QualifiedAllocationExpression.java:331)	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveType(QualifiedAllocationExpression.java:283)	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.resolve(FieldDeclaration.java:264)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1147)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:920)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:965)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:204)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:270)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:190)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:89)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:728)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:788)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
425601,1/13/2014 14:48,manpalat,[dom ast] References to parameterized nested types don't have IBinding#isDeprecated() set master and BETA_JAVA8Some references to parameterized nested types have type bindings whose IBinding#isDeprecated() wrongly returns false.The uncommented references are OK:@Deprecatedpublic class Outer<O> { @Deprecated public class Middle<X> { @Deprecated public class Inner<E> { } } Outer<String> o; Middle<String> m; // Middle should be deprecated Outer<String>.Middle<String> m2; // Middle should be deprecated Outer.Middle m3; Middle<String>.Inner<Object> i; // Inner should be deprecated}class Ref { Outer<String> o; Outer<String>.Middle<String> m; Outer<String>.Middle<String>.Inner<Object> i;}
425621,1/13/2014 21:34,srikanth_sankaran,[1.8][compiler] Missing error for raw type in constructor reference with explicit type arguments From JSR 335 spec 0.9.1 15.28It is a compile-time error If a method reference has the form ClassType :: NonWildTypeArguments new where a constructor typeargument list is provided but the ClassType is a raw type.So the following program must be rejected but we don't:// --class Y<T> { Y() {}} interface I { Y<Y> foo();}public class X { I i = Y::<X>new;}
425632,1/14/2014 3:38,srikanth_sankaran,"[1.8][compiler] Compiler gets the scope of enhanced for loop's expression wrong. See https://bugs.openjdk.java.net/browse/JDK-7139681javac8 has started compiling this code:// --public class X {	int[] i = {1 2 3};	void foo() {		for (int i : i) {			System.out.println(i);		}	}}while eclipse continues to reject it."
425687,1/14/2014 12:36,jarthana,Invalid annotation inference when 2 classes have the same (simple) name Created attachment 238978Project reproducing the bugIn the Wildfly project the CacheGroupService class is annotated with @Listener from the Infinispan project (org.infinispan.notifications.Listener)[1]. CacheGroupService implements org.wildfly.clustering.group.Group which itself defines an inner interface named Listener[2]When JDT APT is enabled there's a compilation error appearing on CacheGroupService[3] : Type mismatch: cannot convert from Group.Listener to AnnotationWithout APT enabled there's no error.I managed to reproduce the issue with a simpler setup (attached). Unzip and import as an eclipse project. You'll see an error on test.Foo annotated with @Something from the annotation package. Foo extends SomeClassDeclaringSomethingToo. Disabling APT makes the error go away. [1] https://github.com/wildfly/wildfly/blob/5670d12b5576d2695f9af7114e548805c87d302e/clustering/server/src/main/java/org/wildfly/clustering/server/group/CacheGroupService.java#L32[2] https://github.com/wildfly/wildfly/blob/5670d12b5576d2695f9af7114e548805c87d302e/clustering/api/src/main/java/org/wildfly/clustering/group/Group.java#L32[3] http://i.imgur.com/hRor2Gd.png
425712,1/14/2014 22:39,srikanth_sankaran,"[1.8][compiler] Valid program rejected by the compiler. BETA_JAVA8:// --public class X { { bar( () -> (char) 0); // [1] } void bar(FB fb) { } public static void main(String[] args) {		System.out.println(""OK"");	}}interface FB {	byte foo();}elicits: The method bar(FB) in the type X is not applicable for the arguments (() -> (char) 0)This program is valid - bug is LE.isCompatibleWith - when checking returnexpressions we should not use parameterCompatibilityLevel we should seeif the expression is assignmenet compatible instead as would be done forreturn expressions.Expression [] returnExpressions = this.resultExpressions;		for (int i = 0 length = returnExpressions.length; i < length; i++) {			if (returnExpressions[i] instanceof FunctionalExpression) { // don't want to use the resolvedType - polluted from some other overload resolution candidate				if (!returnExpressions[i].isCompatibleWith(sam.returnType this.enclosingScope))					return false;			} else {				if (this.enclosingScope.parameterCompatibilityLevel(returnExpressions[i].resolvedType sam.returnType) == Scope.NOT_COMPATIBLE) {					if (sam.returnType.id != TypeIds.T_void || this.body instanceof Block)						return false;				}			}		}This is at the root of the problem reported in https://bugs.eclipse.org/bugs/show_bug.cgi?id=423803#c6"
425718,1/15/2014 2:30,srikanth_sankaran,[1.8] default method changes access privilege of protected overridden method from Object The following code is allowed by ECJ:interface I { default Object clone() { return null; }}public class Main { public void foo() { I x = new I(){}; System.out.println(x.clone()); }}While Javac rejects it as clone is a protected method and should not be allowed to be accessed.
425719,1/15/2014 2:41,srikanth_sankaran,"[1.8][compiler] Bogus ambiguous call error from compiler. BETA_JAVA8: This is probably a recent regression.// --interface I { default void foo(Object obj) {	 System.out.println(""interface method""); }}class Base { public void foo(Object obj) { System.out.println(""class method""); }}public class X extends Base implements I {	 public static void main(String argv[]) {	 	new X().foo(null);	 }}Patch will follow shortly."
425741,1/15/2014 7:07,jarthana,[1.8][dom ast] ITypeBinding#getTypeDeclaration() doesn't strip off type annotations As far as I understood bug 409586 ITypeBinding#getTypeDeclaration() should always strip off type annotations from an ITypeBinding.This currently works fine for a parameterized type binding but it doesn't work for other kinds (primitive class interface raw array ...).package bug;import java.lang.annotation.ElementType;import java.lang.annotation.Target;import java.util.List;@Target(ElementType.TYPE_USE) @interface A { int value() default 0;}public class GetTypeDeclarationProblems { @A int primitive; @A Object clazz; java.lang.@A Object qualified; @A List raw; @A List<@A(1) String> parameterized; @A List<@A(1) ?> wild; @A String @A(1) [] array; @A List<@A(1) String> @A(2) [] array2;}
425743,1/15/2014 7:33,manpalat,"[1.8][api] CompilationUnit#findDeclaringNode(IBinding binding) returns null for type inferred lambda parameter Place the following code after the call to unit.reconcile(..) in org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy#reconcile(ICompilationUnit boolean):AbstractTypeDeclaration test= (AbstractTypeDeclaration) ast.types().get(0);FieldDeclaration fi= (FieldDeclaration) test.bodyDeclarations().get(0);VariableDeclarationFragment vdf= (VariableDeclarationFragment) fi.fragments().get(0);LambdaExpression lambda= (LambdaExpression) vdf.getInitializer();VariableDeclaration param= (VariableDeclaration) lambda.parameters().get(0);if (param instanceof SingleVariableDeclaration) {	IBinding binding= ((SingleVariableDeclaration) param).getName().resolveBinding();	System.out.println(ast.findDeclaringNode(binding));} else {	IBinding binding= ((VariableDeclarationFragment) param).getName().resolveBinding();	System.out.println(ast.findDeclaringNode(binding));}------------------------------------------------------Edit the following example code to invoke the reconciler and check the Console view for the result:public class C1 {	FI fi= (x2) -> x2;}@FunctionalInterfaceinterface FI {	int foo(int n);}------------------------------------------------------#findDeclaringNode returns ""null"" when there is no type specified at the lambda parameter.If we modify the lambda expression to include the parameter type #findDeclaringNode returns the correct AST node: FI fi= (int x2) -> x2;"
425897,1/16/2014 9:20,srikanth_sankaran,[1.8] unexpected capture incompatibility at method reference The test GTT_1_8.testBug425798() currently witnesses a wrong outcome:The example should be accepted whereas we report:The type of annotationType() from the type Annotation is Class<? extends Annotation> this is incompatible with the descriptor's return type: Class<capture#3-of ? extends Annotation>Not marking as inference-related because the error is reported in the regular part of RE.resolveType().
425950,1/17/2014 2:08,noopur_gupta,"[1.8][quick assist][refactoring] ""Convert local variable to field"" on local variables of interface methods interface I {	static void staticMethod() {		int i;	}	default void defaultMethod() {		int j= 0;		j++;	}}Converting local variables in interface methods (example: 'i' and 'j' in the above code) to fields should not be allowed because a field in an interface has to be initialized with some value and is 'final'. Hence the quick assist and refactoring should be disabled in PromoteTempToFieldRefactoring.(See also bug 410173)"
426025,1/17/2014 15:31,tmccrary,[Graphics] Switch JDT UI to use png file instead of .gif
426058,1/19/2014 9:34,jarthana,"IJavaElement.getAttachedJavadoc(IProgressMonitor) uses wrong encoding Created attachment 239121ScreenshotHi I'm chinese and in eclipse 4.3.1 jee edition may there are one erro that is in the ""javadoc display dialog"" I would like to display the javadoc for chinese version but it display the chinese garbled? can any one tell me whay? bacause in v4.2.x it's looks okay!"
426074,1/20/2014 3:11,srikanth_sankaran,"[1.8][compiler] 18.5.2 Functional interface parameterization inference problem with intersection types. // BETA_JAVA8interface Functional<T> { void foo(T t);}interface I { }public class X {	public static void main(String[] args) { 	Functional<? extends X> f = (Functional<? extends X> & I) (X c) -> { 		System.out.println(""main""); 	}; 	f.foo(null); }}The program above is rejected by ECJ erroneously."
426086,1/20/2014 5:02,srikanth_sankaran,"[1.8] LambdaConversionException when method reference to an inherited method is invoked from sub class This code causes an LCE when run:interface Functional { Long square(Integer a);}public class X { static class Base { 	 private Long square(Integer a) { return Long.valueOf(a*a); } } static class SubClass extends Base { public Long callSquare(Integer i) { Functional fi = SubClass.super::square; return fi.square(i); } } public static void main(String argv[]) throws Exception { 	System.out.println(new SubClass().callSquare(-1)); }}Looks like the method reference in the lambda is associated with SubClass even though it is declared to be from 'super'."
426112,1/20/2014 6:59,noopur_gupta,"[move method] NPE on moving instance method having non-public array type argument package p;class X {	public void foo(B [] arg A a) { }}class A {	}class B { 	}------------------------------------Move method #foo to A. We get the following exception:java.lang.reflect.InvocationTargetException	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:422)	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:331)...Caused by: java.lang.NullPointerException	at org.eclipse.jdt.internal.corext.dom.Bindings.equals(Bindings.java:91)	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInstanceMethodProcessor$VisibilityAdjustingArgumentFactory.adjustTypeVisibility(MoveInstanceMethodProcessor.java:1011)	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInstanceMethodProcessor$1.getArgumentNode(MoveInstanceMethodProcessor.java:2062)..."
426206,1/21/2014 2:26,srikanth_sankaran,[1.8][compiler] Compiler tolerates illegal code. // --import java.util.Comparator;public class X { public static void main(String argv[]) { Comparator<? extends String> c = true ? (Integer i Integer j) -> { return 0; } : (Long i Long j) -> { return 1; }; }}The fix for https://bugs.eclipse.org/bugs/show_bug.cgi?id=423685 hasexposed this issue.
426214,1/21/2014 4:45,Olivier_Thomann,"[1.8] Eclipse compiler does not allow certain unicode characters as part of identiifers Eclipse compiler reports errors on the following program:public class X {		int a\u058f = 0; // Rejected 		String a41\u08fc; // Rejected		float a\u057f = 1; // Allowed}My guess is that these are new unicode characters introduced after unicode version 6.0.0 which is the latest we seem to support. Note there's been three versions since then namely 6.1.0 6.2.0 and 6.3.0.At the moment I have no idea what it takes to start supporting new ones. Will investigate."
426277,1/21/2014 11:35,shankhba,[1.8] disassembler output should print actual strings for bootstrap methods The disassembler output should print actual strings for bootstrap methods not just constant pool index #s.E.g. for the example in bug 422016 comment 10 I get:Bootstrap methods: 0 : # 67 arguments: {#68#71#72}Expected:Bootstrap methods: 0 : #67 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; arguments: #68 ()V #71 invokestatic jsr335/Main.lambda$0:()V #72 ()V
426291,1/21/2014 14:16,markus.kell.r,"[key binding] ""Expand Selection To > ..."" conflicts with Mission Control about Ctrl+Shift+Up/Down Created attachment 239202/Users/eclipse/Documents/eclipse.jdt.ui.patchIn recent Mac OS X versions (at least since 10.8) Mission Control by default uses shortcuts Ctrl+Up and Ctrl+Down. Their Shift-ed variants do the same but slow down the animations. Yes they sacrificed shortcuts for a show-effect nobody needs.""Expand Selection To > Enclosing Element"" and ""Restore Last Selection"" conflict with Mission Control. We have to reassign at least those two commands but to keep the four directions in sync I've also reassigned the ""Next/Previous Element"" commands."
426315,1/22/2014 0:05,srikanth_sankaran,"[1.8][compiler] UnsupportedOperationException with conditional expression // --public class X {	static int foo(Object x) {		return 0;	}	static int foo(int e) { 		return 1; 	} 	public static void main(String args[]) { 		Object x = new Object();		System.out.println(foo(true ? x : new int[0]) != 0);	}}triggers: java.lang.UnsupportedOperationException: Unexpected control flow should not have reached Expression.isCompatibleWith	at org.eclipse.jdt.internal.compiler.ast.Expression.isCompatibleWith(Expression.java:1158)	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.isCompatibleWith(ConditionalExpression.java:707)	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4625)	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4594)	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel18(Scope.java:829)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:738)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:676)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1659)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2479)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:856)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:689)	at org.eclipse.jdt.internal.compiler.ast.EqualExpression.resolveType(EqualExpression.java:831)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:641)	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1016)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132)	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:449)	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:376)	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:330)	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:278)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:276)	at org.eclipse.jface.action.Action.runWithEvent(Action.java:499)	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:119)	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)	at sun.reflect.GeneratedMethodAccessor24.invoke(Unknown Source)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:55)	at java.lang.reflect.Method.invoke(Method.java:613)	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56)	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:243)	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:224)	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:167)	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:285)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:504)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:555)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:376)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:322)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:84)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1056)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1104)	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1525)	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4723)	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:344)	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4611)	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4977)	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:88)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:55)	at java.lang.reflect.Method.invoke(Method.java:613)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)	at org.eclipse.equinox.launcher.Main.run(Main.java:1450)	at org.eclipse.equinox.launcher.Main.main(Main.java:1426)"
426318,1/22/2014 2:18,srikanth_sankaran,[1.8][compiler] Bogus name clash error in the presence of default methods and varargs // --abstract class Y { public abstract void foo(Object[] x); public abstract void goo(Object[] x);}interface I { default public <T> void foo(T... x) {}; public abstract void goo(Object ... x);}public abstract class X extends Y implements I { }triggers an incorrect name clash error.
426392,1/22/2014 14:13,markus.kell.r,"NPE in OpenFromClipboardAction#getJavaElementMatches(..) Have the following in the clipboard (without the ---- delimiters) and then use Navigate > Open from Clipboard:------------------------------------------------------------java.lang.Exception: Test did not run: testNullParams(org.eclipse.osgi.tests.util.BidiTextProcessorTestCase)at org.eclipse.core.tests.session.SessionTestRunner.run(SessionTestRunner.java:313)at org.eclipse.core.tests.session.TestDescriptor.run(TestDescriptor.java:87)at org.eclipse.core.tests.session.SessionTestSuite.runSessionTest(SessionTestSuite.java:156)at org.eclipse.core.tests.session.SessionTestSuite.runTest(SessionTestSuite.java:174)at org.eclipse.core.tests.session.ConfigurationSessionTestSuite.run(ConfigurationSessionTestSuite.java:217)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657)------------------------------------------------------------=> Command aborts with NPE:java.lang.NumberFormatException: For input string: ""org.eclipse.osgi.tests.util.BidiTextProcessorTestCase"" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Integer.parseInt(Integer.java:492) at java.lang.Integer.valueOf(Integer.java:582) at org.eclipse.jdt.internal.debug.ui.actions.OpenFromClipboardAction.getJavaElementMatches(OpenFromClipboardAction.java:323) at org.eclipse.jdt.internal.debug.ui.actions.OpenFromClipboardAction.run(OpenFromClipboardAction.java:200)...There are many problems at work here. After bug 327443 the whole input string is put on one line and all whitespace is removed. Then OpenFromClipboardAction#getMatchingPattern(String) calls s.matches(STACK_TRACE_LINE_PATTERN) although that pattern doesn't make sense for multi-line inputs since it starts with "".*"". Finally #getJavaElementMatches(..) uses s.indexOf('(') instead of lastIndexOf which causes the NPE.A quick fix for the NPE is to replace said indexOf with lastIndexOf. That still resolves a wrong type but that doesn't matter since the multi-line input text ends up in the Console view anyway.However the parsing still does way too much (e.g. all references to WS are pointless after whitespace is removed and all patterns containing "".*"" match too much for non-trivial input)."
426411,1/22/2014 21:58,srikanth_sankaran,"[1.8][compiler] NoSuchMethodError at runtime due to emission order of casts in intersection casts From https://bugs.eclipse.org/bugs/show_bug.cgi?id=424211#c5// --public class X {	public static void main(String argv[]) throws Exception {		((Serializable & AutoCloseable) (() -> {})).close();	}}This program fails at runtime."
426434,1/23/2014 4:16,jarthana,"EclipseCompiler#run() crashes when null out/err passed by client EclipseCompiler#run() implements javax.tools.Tool#run() which has following javadoc: * @param in ""standard"" input; use System.in if null * @param out ""standard"" output; use System.out if null * @param err ""standard"" error; use System.err if nullEclipseCompiler doesn't take care of this instead just passes along the parameters err and out. This needs to be fixed."
426436,1/23/2014 4:28,manpalat,[1.8][compiler] Incorrect source range for IProblem.IllegalArrayTypeInIntersectionCast Good: org.eclipse.jdt.core.tests.compiler.regression.NegativeLambdaExpressionsTest.test425512()Bad:org.eclipse.jdt.core.tests.compiler.regression.NegativeLambdaExpressionsTest.test425512cd()No idea why.
426447,1/23/2014 7:09,jarthana,JDT's implementation of JavaFilerManager#inferBinaryName() throws IAE Created attachment 239259TestcaseAs the attached test case demonstrates EclipseFileManager.inferBinaryName(Location JavaFileObject) throws an IAE when name for a file of OTHER kind is requested. The Javadoc in JavaFileManager#inferBinaryName() doesn't say anything about this scenario although it doesn't talk anything about Kind.OTHER being not supported.
426459,1/23/2014 9:47,jarthana,[1.8][dom ast] ITypeBinding#createArrayType(int) should preserve existing type annotations ITypeBinding#createArrayType(int) should preserve existing type annotations. For primitive types it currently strips all type annotations. For other types it preserves annotations on the element types but not on dimensions.Example code to play in the ASTView:import java.lang.annotation.ElementType;import java.lang.annotation.Target;@Target(ElementType.TYPE_USE) @interface A { int value() default 0;}class Test { @A int @A(1)[] @A(2)[] is; @A String @A(1)[] @A(2)[] ss;}
426462,1/23/2014 10:20,manpalat,"[1.8][dom ast] TypeParameter#annotations() should be #modifiers() While reviewing the DOM APIs I found that PackageDeclaration#annotations() and TypeParameterModifier#annotations() are a bit odd:These are the only declaration nodes that have an #annotations() property.All other declaration nodes use #modifiers(). Elsewhere #annotations() is only used on type references (AnnotatableTypes / Dimension).The JLS8 grammar also uses the nonterminals ""PackageModifier"" and ""TypeParameterModifier"" which hints that future language versions may add other modifiers there (e.g. for accessibility).To future-proof our APIs we should rename these #annotations() properties and generalize their type to IExtendedModifier."
426480,1/23/2014 11:22,jarthana,EclipseFileManager#getJavaFileObjectsFromFiles allows directories This is the Javadoc from StandardJavaFileManager#getJavaFileObjectsFromFiles() /** * Gets file objects representing the given files. * * @param files a list of files * @return a list of file objects * @throws IllegalArgumentException if the list of files includes * a directory */But both the following JDT implementations allow directories and need to be fixed:org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManagerorg.eclipse.jdt.internal.compiler.tool.EclipseFileManagerA patch will follow.
426510,1/23/2014 15:08,manpalat,[1.8][dom ast] New API: ImportRewrite#addAnnotation(..) (In reply to Jayaprakash Arthanareeswaran from comment #21)> If you took this new code that create new annotations from the UI code it> may not be a bad idea to move that code to Core so both Core and UI could> use that.Yes we should not duplicate nontrivial code. We should remove the old org.eclipse.jdt.internal.corext.dom.ASTNodeFactory#newAnnotation(..) and turn ImportRewrite#newAnnotation(..) into an API like this:/** * Adds the necessary imports for the given annotation binding to the rewriter's record * and returns an {@link Annotation} that can be used in the code. * <p> * No imports are added for types that are already known. If an import for a type is recorded to be removed this record is discarded instead. * </p> * <p> * The content of the compilation unit itself is actually not modified * in any way by this method; rather the rewriter just records newly added imports. * </p> * @param binding the annotation to be added * @param ast the AST to create the returned annotation for * @param context an optional context that knows about types visible in the current scope or <code>null</code> * to use the default context (only using the available imports) * @return an annotation node. The returned annotation contains unqualified type names where * an import could be added or was already known. Type names are fully qualified if an import conflict prevented an import. * * @since 3.9 BETA_JAVA8 */public Annotation addAnnotation(IAnnotationBinding annotation AST ast ImportRewriteContext context)
426515,1/23/2014 16:25,jarthana,"[1.8][dom ast] Bindings from reconciler are sometimes missing type annotations Bindings from reconciler are sometimes missing type annotations.- launch a clean runtime workspace with a 1.8 JRE- copy all the code below to the clipboard and paste it into the Package Explorer in one batch- put the caret after ""bug.imports.Outer.getInner();"" and press Ctrl+1 Enter=> The created field type is ""@A(1) Outer<Random>.Inner<Date> inner"" which misses most of the type annotations.The problem is that the AST from the SharedASTProvider is missing these type annotations in the binding for the ...getInner() expression. This can also be seen in the ASTView if you switch to ""Use SharedASTProvider.getAST"" or ""Use ICompilationUnit.reconcile"".Workaround to get correct bindings: Switch to another Java editor and then switch back. In this case an ASTParser is used to feed the SharedASTProvider. If you modify the active editor then the bindings become wrong again.=============================package bug.imports;import java.lang.annotation.ElementType;import java.lang.annotation.Target;@Target(ElementType.TYPE_USE) public @interface A { int value() default 0;}package bug.imports;public class Outer<O> { public class Inner<I> { } public static @A(1) Outer<java.util.@A(2) Random>.@A(3) Inner<java.util.@A(4) Date> getInner() { return null; }}package bug.imports;public class Client {// class Random {}// class Date {}// class Outer {}// class Inner {}// class A {} void foo() { bug.imports.Outer.getInner(); }}======================================"
426520,1/23/2014 17:49,manpalat,"[1.8][formatter] inserts spaces into annotated qualified type package bug.formatter;import java.lang.annotation.*;@Target(ElementType.TYPE_USE)@interface T {}public class C {	java.util.concurrent.@T Callable c;	java.util.@T Set<java.lang.@T String> s;}The formatter inserts bad spaces after the package components of an annotated qualified type (but it seems to be afraid of touching a parameterized type):	java. util. concurrent.@T Callable c;	java.util.@T Set< java. lang.@T String> s;"
426537,1/24/2014 1:26,srikanth_sankaran,"[1.8][inference] Eclipse compiler thinks I<? super J> is compatible with I<J<?>> - raw type J involved This is the test code:public class X {	void foo(J[] list I<J<?>> i) {		sort(list i);	}		<T> T[] sort(T[] list I<? super T> i) {		return list;	}}interface I<T> {}interface J<T> {}The invocation sort(list i) should be reported but not."
426544,1/24/2014 3:18,srikanth_sankaran,"[1.8][compiler] Compiler over-eagerly detects collision of single static imports // --package p;public class X { static public int f;}// --package q;public class X { static public int f = 6;}// ---import static p.X.f;import static q.X.f;public class X { public static void main(String argv[]) { }}elicits: ""The import q.X.f collides with another import statement""JLS7 7.5.3 says nothing about collision of single static imports.JDK8 has started accepting this code and for compatibility's sakes we shouldtoo.Related javac bugs:https://bugs.openjdk.java.net/browse/JDK-4980495https://bugs.openjdk.java.net/browse/JDK-8019461The dates don't quite tally up but these have some discussion FWIW."
426565,1/24/2014 7:09,markus.kell.r,"[1.8][compiler] Use standard syntax in AnnotationBinding#toString() Created attachment 239302Fix (tests green)Can we use the standard syntax in org.eclipse.jdt.internal.compiler.lookup.AnnotationBinding#toString()?I find the ""@A{ value = (int)1}"" form hard to read in the debugger.Secret plan: I'd like to abuse this toString() method in the ASTView to render type bindings with type annotations."
426616,1/24/2014 14:35,aclement,"[1.8][compiler] Type Annotations multiple problems I know you are not finished but just some feedback for type annotations:If you compile the following with the Eclipse Compiler:(Size is an easy Type Annotation with 1 argument for wasier debugging)List<@Size(max = 41) CharSequence>[] @Size(max = 42) [] @Nonnull @Size(max = 43) [][] test = new @Size(max = 44) ArrayList @Size(max = 45) [10][][] @Size(max = 47) @Size(max = 48) [];Then we find multiple (none-cosmetic) differences in the compiled byte in comparision to JDK 8 (most recent build) some of them not spec conform I think.1.) No attribute ""Local variable type table"" with the generic type info for the variable is rendered I know generic array declarations are somewhat so-so from spec view. JDK 8 generates this happily...(But you generate the type annotation info for the CharSequence type param.)2.) Size(44) till Size(4) appear 2 times in the Bytecode one is correct int he array structure but you generate it again for the local variable. So they appear at the wrong place whats against the spec (not repeatable type annotations can appear multiple times)3.) The new operation has offset 2 if new is the second operation. I think thats like described (fuzzily) in the spec. The JDK 8 has the previos operation pc as offset! So you are different. I think the JDK is wrong here you might have shorter/stronger communication lines to the JDK team?!4) Little bit different topic but same stuff for me: Java Bytecode Viewer doesn't show class level type annotation attributes..."
426633,1/24/2014 21:59,srikanth_sankaran,"[1.8][compiler] Compiler generates code that invokes inapplicable method. Consider the following program:// -interface I {	 <T> void foo (T... p);}abstract class A implements I {	public void foo(Object [] p) {		System.out.println(""A.foo"");	}}public class X extends A {	public static void main(String[] args) {		A a = new X();		a.foo(""hello"" ""world"");	}}At the call site A.foo is not applicable given the arguments and parametersdiffer in length.I.foo is accessible and applicable but A.foo does override it without beingapplicable."
426669,1/26/2014 12:50,jarthana,"Initial issues doing production builds with BETA_JAVA8 I tried adjusting our production scripts to build the ""BETA_JAVA8 branch"" and in first attempt got the errors below. I have not looked at it enough to know if ""real"" error or related to ""production scripts"" ... just wanted to get it documented. = = = = [ERROR] The build could not read 8 projects -> [Help 1]org.apache.maven.project.ProjectBuildingException: Some problems were encountered while processing the POMs:[FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 15 column 11 [FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 14 column 11 [FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 15 column 11 [FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 15 column 11 [FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 15 column 11 [FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 14 column 11 [FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 15 column 11 [FATAL] Non-resolvable parent POM: Could not find artifact eclipse.jdt.core:tests-pom:pom:4.3.0-SNAPSHOT and 'parent.relativePath' points at wrong local POM @ line 15 column 11 [WARNING] 'build.plugins.plugin.version' for org.eclipse.tycho.extras:tycho-custom-bundle-plugin is missing. @ line 51 column 15"
426678,1/26/2014 18:39,srikanth_sankaran,[1.8][compiler] Another issue with vararg type element accessibility Follow up of https://bugs.eclipse.org/bugs/show_bug.cgi?id=426534:I see another problem with vararg accessibility: I'll shortly release a regressiontest showing the problem.
426680,1/26/2014 21:38,srikanth_sankaran,"[1.8][compiler] Incorrect handling of poly conditional leads to CCE // -- interface BinaryOperation<T> { T operate(T x T y);}class StringCatenation implements BinaryOperation<String> { public String operate(String x String y) { return x + y; }}public class X { public static void main(String argv[]) { 	foo(false ? (ab)->a+b :new StringCatenation()); } static void foo(BinaryOperation<Integer> x) { x.operate(5 15); }}results in CCE from the generated code.JDK 8b123 rejects this code correctly:X.java:10: error: incompatible types: bad type in conditional expression foo(false ? (ab)->a+b :new StringCatenation()); ^ StringCatenation cannot be converted to BinaryOperation<Integer>"
426759,1/28/2014 0:08,jarthana,APT doesn't process .class files created/updated in the preivous round of processing Created attachment 239368Patch for testcaseAs the attached test cases (in the form of unit tests) demonstrate the .class files created by the annotation processor doesn't invoke the processor for another round of processing. Here is what the processor is trying to do:1. Create a .class file for a package-info with an annotation such as the following: PackageAnnot package targets.filer8; @interface PackageAnnot {}2. The processor is tracking down the no of rounds and during the first round copies the .class file's contents from the class loader and writes it using Filer.createClassFile() interface. This is expected (?) to call the annotation processor once again but not. This does happen with Javac however.Another but different issue is the behavior is different in the two test processor that are part of the patch. While Java8FilerProcessor#process() doesn't get the second call Java8ElementProcessor#process() does get the second call albeit with no package element as part of root elements. Javac also exibits different behavior across these two processors.The patch probably contains other unnecessary things but what is significant is in Java8ElementProcessor and those inside targets.filer8.
426843,1/28/2014 21:57,david_williams,"[BETA_JAVA8] use qualifier in org.eclipse.jdt.annotation_v1 Created attachment 239412patch for BETA_JAVA8 branchCurrently the version of org.eclipse.jdt.annotation_v1 in the Git repository is ""hard coded"" down to the qualifier. I suggest it be changed (back) to 1.1.0.qualifier so it can be ""built like usual"" from Git."
426844,1/28/2014 22:10,david_williams,"[BETA_JAVA8] use ""4.3.0"" in tests-pom parent Created attachment 239413patch to change versiosn to ""4.3.0""The pom.xml file in ""tests-pom"" directory was (apparently) copied from 'master' and therefore points to ""4.4.0"" jdt.core parent which does not exist in this branch. I suggest the artifact and the parent it points to both be changed to ""4.3.0"" to be more consistent with a ""branch from kepler""."
426845,1/28/2014 23:29,daniel_megert,"[BETA_JAVA8] increment service field of JDT feature Currently the o.e.jdt feature version is ""3.9.0.qualifier"" in beta branch. In R4_3_maintenance it was recently incremented to 3.9.1.qualifier. in master (Luna) version it is 3.10.0.qualifier. I suggest that the version in beta branch be 3.9.51.qualifier. This allows 50 ""point releases"" of 3.9.1 ""pure Kepler SR2"" before any risk of getting ""larger than"" the beta_java8 version. I think it is semantically clearer if we make the service field ""distinct"" from what is in ""Kepler SR2"". (Ultimately it may not matter if/when we produce pure ""patch features"" but ... if/while we want to ""build everything"" in beta branch it make it much clearer semantically plus avoid the comparator ""swapping in"" some matching version from ""pure kepler SR2"" release. I think that is happening at this moment so we need to ""touch"" the feature in some way ... just as well increment service field."
426851,1/29/2014 2:29,srikanth_sankaran,"[1.8][content assist] content assist for a type use annotation package test.pack1;import java.lang.annotation.ElementType;import java.lang.annotation.Target;@Target(ElementType.TYPE_USE)@interface TypeUse {}@T|interface I {	default @T| void foo() { }}-----------------------------------------------In the above example replace '|' with the caret at both the locations and press Ctrl+space.At 1st location (before interface) @TypeUse is not suggested though it is valid there.At 2nd location (before 'void') @TypeUse is suggested and selecting that results in compilation error."
426861,1/29/2014 3:49,david_williams,"[BETA_JAVA8] use SYSTEM to compile o.e.j.annotations 2.0 Created attachment 239415patch to override normal BREE method of compiling bundles.Since we can't seem to specify ""JavaSE-1.8"" yet for BREE I suggest we patch this 1.8 bundle to use ""SYSTEM"" JDK when compiling and this allows us to use ""BREE"" elsewhere as we normally do in our production builds. And don't get me wrong ... I don't like this solution :) But I hope will be temporary and at same time allow us to do a ""full production build"". It does make the strong assumption that the build is ""ran"" using Java 8 ... not sure how long that will be valid (or acceptable)? But should get us started."
426868,1/29/2014 5:08,noopur_gupta,"[1.8][quick fix] Type use annotation not preserved in add throws and try-catch quick fixes package test;import java.io.IOException;import java.lang.annotation.ElementType;import java.lang.annotation.Target;public class Snippet {	void f1(int a) throws @Marker IOException @Marker SecurityException {	}	void foo() {		try {			f1(0);		} catch (@Marker SecurityException ex) {		}	}}@Target(ElementType.TYPE_USE)@interface Marker { }---------------------------------------------------Hover over the error in abpve example at ""f1(0)"" and select the following quick fixes:- ""Add throws declaration"" results in:	void foo() throws IOException {		try {			f1(0);		} catch (@Marker SecurityException ex) {		}	}- ""Surround with try/catch"" results in:	void foo() {		try {			try {				f1(0);			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}		} catch (@Marker SecurityException ex) {		}	} The type use annotation on IOException is not added in the above quick fix results whereas it is added in case of ""Add catch cause to surrounding try"" and ""Add exception to existing catch clause"" quick fixes."
426902,1/29/2014 10:14,jarthana,"Remember to remove ""SYSTEM"" override once JavaSE-1.8 is supported In bug 426861 we used a ""trick"" to override the BREE setting in the manifest.mf since JavaSE-1.8 does not yet work (See 426692). Once that bug 426692 is fixed (and in a version or snapshot of Tycho we can use) we need to remember to go back and revert the change in bug 426861 ... which is in pom.xml of the o.e.j.annotation version 2.0.0 bundle. Basically to remove the whole <build> element in that pom. Just a wild guess I'm expecting this would be in about March that the changes needed would be available to us to use in our builds."
426903,1/29/2014 10:24,jesper,"[1.8] Cannot evaluate super call to default method From bug 422029 comment #17:""public interface A {	default int getOne() {		return 1;	}}public interface B {	default int getOne() {		return 2;	}}public class Impl implements A B {	public int getOne() {		return B.super.getOne(); //bp here and inspect B.super.getOne()	}	public static void main(String[] args) {		Impl i = new Impl();		System.out.println(i.getOne());	}}Put a breakpoint where indicated and select + inspect ""B.super.getOne()"" - the resulting popup has the error about not being able to find the declaring type for the method.""As Jesper found this is currently not supported by the JDK: https://bugs.openjdk.java.net/browse/JDK-8031195Once JDWP has support for this it will be listed here (under the 'Enhancements ' section) http://docs.oracle.com/javase/7/docs/technotes/guides/jpda/"
426954,1/29/2014 16:40,david_williams,"[BETA_JAVA8] use wide range in manifest.mf prereq for o.e.j.annotations Created attachment 239455change to widen range of prereq of annotationsA couple other local changes I'd made but had forgotten about ... Please note: the one change in org.eclipse.jdt.core.tests.compileris _required_ to compile and package as desired. It is the one that replaces two ""requires"" statements org.eclipse.jdt.annotation;bundle-version=""[1.1.02.0.0)"" org.eclipse.jdt.annotation;bundle-version=""[2.0.03.0.0)"";resolution:=optionalWith one but with wider range: org.eclipse.jdt.annotation;bundle-version=""[1.1.03.0.0)""BUTthe second change for org.eclipse.jdt.core.tests.modelis not technically required and *might* not be desired? It widens the range so either of the two annotations bundles can be 'resolved' but not sure if it was intentionally restricted to 1.1.0 or not?"
426963,1/30/2014 1:32,manju656,"[pull up] Import declaration for the type use annotation is missing after pull up refactoring Consider the code snippet:import org.eclipse.jdt.annotation.NonNull;public class Square implements Shape {	public Integer getArea(@NonNull Integer length) {		return new Integer(length * length);	}}Refactor ""Pull Up"" the method to ""Shape"" the resulting file does not contain the import declaration for @NonNull and hence the user ends up with compilation errors."
426977,1/30/2014 5:25,manpalat,"[dom ast] CCE: AnnotationTypeDeclaration cannot be cast to TypeDeclaration package com.test.todo;import java.lang.annotation.ElementType;import java.lang.annotation.Target;public class Test {	static void m() {			}	new Runnable() {		public void run(|) {					}	};}@Target(ElementType.TYPE_USE)@interface TU { }------------------------------------------------In the above example type ""R"" in the parenthesis of ""run()"" in place of '|'.We get the following exception:java.lang.ClassCastException: org.eclipse.jdt.core.dom.AnnotationTypeDeclaration cannot be cast to org.eclipse.jdt.core.dom.TypeDeclaration	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2729)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:637)	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:199)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2956)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1373)	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:274)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:207)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1248)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)..."
426984,1/30/2014 6:24,srikanth_sankaran,"[1.8][inference] Capture problem in GenericsRegressionTest_1_8.testBug424710() Bug 420525 masked a problem in GenericsRegressionTest_1_8.testBug424710() so that fixing bug 420525 will create a regression in this test saying:Type mismatch: cannot convert from Stream<capture#8-of ? extends Object> to Stream<? extends capture#4-of ? extends Object>I don't really know what ""? extends capture#4-of ? extends Object"" means and if we can avoid such beasts.When releasing the fix for bug 420525 I will disable this test for now."
427072,1/30/2014 23:46,srikanth_sankaran,[1.8][compiler] Regression since fix of bug 423505: Method is ambiguous for type X We don't compile this code anymore:// --interface I { Object m(X t);}interface J extends I {}class X { int foo() { return 0; } int test() { return foo(X::foo); } int foo(I i) {return 0;} int foo(J j) { return 1;}}
427075,1/31/2014 1:16,sarika.sinha,"[1.8] Unable to set breakpoint in interface methods Created attachment 239501BP in interface methodsinterface I2 {	default int m1() {		int a = 1;		return a + 2;	}	static void m2() {		System.out.println(""hi"");	}}---------------------------------------------Try to add a breakpoint within the default/static method above.We get the message as shown in the screenshot and the breakpoint is not added."
427077,1/31/2014 1:31,sarika.sinha,"[1.8] Unable to evaluate expressions in the context of an interface Created attachment 239502Error on inspecting within interface methodspackage p1;public class C2 {	@SuppressWarnings(""unused"")	public static void main(String[] args) {		I2 i2 = (I2) () -> {};		int i = i2.m1(); // [1]		int j = I2.m2(); // [2]	}}interface I2 {	default int m1() {		int a = 1;		return a + 2;	}	static int m2() {		int a = 1;		return a + 2;	}	void foo();}--------------------------------------------------Set the breakpoints at line [1] and [2]. While debugging step into (F5) the methods #m1 and #m2. We get exception in the Error log which is given below.Also try to Inspect(Ctrl+Shift+I) the expr ""a + 2"" in the methods we get the error dialog as shown in the screenshot.Exception:Internal error logged from JDI Debug: org.eclipse.debug.core.DebugException: Unable to evaluate expressions in the context of an interface	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.checkInterface(ASTEvaluationEngine.java:199)	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.evaluate(ASTEvaluationEngine.java:133)	at org.eclipse.jdt.internal.debug.ui.JavaWatchExpressionDelegate$EvaluationRunnable.run(JavaWatchExpressionDelegate.java:142)	at org.eclipse.jdt.internal.debug.core.model.JDIThread$ThreadJob.run(JDIThread.java:3158)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
427089,1/31/2014 3:47,jesper,"[1.8] Debugger evaluations fail silently with lambdas or method references package p1;@SuppressWarnings(""unused"")public class C4 {	public static void main(String[] args) {		I4 i4e= null;		System.out.println(i4e);	}	private static int test(int x) {		return x + 20;	}}@FunctionalInterfaceinterface I4 {	int foo(int x);}class I4Impl implements I4 {	@Override	public int foo(int x) {		return x + 10;	}}----------------------------------------------------------- Set the breakpoint at System.out.println line in #main.- While debugging (at the above line) go to the Variables view right-click on 'i4e' and select ""Change Value..."".- In the Change Object Value dialog enter the following expressions one-by-one and see the result as mentioned below:1. new I4Impl()=> 'i4e' value is updated.2. new I4() {	@Override	public int foo(int x) {		return x + 30;	} };=> we get the error ""Anonymous type declaration cannot be used in an evaluation expression"".3. x -> 104. C4::test=> we get the error ""The target type of this expression must be a functional interface"" for 3 and 4. Why so?5. (I4) x -> 106. (I4) C4::test=> No error and the value of 'i4e' is changed to 'null' which is not correct."
427105,1/31/2014 6:04,srikanth_sankaran,"[1.8][builder] Differences between incremental and full builds in method contract verification in the presence of type annotations Brought from bug 426515 comment #15The following files should be in their own files:I1.javapublic interface I1 {	public String bar2( String s @Marker List l1 List<String> l2);}-------------A.javapublic class A implements I1 {	@Override	public String bar2(String s @Marker List l1 List<String> l2) {		return null;	}}Doing a clean build you can notice there's no error. But when you touch A.java in the editor the reconciler reports an error."
427110,1/31/2014 6:36,sarika.sinha,"[1.8] Open Actual Type / Hierarchy in Variables view for lambda and method reference Created attachment 239523Screenshot on clicking 'Open Actual Type Hierarchy'package p1;public class C6 {		@SuppressWarnings(""unused"")	public static void main(String[] args) {		I6 i6a = s -> -1;		I6 i6b = C6::test;		System.out.println();	}		static int test(String s) {		return -1;	}}@FunctionalInterfaceinterface I6 {	int foo(String s);}-------------------------------------------------- Set the breakpoint at System.out.println(); line.- While debugging (at the above line) open Variables view.- Right-click on 'i6a' or 'i6b'.- Select 'Open Actual Type' - Nothing is highlighted.- Select 'Open Actual Type Hierarchy' - We get the error message as shown in attached screenshot."
427117,1/31/2014 8:26,srikanth_sankaran,"[1.8][code assist] code assist after lambda as a parameter does not work import java.util.ArrayList;import java.util.List;public class X {	public static void bar() {		List<Integer> l = new ArrayList<Integer>();		l.forEach(s -> System.out.println(s)); /* replace lambda with null and the following works*/		l./* Press Ctrl-space before this comment */	}	public static void main(String[] args) {		bar();	}}"
427122,1/31/2014 9:04,noopur_gupta,[1.8][quick fix] Change project compliance and JRE to 1.8 For IProblem ids *NotBelow18 in org.eclipse.jdt.core.compiler.IProblem a new quick fix can be supported to change the project setup to 1.8.It would also be useful for experimental checks in test workspace where back and forth switching between 1.7 and 1.8 is required.
427169,1/31/2014 17:30,noopur_gupta,"[1.8][quick assist] lambda body: convert expression to block I was playing with a lambda with a simple expression and then I wanted to add slightly more logic which required me to use a block instead of the expression.Wouldn't it be cool if JDT/UI offered a quick assist ""Convert body expression to block""? :)To convert this:	void assistDemo(boolean flag) {		perform(() -> 13); 	}into this:	void assistDemo(boolean flag) {		perform(() -> {			return 13;		}); 	}(And perhaps the inverse too if possible)."
427207,2/1/2014 18:37,srikanth_sankaran,"[1.8][bytecode] Runtime type problem: Instruction type does not match stack map This program crashes at runtime when compiling and running it from within eclipse.Compiling and running it with jdk8 b127 from the command line works fine.// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -package crash;import java.util.function.Function;class Crash {		public static void main(String[] args) {		test(1 Crash::intToSome);	}	static <T> Some test(T value Function<T Some> f) {		return (value == null) ? new Nothing() : f.apply(value);	}	static SomeInt intToSome(int i) {		return new SomeInt();	}		static abstract class Some {}	static class SomeInt extends Some {}	static class Nothing extends Some {}		// NOTE: on the other hand this works fine:	//static interface Some {}	//static class SomeInt implements Some {}	//static class Nothing implements Some {}	}// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Exception in thread ""main"" java.lang.VerifyError: Instruction type does not match stack mapException Details: Location: crash/Crash.test(Ljava/lang/Object;Ljava/util/function/Function;)Lcrash/Crash$Some; @21: areturn Reason: Type 'java/lang/Object' (current frame stack[0]) is not assignable to 'crash/Crash$Some' (stack map stack[0]) Current Frame: bci: @21 flags: { } locals: { 'java/lang/Object' 'java/util/function/Function' } stack: { 'java/lang/Object' } Stackmap Frame: bci: @21 flags: { } locals: { 'java/lang/Object' 'java/util/function/Function' } stack: { 'crash/Crash$Some' } Bytecode: 0000000: 2ac7 000d bb00 2259 b700 24a7 000a 2b2a 0000010: b900 2502 00b0 Stackmap Table: same_frame(@14) same_locals_1_stack_item_frame(@21Object[#50])	at java.lang.Class.getDeclaredMethods0(Native Method)	at java.lang.Class.privateGetDeclaredMethods(Class.java:2688)	at java.lang.Class.getMethod0(Class.java:2937)	at java.lang.Class.getMethod(Class.java:1771)	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)"
427227,2/3/2014 1:12,noopur_gupta,[1.8]Handle the UI part for TypeParameter#annotations() change to #modifiers() Due to the changes in jdt/core as per Bug 426462
427232,2/3/2014 3:21,noopur_gupta,"[1.8]Replace newAnnotation() with ImportRewrite#addAnnotation() Ref bug 426510 comment 0To quote:""...We should remove the old org.eclipse.jdt.internal.corext.dom.ASTNodeFactory#newAnnotation(..) and turn ImportRewrite#newAnnotation(..) .."""
427255,2/3/2014 7:08,srikanth_sankaran,"[1.8][code assist] Hang due to infinite loop in Parser.automatonWillShift Using this test code:package shortcutter;public class ShellLink { public final String targetApplication; public final String arguments; public final String appUserModelID; public ShellLink() {}}Steps:1. Click in the name of the constructor with red error marker to place caret there.2. Press Ctrl-Space to invoke code assist.3. The UI becomes unresponsive in about 1 second.Tested in Eclipse SDK 4.3.1 with the latest BETA_JAVA8 plugins. This doesn't reproduce in Eclipse SDK 4.4M5.Stack trace of the hanging main thread: java.lang.Thread.State: RUNNABLE	at org.eclipse.jdt.internal.compiler.parser.Parser.automatonWillShift(Parser.java:12441)	at org.eclipse.jdt.internal.compiler.parser.Parser.atConflictScenario(Parser.java:10817)	at org.eclipse.jdt.internal.compiler.parser.Scanner.maybeAtLambdaOrCast(Scanner.java:4407)	at org.eclipse.jdt.internal.compiler.parser.Scanner.disambiguatedToken(Scanner.java:4480)	at org.eclipse.jdt.internal.compiler.parser.Scanner.getNextToken(Scanner.java:1161)	at org.eclipse.jdt.internal.compiler.parser.Parser.moveRecoveryCheckpoint(Parser.java:10638)	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.resumeAfterRecovery(AssistParser.java:1842)	at org.eclipse.jdt.internal.codeassist.complete.CompletionParser.resumeAfterRecovery(CompletionParser.java:5087)	at org.eclipse.jdt.internal.compiler.parser.Parser.resumeOnSyntaxError(Parser.java:12247)	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:10868)	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11210)	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11167)	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:9610)	at org.eclipse.jdt.internal.codeassist.complete.CompletionParser.dietParse(CompletionParser.java:4543)	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1810)	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:131)	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:358)	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:346)	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.internalComputeCompletionProposals(JavaCompletionProposalComputer.java:244)	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.computeCompletionProposals(JavaCompletionProposalComputer.java:206)	at org.eclipse.jdt.internal.ui.text.java.JavaTypeCompletionProposalComputer.computeCompletionProposals(JavaTypeCompletionProposalComputer.java:63)	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:333)	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:337)	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:325)	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:282)	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1839)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:566)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$16(CompletionProposalPopup.java:563)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:498)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:492)	at org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1665)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:183)	at org.eclipse.ui.texteditor.ContentAssistAction$1.run(ContentAssistAction.java:82)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ui.texteditor.ContentAssistAction.run(ContentAssistAction.java:80)	at org.eclipse.jface.action.Action.runWithEvent(Action.java:499)	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:119)	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)	at java.lang.reflect.Method.invoke(Unknown Source)	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56)	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:243)	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:224)	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:167)	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:285)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:504)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:555)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:376)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:322)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:84)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1056)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1104)	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1525)	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4723)	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:344)	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4611)	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4977)	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3757)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:138)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:610)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)	at java.lang.reflect.Method.invoke(Unknown Source)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)	at org.eclipse.equinox.launcher.Main.run(Main.java:1450)	at org.eclipse.equinox.launcher.Main.main(Main.java:1426)"
427314,2/3/2014 14:01,srikanth_sankaran,[1.8][dom ast] Withdraw ITypeBinding#getEnclosingType() Noopur asked a good question I couldn't answer:org.eclipse.jdt.core.dom.ITypeBinding.getEnclosingType() : How is it different from ITypeBinding.getDeclaringClass()?The API got added in http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=0eef8a719c726a9948e73db62c7f81adbce0f319
427320,2/3/2014 14:24,jarthana,[1.8][dom ast] Type annotation on constructor is returned via IBinding#getAnnotations() Question from Noopur: How to differentiate between a type use annotation and a constructor annotation on a constructor. We get both via IBinding.getAnnotations(). - Probably a bug?I would also expect @A to be treated as a type annotation in the snippet below. Java 8 reflection seems to agree with that viewpoint.package jsr308.bug.ctor;import java.lang.annotation.*;@Target(ElementType.TYPE_USE)@Retention(RetentionPolicy.RUNTIME)@interface A {}@Target(ElementType.TYPE_USE)@Retention(RetentionPolicy.RUNTIME)@interface B {}@Target(ElementType.CONSTRUCTOR)@Retention(RetentionPolicy.RUNTIME)@interface C {}public class Test<E> { @C public @A <T> Test() { // @A should be type annotation on constructor binding new @B() Test(); } public static void main(String[] args) throws Exception { Annotation[] declAnnos = Test.class.getDeclaredConstructors()[0].getAnnotations(); System.out.println(java.util.Arrays.asList(declAnnos)); Annotation[] typeAnnos = Test.class.getDeclaredConstructors()[0].getAnnotatedReturnType().getAnnotations(); System.out.println(java.util.Arrays.asList(typeAnnos)); }}
427322,2/3/2014 14:54,srikanth_sankaran,"[1.8][code assist] Eclipse hangs upon completion just past lambda Start with the valid and working program below computing a factorial:------------------------------------------------package java8.test;public class Main {		interface Duo {		int apply(int n Duo g);	}	 	public static void main(String[] args) {		Duo f = (n g) -> n > 0 ? n * g.apply(n - 1 g) : 1; 		System.out.println(f.apply(5 f));	}}------------------------------------------------then change the line declaring the ""Duo f"" variable as such:------------------------------------------------		Duo f = (n g) -> n > 0 ? n * g.apply(n - 1 g) : 1 f.------------------------------------------------After the ""."" is entered after ""f"" Eclipse hangs and must be killed."
427337,2/3/2014 23:17,jarthana,[1.8][dom ast] Type annotation is appearing in parameter annotation Since the fix for bug 426515 did not resolve the issue reported in bug 426515 comment #1 I am raising a new bug to track it.package pack1;import java.lang.annotation.ElementType;import java.lang.annotation.Target;@Target({ ElementType.TYPE_USE })public @interface ReadOnly {}package pack1;import java.util.List;public interface I1 {public @ReadOnlyString bar2(@ReadOnly String s @ReadOnly List<@ReadOnly String> l2);}package pack1;import java.util.List;public class AImpl implements I1 InnerA {}//Invoke the quick fix to Add Unimplemented methodsinterface InnerA{public @ReadOnlyString bar1(@ReadOnly String s @ReadOnly List<@ReadOnly String> l2);}Inspect the IMethodBinding corresponding to InnerA#bar1(). binding.getParameterTypes()[0].getTypeAnnotations() returns the AnnotationBinding corresponding to @ReadOnly()Now inspect the IMethodBinding corresponding to I1#bar2(). binding.getParameterTypes()[0].getTypeAnnotations() returns empty AnnotationBinding. Now inspect with the same binding binding.getParameterAnnotations(0) this returns the AnnotationBinding corresponding to @ReadOnly() which seems wrong as the Javadoc for getParameterAnnotations() says that this is supposed to return the declaration annotation and not the type annotation.
427357,2/4/2014 7:05,jarthana,"[1.8][dom ast] 'this' parameter unavailable in AST for static method declaration abstract class Test2 {	abstract void m0(Test2 this int i);		void m1(int i Test2 this) { }	static void m2(Test2 this int i) { }		Function<String String> f1= (String s Function this) -> s;	Function<String String> f2= (Function this String s) -> s;}Here 'this' parameter info is present as given below:- In #m0: present in RECEIVER_TYPE_PROPERTY not present in parameters list.- In #m1: not present in RECEIVER_TYPE_PROPERTY present in parameters list.- In #m2: not present in RECEIVER_TYPE_PROPERTY not present in parameters list.- In f1 and f2: present in parameters list of LambdaExpression.Cases for #m0 and f1/f2 are fine.Case for #m1 also seems Ok?In case of #m2 'this' parameter info is not present anywhere in the AST which is wrong.When 'this' parameter is added at an incorrect location it should be present at a consistent place somewhere in the AST."
427362,2/4/2014 9:05,markus.kell.r,"[1.8][dom ast] ASTRewriteFormatter uses wrong ""Insert new line after annotation"" option for SingleVariableDeclaration From bug 425040 comment #1:Consider the following example:--------------------------------------------import java.lang.annotation.ElementType;import java.lang.annotation.Target;public class X {}@Target(ElementType.TYPE_USE)@interface Ann1 { }class A {	public void foo(X x @Ann1 X arg) { }}--------------------------------------------Move method #foo to X by choosing 'X x' as the receiver. It results in inserting a new line after annotation on the parameter as shown below:--------------------------------------------import java.lang.annotation.ElementType;import java.lang.annotation.Target;public class X {	public void foo(@Ann1	X arg) { }}@Target(ElementType.TYPE_USE)@interface Ann1 { }class A {}--------------------------------------------It happens as the parameter (@Ann1 X arg) is considered as a SingleVariableDeclaration during AST rewrite and the formatter option ""Insert new line after annotations on local variables"" is enabled."
427367,2/4/2014 9:41,jarthana,"[1.8][compiler] Produces bad classfile format for unresolved type in annotation value The produced classfile for this CU is problematic:package bug.imports.test;import java.lang.annotation.*;@Target(ElementType.TYPE_USE)@interface Ann { Thread.State value() default Thread.State.NEW; int value2() default 1;}public class BadClassfile { public void foo003( @Ann(value = XXThread.State.BLOCKED value2 = 42) Object o ) {}}The search index says:!MESSAGE The Java indexing could not index /zz1.8/bin/bug/imports/test/BadClassfile.class. This .class file doesn't follow the class file format specification. Please report this issue against the .class file vendorWhen I locate the BadClassfile.class file in the Navigator view and then try to open it the disassembler fails here:java.lang.ArrayIndexOutOfBoundsException: 659	at org.eclipse.jdt.internal.core.util.ClassFileStruct.u1At(ClassFileStruct.java:52)	at org.eclipse.jdt.internal.core.util.ExtendedAnnotation.<init>(ExtendedAnnotation.java:112)	at org.eclipse.jdt.internal.core.util.RuntimeInvisibleTypeAnnotationsAttribute.<init>(RuntimeInvisibleTypeAnnotationsAttribute.java:55)	at org.eclipse.jdt.internal.core.util.MethodInfo.<init>(MethodInfo.java:128)	at org.eclipse.jdt.internal.core.util.ClassFileReader.<init>(ClassFileReader.java:238)	at org.eclipse.jdt.internal.core.util.Disassembler.disassemble(Disassembler.java:261)	at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$SourceAttachmentForm.updateCodeView(ClassFileEditor.java:410)..."
427372,2/4/2014 9:54,daniel_megert,"Let's finish getting rid of eclipse_update_120.jpg +++ This bug was initially created as a clone of Bug #427371 +++I still see this in a few places. This is an old ""update manager"" image that has not been used since p2 was introduced. Besides removing the image the file name should be removed from build.properties if mentioned there. ./eclipse.platform.runtime/features/org.eclipse.core.tools-feature/eclipse_update_120.jpg./eclipse.jdt.ui/org.eclipse.jdt.astview.feature/eclipse_update_120.jpg./eclipse.jdt.ui/org.eclipse.jdt.jeview.feature/eclipse_update_120.jpg./eclipse.platform.ui/features/org.eclipse.e4.rcp/eclipse_update_120.jpg./eclipse.platform.ui/features/org.eclipse.e4.rcp/sourceTemplateFeature/eclipse_update_120.jpg./rt.equinox.framework/features/org.eclipse.equinox.executable.feature/eclipse_update_120.jpgMarking as 'minor' since is ""merely cleanup"" ... but I think important. (I was reminded of this seeing it as part of the ""deltapack"" zip file)."
427383,2/4/2014 11:01,srikanth_sankaran,[1.8] failures in TypeBindingTests308 At commit 055cf2299e246e07310e3c00069174f749475bd4 the tests TypeBindingTests308.testAnnotatedBinaryType* are failing in my workspace.Is that some work-in-progress?
427463,2/5/2014 8:04,srikanth_sankaran,"[1.8][content assist] No completions available in throw statement within lambda body @FunctionalInterfaceinterface FI1 {	int foo(int x) throws Exception;}class Test {	FI1 fi1= (int x) -> {		throw new Ex|	};	private void test() throws Exception {		throw new Ex|	}}------------------------------------------------------------------In the above example replace '|' with the caret in lambda expr and in #test method. Press Ctrl+space.Completions are available in the method but not in the lambda expression body."
427464,2/5/2014 8:17,srikanth_sankaran,"[1.8][content assist] CCE : MethodDeclaration incompatible with CompletionOnAnnotationOfType @FunctionalInterfaceinterface FI1 {	int foo(int x) throws Exception;}class Test {	private void foo() {		FI1 fi1 = (x) -> { 			@|		};	}}---------------------------------------------------------In the above example replace '|' with caret and press Ctrl+space. We get the following exception:java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.ast.MethodDeclaration incompatible with org.eclipse.jdt.internal.codeassist.complete.CompletionOnAnnotationOfType	at org.eclipse.jdt.internal.codeassist.CompletionEngine.completionOnMarkerAnnotationName(CompletionEngine.java:2497)	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1743)	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1937)	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:131)	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:358)	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:346)	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.internalComputeCompletionProposals(JavaCompletionProposalComputer.java:244)..."
427468,2/5/2014 8:46,srikanth_sankaran,"[1.8][compiler] can't resolve java.lang.annotation.Annotation from source Created attachment 239658noJREonClasspath.zipThe Eclipse compiler can't resolve java.lang.annotation.Annotation from source any more.Since bug 419331 I get a compile error ""The type java.lang.annotation.Annotation cannot be resolved. It is indirectly referenced from required .class files"" when I try to compile the attached project. When I revert the change for that bug then the Annotation type is found and I get better (expected/solvable) problems. (The given project is very incomplete but shows the issue).Background: I'm trying to regenerate rtstubs18.jar for the JDT/UI tests so that it includes the APIs from latest JREs. We need this e.g. for the test case in bug 425183 comment 10.ECJ should generally be able to compile a complete rt.jar from source."
427478,2/5/2014 10:26,srikanth_sankaran,"[1.8][compiler] Wrong ""Duplicate default methods"" error on AbstractDoubleSpliterator When trying to compile rt.jar of Java 8 with ecj I'm getting a compile error in java.util.Spliterators.AbstractDoubleSpliterator. I've extracted the problem into a self-contained example below.I think the compile error is wrong because interface OfDouble already overrides the method Spliterator#forEachRemaining(Consumer<? super T>) with a concrete variant OfDouble#forEachRemaining(Consumer<? super Double>) so the former method should not be considered any more when AbstractDoubleSpliterator is compiled.=====================================================================package split2;import java.util.function.Consumer;import java.util.function.DoubleConsumer;public interface Spliterator<T> { default void forEachRemaining(Consumer<? super T> action) { } public interface OfPrimitive<T T_CONS T_SPLITR extends OfPrimitive<T T_CONS T_SPLITR>> extends Spliterator<T> { // overloads Spliterator#forEachRemaining(Consumer<? super T>) default void forEachRemaining(T_CONS action) { } } public interface OfDouble extends OfPrimitive<Double DoubleConsumer OfDouble> { @Override // the method from Spliterator default void forEachRemaining(Consumer<? super Double> action) { } @Override // the method from OfPrimitive default void forEachRemaining(DoubleConsumer action) { } }}class Spliterators { /* Error on class: Duplicate default methods named forEachRemaining with * the parameters (Consumer<? super Double>) and (Consumer<? super T>) are * inherited from the types Spliterator.OfDouble and Spliterator<Double> */ public abstract static class AbstractDoubleSpliterator implements Spliterator.OfDouble { /* Implementation that prevents the compile error: */// @Override // the method from Spliterator// public void forEachRemaining(Consumer<? super Double> action) {// } }}====================================================================="
427532,2/6/2014 0:38,srikanth_sankaran,"[1.8][code assist] Completion engine does not like intersection casts Spawned from https://bugs.eclipse.org/bugs/show_bug.cgi?id=427117#c3Completion fails in before after and inside a lambda in the presence ofintersection casts:// --import java.io.Serializable;interface I {	void foo();}public class X {	I i = () -> {		System.out.println();	};		public static void main(String[] args) {		syso|		I i = (I & Serializable) () -> {			syso}		};		syso|	}}"
427537,2/6/2014 2:20,manpalat,"[1.8][search] CCE with search match location set to cast type and intersection casts // --import java.io.Serializable;interface I {	void foo();}public class X {	public static void main(String[] args) {		I i = (I & Serializable) () -> {};		}}Search for I using Java search + type references + cast locations.java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.ast.IntersectionCastTypeReference incompatible with org.eclipse.jdt.internal.compiler.ast.QualifiedTypeReference	at org.eclipse.jdt.internal.core.search.matching.TypeReferenceLocator.match(TypeReferenceLocator.java:99)	at org.eclipse.jdt.internal.core.search.matching.MatchLocatorParser.consumeCastExpressionLL1WithBounds(MatchLocatorParser.java:227)	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:7015)	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:10965)	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11314)	at org.eclipse.jdt.internal.core.search.matching.MatchLocatorParser.parseBodies(MatchLocatorParser.java:834)	at org.eclipse.jdt.internal.core.search.matching.MatchLocatorParser.parseBodies(MatchLocatorParser.java:808)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.getMethodBodies(MatchLocator.java:889)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.parseAndBuildBindings(MatchLocator.java:1671)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1091)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1196)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1328)	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:96)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516)	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584)	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144)	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
427538,2/6/2014 3:05,jarthana,"[1.8][infrastructure] Enable CompletionTests18 & ResolveTests18 to run with rtstubs18.jar Presently writing completion and selection tests from user provided problemsnippets is a pain because these tests run against minimal version of libraries(JCLMIN) that don't even have java.lang.String in some incarnations of them.For example given:import java.util.List;import java.util.Map;import java.util.stream.Collectors;public class Bug419048 {	void test1(List<Person> roster) { Map<String Person> map = roster .stream() .collect( Collectors.toMap( p -> p.getLast() //[1] p -> p //[2] ));	}}one needs to transform all the symbols that originate from JRE into localtypes or otherwise rewrite the test into shape.Historically the UI project has maintained their some of their tests againsta stubbed version of JRE and recently Markus created the JDK8 version of it.See http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?h=BETA_JAVA8&id=4505fb3550ef580808061e75a5a925cfe9d3b9d2We need CompletionTests18 and ResolveTests18 to similarly run againsta version of library that has all the types in tact (but for methodbodies which are stubbed out) to make it easy to write tests."
427622,2/7/2014 1:59,manpalat,"[1.8][dom ast] Additional CR in annotations on throw types spawned from bug 401848 comment 18 (Reproduced below).bug 426868 comment #1 - the disabled test in the patch is an example of the SE8 exclusive location where the issue occurs.Example:-------------------------------------------------------------------import java.io.FileNotFoundException;import java.lang.annotation.ElementType;import java.lang.annotation.Target;class E {	void test(int a) {		throw new @Marker FileNotFoundException();	}}@Target(ElementType.TYPE_USE)@interface Marker { }-------------------------------------------------------------------Apply the patch from bug 426868 comment #1 in JDT/UI and hover over the error in above example (at 'thorw').Select ""Add throws declaration"" quick fix. The result is:-------------------------------------------------------------------class E {	void test(int a) throws @Marker	FileNotFoundException {		throw new @Marker FileNotFoundException();	}}-------------------------------------------------------------------Here the ""@Marker FileNotFoundException"" node to be added in 'throws' comes as a SimpleType with #annotations having '@Marker'.Please check if the above issue will be resolved with this bug or bug 425040.Refer to bug 401848 comment 19 as well."
427625,2/7/2014 2:43,srikanth_sankaran,"NPE at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.generateCode(ConditionalExpression.java:283) HelloI had a new compilation issue will compiling this piece of code :import java.util.Collection;import java.util.List;public class G {	public void error(Collection<Object> c)	{		boolean b =true;				c.add(b ? new Integer(1)		 : c==null ? null 				 : c instanceof List ? Integer.valueOf(1) 				 : o()); 	}		public Object o()	{		return null;	}}the stackError in JDT Core during AST creationjava.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.generateCode(ConditionalExpression.java:283)	at org.eclipse.jdt.internal.compiler.ast.Statement.generateArguments(Statement.java:265)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.generateCode(MessageSend.java:426)	at org.eclipse.jdt.internal.compiler.ast.Expression.generateCode(Expression.java:699)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:328)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:273)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:570)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:639)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:370)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1214)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)Good luck!Mathieu."
427628,2/7/2014 3:06,srikanth_sankaran,"[1.8] regression : The method * is ambiguous for the type * Hellosince today (1.0.0.v20140207-0104_BETA_JAVA8) I have and error with the following code : public class H {		public void error(I i)	{		test(i!=null?i.getJ():null);	}			public void test(I i)	{			}	public void test(J j)	{			}			public class I{		public J getJ()		{			return null;		}	}	public class J{}}The error is : The method test(H.I) is ambiguous for the type HIs it not possible to guess that the result of the condition will be of the type J ?It was working well with earlier versions (like 1.0.0.v20140206-0106_BETA_JAVA8)"
427677,2/7/2014 10:30,manpalat,"[1.8][search] NPE in MatchLocator.reportMatching with unresolved NameQualifiedType qualifier Select ""TYPE_USE"" and search for references in Workspace => stops with NPE.============================================================package testing;import java.lang.annotation.ElementType;import java.lang.annotation.Target;class Y0 implements unresolved. @Marker1 Collection<Integer> { }@Target (ElementType.TYPE_USE)@interface Marker1 {}============================================================!ENTRY org.eclipse.core.jobs 4 2 2014-02-07 16:21:02.575!MESSAGE An internal error occurred during: ""Java Search"".!STACK 0java.lang.NullPointerException	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2328)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2733)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2513)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1746)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1155)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1196)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1328)	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:96)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516)	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584)	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144)	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
427744,2/9/2014 0:22,srikanth_sankaran,[1.8][compiler][regression] Issue with boxing compatibility in poly conditional This is a regression since the fix for https://bugs.eclipse.org/bugs/show_bug.cgi?id=427628.The following program does not compile any more:// --public class X { public static void main(String argv[]) { int i = ((I) (x) -> { return 999; }).foo(true ? 0 : (Comparable) null); System.out.println(i); } interface I { int foo (Comparable arg); default int foo (Object arg) { return 0; } }}
427745,2/9/2014 1:21,sasikanth.bharadwaj,"[1.8][compiler]javac compatibility @Retention Runtime ignored import java.lang.annotation.Annotation;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.reflect.Method;public class X extends Super { public static void main(String[] args) { try { Method m = X.class.getMethod(""setFoo"" String.class); Annotation a = m.getAnnotation(Anno.class); System.out.println(""Annotation was "" + (a == null ? ""not "" : """") + ""found""); } catch (Exception e) { e.printStackTrace(); } }}class Super { @Anno public void setFoo(String foo) {}}@Retention(RetentionPolicy.RUNTIME)@interface Anno {}MethodVerifyTest#208On running the above javac finds (""Annotation was found"") the annotation while eclipse jdt does not. The behaviour was ""Annotation not found"" in 1.7 in javac as well. Looks like it was a bug that got fixed in javac. b126 in 1.7 mode also finds the annotations. - [May have to move out of 1.8 as well after analysis.]"
427749,2/9/2014 5:14,srikanth_sankaran,"[1.8][compiler]NullPointerException in ReferenceExpression.resolveType interface I { void foo(X<String> y);}public class X<T> { class Z<K> { Z(X<String> y) { System.out.println(""Y<T>.Z<K>:: new""); } public void bar() { I i = Y<String>.Z<Integer>::<String> new; i.foo(new Y<String>()); } }	public void foo() {		Z<String> z = new Z<String>(null);		z.bar();	}	public static void main(String[] args) {		Y<String> y = new Y<String>();		y.foo();	}}java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.resolveType(ReferenceExpression.java:345)	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:248)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:618)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:532)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1312)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1110)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:571)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1208)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813)"
427754,2/9/2014 8:26,manpalat,"[1.8][tests] javac compatibility harness issue Run SerializableLambdaTest#test001_simpleCompatibility fails - Issue: Helper.class to be created under util/ but created in the current directory and hence error ""java.lang.NoClassDefFoundError: util/Helper"" [stop in ART.execute() and check errorLogger() to find this issue].Once this is fixed failing tests of SLT have to be re-run."
427787,2/10/2014 7:25,srikanth_sankaran,[1.8] Ensure ECJ8 is able to build JRE8 This bug is to track our effort on testing our 1.8 compiler with the source code of 1.8 JDK. The primary goal is to cover as much variety of code s possible since there's lot of generics and lambda related code as part of the JDK's source code. From previous offline discussions here are some ideas from Stephan:1. Just extract the src.zip and use eclipse command line compiler.2. Import the source as a project into eclipse and compile at 1.8 level.The idea is to test the compiler against both 1.8 and non 1.8 code and raise defects and follow up.
427808,2/10/2014 10:46,srikanth_sankaran,"[1.8] Correct super() invocation is not inferred when argument is a conditional expression This code is rejected by ECJ but allowed by Javac:public class X extends Foo {	public X(I i) {		super(i != null ? i.toString() : null); }}class Foo implements I {	Foo(I i) {}	Foo(String string){}}interface I {}"
427883,2/11/2014 6:24,Lars.Vogel,Use ArrayContentProvider in ExtractClassWizard I think the the custom content provider in ExtractClassWizard can be replaced with the ArrayContentProvider.
427922,2/11/2014 11:55,jarthana,"[1.8] MirrorDeclarationTests.testMirrorDeclaration() is failing in BETA_JAVA8 MirrorDeclarationTestAnnotationProcessor has the following code which is causing problems:ArrayList<AnnotationMirror> annotationMirrors = new ArrayList<AnnotationMirror>();for (MethodDeclaration methodDeclaration : methodDecls) {	Collection<AnnotationMirror> mirrors = methodDeclaration.getAnnotationMirrors();	annotationMirrors.addAll(mirrors);}ProcessorTestStatus.assertEquals(""Wrong size for annotation mirrors"" 3 annotationMirrors.size());It appears that now AnnotationMirrorImpl (JLS5) has equals() that checks for equality of underlying dom binding. This check probably was returning false earlier but now returns true since we now reuse the same binding for annotations. The test code has three methods all annotated with the same annotation which means we will only have one entry annotationMirrors in the end.I think we only need to fix the test just to check that individual methods get their annotations."
427943,2/11/2014 16:57,het,"The method org.eclipse.jdt.internal.compiler.apt.model.Factory.getPrimitiveType does not throw IllegalArgumentException The documentation for org.eclipse.jdt.internal.compiler.apt.model.Factory.getPrimitiveType reads:	/**	 * Get a type mirror object representing the specified primitive type kind.	 * @throw IllegalArgumentException if a non-primitive TypeKind is requested	 */The method body tells a different story:	public PrimitiveTypeImpl getPrimitiveType(TypeKind kind)	{		switch (kind) {		case BOOLEAN:			return PrimitiveTypeImpl.BOOLEAN;		case BYTE:			return PrimitiveTypeImpl.BYTE;		case CHAR:			return PrimitiveTypeImpl.CHAR;		case DOUBLE:			return PrimitiveTypeImpl.DOUBLE;		case FLOAT:			return PrimitiveTypeImpl.FLOAT;		case INT:			return PrimitiveTypeImpl.INT;		case LONG:			return PrimitiveTypeImpl.LONG;		case SHORT:			return PrimitiveTypeImpl.SHORT;		default:			throw new IllegalStateException();		}	}Proposed patch:s/IllegalStateException/IllegalArgumentException/"
427955,2/11/2014 21:35,srikanth_sankaran,"[1.8][compiler] NPE in TypeSystem.getUnannotatedType From building JDK source code comes this reduced test case which causes a flood of error log entries and an error message popup:package npe.oejicl.TypeSystem.getUnannotatedType.line76;/** * @param <K> unused * @param <V> unused */class Outer<K V> { void method() { //Internal compiler error: java.lang.NullPointerException at // org.eclipse.jdt.internal.compiler.lookup.TypeSystem.getUnannotatedType(TypeSystem.java:76) new Inner<>(null); } final class Inner<K2 V2> { /** * @param next unused */ Inner(Inner<K2 V2> next) {} }}Tested with the latest BETA_JAVA8 plugins.Here is the stack trace:java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.getUnannotatedType(TypeSystem.java:76)	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.getParameterizedType(TypeSystem.java:146)	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getParameterizedType(AnnotatableTypeSystem.java:123)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createParameterizedType(LookupEnvironment.java:946)	at org.eclipse.jdt.internal.compiler.lookup.Scope$Substitutor.substitute(Scope.java:507)	at org.eclipse.jdt.internal.compiler.lookup.Scope$Substitutor.substitute(Scope.java:493)	at org.eclipse.jdt.internal.compiler.lookup.Scope$Substitutor.substitute(Scope.java:614)	at org.eclipse.jdt.internal.compiler.lookup.Scope.substitute(Scope.java:439)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getStaticFactory(Scope.java:4958)	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.inferElidedTypes(AllocationExpression.java:576)	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolvePart2(AllocationExpression.java:496)	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:486)	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1019)	at org.eclipse.jdt.internal.compiler.ast.Block.resolveUsing(Block.java:136)	at org.eclipse.jdt.internal.compiler.ast.SynchronizedStatement.resolve(SynchronizedStatement.java:198)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:618)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:532)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:571)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:921)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:966)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1248)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:178)	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:114)	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:136)	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:105)	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:406)	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:173)"
427962,2/12/2014 3:08,srikanth_sankaran,"[1.8][compiler] Stream#toArray(String[]::new) not inferred without help This example compiles correctly with javac but ECJ gives 4 errors:public class Excercise { static <A B> Stream<B> objmap(Function<A B> p1 A[] p2) {return Stream.of(p2).map(p1);} static <B> Stream<B> intmap(IntFunction<B> p1 int[] p2) {return IntStream.of(p2).mapToObj(p1);} public static void main(String[] args) { Integer[] p12 = {1 2 3}; int[] p22 = {1 2 3}; //works String[] a11 = objmap(String::valueOf p12).<String> toArray(String[]::new); String[] a21 = intmap(String::valueOf p22).<String> toArray(String[]::new); //does not work String[] a12 = objmap(String::valueOf p12).toArray(String[]::new); String[] a22 = intmap(String::valueOf p22).toArray(String[]::new); }}The errors I get are:Description	Resource	Location	Path	TypeThe method toArray(IntFunction<A[]>) in the type Stream<String> is not applicable for the arguments (String[]::new)	Excercise.java	line 21	/EclipseBugsLive/src/homework	Java ProblemConstructed array String[] cannot be assigned to A[] as required in the interface descriptor 	Excercise.java	line 21	/EclipseBugsLive/src/homework	Java ProblemThe method toArray(IntFunction<A[]>) in the type Stream<String> is not applicable for the arguments (String[]::new)	Excercise.java	line 20	/EclipseBugsLive/src/homework	Java ProblemConstructed array String[] cannot be assigned to A[] as required in the interface descriptor 	Excercise.java	line 20	/EclipseBugsLive/src/homework	Java Problem"
428071,2/13/2014 3:40,srikanth_sankaran,"[1.8][compiler] Bogus error about incompatible return type during override Hello I have an error from the compiler while compiling this code: K1.java :import java.util.List;import java.util.Map; public interface K1 {	public Map<StringList> get();}K.javaimport java.util.List;import java.util.Map;public class K implements K1{	@Override	public Map<String List> get() {		return null;	}}""The return type is incompatible with K1.get()""Why do i have this error as the signature are the same?When i put List<?> in both the interface and the class this work properly. Is the wildcard mandatory?I am using 1.0.0.v20140213-0104_BETA_JAVA8 Eclipse Java Development Tools Patch for Java 8 Support (BETA) Eclipse Plugin-in Development Environment Patch for Java 8 Support (BETA) Eclipse RCP Patch for Java 8 Support (BETA)Thanks!"
428112,2/13/2014 10:46,srikanth_sankaran,"[1.8][compiler] ClassCastException in ReferenceExpression.generateCode Created attachment 239911Example from Horstmann's 'Java SE 8 for the Really Impatient' chapter 8 section 7Received following exception while compiling the attached source:!ENTRY org.eclipse.jdt.ui 4 0 2014-02-13 08:21:36.316!MESSAGE Error in JDT Core during AST creation!STACK 0java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.NestedTypeBinding	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.generateCode(ReferenceExpression.java:216)	at org.eclipse.jdt.internal.compiler.ast.Statement.generateArguments(Statement.java:289)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.generateCode(MessageSend.java:426)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.generateCode(MessageSend.java:419)	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.generateCode(LocalDeclaration.java:152)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:328)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:273)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:570)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:639)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:370)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1214)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:474)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)Encountered in Luna build I20140123-1600 with Eclipse Java Development Tools Patch for Java 8 Support (BETA) v 1.0.0.v20140213-0104_BETA_JAVA8"
428178,2/14/2014 6:01,jarthana,[1.8] isMainMethod(IMethod) should consider the default Public modifier for main method in interface Member.isMainMethod(IMethod)currently checks for isPublic() flag on main method. With Java 8 Interface can have main method without explicit Public modifier.So the condition needs to be modified to take care of this.
428203,2/14/2014 9:41,srikanth_sankaran,[1.8][compiler] Build Eclipse SDK as a collection of 1.8 project using ECJ8. As a way to stress test the Java 8 compiler we could build the entireeclipse SDK as a collection of 1.8 projects.We already know that we are able to build the SDK at the prevailing compliance/source levels but artificially boosting to 1.8 and buildingcould serve as an excellent test.This CR will serve as the master bug for this project with leaf level bugscreated for problems and linked here.
428220,2/14/2014 13:50,srikanth_sankaran,"[1.8][compiler] Javadoc processing interferes with type inference. From https://bugs.eclipse.org/bugs/show_bug.cgi?id=427787#c26Here's an interesting case from the list:public class HashMap<K V> {	static class Node<K V> {		Node(int hash K key V value Node<K V> next) {}	}	/** @see #put(Object Object) */	public V put(K key V value) {	return null; }	Node<K V> newNode(int hash K key V value Node<K V> next) {		return new Node<>(hash key value next); // Error	}}But the error goes away if I get rid of either the put() method or the javadoc above that."
428247,2/15/2014 4:53,srikanth_sankaran,"[1.8][compiler] Race condition causes injection of spurious raw types into the type system. In this call stack:SourceTypeBinding.kind() line: 797	LookupEnvironment.convertUnresolvedBinaryToRawType(TypeBinding) line: 605	ParameterizedTypeBinding.swapUnresolved(UnresolvedReferenceBinding ReferenceBinding LookupEnvironment) line: 1221	UnresolvedReferenceBinding.setResolvedType(ReferenceBinding LookupEnvironment) line: 133	PackageBinding.addType(ReferenceBinding) line: 78	ClassScope.buildType(SourceTypeBinding PackageBinding AccessRestriction) line: 411	CompilationUnitScope.buildTypeBindings(AccessRestriction) line: 153	LookupEnvironment.buildTypeBindings(CompilationUnitDeclaration AccessRestriction) line: 190	CompilationUnitResolver(Compiler).accept(ICompilationUnit AccessRestriction) line: 331	CompilationUnitResolver.accept(ICompilationUnit AccessRestriction) line: 178	CompilationUnitResolver.accept(ISourceType[] PackageBinding AccessRestriction) line: 174	LookupEnvironment.askForType(char[][]) line: 147	UnresolvedReferenceBinding.resolve(LookupEnvironment boolean) line: 103	BinaryTypeBinding.resolveType(TypeBinding LookupEnvironment boolean) line: 174	PackageBinding.getTypeOrPackage(char[]) line: 190	ClassScope(Scope).getTypeOrPackage(char[] int boolean) line: 3296	ClassScope(Scope).getType(char[]) line: 3008	SingleTypeReference.getTypeBinding(Scope) line: 54	SingleTypeReference(TypeReference).internalResolveType(Scope) line: 468	SingleTypeReference(TypeReference).resolveType(ClassScope) line: 559	SingleTypeReference(TypeReference).resolveSuperType(ClassScope) line: 537	ClassScope.findSupertype(TypeReference) line: 1264	ClassScope.connectSuperInterfaces() line: 1030	ClassScope.connectTypeHierarchy() line: 1085	CompilationUnitScope.connectTypeHierarchy() line: 308	LookupEnvironment.completeTypeBindings() line: 228	LookupEnvironment.completeTypeBindings(CompilationUnitDeclaration) line: 260	CompilationUnitResolver(Compiler).accept(ICompilationUnit AccessRestriction) line: 335	CompilationUnitResolver.accept(ICompilationUnit AccessRestriction) line: 178	CompilationUnitResolver.accept(ISourceType[] PackageBinding AccessRestriction) line: 174	LookupEnvironment.askForType(char[][]) line: 147	UnresolvedReferenceBinding.resolve(LookupEnvironment boolean) line: 103	BinaryTypeBinding.resolveType(TypeBinding LookupEnvironment boolean) line: 174	PackageBinding.getTypeOrPackage(char[]) line: 190	MethodScope(Scope).getTypeOrPackage(char[] int boolean) line: 3296	MethodScope(Scope).getType(char[]) line: 3008	SingleTypeReference.getTypeBinding(Scope) line: 54	SingleTypeReference(TypeReference).internalResolveType(Scope) line: 468	SingleTypeReference(TypeReference).resolveType(BlockScope boolean) line: 555	MethodScope(Scope).connectTypeVariables(TypeParameter[] boolean) line: 935	SourceTypeBinding.resolveTypesFor(MethodBinding) line: 1793	SourceTypeBinding.methods() line: 1467	SourceTypeBinding.faultInTypesForFieldsAndMethods() line: 855	CompilationUnitScope.faultInTypes() line: 424	CompilationUnitResolver.resolve(CompilationUnitDeclaration ICompilationUnit NodeSearcher boolean boolean boolean) line: 1201	CompilationUnitResolver.resolve(ICompilationUnit IJavaProject List NodeSearcher Map WorkingCopyOwner int IProgressMonitor) line: 693	ASTParser.internalCreateAST(IProgressMonitor) line: 1187	ASTParser.createAST(IProgressMonitor) line: 813	ASTProvider$1.run() line: 548	SafeRunner.run(ISafeRunnable) line: 42	ASTProvider.createAST(ITypeRoot IProgressMonitor) line: 541	ASTProvider.getAST(ITypeRoot SharedASTProvider$WAIT_FLAG IProgressMonitor) line: 484	SharedASTProvider.getAST(ITypeRoot SharedASTProvider$WAIT_FLAG IProgressMonitor) line: 132	SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(ITypeRoot ITextSelection IProgressMonitor) line: 170	SelectionListenerWithASTManager$PartListenerGroup$3.run(IProgressMonitor) line: 155	Worker.run() line: 53	we could conclude that a non-generic type is a generic type and createraw versions of it.This is because ClassScope.buildType() calls PackageBinding.addType() toadd the new source type that is being built *before* its type variables arebuilt. These type variables are consulted by frame 0 i.e SourceTypeBinding.kind()which reads:if (this.typeVariables != Binding.NO_TYPE_VARIABLES) return Binding.GENERIC_TYPE;since this.typeVariables is still null and not initialized with eitherthe special value Binding.NO_TYPE_VARIABLES or to the built type variablesin the case of generic type we would confuse a non-generic type to bea generic type and create raw versions of it.This results various type incompatibilities down the road between List<Type#Raw> and List<Type>For example while building JRE8 from the sources we obsreve errors ofthe form:Type mismatch: cannot convert from List<GarbageCollectorMXBean> to List<GarbageCollectorMXBean>	ManagementFactory.java	/JDK Source/src/java/lang/management	line 415	Java ProblemType mismatch: cannot convert from List<MemoryManagerMXBean> to List<MemoryManagerMXBean>	ManagementFactory.java	/JDK Source/src/java/lang/management	line 399	Java ProblemType mismatch: cannot convert from List<MemoryPoolMXBean> to List<MemoryPoolMXBean>	ManagementFactory.java	/JDK Source/src/java/lang/management	line 386	Java Problem"
428261,2/15/2014 13:14,srikanth_sankaran,"[1.8][compiler] Incorrect error: No enclosing instance of the type X is accessible in scope The following program should compile but is presently rejected:// --interface I {	X foo(int a);}public class X {	public static void main(String[] args) {		String s = ""Blah"";		class Local extends X {			Local(int a) {				System.out.println(a);				System.out.println(s);			}		}		I i = Local::new; // Incorrect error here. i.foo(10);	}}Point is Local being in static context does not have an enclosing instance."
428285,2/16/2014 5:05,srikanth_sankaran,"[1.8][compiler] ECJ fails to recognize ? super Object == { Object } The following program refuses to compile with ECJ in all modes and compileswith JDK in all modes. There is no type safety compromise here:// --class Reference<T> {	ReferenceQueue<? super T> queue;}class ReferenceQueue<T> {}public class X { public static void main(String args[]) { Reference<Object> r = null; ReferenceQueue<Object> q = r.queue; }}This is blocking ECJ8 from building JRE8."
428305,2/16/2014 15:14,srikanth_sankaran,[1.8][compiler] Various loose ends in Diamond inference implementation Using this CR as the home I'll shortly release a patch that fixes a bunch of loose ends with the present synthetic static factory based <> inference. Manyof these problems show up while building JRE8 from source zip.Basically - Type variables from enclosing types are not handled correctly. - Rawness of enclosing type is lost (static nested generic class sees its outer as raw.) - Certain scenarios result in NPEs while diagnosing redundant type argument specification. - Outer rawness gets dropped during substitutions - Static factory method's return type is not encoded properly.These problems do not affect the most common scenarios but are importantenough to fix because these impact the inference in non so uncommon scenarios.
428381,2/17/2014 17:18,david_williams,"[BETA_JAVA8] Should org.eclipse.jdt.junit be included in 4.3.2 patch? I'm opening this bug to continue/finish the discussion from bug 426543 comment 19 +/- a few comments.Even in the most recent X-build http://build.eclipse.org/eclipse/builds/4X/siteDir/eclipse/downloads/drops4/X20140217-0938/... which uses latest compiler version3.9.2.v20140216-2054The same JUnitStubUtility.class shows up as different as a result of using the new Beta Java 8 compiler. http://build.eclipse.org/eclipse/builds/4X/siteDir/eclipse/downloads/drops4/X20140217-0938/buildlogs/comparatorlogs/buildtimeComparatorUnanticipated.log.txtSo the alternatives are: A. The difference is actually a bug in JDT compiler? -- in this case org.eclipse.jdt.junit does not need to be included in the patch and the compiler just needs to be fixed. B. The difference is an intentional important change produced by the JDT compiler. -- In this case the version of the org.eclipse.jdt.junit bundle should be increased and it should be included in the ""patch feature"". C. It's just noise and really does not effect functioning of that ""JUnitStubUtility"" class. -- In this case it could go either way. Functionally it would not have to be included but my preference would be to go ahead and do ""B"" above just to be sure all our byte codes match what the compiler produces."
428384,2/17/2014 19:24,noopur_gupta,[1.7][typing] Wrong indentation after empty type arguments (i.e. <>) The default Java formatter seems to handle empty type arguments incorrectly if the second part of an assignment is placed after a newline.Steps to reproduce 1. Launch Eclipse create workspace and new Java project 2. Keep using the default formatter settings 3. Create a new class with a method. 3. Enter the following code fragment into the just created method: List<String> wrong = new ArrayList<>(); System.out.println( wrong ); 4. Select entire file press Ctrl+i for correct indentationExpected outcome: No changeActual outcome: List<String> wrong = new ArrayList<>(); System.out.println( wrong ); // Incorrect indentationReproducibility: AlwaysEclipse versions: 4.3.1-5 for Fedora 19 (32 bit) Every recent build of 4.3.1 for Windows 64-bitWorkaround (which I don't like a lot): List<String> wrong = new ArrayList<>(); System.out.println( wrong );ByeG.
428388,2/17/2014 22:12,srikanth_sankaran,"[1.8][compiler] Casting to primitives is over tolerant - probable regression since bug 428274 We have started accepting the following:// --public class X { public static void main(String[] args) {	int x = (int) ""Hello""; }}probably due to the fix for https://bugs.eclipse.org/bugs/show_bug.cgi?id=428274being too permissive - certain provably impossible false are not rejected."
428468,2/18/2014 12:41,jarthana,[1.8][compiler] Finishing touches for Java 8 release. I wanted to capture the finishing touches in this ticket so we don'tgoof up and miss something in the last stages. This is to be taken uppost RC2 (March 7th 2014) Here is the list I came up with:Core + APT: 1. Remove JCP disclaimer from all files. 2. Update @since 3.9 BETA_JAVA8 tags with appropriate values. 3. Does bundle versions/qualifier need change ? 4. Check if batch compiler version strings need to bumped up. 5. Build state identifier needs bump up ? 6. Make BETA_JAVA8 the master branch.UI: 7. Do what is applicable from 1-6. 8. Change compliance string from 1.8_BETA to 1.8 9. Remove JCP disclaimer from dialog boxes.10. Open up a bottle of champagne :)
428522,2/19/2014 5:34,srikanth_sankaran,"[1.8] VerifyError when a non primitive type cast to primitive type To reproduce run the following code with ""Preserve unused local variables"" option turned off:public class X { public static void main(String args[]) { 	long l = (long) ((Object) 100L); }}This is a recent regression."
428524,2/19/2014 5:39,srikanth_sankaran,"[1.8][compiler] NPE when using JSE8 Class Constructor ref ""TheClass::new"" and ""TheClass"" is using default no-arg constructor Created attachment 240103Example class and NPE Stack in Event DetailsWhen using a Class Constructor Ref ""TheClass::new"" and ""TheClass"" is using a default no-arg constructor the JDT fails with NPE.java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.lookup.SyntheticMethodBinding.<init>(SyntheticMethodBinding.java:385)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.addSyntheticFactoryMethod(SourceTypeBinding.java:687)when using 		Supplier<WithoutNoArgConstructor> error = WithoutNoArgConstructor::new;		System.err.println(error.get());...	private static class WithoutNoArgConstructor {	}"
428526,2/19/2014 5:42,srikanth_sankaran,[1.8] API to get the single abstract method in a functional interface An API could be provided in ITypeBinding to get the single abstract method (SAM) of a functional interface type corresponding to the internal implementation of ReferenceBinding#getSingleAbstractMethod and relevant checks from ReferenceBinding.isFunctionalInterface.The API ITypeBinding#isFunctionalInterface can be replaced with the new API returning SAM and at the client side a null check for SAM will tell if the type is a functional interface.The new API will help in avoiding with these checks at the client in the interface hierarchy (JSR 335 - 9.8 Functional Interfaces):- excluding methods that are also public methods in Object.- The signature of m is a subsignature (8.4.2) of every method's signature in M.- m is return-type-substitutable (8.4.5) for every method in M.See also bug 424509.
428552,2/19/2014 9:23,srikanth_sankaran,"[1.8][compiler][codegen] Serialization does not work for method references For lambdas created using a method reference of the form Type::MethodName instead of a lambda expression of the form (arg)->expression the Serialization does not work.They will be compiled like non-Serializable lambdas ignoring if the functional interface extends Serializable.import java.io.*;public class SimpleTestCase {	interface Example extends Serializable	{		String convert(Object o);	}	public static void main(String[] args) throws IOException {		Example e=Object::toString;		try(ObjectOutputStream os=new ObjectOutputStream(new ByteArrayOutputStream())) {			os.writeObject(e);		}	}}ProducesException in thread ""main"" java.io.NotSerializableException: Non-serializable lambda	at SimpleTestCase$$Lambda$1/2536472.writeObject(Unknown Source)"
428642,2/20/2014 8:11,aclement,"[1.8][compiler] java.lang.IllegalArgumentException: Invalid lambda deserialization exception From https://bugs.eclipse.org/bugs/show_bug.cgi?id=428552#c3:The following program throws an exception when executed:import java.io.*;import java.util.function.IntConsumer;public class QuickSerializedLambdaTest {	interface X extends IntConsumerSerializable{}	public static void main(String[] args) throws IOException ClassNotFoundException {		X x1 = i -> System.out.println(i);// lambda expression		X x2 = System::exit; // method reference		ByteArrayOutputStream debug=new ByteArrayOutputStream();		try(ObjectOutputStream oo=new ObjectOutputStream(debug))		{			oo.writeObject(x1);			oo.writeObject(x2);		}		try(ObjectInputStream oi=new ObjectInputStream(new ByteArrayInputStream(debug.toByteArray())))		{			X x=(X)oi.readObject();			x.accept(42);// shall print ""42""			x=(X)oi.readObject();			x.accept(0);// shall exit		}		throw new AssertionError(""should not reach this point"");	}}"
428735,2/21/2014 8:22,srikanth_sankaran,"[1.8][assist] Missing completion proposals inside lambda body expression - other than first token Completion is missing at ""|"":class Person { String getLastName() { ... }}...void test1 (List<Person> people) { // want to see getLastName(): people.stream().forEach(p -> System.out.println(p.|)); // NOK}In the next example completion works OK:void test2(List<Person> people) { people.sort((xy) -> x.|); // OK}but when I continue the second attempt yields nothing:void test2(List<Person> people) { people.sort((xy) -> x.getLastName().compareTo(y.|)); }If there's a pattern behind it could be- completion works on the initial token of a lambda body- completion fails on tokens nested in some expression inside a lambda bodymore failing examples: people.sort((xy) -> x.getLastName()+y.|); people.sort((xy) -> """"+x.|); At first I thought this might be limited to type elided lambdas but adding parameter types doesn't seem to help (didn't test all cases)."
428741,2/21/2014 8:51,noopur_gupta,"[1.8][quick assist] convert method reference expression to lambda Now that bug 427169 works nicely (thanks!) ""wouldn't it be cool"" if the next level of conversion be supported too:from people.map(Person::getLastName)to people.map(p -> p.getLastName())This direction shouldn't require too much analysis (just needs a new name 'p').The opposite direction would be even cooler but for that you'd need to analyse which lambdas are amenable to this conversion. That could be tricky.I believe such quick assists would be highly educational for J8 newbies :)"
428795,2/21/2014 14:36,srikanth_sankaran,[1.8]Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123) I am getting anInternal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)with this code:import java.net.NetworkInterface;import java.util.Optional;public class Tutego{ public static void main( String[] args ) { Optional.ofNullable( NetworkInterface.getByIndex( 2 ) ).ifPresent( ni -> { Optional.ofNullable( ni.getDisplayName() ).ifPresent( name -> System.out.println( name.get().toUpperCase() ) ); } ); }}
428811,2/21/2014 18:44,srikanth_sankaran,"[1.8][compiler] Type witness unnecessarily required Eclipse Java Development Tools Patch for Java 8 Support (BETA)	1.0.0.v20140221-1402JDK 8 b129 64-bit-----import java.util.AbstractList;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.List;import java.util.stream.Collector;public class MoreCollectors { public static void main (String[] args) { ImmutableList<String> list = Arrays.asList(""a"" ""b"" ""c"").stream().collect(toImmutableList()); System.out.println(list); } public static <T> Collector<T ? ImmutableList<T>> toImmutableList () { return Collector.of(ArrayList<T>::new List<T>::add (left right) -> { left.addAll(right); return left; } ImmutableList::copyOf); } private static class ImmutableList<T> extends AbstractList<T> { public static <T> ImmutableList<T> copyOf (Collection<T> c) { return new ImmutableList<>(c.toArray()); } private Object[] array; private ImmutableList (Object[] array) { this.array = array; } @Override @SuppressWarnings(""unchecked"") public T get(int index) { return (T)array[index]; } @Override public int size() { return array.length; } }}-----The Eclipse compiler requires the Collector.of method in toImmutableList to have a type witness of <T List<T> ImmutableList<T>> to compile while the JDK8 compiler does not. I'm not 100% sure whether it should be required but I would think javac is correct.(If you're wondering I'm using Guava's ImmutableList. I made the one here to keep the example self-contained.)"
428845,2/23/2014 10:19,sasikanth.bharadwaj,"eclipse compiler does not flag ambiguous method call in some cases Not sure if this is a dup of bug 340506 or bug 427719 but here is a small example where eclipse fails to report ambiguous method invocation. Almost looks like jdt compiler is confused about newAbstractClass() return type and uses IInterface interface instead of AbstractClass abstract class. The error is correctly flagged by javacTested with eclipse 4.4M5 (I20140123-1600) and javac from jdk 1.7.0_45-b18 on command line.-------------------------------------package ambiguous;import java.io.File;public class AmbiguousTets { static interface IInterface { public void method(File file); } static abstract class AbstractClass implements IInterface { public void method(File file) { System.err.println(""file""); } public void method(String string) { System.err.println(""string""); } } private static AbstractClass newAbstractClass() { return new AbstractClass() {}; } public static void main(String[] args) { // this should be flagged as ambiguous but is not // correctly reported by javac as an error newAbstractClass().method(null); }}-------------------------------------"
428856,2/23/2014 19:34,noopur_gupta,"[1.8][extract method] Extracted method adds an additional throws clause which result in compiler error Consider the below code snippet:package p1;public interface Change<T R E extends Exception> {	R apply(T t) throws E;	default <V> Change<V R E> from(Change<? super V ? extends T E> before) {		// extract method		return /**/(V v) -> apply(before.apply(v));/**/	}}Invoke Extract method on ""(V v) -> apply(before.apply(v));""The resultant code after refactoring has compiler error: ""Unhandled exception type E"""
428862,2/23/2014 23:56,sarika.sinha,"[1.8] Unable to install breakpoint Using Kepler SR2 + Java 8 RC1 + Eclipse Java Development Tools Patch for Java 8 Support (BETA) 1.0.0.v20140223-2022 consider the below code snippet:package p1;import java.io.*;import java.util.function.IntConsumer;public class QuickSerializedLambdaTest {	interface X extends IntConsumerSerializable{}	public static void main(String[] args) throws IOException ClassNotFoundException {		X x1 = i -> System.out.println(i);// lambda expression		X x2 = System::exit; // method reference		ByteArrayOutputStream debug=new ByteArrayOutputStream();		try(ObjectOutputStream oo=new ObjectOutputStream(debug))		{			oo.writeObject(x1); // TODO: Add breakpoint in this line			oo.writeObject(x2);		}		try(ObjectInputStream oi=new ObjectInputStream(new ByteArrayInputStream(debug.toByteArray())))		{			X x=(X)oi.readObject();			x.accept(42);// shall print ""42""			x=(X)oi.readObject();			x.accept(0);// shall exit		}catch(Exception e){			e.printStackTrace();		}		throw new AssertionError(""should not reach this point"");	}}Add a breakpoint inside the main method and debug as Java Application. When the breakpoint is hit a popup dialog is displayed saying: ""Unable to install breakpoint in p1.QuickSerializedLambdaTest$X due to missing line number attributes. Modify compiler options to generate line number attributes.Reason:	Absent Line Number Information""As mentioned in bug 135027 executed ""javap -l"". Below is the result:Compiled from ""QuickSerializedLambdaTest.java""public class p1.QuickSerializedLambdaTest { public p1.QuickSerializedLambdaTest(); LineNumberTable: line 5: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lp1/QuickSerializedLambdaTest; public static void main(java.lang.String[]) throws java.io.IOException java.lang.ClassNotFoundException; LineNumberTable: line 8: 0 line 9: 6 line 10: 12 line 11: 20 line 11: 26 line 13: 36 line 14: 42 line 15: 48 line 16: 107 line 16: 113 line 18: 133 line 19: 143 line 20: 152 line 21: 162 line 22: 170 line 23: 231 line 25: 236 LocalVariableTable: Start Length Slot Name Signature 0 246 0 args [Ljava/lang/String; 6 240 1 x1 Lp1/QuickSerializedLambdaTest$X; 12 234 2 x2 Lp1/QuickSerializedLambdaTest$X; 20 226 3 debug Ljava/io/ByteArrayOutputStream; 36 37 6 oo Ljava/io/ObjectOutputStream; 133 62 6 oi Ljava/io/ObjectInputStream; 143 27 7 x Lp1/QuickSerializedLambdaTest$X; 231 5 4 e Ljava/lang/Exception;}Why is this dialog coming up?"
428863,2/24/2014 0:11,david_williams,new branding icon for JDT Created attachment 240243patch filefrom bug 426260some branding bundles have/had both eclipse32.png and eclipse32.gif but I think we only need eclipse32.png?
428894,2/24/2014 6:47,akurtakov,Unify antrun plugin version used. In org.eclipse.jdt.core version for maven-antrun-plugin is not specified which makes maven resolve based on the version specified in maven parent pom which currently is version 1.4. In org.eclipse.jdt.compiler.apt and org.eclipse.jdt.compiler.tool maven-antrun-plugin is specified to be version 1.7 and I think it would be good to set the version in org.eclipse.jdt.core to 1.7 too so build relies on the same version of the antrun plugin.
428965,2/24/2014 20:08,noopur_gupta,"[pull up] Non public method when pulled up to interface creates protected method When a non-public method from a class is pulled up to an interface a protected method is created in the interface and hence results in compiler error in both source and destination files.package com.p1;public interface I {}package com.p2;import com.p1.I;public class C1 implements I{	private String foo() { // Pull up to I		return null;	}}Two points to be taken care off;1. When a method is pulled up to an interface the method should be made public.2. Since the overriding method cannot reduce the visibility of the inherited method the method in C1 also should be changed to public visibility."
429012,2/25/2014 9:28,manpalat,"[1.8][search] Add finegrain (limitTo) option for method reference expressions The search engine should support a new 'limitTo' option in IJavaSearchConstants to limit matches to Java-8-style method reference expressions.E.g. only one reference to Integer#toHexString(int) should be found in this code when the flag is set:	Function<Integer String> hexer= Integer::toHexString; // yep	System.out.println(hexer.apply(666));	System.out.println(Integer.toHexString(666)); // nope"
429043,2/25/2014 10:14,thanh.ha,Update Gerrit permissions for JDT repos Per bug 418966 I'd like to start deploying new Gerrit permission sets to all JDT repos as described in bug 418966 comment 14. This would affect all the repos listed below.eclipse.jdt.core.binaries.giteclipse.jdt.core.giteclipse.jdt.debug.giteclipse.jdt.giteclipse.jdt.ui.git
429110,2/26/2014 3:22,markus.kell.r,"[1.8][quick fix] Hovering over the error does not show the quick fix Copied from bug 427122 comment #9:When the Java project was on 1.6 hovering over the error marker on @NonNull did not show the Quick Fix for the below scenario:package test1;import java.lang.annotation.ElementType;import java.lang.annotation.Target;import java.util.List;public class CheckCompiler {	@Target(ElementType.TYPE_USE)	static @interface NonNull { }	List<@NonNull String> foo(List<@NonNull String> arg) {		return arg;	}}If we use ""Ctrl+1' to invoke the Quick Fix then the fix was available.On analysis found that when we invoke Quick Fix(Ctrl+1) JavaCorrectionProcessor#computeQuickAssistProposals is invoked which collects all the problem ids and suggest the proposal but when we hover JavaCorrectionProcessor#collectCorrections is invoked with just one problem Id and that id (IProblem.DisallowedTargetForAnnotation) we are suppressing currently."
429112,2/26/2014 3:35,srikanth_sankaran,[1.8][compiler] Exception when compiling Serializable array constructor reference Compiling the following code causes an exception inside the compiler:import java.io.Serializable;import java.util.function.IntFunction;public class ArrayConstructorReference{ interface IF extends IntFunction<Object> Serializable {} public static void main(String[] args) { IF factory=String[]::new; }}producesErrors occurred during the build.Errors running builder 'Java Builder' on project '??'.org.eclipse.jdt.internal.compiler.lookup.ArrayBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ReferenceBindingNote that this problem only occurs when the functional interface is Serializable.
429262,2/27/2014 13:28,srikanth_sankaran,[1.8][code select] Hover/navigation support at -> and :: From https://bugs.eclipse.org/bugs/show_bug.cgi?id=425134#c0:I have extracted ---------- CodeSelect should resolve the lambda element when the caret is on the '->'. Currently there's no easy way to see the contract of the functional interface method that the lambda implements. We should show a Javadoc hover for lambdas.------into the present ER.This is unrelated to the requirement in that bug - see that the model elementneeded to be returned when hovering on -> or :: is the one for the SAM and not the lambda.i.e we would treat it somewhat analogous to hovering on a message send and showthe binding that corresponds to the method.We need enablement from UI : presently ICodeAssist.codeSelect is not invokedapparently when the cursor is not an identifier. I'll raise a bug shortly.
429279,2/27/2014 21:52,manpalat,[1.8][index] Java 8 search support degrades indexing performance. Manoj has collected some profiles that show that ~70% of time spentin indexing goes into the new method SourceIndex.indexedResolvedDocument.We need to find ways to speed this up:Some obvious candidates looking at the profile (Manoj - please attach) - Disabling task tag processing - Setting a bit in those methods that have a functional type and onlypopulating those methods's bodies in the parse tree (others will have theskeleton built by diet parser)etc.
429340,2/28/2014 12:41,markus.kell.r,"[content assist] No Javadoc proposals anywhere before @deprecated tag 4.4.0.I20140225-1430Content assist doesn't show any Javadoc proposals after ""@see #"" when the next line is ""@deprecated"" e.g. here:/** * * @see # * @deprecated */public class Depr {	public void foo() { }}"
429387,3/1/2014 13:01,srikanth_sankaran,"[1.8][compiler] AIOOBE in AbstractMethodDeclaration.createArgumentBindings This non-compiling method snippet copy-pasted from a larger class still causes the same ArrayIndexOutOfBoundsExceptions being thrown. Easiest reduction by far ever! The code:package aioobe_oejica_AbstractMethodDeclaration_createArgumentBindings_line_107;import java.util.function.BiFunction;import java.util.function.Supplier;import java.util.function.ToIntFunction;import java.util.stream.IntStream;import java.util.stream.Stream;public interface Foo {static <BT T extends BT IS extends IntStream E extends Exception> IntStreamy<E>internalFlatMapToInt(Functionish<BT IS E> mapperClass<E> classOfESupplier<Stream<T>> maker) {BiFunction<Stream<T> ToIntFunction<BT> IntStream> func = (Stream<T> t ToIntFunction<BT IS> m) -> t.flatmmapToInt(m);return IntStreamy.fromFlatMap(func mapper classOfE maker);}}The installation:eclipse.buildId=4.4.0.I20140123-1600java.version=1.8.0java.vendor=Oracle CorporationBootLoader constants: OS=win32 ARCH=x86_64 WS=win32 NL=en_USCommand-line arguments: -os win32 -ws win32 -arch x86_64 -data C:\Users\Timo\workspaceThe stack trace:java.lang.ArrayIndexOutOfBoundsException: 0	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.createArgumentBindings(AbstractMethodDeclaration.java:107)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.resolveType(LambdaExpression.java:393)	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:251)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:623)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:533)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:591)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1208)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:549)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:542)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:485)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
429395,3/2/2014 0:51,manpalat,[1.8][compiler] TypeSystem.getParameterizedType() method is expensive Created attachment 240434Hierarchical perf figures rooted at getParameterizedType()27% of the total time for build was found to be spent inside this function hierarchy. On its own this function accounts for 11%. To reduce to whatever possible.
429399,3/2/2014 3:47,manju656,"[1.8][quick fix] Missing import quick fix for IProblem.UndefinedName We don't report IProblem.undefinedType but report UndefinedName becausethe grammar does not allow us to discriminate.// --import java.util.Arrays;import java.util.List;import java.util.function.Function;public class X { public static void main (String[] args) { Function<List<String> String> func = ArrayList::toString; System.out.println(func.apply(Arrays.asList(""a"" ""b""))); }}"
429419,3/2/2014 16:11,manju656,"Import declarations now hidden by default doc (tutorial) not updated. Java Development User Guide > Getting Started > Basic Tutorial > Editing Java elements > Organizing import statements says""Delete the import declarations by selecting them in the Outline view ...""but they aren't there anymore. This was mentioned in a forum post 28.11.2012 where Dani Megert promptly replied saying they're now hidden by default and requesting a bug be filed against the doc. I just ran into this in build 4.3.0.M20130911-1000. I couldn't find a bug so I'm filing one.Please see forum:http://www.eclipse.org/forums/index.php/mv/msg/440736/987918/#msg_987918 andhttp://www.eclipse.org/forums/index.php/mv/msg/440736/987885/#msg_987885Paul RobinsonP.S. Just downloaded eclipse.buildId=4.3.2.M20140221-1700 and checked. Problem is still there."
429425,3/2/2014 19:05,manju656,Tutorial Documentation Inconsistency: Java development user guide > Getting Started > Basic Tutorial > Editing Java elements > Extracting a new method Java development user guide > Getting Started > Basic Tutorial > Editing Java elements > Extracting a new method 1. shows... addTestMethod(methods[i] names constructor); ...while the screenshot under 2. and the actual source we work with has... addTestMethod(methods[i] names theClass); ...Paul
429430,3/3/2014 3:23,srikanth_sankaran,"[1.8] Lambdas and method reference infer wrong exception type with generics (RuntimeException instead of IOException) See below for code. It compiles in JDK 8 build 129 but fails to compile in JDT with the error message ""Unhandled exception type IOException"".Based on the quick-fix suggestions JDT seems to have inferred X as RuntimeException.CAVEAT: I do not know if the ""broken"" lines adhere to the spec so it's possible the JDK is in error.java version ""1.8.0""Java(TM) SE Runtime Environment (build 1.8.0-b129)Java HotSpot(TM) Server VM (build 25.0-b69 mixed mode)Eclipse version:Version: Kepler Service Release 2Build id: 20140224-0627Eclipse Java Development Tools Patch for Java 8 Support (BETA)1.0.0.v20140302-1952org.eclipse.jdt.java8patch.feature.groupInclude jdt.annotation 2.0 support in patch feature.1.0.0.v20140220-1916org.eclipse.jdt.a2.java8patch.feature.groupEclipse Plug-in Development Environment Patch for Java 8 Support (BETA)1.0.0.v20140228-2041org.eclipse.pde.java8patch.feature.groupimport java.io.*;public class Main { public static interface Closer<T X extends Exception> { void closeIt(T it) throws X; } public static <T X extends Exception> void close( Closer<T X> closer T it ) throws X { closer.closeIt(it); } public static void main(String[] args) throws IOException { InputStream in = null; close( x -> x.close() in ); // eclipse: NO javac: YES close( InputStream::close in ); // eclipse: NO javac: YES close( (Closer<InputStream IOException>)InputStream::close in ); // eclipse: YES javac: YES // JDT reports: ""Unhandled exception type IOException"" in ""NO"" cases }}"
429435,3/3/2014 3:58,srikanth_sankaran,"[1.8][search]Hierarchy search for lambda expressions do not show all the lambda expressions interface I { public int doit();}public class X { @SuppressWarnings(""unused"")void zoo() {	 I i = () /*1*/-> { I i2 = () /*2*/-> Y.foo(() -> Y.foo(()->Y.foo(()->10))); final Y y = new Y() { 		@Override 		public int doit() { 			I i = () -> 10; 			return i.doit(); 		} }; return 0; }; }} class Y implements I{	static int foo(I i) { return 0;}	@Override	public int doit() {		// TODO Auto-generated method stub		return 0;	}	 }/* Press F4 for I and check out the lambdas listed. same LEs are highlighted multiple times in the expression: I i2 = () /*2*/-> Y.foo(() -> Y.foo(()->Y.foo(()->10))); */"
429498,3/3/2014 14:17,manju656,"[1.8][refactoring] Change Method Signature refactoring breaks lambda interface I { public void doit();}public class X {	I i = () -> {};}Change I.doit()'s signature - the lambda does not compile anymore.Now that declarations in hierarchy correctly tags the lambda as implementingI.doit expectation is that this should work."
429537,3/4/2014 3:33,srikanth_sankaran,"[1.8][hierarchy]NPE in hierarchy resolution public class X extends Y { public static void main(String [] args) {	I<Y> c = () /* foo */ -> () /* bar */ -> {};	I<Y> y = args.length < 1 ? (() /* true */-> 42) : (() /* false */ -> 23);	Object o = (I) () /* cast */ -> 42;	}}interface I<T> {	public T foo();}class Y {	public void bar() {}}/* Code has errors - these errors are required to get the bug reproduced */Press F4 for I and NPE with the following stack occurs:java.lang.NullPointerException	at org.eclipse.jdt.internal.core.LambdaExpression.<init>(LambdaExpression.java:41)	at org.eclipse.jdt.internal.core.util.HandleFactory.createElement(HandleFactory.java:217)	at org.eclipse.jdt.internal.core.util.HandleFactory.createLambdaTypeElement(HandleFactory.java:171)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.rememberAllTypes(HierarchyResolver.java:492)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:824)	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.buildForProject(IndexBasedHierarchyBuilder.java:227)	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.buildFromPotentialSubtypes(IndexBasedHierarchyBuilder.java:307)	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:132)	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:301)	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1268)	at org.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyLifeCycle.doHierarchyRefresh(TypeHierarchyLifeCycle.java:336)	at org.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyLifeCycle.doHierarchyRefreshBackground(TypeHierarchyLifeCycle.java:271)	at org.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyLifeCycle$2.run(TypeHierarchyLifeCycle.java:224)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
429555,3/4/2014 5:21,srikanth_sankaran,[1.8][inference] see if we can avoid side effects inside Scope.compatibilityLevel18FromInner() In order to check parameter compatibility the method compatibilityLevel18FromInner may perform inner inference and if successful calls innerPoly.updateBindings(..). Since at this point selection of the most specific method for the outer invocation hasn't happened we should try to avoid this side effect. But then we need to ensure that final binding update always happens for all inners.
429635,3/5/2014 3:00,manpalat,Improve x-internal API error message Currently if I use an API release as x-internal I get the following error message:Discouraged access: The method ..... from the type .... is not accessible due to restriction on required project ....This is always confusing to the participants of my plug-in and RCP training sessions.Can we change it to something like:Discouraged access: The method ..... from the type .... is not released as official API in project ....
429641,3/5/2014 4:23,jarthana,IMethod should expose isLambdaMethod() public API IMethod should expose a public API like isLambda() to know if a method is of the LambdaMethod
429738,3/6/2014 3:20,manpalat,"[1.8][search] Find Declarations (Ctrl + G) shows no result for type-less lambda parameter package one.test;@FunctionalInterfaceinterface Foo {	int foo(int x);}public class T {	// Select 'x' in lambda body and press Ctrl+G.	Foo f1= x -> x; //[1]	Foo f2= (int x) -> x; //[2]}------------------------------------------------------ Select 'x' in lambda body.- Go to the menu: Search > Declarations > Workspace. Or press Ctrl+G.- Works at [2] but shows no result at [1]."
429749,3/6/2014 5:06,manpalat,[1.8][search] Enable the disabled 308 tests in JavaSearchBugs8Tests some of the test cases of bug 400899 are disabled currently. Enable the following test cases: test400899g181922. Remove incorrect tests. and correct and output to the rest.
429759,3/6/2014 7:33,srikanth_sankaran,"[1.8][compiler] Lambda expression's signature matching error Hi one more finding (jdk8 compiles eclipse not):public class Main {	public static void main(String[] args) {		// *		// * ERROR MESSAGE:		// * Lambda expression's signature does not match		// * the signature of the functional interface method get()		// *		final int i = new Test<Integer>().test("""" (String s) -> 1);	}	static class Test<R> {		<T> R test(T t Supplier<R> s) {			return s.get();		}		<T> R test(T t Function<T R> f) {			return f.apply(t);		}	}}"
429763,3/6/2014 7:51,srikanth_sankaran,"[1.8][compiler] Incompatible type specified for lambda expression's parameter stumbled upon this one...public class Main {	public static void main(String[] args) {				// does not compile		final int i = new Test<Integer>().test((Byte b) -> (int) b);			}		static class Test<R> {				<T> R test(Function<TR> f) {			return null;		}			}	}"
429771,3/6/2014 9:04,Michael_Rennie,[1.8] Update bundle version numbers to require Java 8 version of JDT core Since we are using new APIs from jdt.core we need to update the minimum required version of jdt.core to the version that contains the new APIs being used.
429812,3/6/2014 14:12,jarthana,"[1.8][model] Signatures returned by lambda IMethod APIs should be dot-based The signatures returned by lambda IMethod APIs should be dot-based. Currently getReturnType() and getParameterTypes() return slash-based signatures.This needs to be fixed to make Javadoc hovers on Lambda expressions work (once codeSelect on ""->"" returns the lambda method and not the SAM).Example:interface I {	/**	 * Does it! Really.	 * @param number the int	 * @param str the String	 */	Object doit(int number String str);}class X { I i = (i s) -> { return null; };}E.g. use the JavaElement view to inspect the local variable ""s"" and then check its declaring member.- second parameter type is ""Ljava/lang/String;"". Should be ""Ljava.lang.String;"".- return type is ""Qjava/lang/Object;"" which is wrong. An unresolved signature (""Q"") cannot be qualified. Should be ""Ljava/lang/Object;""- please also check the other API methods"
429832,3/6/2014 21:06,mateusz.matela,[formatter] Function call with 1 argument not line wrapped when Wrap all elements on new lines is in use A nested function call with 1 argument is not line wrapped correctly when Formatter - Line Wrapping - Function calls - Arguments - Wrap all elements every element on a new line is used. Instead they remain stubbornly in place regardless of what the line length limit is set to. Nested functions called with 2 or more arguments work correctly and each argument gets a new line.Tested with eclipse-SDK-I20140306-1200-win32-x86_64. I will attach a workspace shortly that has the right settings for formatter which show the problem.
429833,3/6/2014 21:15,srikanth_sankaran,"[1.8][compiler] Missing types cause NPE in lambda analysis. From https://bugs.eclipse.org/bugs/show_bug.cgi?id=425152#c8--------------------------------------------package bug;interface I1 { int foo(String i); }class Y {	I1 i = (a) -> { 		a.charAt(0);	};}--------------------------------------------Place caret at end of ""String"" and press Backspace to delete 'g'.We get this exception:java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.MessageSend.analyseCode(MessageSend.java:123)	at org.eclipse.jdt.internal.compiler.ast.Block.analyseCode(Block.java:52)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.analyseCode(LambdaExpression.java:485)	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.analyseCode(FieldDeclaration.java:91)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.internalAnalyseCode(TypeDeclaration.java:703)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.analyseCode(TypeDeclaration.java:265)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.analyseCode(CompilationUnitDeclaration.java:122)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1211)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541)..."
429836,3/6/2014 22:32,manpalat,"[1.8][search] Search implementors in workspace does not show lambda expressions. F4 works fine in this case but (menu) Search + Implementors + Workspacebrings up nothing after selecting Foo.// --@FunctionalInterfaceinterface Foo {	int foo(int x);}public class T {	// Select 'x' in lambda body and press Ctrl+G.	Foo f1= x -> x; //[1]	Foo f2= (int x) -> x; //[2]}"
429845,3/7/2014 4:04,srikanth_sankaran,"[1.8] CCE on hover package pkg.test;@FunctionalInterfaceinterface FI {	int foo();}class C1 {	void fun1(int x) {		FI test= () -> {			for (int k=0;k<1;) ;			for (int k=0;k<1;) ;			try {							} catch (Exception ex) {							}			return 0;		};	}}---------------------------------------------------------------Hover over ""ex"" in catch clause. We get the following exception:java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.ast.ForStatement cannot be cast to org.eclipse.jdt.internal.compiler.ast.LambdaExpression	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeLambdaExpression(Parser.java:7975)	at org.eclipse.jdt.internal.codeassist.select.SelectionParser.consumeLambdaExpression(SelectionParser.java:765)	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6827)	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11023)	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.parseBlockStatements(AssistParser.java:1628)	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.parseBlockStatements(AssistParser.java:1466)	at org.eclipse.jdt.internal.codeassist.impl.Engine.parseBlockStatements(Engine.java:308)	at org.eclipse.jdt.internal.codeassist.impl.Engine.parseBlockStatements(Engine.java:271)	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:964)	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:163)	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:381)	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:375)	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:118)..."
429898,3/7/2014 12:35,Michael_Rennie,[1.8] Merge BETA_JAVA8 branch into master Tracks the work of merging the beta Java 8 work back into master.I created a BETA_JAVA8_LUNA branch off master and cherry-picked all the work into it: http://git.eclipse.org/c/jdt/eclipse.jdt.debug.git/log/?h=BETA_JAVA8_LUNA
429910,3/7/2014 15:31,jarthana,"[1.8][model] Superinterfaces of lambda element's IType are missing type arguments Created attachment 240672Patch 1Superinterfaces of lambda element's IType are missing type arguments. The effect of this is that method override computations in JDT UI fail (e.g. in Ctrl+T and to render Javadocs for the lambda IMethod).Example: Function<List<String> List<String>> sup = (arg) -> { return new ArrayList<>(arg); }; Function<List<String> List<String>> suppe = new Function<List<String> List<String>>() { @Override public List<String> apply(List<String> arg) { return new ArrayList<>(arg); } };IType#getSuperInterfaceTypeSignatures() on the IType for the lambda returns ""QFunction;"". This signature is missing type arguments.The corresponding anonymous type always returns the supertype via IType#getSuperclassTypeSignature(). Here it returns the correctly parameterized signature ""QFunction<QList<QString;>;QList<QString;>;>;"".For the lambda IType resolved supertypes would be also be better than unresolved ones.The attached patch fixes this but I don't really understand the difference between the LambdaExpression and ResolvedLambdaExpression types."
429934,3/8/2014 8:14,srikanth_sankaran,"[1.8][search] for references to type of lambda with 'this' parameter throws AIIOBE Search for references to the functional interface type of a lambda with an (illegal!) 'this' parameter throws AIIOBE.Search for references to type ""Function"" here:	Function<String String> f1= (String s Function this) -> s;	Function<String String> f2= (Function this String s) -> s;The line numbers in the stacktrace may not be accurate since I had some pending changes in my workspace. The AIOOBE happens in line	String signature = manager.intern(new String(lambdaExpression.descriptor.parameters[i].signature()));I think the ""length"" variable should be set to min(lambdaExpression.descriptor.parameters.lengthlambdaExpression.arguments.length). Note that ""length"" is currently written twice.!ENTRY org.eclipse.core.jobs 4 2 2014-03-08 14:06:23.938!MESSAGE An internal error occurred during: ""Java Search"".!STACK 0java.lang.ArrayIndexOutOfBoundsException: 1	at org.eclipse.jdt.internal.core.LambdaMethod.make(LambdaMethod.java:62)	at org.eclipse.jdt.internal.core.LambdaExpression.<init>(LambdaExpression.java:49)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.createHandle(MatchLocator.java:457)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2226)	at org.eclipse.jdt.internal.core.search.matching.MemberDeclarationVisitor.visit(MemberDeclarationVisitor.java:216)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.traverse(LambdaExpression.java:637)	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.traverse(FieldDeclaration.java:343)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2612)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2845)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2572)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1755)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1164)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1205)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1322)	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:122)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516)	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584)	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144)	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
429935,3/8/2014 9:20,srikanth_sankaran,"[1.8][compiler] NPE with reference to missing functional interface type This is a recent regression: // --public class X {	public static void main(String[] args) {		I i = (I s) -> s; 	} }results injava.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.lookup.MethodBinding.collectMissingTypes(MethodBinding.java:378)	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.missingTypeInLambda(ProblemReporter.java:6190)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.resolveType(LambdaExpression.java:425)	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:251)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:623)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:533)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:591)"
429948,3/8/2014 21:45,srikanth_sankaran,"[1.8][model] UnsupportedOperationException is thrown when a lambda expression is nested I use Eclipse Support for Java 8 (https://wiki.eclipse.org/JDT/Eclipse_Java_8_Support_(BETA)).Installation details: - Eclipse Java Development Tools Patch for Java 8 Support (BETA)	1.0.0.v20140308-1731 - Eclipse Plug-in Development Environment Patch for Java 8 Support (BETA)	1.0.0.v20140303-1740- Eclipse Standard/SDK	2.0.2.20140224-0000	epp.package.standardI can't run following code from Eclipse.This code works fine with JDK javac and java command.------------------------------------------------------------------------------------package xxx;import java.util.function.Supplier;public class Main {	public static void main(String[] args) {		execute(() -> {			executeInner(() -> {			});			return null;		});		System.out.println(""done"");	}	static <R> R execute(Supplier<R> supplier) {		return null;	}	static void executeInner(Runnable callback) {	}}------------------------------------------------------------------------------------eclipse.buildId=4.3.2.M20140221-1700java.version=1.8.0java.vendor=Oracle CorporationBootLoader constants: OS=macosx ARCH=x86_64 WS=cocoa NL=ja_JPFramework arguments: -product org.eclipse.epp.package.standard.product -keyring /Users/nakamura/.eclipse_keyring -showlocationCommand-line arguments: -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.standard.product -keyring /Users/nakamura/.eclipse_keyring -showlocationErrorSun Mar 09 11:20:45 JST 2014Unhandled event loop exceptionjava.lang.UnsupportedOperationException	at org.eclipse.jdt.internal.compiler.lookup.InferenceVariable.constantPoolName(InferenceVariable.java:50)	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.signature(ReferenceBinding.java:1734)	at org.eclipse.jdt.internal.core.LambdaMethod.make(LambdaMethod.java:54)	at org.eclipse.jdt.internal.core.LambdaExpression.<init>(LambdaExpression.java:47)	at org.eclipse.jdt.internal.core.util.HandleFactory.createElement(HandleFactory.java:217)	at org.eclipse.jdt.internal.core.util.HandleFactory.createElement(HandleFactory.java:216)	at org.eclipse.jdt.internal.core.util.HandleFactory.createLambdaTypeElement(HandleFactory.java:171)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.rememberAllTypes(HierarchyResolver.java:492)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:824)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:624)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyBuilder.buildSupertypes(HierarchyBuilder.java:116)	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:136)	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:301)	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1268)	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:741)	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:693)	at org.eclipse.jdt.internal.launching.JavaLaunchableTester.hasSuperclass(JavaLaunchableTester.java:467)	at org.eclipse.jdt.internal.launching.JavaLaunchableTester.test(JavaLaunchableTester.java:610)	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)	at org.eclipse.core.internal.expressions.IterateExpression.evaluate(IterateExpression.java:150)	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)	at org.eclipse.core.internal.expressions.WithExpression.evaluate(WithExpression.java:72)	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)	at org.eclipse.core.internal.expressions.EnablementExpression.evaluate(EnablementExpression.java:53)	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchShortcutExtension.evalEnablementExpression(LaunchShortcutExtension.java:287)	at org.eclipse.debug.ui.actions.ContextualLaunchAction.isApplicable(ContextualLaunchAction.java:295)	at org.eclipse.debug.ui.actions.ContextualLaunchAction.fillMenu(ContextualLaunchAction.java:218)	at org.eclipse.debug.ui.actions.ContextualLaunchAction$1.menuShown(ContextualLaunchAction.java:137)	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:255)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4166)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1466)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1489)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1474)	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1279)	at org.eclipse.jface.action.ActionContributionItem.copyMenu(ActionContributionItem.java:1268)	at org.eclipse.jface.action.ActionContributionItem.handleShowProxy(ActionContributionItem.java:1248)	at org.eclipse.jface.action.ActionContributionItem.access$4(ActionContributionItem.java:1237)	at org.eclipse.jface.action.ActionContributionItem$8.handleEvent(ActionContributionItem.java:1210)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4166)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1466)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1489)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1470)	at org.eclipse.swt.widgets.Menu.menuWillOpen(Menu.java:806)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5610)	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method)	at org.eclipse.swt.internal.cocoa.NSMenu.popUpContextMenu(NSMenu.java:77)	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:278)	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4089)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3644)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:140)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:611)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)	at org.eclipse.equinox.launcher.Main.run(Main.java:1450)"
429966,3/9/2014 18:14,srikanth_sankaran,"[1.8] CUD#functionalExpressions may record lambda copies in nested lambda situations From bug 429948 comment 5:Digging deeper the following root cause looks suspicious to me see this block in LE.resolveType():if (this.expectedType != null && this.original == this) { // final resolution.	this.ordinal = blockScope.referenceCompilationUnit().record(this);}This check misses the fact that we might be within a copy-resolve process of an enclosing lambda i.e. our entire universe is only fake still the current lambda is final resolved sure but still this final resolve in a fake universe shouldn't count and shouldn't be recorded in the CUD.In fact in test429948() the CUD contains 4 elements in CUD#functionalExpressions although the source has only two lambdas."
429969,3/9/2014 20:16,srikanth_sankaran,"[1.8][compiler] Possible RuntimeException in Lambda tangles ECJ [Eclipse 4.3.2 Jdk 1.8 build 132 BETA_JAVA8 1.0.0.v20140309-1413]ECJ does not compile the following class. I had to open it explicitly otherwise the Eclipse GUI did not complain. Jdk8 (b132) does compile and run it.import java.util.Arrays;import java.util.Optional;public class Test {	 public static void main(String[] args) { final String s = Arrays.asList(""test"").stream().reduce(null (s1s2) -> { // THE FOLLOWING LINE CAUSES THE PROBLEM require(s1 != null || s2 != null ""both strings are null""); return (s1 != null) ? s1 : s2; } (s1s2) -> (s1 != null) ? s1 : s2);	 System.out.println(s); } static void require(boolean condition String msg) throws RuntimeException { if (!condition) { throw new RuntimeException(msg); } }}ERROR MESSAGE: Type mismatch: cannot convert from Object to String"
429985,3/10/2014 5:40,srikanth_sankaran,"[1.8][compiler] Resolution of right method signature Using Eclipse 4.3.2 BETA_JAVA8 JDT plugins 1.0.0.v20140309-1413 Eclipse.org jdk1.8 build 132ECJ compiler fails with theERROR MESSAGE: ""The target type of this expression must be a functional interface"".This worked a few days before.Jdk8 compiles fine.import java.util.function.Supplier;public class Main {	public static void main(String[] args) {				// This does not compile with ECJ		test(() -> ""hi"");			}		// Note: when removing this code the main function compiles with ECJ	static void test(String message) {	}	static void test(Supplier<String> messageSupplier) {	}	}"
430015,3/10/2014 11:01,srikanth_sankaran,"[1.8] NPE trying to disassemble classfile with lambda method and MethodParameters NPE trying to disassemble classfile with lambda method and MethodParameters.------------------------------package jsr335.funint;import java.lang.reflect.Method;import java.lang.reflect.Parameter;import java.util.Arrays;import java.util.function.IntConsumer;public class Snippet { IntConsumer xx(int a) { return i -> { }; } public static void main(String[] args) { Method[] methods = Snippet.class.getDeclaredMethods(); Parameter[] parameters = methods[2].getParameters(); System.out.println(Arrays.asList(parameters)); }}------------------------------For this snippet ecj produces a classfile in which the lambda$xx$0(int) method has a MethodParameters attribute whose single parameter has a zero name and the ""synthetic"" flag.Problems:1.) Should we really produce a MethodParameters attribute for the lambda? Javac doesn't produce one.1.1) If yes should the parameter really be synthetic? The lambda method is already synthetic and I don't think that should make everything inside it synthetic as well.2.) Disassembler should not throw an NPE in this case. JVMS8 4.7.24 allows a zero parameter name. javap also supports it but reflection is broken in 1.8.0-b131.!ENTRY org.eclipse.e4.ui.workbench 4 0 2014-03-10 14:54:23.741!MESSAGE !STACK 0java.lang.NullPointerException	at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:504)	at java.lang.StringBuffer.append(StringBuffer.java:314)	at org.eclipse.jdt.internal.core.util.Disassembler.disassemble(Disassembler.java:604)	at org.eclipse.jdt.internal.core.util.Disassembler.disassemble(Disassembler.java:910)	at org.eclipse.jdt.internal.core.util.Disassembler.disassembleTypeMembers(Disassembler.java:2382)	at org.eclipse.jdt.internal.core.util.Disassembler.disassemble(Disassembler.java:1154)	at org.eclipse.jdt.internal.core.util.Disassembler.disassemble(Disassembler.java:261)	at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$SourceAttachmentForm.updateCodeView(ClassFileEditor.java:410)	at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor$SourceAttachmentForm.createControl(ClassFileEditor.java:210)	at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.verifyInput(ClassFileEditor.java:797)	at org.eclipse.jdt.internal.ui.javaeditor.ClassFileEditor.createPartControl(ClassFileEditor.java:747)	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:142)"
430026,3/10/2014 12:42,srikanth_sankaran,"[1.8] Lambda parameter has wrong parent if it declares its type package jsr335.funint6;interface MyFunction<T R> { R apply(T t); default <V> MyFunction<V R> compose(MyFunction<? super V ? extends T> before) { return (V v) -> apply(before.apply(v));// return (v) -> apply(before.apply(v)); // OK }}The lambda parameter v has MyFunction#compose(..) as parent element. If you use the ""// OK"" variant where v's type V is not explicitly declared then the parent becomes a LambdaExpression as expected."
430027,3/10/2014 12:46,srikanth_sankaran,"[1.8][model] Mitigate issues due to Lambda model element hierarchy lacking support for binary elements. - select java.util.function.Function#apply(T)- Search > References > In Hierarchy-> NPEAFAICS the problem happens with the lambda in java.util.function.Function#compose(..). The LambdaExpression extends SourceType although that lambda is actually for a binary type. Therefore the implementation in SourceType#getPrimaryElement(boolean) doesn't make sense.!ENTRY org.eclipse.core.jobs 4 2 2014-03-10 17:20:42.837!MESSAGE An internal error occurred during: ""Java Search"".!STACK 0java.lang.NullPointerException	at org.eclipse.jdt.internal.core.SourceType.getPrimaryElement(SourceType.java:445)	at org.eclipse.jdt.internal.core.JavaElement.getPrimaryElement(JavaElement.java:359)	at org.eclipse.jdt.internal.core.search.HierarchyScope.enclosesType(HierarchyScope.java:391)	at org.eclipse.jdt.internal.core.search.HierarchyScope.encloses(HierarchyScope.java:356)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.encloses(MatchLocator.java:775)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2230)	at org.eclipse.jdt.internal.core.search.matching.MemberDeclarationVisitor.visit(MemberDeclarationVisitor.java:216)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.traverse(LambdaExpression.java:636)	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.traverse(ReturnStatement.java:376)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:351)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2304)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2858)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2572)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1755)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1164)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1205)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1337)	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:122)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516)	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584)	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144)	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
430035,3/10/2014 14:20,srikanth_sankaran,"[1.8][compiler][codegen] Bridge methods are not generated for lambdas/method references import java.util.function.Consumer;public class LambdaWithBridge { interface StringConsumer extends Consumer<String> { void accept(String t); } static void m(String s) { System.out.println(""m(""+s+"")""); } public static void main(String... x) { StringConsumer c = LambdaWithBridge::m; c.accept(""direct call""); Consumer<String> c4b=c; c4b.accept(""bridge method""); }}andimport java.util.function.Consumer;public class LambdaWithBridge { interface StringConsumer extends Consumer<String> { void accept(String t); } public static void main(String... x) { StringConsumer c = s->System.out.println(""m(""+s+')'); c.accept(""direct call""); Consumer<String> c4b=c; c4b.accept(""bridge method""); }}producem(direct call)Exception in thread ""main"" java.lang.AbstractMethodError: Method LambdaWithBridge$$Lambda$1.accept(Ljava/lang/Object;)V is abstract	at LambdaWithBridge$$Lambda$1/2536472.accept(Unknown Source)	at LambdaWithBridge.main(LambdaWithBridge.java:13)which indicates that the necessary bridge method has not been generated. The compiler must emit code which invokes altMetafactory with FLAG_BRIDGES and the bridge method signatures. An alternative would be creating the bridge method as synthetic default method inside the interface however if the interface is not on the build path and originates from a non-Java8 project the bridge method must be generated for the lambda."
430069,3/11/2014 4:31,manpalat,[1.8] Test failures when run with JRE7- Ref Bug 429571 comment 13.The following needs to be modified/moved to address the issue that these tests cannot run in 1.8jdt.core.tests.build.IncrementalTests18 (5)- all errors(5)jdt.core.tests.compiler(2) - all failures(2) - GRT_1.7.429203 CDT.test429110jdt.core.tests.model(8) -All Errors (all tests in NullAnnotationModelTests)
430073,3/11/2014 5:20,jarthana,[1.8][model] Lambda model elements hierarchy needs rewiring. See https://bugs.eclipse.org/bugs/show_bug.cgi?id=430027#c0 andhttps://bugs.eclipse.org/bugs/show_bug.cgi?id=430027#c6
430084,3/11/2014 6:33,shankhba,"[compiler][null] NPE: Method without return value import org.eclipse.jdt.annotation.NonNullByDefault;@NonNullByDefaultpublic class X {	Y() {} }java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.lookup.MethodBinding.fillInDefaultNonNullness18(MethodBinding.java:540)	at org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.checkImplicitNullAnnotations(ImplicitNullAnnotationVerifier.java:155)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.createArgumentBindings(SourceTypeBinding.java:2004)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:1971)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:1465)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:853)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:424)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1201)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)"
430108,3/11/2014 10:02,markus.kell.r,"[type wizards] Creating class pkg1.A that implements/extends type pkg2.A result in code with error I have some code that create a Java class that extends a specific interface.By default the created class and the interface have the same names (though different packages).Since migrating our product from Indigo to Kepler it does not produce the same code anymore.In Indigo the code produced would be:package pkg1;class A implements pkg2.A { ...}=> the wizard noticed the type names are the same hence it uses the full classname for the implements.Now in Kepler we get:package pkg1;import pkg2.Aclass A implements A { ...}=> error on the import (""The import pkg2.A conflicts with a type defined in the same file"" ) and on the implemented A ( ""Cycle detected: the type Initial cannot extend/implement itself or one of its own member types"" )The code we use to open the wizard is this:final OpenNewClassWizardAction wizardCreator = new OpenNewClassWizardAction();final NewClassWizardPage page = new NewClassWizardPage();page.setTitle(...);page.setDescription(...);page.addSuperInterface(""pkg2.A"");page.setTypeName(""A"" true);final IPackageFragmentRoot root = jproject.getPackageFragmentRoot(jproject.getElementName() + ""/src"");page.setPackageFragmentRoot(root true);final IPackageFragment fragment = root.getPackageFragment(""pkg1"");page.setPackageFragment(fragment false);page.setEnclosingTypeSelection(false false);page.setMethodStubSelection(false false true false);page.setModifiers(page.F_PUBLIC false);wizardCreator.setConfiguredWizardPage(page);wizardCreator.run();"
430136,3/11/2014 15:14,jarthana,"[1.8][model] JavaElement.JEM_LAMBDA_METHOD should not use '*' and '>' as memento delimiter JavaElement.JEM_LAMBDA_METHOD should not use '*' and '>' as memento delimiter.I just saw that the fix for bug 425134 had to make adjustments in MementoTests. That's not good. Existing JavaElement handles should stay as stable as possible see Javadoc of IJavaElement#getHandleIdentifier(). '*' and '>' were already used by existing mementos and such stored mementos cannot be parsed any more now.I see that most ""safe"" ASCII characters are already used as token delimiters or in token data but these look free:&')`Forbidden character groups:- identifier characters- characters used in Signature (at least for parameter type signatures)- is IMO risky as well (often used by clients to separate data)We should also have a test for lambda type and lambda method mementos. I don't think these will be stored often (since they are inherently unstable) but they can be used locally (e.g. to put an element on the clipboard or for hyperlinks in Javadoc hovers)."
430141,3/11/2014 16:18,srikanth_sankaran,"[1.8][hierarchy] Incorrect hierarchy with lambda elements missing interface I {	void doit();}interface J extends I {	}public class X {	public static void main(String[] args) {		J j = () -> { System.out.println(""Lambda""); };		j.doit();	}}Given the above neither the hierarchy rooted at I nor one rooted at Jshow the lambda expression."
430157,3/12/2014 4:32,sasikanth.bharadwaj,"[1.8][compiler][codegen] Code generated for method/constructors references could be more efficient ATM under some situations that call for ""special"" handling forexpediency we turn a method/constructor into an implicit lambdaexpression. See ReferenceExpression.shouldGenerateImplicitLambda(BlockScope) forthe situations.Comment from there says: // these cases are either too complicated impossible to handle or result in significant code duplication We need to revisit this part and arrange for a more direct and so more efficientcode generation."
430159,3/12/2014 5:24,manpalat,[1.8][search] Lambda Expression not found when searching using OrPattern or AndPattern Created attachment 240793test case as a JavaSearchBugs8Test functionfollow up of bug 429498.
430195,3/12/2014 10:46,jarthana,"[1.8][model][api] Lambda IType API problems (isLambda(); getElementName() returns """") API problems in the IType for a lambda:- getElementName() should return an empty name like for anonymous types (this is currently specified in the Javadoc of IType but that should be copied or moved to getElementName()). The current ""Lambda(FunctionalInterfaceName)"" violates the ""simple name"" statement in IType#getElementName(). And it make sense not to perform some ad-hoc rendering in jdt.core.Caveat: Implementation of SourceType#isAnonymous() is: return this.name.length() == 0- specify getTypeQualified*(..) APIs for lambda types- add API isLambda()- add note in IType Javadoc that ITypes for lambda expressions are pseudo-elements like ILocalVariable that are not returned by getChildren() on their parent"
430219,3/12/2014 14:06,shankhba,"[1.8][compiler][null] NPE: Null Annotation on Parameter Type import org.eclipse.jdt.annotation.NonNullByDefault;@NonNullByDefaultpublic class X {	void foo(int @NonNull [] x) {}}Null Pointer Exception. Stack Trace.LookupEnvironment.createAnnotatedType(TypeBinding AnnotationBinding[]) line: 976		MethodBinding.fillInDefaultNonNullness18(AbstractMethodDeclaration LookupEnvironment) line: 524		ImplicitNullAnnotationVerifier.checkImplicitNullAnnotations(MethodBinding AbstractMethodDeclaration boolean Scope) line: 155		SourceTypeBinding.createArgumentBindings(MethodBinding CompilerOptions) line: 2004		SourceTypeBinding.resolveTypesFor(MethodBinding) line: 1971		SourceTypeBinding.methods() line: 1465		SourceTypeBinding.faultInTypesForFieldsAndMethods() line: 853		CompilationUnitScope.faultInTypes() line: 424		AbstractRegressionTest$26(Compiler).process(CompilationUnitDeclaration int) line: 764		AbstractRegressionTest$26.process(CompilationUnitDeclaration int) line: 2601		AbstractRegressionTest$26(Compiler).compile(ICompilationUnit[]) line: 471		NullAnnotationTest(AbstractRegressionTest).runTest(boolean String[] String[] String[] Map boolean ICompilerRequestor boolean String String[] boolean String[] String String ASTVisitor AbstractRegressionTest$JavacTestOptions) line: 2610		NullAnnotationTest(AbstractRegressionTest).runTest(boolean String[] String[] Map boolean ICompilerRequestor boolean String boolean String[] String String AbstractRegressionTest$JavacTestOptions) line: 2429		NullAnnotationTest(AbstractRegressionTest).runNegativeTest(String[] String String[] boolean) line: 2126		NullAnnotationTest(AbstractNullAnnotationTest).runNegativeTestWithLibs(String[] String) line: 114		NullAnnotationTest.testNullNPETest() line: 7013		NativeMethodAccessorImpl.invoke0(Method Object Object[]) line: not available [native method]		NativeMethodAccessorImpl.invoke(Object Object[]) line: 62		DelegatingMethodAccessorImpl.invoke(Object Object[]) line: 43		Method.invoke(Object Object...) line: 483		NullAnnotationTest(TestCase).runTest() line: 176		NullAnnotationTest(TestCase).runBare() line: 141		TestResult$1.protect() line: 122		TestResult.runProtected(Test Protectable) line: 142		TestResult.run(TestCase) line: 125		NullAnnotationTest(TestCase).run(TestResult) line: 129		RegressionTestSetup(TestSuite).runTest(Test TestResult) line: 255		RegressionTestSetup(TestSuite).run(TestResult) line: 250		RegressionTestSetup(CompilerTestSetup).run(TestResult) line: 55		TestSuite.runTest(Test TestResult) line: 255		TestSuite.run(TestResult) line: 250		JUnit3TestReference.run(TestExecution) line: 131		TestExecution.run(ITestReference[]) line: 38		RemotePluginTestRunner(RemoteTestRunner).runTests(String[] String TestExecution) line: 467		RemotePluginTestRunner(RemoteTestRunner).runTests(TestExecution) line: 683		RemotePluginTestRunner(RemoteTestRunner).run() line: 390		RemotePluginTestRunner.main(String[]) line: 62		CoreTestApplication.run(Object) line: 23		NativeMethodAccessorImpl.invoke0(Method Object Object[]) line: not available [native method]		NativeMethodAccessorImpl.invoke(Object Object[]) line: 62		DelegatingMethodAccessorImpl.invoke(Object Object[]) line: 43		Method.invoke(Object Object...) line: 483		EclipseAppContainer.callMethodWithException(Object String Class[] Object[]) line: 587		EclipseAppHandle.run(Object) line: 198		EclipseAppLauncher.runApplication(Object) line: 110		EclipseAppLauncher.start(Object) line: 79		EclipseStarter.run(Object) line: 354		EclipseStarter.run(String[] Runnable) line: 181		NativeMethodAccessorImpl.invoke0(Method Object Object[]) line: not available [native method]		NativeMethodAccessorImpl.invoke(Object Object[]) line: 62		DelegatingMethodAccessorImpl.invoke(Object Object[]) line: 43		Method.invoke(Object Object...) line: 483		Main.invokeFramework(String[] URL[]) line: 636		Main.basicRun(String[]) line: 591		Main.run(String[]) line: 1450		Main.main(String[]) line: 1426 ------------------------------------------------------------------I will put up the fix in a few minutes."
430241,3/12/2014 23:41,srikanth_sankaran,"[1.8][compiler] Raw return type results in incorrect covariant return bridge request to LambdaMetaFactory The following program does not require bridges but we request one:// --interface K extends I J {}interface I { Comparable<Integer> foo();}interface J { Comparable foo();}public class X {	public static void main(String[] args) {		K k = () -> null;		k.foo();	}}Problem in comparing return types as is to see if they differ - we shouldcompare the erasures - fix will follow shortly."
430267,3/13/2014 6:24,noopur_gupta,"[refactoring][extract method] Extract Method misses parameter used in try-with-resources statement Given the following code:static String readFirstLineFromFile(String path) throws IOException {	try (BufferedReader br = new BufferedReader(new FileReader(path))) {		return br.readLine();	}}When using Extract Method on the body of the method the required parameter ""path"" is not passed to the extracted method:static String readFirstLineFromFile(String path) throws IOException {	return readLine();}private static String readLine() throws IOException FileNotFoundException {	try (BufferedReader br = new BufferedReader(new FileReader(path))) {		return br.readLine();	}}"
430286,3/13/2014 10:13,markus.kell.r,[1.8][render] Rendering of Lambda types; use #isLambda() APIs Adapt to APIs from bug 430195.
430307,3/13/2014 13:02,jarthana,"[1.8][model] NPE trying to get children of a LambdaExpression restored from handleIdentifier I encountered this problem when I closed and reopened a Type Hierarchy view but the scenario is not well reproducible because the E4 workbench is very unreliable (bug 430306).Easier steps in the JavaElement View:package jsr335.funint6;import java.util.function.IntConsumer;class Test { void foo() { IntConsumer c = (i) -> { }; }}- set input to 'i' and then follow > PARENT > PARENT to get the LambdaExpression- show Properties and copy the handleIdentifier. Mine is this:=zz1.8/src<jsr335.funint6{Test.java[Test~foo)Lambda\(IntConsumer\)""Ljava.util.function.IntConsumer;!125!134!130- open JavaElement View's view menu and run ""Create from Handle...""- try to re-create the copied handleIdentifier=> fails when trying to access the children of the LambdaExpression elementThe problem is that LambdaExpression is not prepared to be restored from a handle memento since that doesn't restore its lambdaMethod field.org.eclipse.jdt.internal.core.Member#getHandleFromMemento(..) does this:LambdaExpression expression = new LambdaExpression(this name interphase sourceStart sourceEnd arrowPosition);if (!memento.hasMoreTokens() || (token = memento.nextToken()) != MementoTokenizer.LAMBDA_METHOD) 	return expression;The end of the called LambdaExpression constructor has a comment// Method is in the process of being fabricated will be attached shortly. but the lambdaMethod field is never initialized when the plain LambdaExpression is returned.I guess the solution has to be that a LambdaExpression always stores the lambda method as well but we have a different formatting for the LambdaExpression's handleIdentifier (e.g. an additional JEM_LAMBDA_EXPRESSION appended).!ENTRY org.eclipse.e4.ui.workbench 4 0 2014-03-13 16:19:33.484!MESSAGE !STACK 0java.lang.NullPointerException	at org.eclipse.jdt.internal.core.JavaElement.getChildrenOfType(JavaElement.java:226)	at org.eclipse.jdt.internal.core.SourceType.getMethods(SourceType.java:418)	at org.eclipse.jdt.internal.ui.viewsupport.JavaElementLabelComposer.isLambdaType(JavaElementLabelComposer.java:1099)	at org.eclipse.jdt.internal.ui.viewsupport.JavaElementLabelComposer.appendTypeLabel(JavaElementLabelComposer.java:987)	at org.eclipse.jdt.internal.ui.viewsupport.JavaElementLabelComposer.appendElementLabel(JavaElementLabelComposer.java:287)	at org.eclipse.jdt.ui.JavaElementLabels.getElementLabel(JavaElementLabels.java:518)	at org.eclipse.jdt.ui.JavaElementLabels.getElementLabel(JavaElementLabels.java:491)	at org.eclipse.jdt.internal.ui.typehierarchy.HistoryAction.getShortLabel(HistoryAction.java:111)	at org.eclipse.jdt.internal.ui.typehierarchy.HistoryAction.getElementLabel(HistoryAction.java:93)	at org.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyViewPart.restoreState(TypeHierarchyViewPart.java:1697)	at org.eclipse.jdt.internal.ui.typehierarchy.TypeHierarchyViewPart.createPartControl(TypeHierarchyViewPart.java:1006)	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:142)..."
430310,3/13/2014 13:48,srikanth_sankaran,"[1.8][compiler] Functional interface incorrectly rejected as not being. interface Func1<T1 R> { R apply(T1 v1); void other(); } @FunctionalInterface // spurious error: F1<T R> is not a functional interface interface F1<T1 R> extends Func1<T1 R> { default void other() {} }or more simply: @FunctionalInterface // spurious error: F2<T R> is not a functional interface interface F2<T1 R> extends Func1<T1 R> { 	R apply(T1 v1); default void other() {} }Tested with: Version: Kepler Service Release 1 Build id: 20130919-0819 Eclipse Java Development Tools Patch for Java 8 Support (BETA)	1.0.0.v20140312-1826	org.eclipse.jdt.java8patch.feature.group	Eclipse.org"
430336,3/13/2014 19:27,sasikanth.bharadwaj,"[1.8][compiler] Bad syntax error recovery: Lonely identifier should be variable name not type --------------------package test1;import java.util.Collection;public class E { void foo(Collection collection) { collection }}--------------------In BETA_JAVA8 the compiler reports 3 errors for this snippet:Pb(240) Syntax error insert ""VariableDeclarators"" to complete LocalVariableDeclarationPb(240) Syntax error insert "";"" to complete BlockStatementsPb(2) collection cannot be resolved to a typeThe third error is not reported in master and that's what I'd still expect. This breaks the new quick fix that generates a 'for' loop around the variable (bug 241696).Analysis:I saw that AbstractMethodDeclaration#resolveStatements() has this.statements==null in master but contains a LocalDeclaration with contents ""collection $missing$;"" in BETA_JAVA8.The recovered DOM AST is also completely different:- In master I get:ExpressionStatement [111+10] (recovered) EXPRESSION Assignment [111+10] (recovered) LEFT_HAND_SIDE SimpleName [111+10] // ""collection"" RIGHT_HAND_SIDE SimpleName [121+0] (recovered) // """"- In BETA_JAVA8 it's:VariableDeclarationStatement [111+10] (recovered) TYPE SimpleType [111+10] // ""collection"" FRAGMENTS (1) VariableDeclarationFragment [121+0] // """"The old recovery was much better."
430425,3/14/2014 17:05,srikanth_sankaran,"[1.8][compiler] Type mismatch: cannot convert from StyleConverter<ParsedValue[]Insets> to StyleConverter<ParsedValue[]Insets> Created attachment 240921This is the project that shows the incremental compile error.This problem is critical to compiling OpenJFX under Eclipse 8.0) Start Eclipse1) Ensure that you have JDK8 with JavaFX as the default JRE - jfxrt.jar must be on the class path for the project to compile clean2) Import 'Junk3' the attached project into Eclipse3) Ensure that it compiles cleanly4) Edit the method StyleConverter (change ""fred55"" to ""fred5"")5) BUG: Type mismatch: cannot convert from StyleConverter<ParsedValue[]Insets> to StyleConverter<ParsedValue[]Insets>6) Project->Clean??->Clean all projects7) The compile error goes awayFrom memory I have seen this issue come and go however it might be that I was running a really old Eclipse that never had the problem."
430441,3/15/2014 8:57,shankhba,"[compiler] NPE in ImplicitNullAnnotationVerifier.collectOverriddenMethods from Content Assist in a .jpage file Create in a root of a project a new file called jots.jpage and paste the following in it:String s = ""foo"";s.On the line ""s."" press Ctrl+Space. This causes an NPE to be logged. I am using fairly recent BETA_JAVA8 plugins and it's possible this might have been fixed in the latest. I'll test this again once I'm up-to-date.org.eclipse.swt.SWTException: Failed to execute runnable (java.lang.NullPointerException)	at org.eclipse.swt.SWT.error(SWT.java:4441)	at org.eclipse.swt.SWT.error(SWT.java:4356)	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:139)	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1122)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1006)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:146)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:615)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:566)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:109)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:80)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:372)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:226)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591)	at org.eclipse.equinox.launcher.Main.run(Main.java:1450)Caused by: java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.collectOverriddenMethods(ImplicitNullAnnotationVerifier.java:190)	at org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.findAllOverriddenMethods(ImplicitNullAnnotationVerifier.java:173)	at org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.checkImplicitNullAnnotations(ImplicitNullAnnotationVerifier.java:100)	at org.eclipse.jdt.internal.compiler.lookup.ImplicitNullAnnotationVerifier.checkImplicitNullAnnotations(ImplicitNullAnnotationVerifier.java:112)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.createArgumentBindings(SourceTypeBinding.java:2004)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(SourceTypeBinding.java:1971)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.methods(SourceTypeBinding.java:1465)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.faultInTypesForFieldsAndMethods(SourceTypeBinding.java:853)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:424)	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1920)	at org.eclipse.jdt.internal.eval.EvaluationContext.complete(EvaluationContext.java:187)	at org.eclipse.jdt.internal.core.eval.EvaluationContextWrapper.codeComplete(EvaluationContextWrapper.java:112)	at org.eclipse.jdt.internal.core.eval.EvaluationContextWrapper.codeComplete(EvaluationContextWrapper.java:100)	at org.eclipse.jdt.internal.core.eval.EvaluationContextWrapper.codeComplete(EvaluationContextWrapper.java:88)	at org.eclipse.jdt.internal.debug.ui.snippeteditor.JavaSnippetEditor.codeComplete(JavaSnippetEditor.java:722)	at org.eclipse.jdt.internal.debug.ui.snippeteditor.JavaSnippetCompletionProcessor.computeCompletionProposals(JavaSnippetCompletionProcessor.java:104)	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1861)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:568)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$16(CompletionProposalPopup.java:565)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:500)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:494)	at org.eclipse.jface.text.contentassist.ContentAssistant$2.run(ContentAssistant.java:378)	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)	... 23 more"
430451,3/15/2014 12:25,jarthana,"Tests fail in org.eclipse.jdt.compiler.tool.tests.CompilerInvocationTests with JRE 1.8 Created attachment 240928Patch to fix failing testsThe following tests are failing with JRE 1.8. They fail because the in 1.8 Iterable.toString has a surrounding ""[]"". The patch fixes the failing ones:test002_dash_d_optiontest003_dash_d_optiontest005_dash_d_option_custom_file_manager"
430487,3/16/2014 17:46,markus.kell.r,"[1.8][refactoring] Rename Method refactoring breaks lambda The Rename Method refactoring breaks lambda expressions (overwrites parameters list and ""->"")."
430571,3/17/2014 20:48,shankhba,[1.8][compiler] Lambda parameter names and annotations don't make it to class files. From here: http://mail.openjdk.java.net/pipermail/type-annotations-spec-comments/2014-March/000071.htmlWe have a bug that parameter annotations and names don't make it to classfiles.
430572,3/17/2014 20:59,srikanth_sankaran,"[1.8] CCE on hovering over 'super' in lambda expression @FunctionalInterfaceinterface FI {	default int getID() {		return 11;	}	void print();}class T {	FI f2 = () -> System.out.println(super.toString()); // Hover on 'super'	}-----------------------------------------Hover over 'super' in the above example.We get this exception:java.lang.ClassCastException: org.eclipse.jdt.internal.codeassist.select.SelectionOnSuperReference cannot be cast to org.eclipse.jdt.internal.compiler.ast.LambdaExpression	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeLambdaExpression(Parser.java:7975)	at org.eclipse.jdt.internal.codeassist.select.SelectionParser.consumeLambdaExpression(SelectionParser.java:766)	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6827)	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11023)	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11271)	at org.eclipse.jdt.internal.codeassist.select.SelectionParser.parse(SelectionParser.java:1443)	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11228)	at org.eclipse.jdt.internal.compiler.parser.Parser.dietParse(Parser.java:9649)	at org.eclipse.jdt.internal.codeassist.select.SelectionParser.dietParse(SelectionParser.java:1278)	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:887)	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:163)	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:381)	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:375)	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractJavaEditorTextHover.getJavaElementsAt(AbstractJavaEditorTextHover.java:118)..."
430573,3/17/2014 21:24,jerome.cambon,"[1.8][clean up][quick assist] Convert lambda to anonymous must qualify references to 'this'/'super' Convert lambda to anonymous must qualify references to 'this'/'super':package p;import java.util.function.IntSupplier;public class A { public static void main(String[] args) { new A(); } A() { IntSupplier i = () -> this.m(); System.out.println(i.getAsInt()); } public int m() { return 7; }}=> In the anonymous the method must return ""A.this.m()"" not just ""this.m()""."
430574,3/17/2014 22:20,markus.kell.r,"[change method signature] SWTException: Widget is disposed with Change method signature class Test {	void m(int arg) { }}----------------- Invoke Change method signature refactoring on method #m.- Select 'arg' in the Name column of wizard (see attached screenshot).- Click 'Close' on wizard with focus on the selected arg.We get this exception:org.eclipse.swt.SWTException: Failed to execute runnable (org.eclipse.swt.SWTException: Widget is disposed)	at org.eclipse.swt.SWT.error(SWT.java:4441)......Caused by: org.eclipse.swt.SWTException: Widget is disposed	at org.eclipse.swt.SWT.error(SWT.java:4441)	at org.eclipse.swt.SWT.error(SWT.java:4356)	at org.eclipse.swt.SWT.error(SWT.java:4327)	at org.eclipse.swt.widgets.Widget.error(Widget.java:476)	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:348)	at org.eclipse.swt.widgets.Control.getVisible(Control.java:1661)	at org.eclipse.jface.viewers.CellEditor.isActivated(CellEditor.java:499)	at org.eclipse.jface.viewers.CellEditor.focusLost(CellEditor.java:721)	at org.eclipse.jdt.internal.ui.dialogs.TableTextCellEditor.focusLost(TableTextCellEditor.java:103)	at org.eclipse.jdt.internal.ui.dialogs.TableTextCellEditor$7$1.run(TableTextCellEditor.java:254)	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)	... 23 more"
430580,3/18/2014 2:39,sarika.sinha,"[1.8] NPE for java 1.8 test cases http://download.eclipse.org/eclipse/downloads/drops4/N20140317-2000/testresults/html/org.eclipse.jdt.debug.tests_linux.gtk.x86_6.0.htmltestInterfaceUnimplementedMethodBreakpoint	Error	N/Ajava.lang.NullPointerExceptionat org.eclipse.jdt.debug.tests.breakpoints.AbstractToggleBreakpointsTarget$1.run(AbstractToggleBreakpointsTarget.java:118)at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748)at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396)at org.eclipse.jdt.debug.tests.DebugSuite.run(DebugSuite.java:69)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310)at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197)at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748)at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396)at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1119)at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1003)at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:147)at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:630)at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:574)at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125)at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140)at org.eclipse.test.UITestApplication.run(UITestApplication.java:62)at org.eclipse.test.UITestApplication.start(UITestApplication.java:212)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:133)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:103)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:378)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:232)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)at org.eclipse.equinox.launcher.Main.run(Main.java:1462)at org.eclipse.equinox.launcher.Main.main(Main.java:1438)at org.eclipse.core.launcher.Main.main(Main.java:34)	0.120testInterfaceStaticMethodBreakpoint	Error	N/Ajava.lang.NullPointerExceptionat org.eclipse.debug.core.sourcelookup.containers.LocalFileStorage.getName(LocalFileStorage.java:84)at org.eclipse.jdt.internal.debug.ui.StorageEditorInput.getName(StorageEditorInput.java:55)at org.eclipse.ui.internal.WorkbenchPage.checkEditor(WorkbenchPage.java:2255)at org.eclipse.ui.internal.WorkbenchPage.findEditors(WorkbenchPage.java:2215)at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:3081)at org.eclipse.ui.internal.WorkbenchPage.access$23(WorkbenchPage.java:3053)at org.eclipse.ui.internal.WorkbenchPage$9.run(WorkbenchPage.java:3035)at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3031)at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2995)at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2978)at org.eclipse.jdt.debug.tests.breakpoints.AbstractToggleBreakpointsTarget$1.run(AbstractToggleBreakpointsTarget.java:116)at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748)at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396)at org.eclipse.jdt.debug.tests.DebugSuite.run(DebugSuite.java:69)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310)at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197)at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748)at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396)at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1119)at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1003)at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:147)at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:630)at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:574)at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125)at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140)at org.eclipse.test.UITestApplication.run(UITestApplication.java:62)at org.eclipse.test.UITestApplication.start(UITestApplication.java:212)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:133)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:103)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:378)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:232)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)at org.eclipse.equinox.launcher.Main.run(Main.java:1462)at org.eclipse.equinox.launcher.Main.main(Main.java:1438)at org.eclipse.core.launcher.Main.main(Main.java:34)	0.046testInterfaceLineBreakpoint	Error	N/Ajava.lang.NullPointerExceptionat org.eclipse.debug.core.sourcelookup.containers.LocalFileStorage.getName(LocalFileStorage.java:84)at org.eclipse.jdt.internal.debug.ui.StorageEditorInput.getName(StorageEditorInput.java:55)at org.eclipse.ui.internal.WorkbenchPage.checkEditor(WorkbenchPage.java:2255)at org.eclipse.ui.internal.WorkbenchPage.findEditors(WorkbenchPage.java:2215)at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:3081)at org.eclipse.ui.internal.WorkbenchPage.access$23(WorkbenchPage.java:3053)at org.eclipse.ui.internal.WorkbenchPage$9.run(WorkbenchPage.java:3035)at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3031)at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2995)at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2978)at org.eclipse.jdt.debug.tests.breakpoints.AbstractToggleBreakpointsTarget$1.run(AbstractToggleBreakpointsTarget.java:116)at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748)at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396)at org.eclipse.jdt.debug.tests.DebugSuite.run(DebugSuite.java:69)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310)at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197)at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748)at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396)at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1119)at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1003)at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:147)at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:630)at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:574)at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125)at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140)at org.eclipse.test.UITestApplication.run(UITestApplication.java:62)at org.eclipse.test.UITestApplication.start(UITestApplication.java:212)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:133)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:103)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:378)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:232)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)at org.eclipse.equinox.launcher.Main.run(Main.java:1462)at org.eclipse.equinox.launcher.Main.main(Main.java:1438)at org.eclipse.core.launcher.Main.main(Main.java:34)	0.001testInterfaceDefaultMethodBreakpoint	Error	N/Ajava.lang.NullPointerExceptionat org.eclipse.debug.core.sourcelookup.containers.LocalFileStorage.getName(LocalFileStorage.java:84)at org.eclipse.jdt.internal.debug.ui.StorageEditorInput.getName(StorageEditorInput.java:55)at org.eclipse.ui.internal.WorkbenchPage.checkEditor(WorkbenchPage.java:2255)at org.eclipse.ui.internal.WorkbenchPage.findEditors(WorkbenchPage.java:2215)at org.eclipse.ui.internal.WorkbenchPage.busyOpenEditor(WorkbenchPage.java:3081)at org.eclipse.ui.internal.WorkbenchPage.access$23(WorkbenchPage.java:3053)at org.eclipse.ui.internal.WorkbenchPage$9.run(WorkbenchPage.java:3035)at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:3031)at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2995)at org.eclipse.ui.internal.WorkbenchPage.openEditor(WorkbenchPage.java:2978)at org.eclipse.jdt.debug.tests.breakpoints.AbstractToggleBreakpointsTarget$1.run(AbstractToggleBreakpointsTarget.java:116)at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748)at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396)at org.eclipse.jdt.debug.tests.DebugSuite.run(DebugSuite.java:69)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310)at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197)at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3748)at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3396)at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1119)at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1003)at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:147)at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:630)at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:574)at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125)at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140)at org.eclipse.test.UITestApplication.run(UITestApplication.java:62)at org.eclipse.test.UITestApplication.start(UITestApplication.java:212)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:133)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:103)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:378)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:232)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)at org.eclipse.equinox.launcher.Main.run(Main.java:1462)at org.eclipse.equinox.launcher.Main.main(Main.java:1438)at org.eclipse.core.launcher.Main.main(Main.java:34)"
430656,3/18/2014 21:50,srikanth_sankaran,"[1.8][content assist] Content assist does not work for method reference argument package p1;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;public class Test {	public void bar() {		List<Person> people = new ArrayList<>();		Collections.sort(people Comparator.comparing(Person::get|)); 	}}class Person {	String getLastName() {		return null;	}}-------------------------------------------------------Replace '|' with caret in the above code and press Ctrl+space. No proposals are shown."
430667,3/19/2014 2:48,srikanth_sankaran,"[1.8][content assist] no proposals around lambda as a field public class D_DemoRefactorings {		D_FI fi1= (String value int n) -> {		for (int j = 0; j < n; j++) {			System.out.println(value); 					}	};	D_F|	}interface D_FI {	void print(String value int n);}--------------------------------------------------------------public class D_DemoRefactorings {	 D_F|	D_FI fi1= (String value int n) -> {		for (int j = 0; j < n; j++) {			System.out.println(value); 					}	};}interface D_FI {	void print(String value int n);}--------------------------------------------------------------In the above cases we don't get any proposal on Ctrl+space."
430686,3/19/2014 7:01,srikanth_sankaran,[1.8][compiler] Generics: erroneously reports 'method not applicable for the arguments' The following snippet does not compile with Java 1.8 using (Java Development Tools) Patch with Java 8 support 1.0.0.v20140317-1956.It does compile using javac 1.8.0 from Oracle JDK though. (And it also compiles in Eclipse with compatability level 1.7.)The given error message is added as a comment to the respective line in the code.public class TestClass{ private static class Alice<A extends Alice<A B> B extends Bob> { } public static class Bob { } public void callingMethod() { calledMethod(); // error: The method calledMethod() in the type TestClass is not applicable for the arguments () } private <A extends Alice<A B> B extends Bob> A calledMethod() { return null; }}
430766,3/20/2014 4:25,sasikanth.bharadwaj,[1.8] Internal compiler error Created attachment 241037Eclipse log containing Java source and error informatinoI wanted to try out functionality of Java 8 in Eclipse.However a simple Java file makes the compiler crash with an Internal compiler error.Log file is attached which also contains the Java source forcing the crash.I'm using Java JDK 1.8.0 and Kepler 4.3.2.I have added Java 8 support as described onhttps://wiki.eclipse.org/JDT/Eclipse_Java_8_Support_For_Kepler
430802,3/20/2014 10:58,noopur_gupta,"[1.8] Override method content assist for default method generates code with errors Given the following code:public class Main {	private static class Cls implements Interface {	}	private static interface Interface {		default void hello() {			System.out.println(""Hello"");		}	}}Do the following:1. Put the cursor in the body of Cls2. Type ""hello"" and invoke content assist3. Select ""Override method in 'Interface'""Expected: The following is generated:		@Override		public void hello() {		}Actual: The following is generated:		@Override		public default void hello() {		}Which leads to the following error (which is confusing but that's bug 421477): Default methods are allowed only in interfaces with source level 1.8 or greater."
430814,3/20/2014 13:31,noopur_gupta,"[1.8] Override method content assist in interface for default method generates code with errors Given this:public class Main {	private static interface Foo {		default void hello() {			System.out.println(""Hello"");		}	}	private static interface Bar extends Foo {	}}Do the following:1. Put the cursor in the body of Bar2. Type ""hello"" and invoke content assist3. Select ""Override method in 'Foo'""Expected: The following is generated:		@Override		public default void hello() {		}Actual: The following is generated:		@Override public default void hello();Which has the following error: This method requires a body instead of a semicolonSee also bug 430802 for the case where Bar is a class that implements Foo.Eclipse: I20140318-0830"
430818,3/20/2014 13:54,hanke,"[1.8][quick fix] Quick fix for ""for loop"" is not shown for bare local variable/argument/field Using I20140318-0830 the quick fixes from bug 241696 for for loops are not shown in the following situations: List<String> list = ...; list<-- Cursor position hereIt also doesn't work for arguments or fields. Also not for other collection types or arrays.What works is this: Map<String String> map = ...; map.entrySet()<-- Cursor position hereThe first examples shows the following errors in the ruler:- Syntax error insert "";"" to complete LocalVariableDeclarationStatement- list cannot be resolved to a type- Syntax error insert ""VariableDeclarators"" to complete LocalVariableDeclarationThe second example shows only the following error (which may be the cause for the difference):- Syntax error insert "";"" to complete Statement"
430867,3/21/2014 6:57,shankhba,Test Case reports different set of errors for JRE 1.7 and JRE 1.8 Build ID: N20140320-2000Platform Windows.Test Results:http://download.eclipse.org/eclipse/downloads/drops4/N20140320-2000/testresults/html/org.eclipse.jdt.core.tests.compiler_win32.win32.x86_7.0.htmltest429110 - 1.7junit.framework.ComparisonFailure: Invalid problem log .----------- Expected ----------------------\n1. ERROR in X.java (at line 7)\nList<@NonNull String> foo(List<@NonNull String> arg) {\n^^^^^^^^\nSyntax error type annotations are available only when source level is at least 1.8\n----------\n2. ERROR in X.java (at line 7)\nList<@NonNull String> foo(List<@NonNull String> arg) {\n^^^^^^^^\nSyntax error type annotations are available only when source level is at least 1.8\n----------\n------------ but was ----------------------\n1. ERROR in X.java (at line 5)\n@Target(ElementType.TYPE_USE)\n^^^^^^^^\nTYPE_USE cannot be resolved or is not a field\n----------\n2. ERROR in X.java (at line 7)\nList<@NonNull String> foo(List<@NonNull String> arg) {\n^^^^^^^^\nSyntax error type annotations are available only when source level is at least 1.8\n----------\n3. ERROR in X.java (at line 7)\nList<@NonNull String> foo(List<@NonNull String> arg) {\n^^^^^^^^\nSyntax error type annotations are available only when source level is at least 1.8\n----------\n--------- Difference is ----------expected:<... in X.java (at line [7)\nList<@NonNull String> foo(List<@NonNull String> arg) {\n^^^^^^^^\nSyntax error type annotations are available only when source level is at least 1.8\n----------\n2]. ERROR in X.java (a...> but was:<... in X.java (at line [5)\n@Target(ElementType.TYPE_USE)\n^^^^^^^^\nTYPE_USE cannot be resolved or is not a field\n----------\n2. ERROR in X.java (at line 7)\nList<@NonNull String> foo(List<@NonNull String> arg) {\n^^^^^^^^\nSyntax error type annotations are available only when source level is at least 1.8\n----------\n3]. ERROR in X.java (a...>at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:250)at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:226)at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.checkCompilerLog(AbstractRegressionTest.java:1074)at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2624)at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2425)at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runNegativeTest(AbstractRegressionTest.java:2063)at org.eclipse.jdt.core.tests.compiler.parser.ComplianceDiagnoseTest.test429110(ComplianceDiagnoseTest.java:3382)at org.eclipse.jdt.core.tests.util.CompilerTestSetup.run(CompilerTestSetup.java:55)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310)at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36)at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32)at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:133)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:103)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:378)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:232)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)at org.eclipse.equinox.launcher.Main.run(Main.java:1462)at org.eclipse.equinox.launcher.Main.main(Main.java:1438)at org.eclipse.core.launcher.Main.main(Main.java:34)==========================================================================The issue is nightly is run with the JRE 1.7. Generally while 1.8 defects we run the tests with JRE 1.8. Different set of errors are thrown up in both cases.
430869,3/21/2014 7:28,jarthana,"Model Tests Apt Tests Compiler Apt Tests Performance Tests: Failed to run Build ID: N20140320-2000Test Results: http://download.eclipse.org/eclipse/downloads/drops4/N20140320-2000/testresults/html/org.eclipse.jdt.core.tests.model_win32.win32.x86_7.0.htmlhttp://download.eclipse.org/eclipse/downloads/drops4/N20140320-2000/testresults/html/org.eclipse.jdt.core.tests.model_macosx.cocoa.x86_5.0.htmlTestCase AllJavaModelTestsTestCase RunAllTestsTestCase RunFormatterTestsjava.lang.Exception: Could not find plugin ""org.eclipse.jdt.core.tests.model""org.eclipse.test.EclipseTestRunner$TestFailedException: java.lang.Exception: Could not find plugin ""org.eclipse.jdt.core.tests.model""at org.eclipse.test.EclipseTestRunner.runFailed(EclipseTestRunner.java:587)at org.eclipse.test.EclipseTestRunner.getTest(EclipseTestRunner.java:516)at org.eclipse.test.EclipseTestRunner.<init>(EclipseTestRunner.java:496)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:308)at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36)at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32)at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:133)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:103)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:378)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:232)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)at org.eclipse.equinox.launcher.Main.run(Main.java:1462)at org.eclipse.equinox.launcher.Main.main(Main.java:1438)at org.eclipse.core.launcher.Main.main(Main.java:34)Caused by: java.lang.Exception: Could not find plugin ""org.eclipse.jdt.core.tests.model""at org.eclipse.test.EclipseTestRunner.loadSuiteClass(EclipseTestRunner.java:604)at org.eclipse.test.EclipseTestRunner.getTest(EclipseTestRunner.java:513)"
430902,3/21/2014 13:47,sarika.sinha,"Method breakpoint not working on generic method with generic array argument Created attachment 241113The video that records my problem in .wmv format in a .zip package.I was debugging on something like this there are 3 method breakpoints. The first one didn't work it seems that Eclipse didn't see it existed. The 2nd and the 3rd worked fine.I submitted a video attachment as the supplementary description of the problem that I met.Hope to receive a reply in the near future Thanks!public class Foo {		public static <T extends Comparable<T>> int func(T[] arr int m int n) { // method breakpoint on func(T[]intint)		int i = 0;		++i;		++i;		++i;		return i;	}		public static <T extends Comparable<T>> int func(int m int n) { // method breakpoint on func(intint)		int i = 0;		++i;		++i;		++i;		return i;	}		public static <T extends Comparable<T>> int func(T t int m int n) { // method breakpoint on func(intint)		int i = 0;		++i;		++i;		++i;		return i;	}	public static void main(String[] args) {		int pivot = 0;		String[] ss = new String[]{""a""""b""};		pivot++;		pivot++;		func(ss 1 2); // should hit in func(T[]intint) but unfortunately no hit		pivot++;		pivot++;		func(1 2); // hits in func(intint)		pivot++;		pivot++;		func(""s"" 1 2); // hits in func(Tintint)		pivot++;		pivot++;	}	}"
431158,3/25/2014 15:45,manju656,"[inline] Cannot inline constant from enclosing class inside enum argument list Here's an example demonstrating this issue:class Constants {	static final String EXT2_CLASS = "".class"";	static final String EXT2_JAVA = "".java"";	enum Replacer2 {		NILL1(EXT2_CLASS) // inlining EXT2_CLASS doesn't work 		// inlining works here but only within ""EXT2_JAVA"" 		NILL2(Constants.EXT2_JAVA); 		String s;		Replacer2(String s) {			this.s = s;		}	}}Trying to inline EXT2_CLASS gives a confused info message ""Select a method declaration a method invocation a static final field or a local variable that you want to inline."" This happens whether the caret is inside EXT2_CLASS without any text selected or if the EXT2_CLASS text is selected.Trying to inline EXT2_JAVA works but only within the range mentioned above. Selecting the whole ""Constants.EXT2_JAVA"" text and trying to inline fails with the above message.Tested with Eclipse Version: Luna (4.4) Build id: Y20140315-2100"
431190,3/26/2014 0:19,sasikanth.bharadwaj,"[1.8] VerifyError when using a method reference Created attachment 241252Source fileWhen running the following class you get a verify error:public class Java8VerifyError { public static class Foo { public Object get() { return new Object(); } } @FunctionalInterface public static interface Provider<T> { public T get(); } public static void main(String[] args) { Provider<Foo> f = () -> new Foo(); Provider<Provider<Object>> meta = () -> f.get()::get; System.out.println(meta); }}Exception in thread ""main"" java.lang.VerifyError: Bad type on operand stackException Details: Location: Java8VerifyError.lambda$1(LJava8VerifyError$Provider;)LJava8VerifyError$Provider; @6: invokedynamic Reason: Type 'java/lang/Object' (current frame stack[0]) is not assignable to 'Java8VerifyError$Foo' Current Frame: bci: @6 flags: { } locals: { 'Java8VerifyError$Provider' } stack: { 'java/lang/Object' } Bytecode: 0000000: 2ab9 0033 0100 ba00 3a00 00b0Work around: Provider<Provider<Object>> meta = () -> { Foo foo = f.get(); return foo::get; };"
431199,3/26/2014 5:35,jarthana,Disable JavaElement8Tests with JRE 1.7 and below When JavaElement8Tests is run with JRE 1.7 test430033() is failing because it's 1.8 specific test. These tests being specific to 1.8 level are better disabled at levels 1.7 and below.
431238,3/26/2014 10:26,markus.kell.r,"No Javadoc for org.eclipse.jdt.annotation 1.1.0 in Luna In Luna builds we only generate Javadoc for the org.eclipse.jdt.annotation project (2.0.0) but not for the old 1.1.0 version.We can't just add org.eclipse.jdt.annotation_v1 to jdtOptions.txt since the Javadoc tool can't handle multiple versions (second version just overrides previous files).I see two possible solutions:a) generate Javadoc for 1.1.0 separately and then try to insert links into the generated TOC from the main Javadoc buildb) add a link to the old version to the the current Javadocs e.g.: * <p> * <b>Note:</b> Since org.eclipse.jdt.annotation 2.0.0 the * <code>@Target</code> is <code>{TYPE_USE}</code>. See * <a href=""http://help.eclipse.org/kepler/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/annotation/NonNull.html""> * <code>@NonNull</code> in 1.1.0</a> * </p>I prefer (b) but I'd like to hear others' opinions.See also bug 431236 (need to use Java 8 to generate Javadocs)."
431253,3/26/2014 11:31,jarthana,Test org.eclipse.jdt.apt.tests.ReadAnnotationTests.test1() failing Test org.eclipse.jdt.apt.tests.ReadAnnotationTests.test1() is failing the results being here:http://download.eclipse.org/eclipse/downloads/drops4/N20140325-2000/testresults/html/org.eclipse.jdt.apt.tests_macosx.cocoa.x86_64_7.0.htmlThe testcase involved is: /org.eclipse.jdt.apt.tests/src-resources/question/AnnotationTest.javaExpected value for one of the annotations used is:@RTVisibleAnno(name = Foundation boolValue = false byteValue = 16 charValue = c doubleValue = 99.0 floatValue = 9.0 intValue = 999 longValue = 3333 shortValue = 3 colors = {RED BLUE} anno = @SimpleAnnotation(value = core) simpleAnnos = {@SimpleAnnotation(value = org) @SimpleAnnotation(value = eclipse) @SimpleAnnotation(value = jdt)} clazzes = {java.lang.Object java.lang.String} clazz = java.lang.Object)But actual is:@RTVisibleAnno(name = Foundation boolValue = false byteValue = 16 charValue = c doubleValue = 99.0 floatValue = 9.0 intValue = 999 longValue = 3333 shortValue = 3 colors = {} anno = @SimpleAnnotation(value = core) simpleAnnos = {@SimpleAnnotation(value = org) @SimpleAnnotation(value = eclipse) @SimpleAnnotation(value = jdt)} clazzes = {java.lang.Object java.lang.String} clazz = java.lang.Object)Notice the attribute 'colors' being an empty array. Investigated a bit and found out that in the failing case the ElementValuePair#value is a UnresolvedEnumConstant. Back in the history when it was passing it was a FieldBinding.And this is a very recent regression caused by this commit:http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=43cdae5117454d896e9e9cf435f63b0b509e3a4cStephan please let me know if you have some clues on what might be happening.
431275,3/26/2014 14:08,jarthana,Deadlock in JavaModelManager$PerProjectInfo and DeltaProcessingState An adopter product (IBM) than runs in headless mode is hitting a deadlock with monitors org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo and org/eclipse/jdt/internal/core/DeltaProcessingState. This product started to hit this deadlock with JDT 3.6.50.v_B79_R36x_J7 (org.eclipse.jdt.core_3.6.50.v_B79_R36x_J7.jar). They did not see this deadlock when they were using 3.6.4.v_A79_R36x (org.eclipse.jdt.core_3.6.4.v_A79_R36x). I noticed that the patch in bugzilla https://bugs.eclipse.org/bugs/show_bug.cgi?id=338006 was put into the stream between those two versions (although the bugzilla was targeted to 3.7. maybe was backported) and the code added there appears in all the stack traces I have collected (specifically the call to the new method DeltaProcessor.addPackageFragmentRoot in DeltaProcessor.addToParentInfo). BTW I compared the code with the latest code in master and the code path involved in these stacks has not changed so I believe this could happen in master as well. Below are the stack traces.Thread NameWorker-2StateDeadlock/BlockedMonitorOwns Monitor Lock on org/eclipse/jdt/internal/core/DeltaProcessingState@0x0000000007292CF8 Waiting for Monitor Lock on org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo@0x000000001603D008Java Stackat org/eclipse/jdt/internal/core/JavaProject.getResolvedClasspath(JavaProject.java:1956) at org/eclipse/jdt/internal/core/PackageFragmentRoot.getResolvedClasspathEntry(PackageFragmentRoot.java:563) at org/eclipse/jdt/internal/core/DeltaProcessor.addPackageFragmentRoot(DeltaProcessor.java:325) at org/eclipse/jdt/internal/core/DeltaProcessor.addToParentInfo(DeltaProcessor.java:297) at org/eclipse/jdt/internal/core/DeltaProcessor.elementAdded(DeltaProcessor.java:1156) at org/eclipse/jdt/internal/core/DeltaProcessor.updateCurrentDeltaAndIndex(DeltaProcessor.java:2483) at org/eclipse/jdt/internal/core/DeltaProcessingState.updateRoots(DeltaProcessingState.java:621) at org/eclipse/jdt/internal/core/DeltaProcessor.updateCurrentDeltaAndIndex(DeltaProcessor.java:2479) at org/eclipse/jdt/internal/core/DeltaProcessor.traverseDelta(DeltaProcessor.java:2206) at org/eclipse/jdt/internal/core/DeltaProcessor.processResourceDelta(DeltaProcessor.java:1894) at org/eclipse/jdt/internal/core/DeltaProcessor.resourceChanged(DeltaProcessor.java:2067) at org/eclipse/jdt/internal/core/DeltaProcessingState.resourceChanged(DeltaProcessingState.java:470) at org/eclipse/core/internal/events/NotificationManager$2.run(NotificationManager.java:291) at org/eclipse/core/runtime/SafeRunner.run(SafeRunner.java:42) at org/eclipse/core/internal/events/NotificationManager.notify(NotificationManager.java:285) at org/eclipse/core/internal/events/NotificationManager.broadcastChanges(NotificationManager.java:149) at org/eclipse/core/internal/resources/Workspace.broadcastPostChange(Workspace.java:327) at org/eclipse/core/internal/resources/Workspace.endOperation(Workspace.java:1181) at org/eclipse/core/internal/resources/Workspace.run(Workspace.java:1984) at org/eclipse/core/internal/events/NotificationManager$NotifyJob.run(NotificationManager.java:40) at org/eclipse/core/internal/jobs/Worker.run(Worker.java:54)Thread NamemainStateDeadlock/BlockedMonitorOwns Monitor Lock on org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo@0x000000001603D008 Waiting for Monitor Lock on org/eclipse/jdt/internal/core/DeltaProcessingState@0x0000000007292CF8Java Stackat org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo.addClasspathChange(JavaModelManager.java:1209) at org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo.setClasspath(JavaModelManager.java:1190) at org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo.setResolvedClasspath(JavaModelManager.java:1229) at org/eclipse/jdt/internal/core/JavaProject.resolveClasspath(JavaProject.java:2859) at org/eclipse/jdt/internal/core/JavaProject.getResolvedClasspath(JavaProject.java:1991) at org/eclipse/jem/workbench/utility/JemProjectUtilities.collectClasspathURLs(JemProjectUtilities.java:452) at org/eclipse/jem/workbench/utility/JemProjectUtilities.getClasspathAsURLArray(JemProjectUtilities.java:436) ...(Adopter code)...at org/eclipse/core/internal/resources/Workspace.run(Workspace.java:1975) at org/eclipse/core/internal/resources/Workspace.run(Workspace.java:1957) ...(Adopter code)...at sun/reflect/NativeMethodAccessorImpl.invoke0(Native Method) at sun/reflect/NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:60) at sun/reflect/DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37) at java/lang/reflect/Method.invoke(Method.java:611) at org/eclipse/equinox/internal/app/EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587) at org/eclipse/equinox/internal/app/EclipseAppHandle.run(EclipseAppHandle.java:198) at org/eclipse/core/runtime/internal/adaptor/EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org/eclipse/core/runtime/internal/adaptor/EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org/eclipse/core/runtime/adaptor/EclipseStarter.run(EclipseStarter.java:369) ...(Adopter code)
431357,3/27/2014 9:28,manpalat,[search] Search API got wrong result when searching for method references where the parameter is a member type of another type. org.eclipse.jdt.core search API got wrong result when searching for method references where the parameter is a member type of another type.For example:interface MyIF { // Search result of method query(Foo.InnerKey) returns the method query(Bar.InnerKey) too public void query(Foo.InnerKey key); public void query(Bar.InnerKey key);}class Foo { static class InnerKey {}}class Bar { static class InnerKey {}}* Here is a discussion on stackoverflow:http://stackoverflow.com/questions/22317878/eclipse-open-call-hierarchy-got-wrong-result* It seems that the bug was introduced by fixing JDT Bug 41018.https://bugs.eclipse.org/bugs/show_bug.cgi?id=41018
431402,3/27/2014 15:46,srikanth_sankaran,"[assist] NPE in AssistParser.triggerRecoveryUponLambdaClosure:483 using Content Assist Using this code:import java.util.function.Predicate;public class Snippet {	private static void writeIt(Object list) {		list = replace(s -> true);		Object asList = null;		if(Boolean.TRUE) {			// activating content assist on ""asli"" causes NPE			Object s = removeAll(asli);		}	}	private static Object replace(Predicate<String> tester) { return tester; }	Object removeAll(Object o1) { return o1; }}Trying to complete asli to asList causes a warning message dialog to show up and an NPE is logged in error view.Tested with Eclipse SDK Version: Luna (4.4) Build id: Y20140315-2100Here is the stack trace:java.lang.NullPointerException	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.triggerRecoveryUponLambdaClosure(AssistParser.java:483)	at org.eclipse.jdt.internal.codeassist.complete.CompletionParser.consumeInvocationExpression(CompletionParser.java:4010)	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeMethodInvocationName(Parser.java:5283)	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.consumeMethodInvocationName(AssistParser.java:562)	at org.eclipse.jdt.internal.codeassist.complete.CompletionParser.consumeMethodInvocationName(CompletionParser.java:2925)	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6955)	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11019)	at org.eclipse.jdt.internal.codeassist.complete.CompletionParser.parseSomeStatements(CompletionParser.java:4842)	at org.eclipse.jdt.internal.codeassist.UnresolvedReferenceNameFinder.findBefore(UnresolvedReferenceNameFinder.java:210)	at org.eclipse.jdt.internal.codeassist.UnresolvedReferenceNameFinder.findBefore(UnresolvedReferenceNameFinder.java:176)	at org.eclipse.jdt.internal.codeassist.CompletionEngine.findUnresolvedReferenceBefore(CompletionEngine.java:11348)	at org.eclipse.jdt.internal.codeassist.CompletionEngine.findUnresolvedReference(CompletionEngine.java:11248)	at org.eclipse.jdt.internal.codeassist.CompletionEngine.completionOnSingleNameReference(CompletionEngine.java:3276)	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1712)	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1938)	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:131)	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:357)	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:345)	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.internalComputeCompletionProposals(JavaCompletionProposalComputer.java:244)	at org.eclipse.jdt.internal.ui.text.java.JavaCompletionProposalComputer.computeCompletionProposals(JavaCompletionProposalComputer.java:206)	at org.eclipse.jdt.internal.ui.text.java.JavaTypeCompletionProposalComputer.computeCompletionProposals(JavaTypeCompletionProposalComputer.java:63)	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalComputerDescriptor.computeCompletionProposals(CompletionProposalComputerDescriptor.java:333)	at org.eclipse.jdt.internal.ui.text.java.CompletionProposalCategory.computeCompletionProposals(CompletionProposalCategory.java:337)	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.collectProposals(ContentAssistProcessor.java:325)	at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.computeCompletionProposals(ContentAssistProcessor.java:282)	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1861)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:568)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$16(CompletionProposalPopup.java:565)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:500)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:494)	at org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1687)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:183)	at org.eclipse.ui.texteditor.ContentAssistAction$1.run(ContentAssistAction.java:82)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ui.texteditor.ContentAssistAction.run(ContentAssistAction.java:80)	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519)	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122)	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)	at sun.reflect.GeneratedMethodAccessor22.invoke(Unknown Source)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56)	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229)	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:153)	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:222)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:285)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:505)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:556)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:377)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:323)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:85)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1112)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108)	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1529)	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4722)	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:343)	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4610)	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5020)	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1119)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1003)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:147)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:630)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:574)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:133)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:103)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:378)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:232)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)"
431461,3/28/2014 7:09,Michael_Rennie,JDT Debug contributor guide is non-existent A year ago I stumbled upon a bug in JDT analyzed it and filed an issue at https://bugs.eclipse.org/bugs/show_bug.cgi?id=414285 I believed the solution to be trivial but did not dare to try fixing the bug because I could not build and test my solution. When I saw that this bug was removed from Eclipse 4.4 plans I tried again and after about an hour managed to submit a patch to gerrit. However I'm still unable to build and verify the patch.There are two contributor guides I've found so far: - http://wiki.eclipse.org/Debug/Developers - https://wiki.eclipse.org/JDT_Core_Committer_FAQ - http://wiki.eclipse.org/Platform-relengThe first one starts with a suggestion to connect to CVS which is plain pathetic. The second one is somewhat useful but suggests to directly clone eclipse.jdt.*.git repos which won't work since all pom.xml:s contain ../eclipse-platform-parent reference. I'm now trying to follow instructions at http://wiki.eclipse.org/Platform-releng/Platform_Build#Build_environment_setup and will see how they would work out. However I'm still not sure if it is possible to build Eclipse outside eclipse.org build servers without spending a lot of time on tweaking environment and writing scripts.All-in-all I've now spent several hours searching for information and testing different approaches. I believe this is too much for an average person to even bother contributing to JDT which means the project looses would-be contributors. A proper contributor guide should answer all the questions above and make it easier to contribute to JDT Debug. I think a common guide for Platform + JDT + PDE would also make sense but since my problem was specific to JDT debug I file it here.For inspiration see these guides: - http://wiki.eclipse.org/Tycho/Contributor_Guide - http://wiki.eclipse.org/EGit/Contributor_Guide - http://wiki.eclipse.org/EMF_Compare/Contributor_Guide - http://wiki.eclipse.org/GEF/Contributor_Guide - https://www.kernel.org/doc/Documentation/HOWTO
431488,3/28/2014 9:39,markus.kell.r,[1.8][search] UI for finegrain IJavaSearchConstants#METHOD_REFERENCE_EXPRESSION Add UI for finegrain IJavaSearchConstants#JAVA8_METHOD_REFERENCE from bug 429012 and test the functionality.
431501,3/28/2014 10:59,shankhba,"NameLookup#findType API finds secondary types with secondaryType and partial match set Please see: Bug 405026 Comment 30Consider the test case TypeResolveTests#test405026bThe following API call fails to return the correct result:itype = nameLookup.findType(""test1"" packageFragments[0] true NameLookup.ACCEPT_ALL false false);assertEquals(""test13"" itype.getElementName()); // Fails Here--------------------------------------------itype.getElementName() -> test13Outer--------------------------------------------This is invalid as considerSecondaryTypes is set to false.Once this is resolved please add the two test cases which were removed as part of http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=8aae944f1fec216ec7aa5c56aa9511065ae60c18.This defect is reproducible with 1.7 32 bit JRE.Thanks"
431514,3/28/2014 12:35,sasikanth.bharadwaj,"[1.8] Incorrect compilation error in lambda expression package test1;class C1 {	void fun1(int x) {		int c;		class Inner {			FI test = () -> {				try {				} catch (Exception c) {					int x;				}			};		}	}}interface FI {	void foo();}--------------------------------------------------------------------------The above code compiles with b132 but gives compilation error with ECJ at ""int x;"" in catch clause: Lambda expression's local variable x cannot redeclare another local variable defined in an enclosing scope."
431577,3/30/2014 7:39,sasikanth.bharadwaj,"[1.8][bytecode] Bad type on operand stack (different than Bug 429733) Running this snipped in Eclipse Kepler SR2 with official JAVA8 plugins produces an error (see below). Running it on the command-line with 1.8.0_20-ea-b05 works fine.import java.util.function.Function;import java.util.function.IntFunction;public class Test<R> {	public static void main(String[] args) {		new Test<>().test((Integer i) -> null);	}	// this method should be called	<T> void test(Function<T R> f) {	}	// BUG: the presence of this method causes problems	void test(int i IntFunction<R> f) {		// WORKAROUND: casting i to (Integer) i		new State<>(new Val<>(i));	}		static class State<R> {		State(Val<?> o) {		}	}		static class Val<T> {		Val(T t) {}	}}"
431716,4/1/2014 10:46,jarthana,"[1.8][compiler] NPE when creating LambdaMethod element for lambda expressions with errors package npe_oejic_LambdaMethod_getTypeSignature_line_97;With this code having compile errors trying to inline method toLongFunction results in an NPE:package npe_oejic_LambdaMethod_getTypeSignature_line_97;import java.util.function.ToLongFunction;import java.util.stream.Stream;public interface Streamy<T> {	public static <T> ToLongFunction<? super T> toLongFunction() {		return null;	}	default void asIntStream(Stream<T> makerget) {		makerget.mapToInt((long l) -> (int) l);		// trying to inline this method results causes NPE		toLongFunction();	}}Originally the asIntStream method was two separate methods in the same order but for a shorter test case this wasn't a necessary thing to keep. I am using all warnings (almost) in case it makes a difference.Tested with Eclipse SDK Version: Luna (4.4) Build id: I20140325-0830 and JDT Core plugin build from from HEAD in the last few days.Here is the full stack trace:java.lang.reflect.InvocationTargetException	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:423)	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:331)	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:637)	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:153)	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:710)	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:455)	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:466)	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:619)	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)	at org.eclipse.jface.window.Window.runEventLoop(Window.java:832)	at org.eclipse.jface.window.Window.open(Window.java:808)	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:187)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:202)	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:122)	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:38)	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startInlineMethodRefactoring(RefactoringExecutionStarter.java:330)	at org.eclipse.jdt.internal.ui.refactoring.actions.InlineMethodAction.tryInlineMethod(InlineMethodAction.java:148)	at org.eclipse.jdt.ui.actions.InlineAction.run(InlineAction.java:124)	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:279)	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251)	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519)	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122)	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)	at sun.reflect.GeneratedMethodAccessor51.invoke(Unknown Source)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)	at java.lang.reflect.Method.invoke(Unknown Source)	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56)	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229)	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149)	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:209)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:285)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:505)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:556)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:377)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:323)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:85)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1112)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108)	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1529)	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4722)	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:343)	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4610)	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5020)	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1116)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1000)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:147)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:630)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:574)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:379)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:233)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)	at java.lang.reflect.Method.invoke(Unknown Source)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)	at org.eclipse.equinox.launcher.Main.run(Main.java:1462)	at org.eclipse.equinox.launcher.Main.main(Main.java:1438)Caused by: java.lang.NullPointerException	at org.eclipse.jdt.internal.core.LambdaMethod.getTypeSignature(LambdaMethod.java:95)	at org.eclipse.jdt.internal.core.LambdaMethod.make(LambdaMethod.java:51)	at org.eclipse.jdt.internal.core.LambdaExpression.<init>(LambdaExpression.java:45)	at org.eclipse.jdt.internal.core.util.HandleFactory.createElement(HandleFactory.java:213)	at org.eclipse.jdt.internal.core.util.HandleFactory.createLambdaTypeElement(HandleFactory.java:167)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.rememberAllTypes(HierarchyResolver.java:488)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:822)	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.buildForProject(IndexBasedHierarchyBuilder.java:227)	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.buildFromPotentialSubtypes(IndexBasedHierarchyBuilder.java:329)	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:132)	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:301)	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1268)	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:829)	at org.eclipse.jdt.internal.core.SourceType.newTypeHierarchy(SourceType.java:787)	at org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.checkOverridden(InlineMethodRefactoring.java:471)	at org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.checkFinalConditions(InlineMethodRefactoring.java:285)	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:209)	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2333)	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)"
431768,4/1/2014 21:58,markus.kell.r,"Relative links don't work in Javadoc from overridden binary method with attached Javadoc Javadoc links to classes within the Javadoc of overridden methods in my Eclipse Workspace do not active when built from a .jar file. Instead they go to a ""This page can't be displayed"" screen in my Javadoc window and Javadoc tooltips.These same links work perfectly in the browser for my documentation (I'm using Chrome) and when the project is not built from the .jar but is viewed in the developer's workspace. This problem is critical because users building from a .jar file cannot view public documentation intentionally made available to them in their Eclipse Workspace."
431810,4/2/2014 9:57,shankhba,Annotations on constructors are always interpreted as type use annotations Created attachment 241511Test projectWe have a test in Xtext that fails on the current 4.4 integration build becauseannotations on constructors are interpreted as type use annotations and as such no longer returned by IMethodBinding.getAnnotations(). The annotation does not have a @Target.As we neither compile nor execute against Java8 this is a regression. I've attached a test project: The (plug-in) test fails as long as the @Target is not defined on MyAnnotation.
431811,4/2/2014 10:32,srikanth_sankaran,content assist should propose keyword 'super' after type name Content assist should propose keyword 'super' in the places it appears in this snippet:public class Main implements Intf { class Inner { { Main.super.hashCode(); } } @Override public void foo() { Intf.super.foo(); }}Implementation hint: Looks like keyword 'this' is implemented here: org.eclipse.jdt.internal.codeassist.CompletionEngine.findMembers(char[] ReferenceBinding Scope InvocationSite boolean Binding[] int[] int[] boolean)
431911,4/3/2014 9:50,shankhba,Reconsider test tweaks for JRE 8 compatibility With the solution in bug 390889 (if that strategy stays) much of the arduous tweak from bug 388800 comment 21 [1] might actually be obsolete now.I'll use this bug to investigate what can be removed / reverted.[1] http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&id=dd3bff4d99a5193497eb7e3c0e1bc46a32b7c36a
431963,4/3/2014 22:41,markus.kell.r,"[1.8][DOM] Confusion about type annotations of varargs method parameter From bug 420116 comment 9 consider the below code snippet:interface A {	int foo2C(Object @NonNull [] @Nullable... o2);}parameter#getTypeAnnotations() invoked on o2 returns only @NonNull annotation which results in:class C implements A {	@Override	public int foo2C(Object[] @NonNull... o2) { // @Nullable is missing		// TODO Auto-generated method stub		return 0;	}}"
432051,4/4/2014 13:12,manpalat,"ASTParser crashes with IAE for broken source Paste the snippet below and then delete the line /**that starts the Javadoc.=> ASTParser crashes with an IAEOriginally happened when I tried to edit org.eclipse.jdt.internal.corext.util.JavaModelUtil#getResolvedTypeName(String IType)Snippet:package xy;public class Crashing { /** * Delete line '/**' above. * * @param a (for example 'QVector') * @param declaringMember the context for resolving (made in) * @return if */ void foo() { }}java.lang.IllegalArgumentException	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:506)	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2956)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)	at ..."
432056,4/4/2014 14:41,markus.kell.r,"[1.8][javadoc] ""Open Attached Javadoc"" needs to adapt to Javadoc's new anchor format The Javadoc tool for Java SE 8 changed the anchor syntax and now tries to avoid ""strange"" characters in URLs by replacing them with ""-"" or "":A"" (for ""[]"").This breaks all clients that directly create such URLs. We can't know what format is required (at least without pre-loading the generated Javadoc) so we just guess by the project's compiler compliance."
432110,4/6/2014 14:13,srikanth_sankaran,"[1.8][compiler] nested lambda type incorrectly inferred vs javac Eclipse shows an error in the flatten2 method:Type mismatch: cannot convert from Stream<Object> to Stream<? extends Integer>The editor also shows this in the hover for the bug marker:Multiple markers at this line - Type mismatch: cannot convert from Stream<Object> to Stream<? extends Integer> - (Recovered) Internal inconsistency detected during lambda shape analysisjavac compiles the code with no warnings or errors.$ java -versionjava version ""1.8.0""Java(TM) SE Runtime Environment (build 1.8.0-b132)Java HotSpot(TM) 64-Bit Server VM (build 25.0-b70 mixed mode)$ javac -versionjavac 1.8.0Eclipse Java EE IDE for Web Developers.Version: Kepler Service Release 2Build id: 20140224-0627With: Eclipse JDT (Java Development Tools) Patch with Java 8 support (for Kepler SR2)	1.0.0.v20140317-1956	org.eclipse.jdt.java8patch.feature.group	Eclipse.org Eclipse PDE (Plug-in Development Environment) Patch with Java 8 support (for Kepler SR2)	1.0.0.v20140317-1956	org.eclipse.pde.java8patch.feature.group	Eclipse.orgDemonstration code follows---import java.util.List;import java.util.function.Function;import java.util.stream.Stream;class Bug{ // fully inline // compiles successfully Stream<? extends Integer> flatten1( final Stream<List<Integer>> input) { return input.flatMap(item -> item.stream().map(value -> value)); } // lambda using braces // compiles with error in eclipse successfully with javac Stream<? extends Integer> flatten2( final Stream<List<Integer>> input) { return input.flatMap(item -> { return item.stream().map(value -> value); }); } // without map step // compiles successfully Stream<? extends Integer> flatten3( final Stream<List<Integer>> input) { return input.flatMap(item -> { return item.stream(); }); } // with map step but not inline // compiles successfully Stream<? extends Integer> flatten4( final Stream<List<Integer>> input) { return input.flatMap(item -> { final Function<? super Integer ? extends Integer> mapper = value -> value; return item.stream().map(mapper); }); } // with map step but outer lambda is not inline // compiles successfully Stream<? extends Integer> flatten5( final Stream<List<Integer>> input) { final Function<? super List<Integer> ? extends Stream<? extends Integer>> func = item -> { return item.stream().map(value -> value); }; return input.flatMap(func); }}"
432121,4/7/2014 3:37,markus.kell.r,"[javadoc] IAE when hovering over types I had imported ""org.eclipse.jdt.ui.tests"" in my runtime workspace.Open ReturnTypeQuickFixTest.java and hover over IJavaProject in ""private IJavaProject fJProject1;"" the below exception is thrown.From the stack trace it looks like a regression from the recent fix for bug 432056.No exception is thrown when hovering over ""StringBuffer"" or ""List"". Whereas exception was consistently thrown when hovering over ""IJavaProject"" ""IJavaElement"" ""ICompilationUnit"" etc.java.lang.IllegalArgumentException: URI is not absolute	at java.net.URI.toURL(URI.java:1088)	at org.eclipse.jdt.internal.corext.javadoc.JavaDocLocations.getJavadocLocation(JavaDocLocations.java:544)	at org.eclipse.jdt.ui.JavaUI.getJavadocLocation(JavaUI.java:985)	at org.eclipse.jdt.internal.corext.javadoc.JavaDocLocations.getBaseURL(JavaDocLocations.java:635)	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:694)	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:607)	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:599)	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)"
432125,4/7/2014 3:51,markus.kell.r,"[quick fix] ""Expression needs unchecked conversion"" ""Replace with..."" quick fix should not insert wild cards (resulting in a compile error) Consider this code: public static void method(Collection<? extends Number> coll) { /* ... */ } public static void main(String[] args) { method(Collections.EMPTY_LIST); }The ""method"" call comes with a warning: ""Type safety: The expression of type List needs unchecked conversion to conform to Collection<? extends Number>"". The quick fix (which btw I appreciate very much in non-generic situations) replaces it with method(Collections.<? extends Number> emptyList());which is a compile error. It should be Collections<Number> or more generally the lower bound for the generic type parameter (e.g. Object in case of the type argument simply being <?>).Of course there is no obvious quick fix if there are multiple bounds as in the following line so probably no quick fix should be attempted here: public static <T extends Number & Comparable<?>> void method2(Collection<T> coll) { /* ... */ }"
432132,4/7/2014 4:51,noopur_gupta,JUnit test failures in AddUnimplementedMethodsTest http://download.eclipse.org/eclipse/downloads/drops4/N20140406-2000/testresults/html/org.eclipse.jdt.ui.tests_win32.win32.x86_7.0.htmlThere are 4 test failures in AddUnimplementedMethodsTest which can be reproduced by running the tests locally in workspace also. However these are not reproducible while performing the Override methods action in runtime.
432175,4/7/2014 12:57,manpalat,"[1.8] IAE in ImportRewrite#addImport(..) for IntersectionCastTypeBinding Created attachment 241686workaroundTry to extract ""Collections.emptyList()"" into a local variable here:package p;import java.util.*;public class C1 { public static <T extends Number & Comparable<?>> void method2(Collection<T> coll) {} public static void main(String[] args) { method2(Collections.emptyList()); }}java.lang.IllegalArgumentException: Invalid identifier : >Comparable & Number<	at org.eclipse.jdt.core.dom.SimpleName.setIdentifier(SimpleName.java:199)	at org.eclipse.jdt.core.dom.AST.newSimpleName(AST.java:2202)	at org.eclipse.jdt.core.dom.AST.newName(AST.java:1929)	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.createBaseType(ImportRewrite.java:1237)	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.internalAddImport(ImportRewrite.java:1291)	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.addImport(ImportRewrite.java:756)	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.internalAddImport(ImportRewrite.java:1307)	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.addImport(ImportRewrite.java:756)	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.createTempType(ExtractTempRefactoring.java:894)	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.createTempDeclaration(ExtractTempRefactoring.java:696)	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.createAndInsertTempDeclaration(ExtractTempRefactoring.java:667)	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.createTempDeclaration(ExtractTempRefactoring.java:760)	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.doCreateChange(ExtractTempRefactoring.java:549)	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.checkFinalConditions(ExtractTempRefactoring.java:492)The underlying problem is bug 99931 but we should try to avoid the IAE when dealing with IntersectionCastTypeBindings. The easiest solution I see is to use the same workaround in TypeBinding#getName() as already done in IntersectionCastTypeBinding#constantPoolName() and visible via TypeBinding#getKey(): Just pick one of the intersectingTypes. While this is not correct it at least meets the expectation of callers (get a single identifier)."
432189,4/7/2014 14:07,sarika.sinha,"Hot Code Replace Failed can appear multiple times occluding the original If I have the debugger running and I use git to switch to a different branch the ""Hot Code Replace Failed"" dialogue comes up. If I ignore it and continue working and later switch to yet another branch (or back to the original) Eclipse will pop up another copy of the ""Hot Code Replace Failed"" dialogue which completely occludes the original box. At this point only the original (hidden) dialogue box is active but it's hidden. clicking on the second dialogue box gets no response. You have to move the dialogue box in order to find the original. This can happen multiple times and the boxes have to be closed in FIFO order."
432190,4/7/2014 14:34,markus.kell.r,Update default Javadoc locations 1.4 and 1.3 docs/api/... are gone Javadoc for 1.3 and 1.4 has been archived athttp://docs.oracle.com/javase/1.4.2/docs/api/ andhttp://docs.oracle.com/javase/1.3/docs/api/ and the individual html pages are no longer available.http://docs.oracle.com/javaee/1.4/api/javax/enterprise/deploy/shared/ActionType.html is still available but the link to http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html also results in a 404 or timeout.
432284,4/8/2014 9:42,markus.kell.r,[1.8] Javadoc-8-style anchors not found by IMethod#getAttachedJavadoc(..) The Javadoc 8 tool has replaced certain special characters in method anchors with other characters. This breaks the implementation of IMethod#getAttachedJavadoc(..) in JavadocContents.I've filed a bug for Oracle for the breaking change (Review ID: JI-9011589).
432487,4/10/2014 4:49,shankhba,"[1.8][compiler] NullPointerException during compilation using jdk1.8.0 Created attachment 241815error dialogWhen compiling a piece of code (which contains errors) using jdk1.8.0 the compilation process stops with the attached error dialog. I've noticed the following things:- Compilation using jdk1.6.0_45 is working.- Compilation works when the compiler compliance level is set to 1.6 (using jdk1.8.0).- Compilation works when the compiler compliance level is set to 1.7 (using jdk1.8.0).I can reproduce this bug on a different computer (with the same eclipse version and sources)The following stack trace was logged:!ENTRY org.eclipse.core.resources 4 75 2014-04-10 09:56:07.706!MESSAGE Errors occurred during the build.!SUBENTRY 1 org.eclipse.jdt.core 4 75 2014-04-10 09:56:07.706!MESSAGE Errors running builder 'Java Builder' on project 'OffsiteSuite'.!STACK 0java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.MessageSend.computeConversion(MessageSend.java:378)	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.computeConversions(ConditionalExpression.java:663)	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.checkAgainstFinalTargetType(ConditionalExpression.java:723)	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolvePolyExpressionArguments(ASTNode.java:738)	at org.eclipse.jdt.internal.compiler.lookup.Scope.inferInvocationType(Scope.java:5131)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findDefaultAbstractMethod(Scope.java:1294)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1880)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1659)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:668)	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1018)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:619)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:299)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:529)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1317)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587)	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:771)	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137)	at java.lang.Thread.run(Thread.java:744)"
432515,4/10/2014 8:12,noopur_gupta,"[1.8][rename] Method renaming does not work well for method reference If I rename the mul() method to mulx() in following code:public class Test02 {	private static class Multiplier {		private final long mMul; 		public Multiplier(long iMul) { 			this.mMul = iMul;		}		public Long mul(Long iItem) {			return iItem * mMul;		}	}	private static void test(UnaryOperator<Long> iFn) {	}	public static void main(String[] args) {		UnaryOperator<Long> mul = (new Multiplier(3))::mul; 		test((new Multiplier(3))::mul);	}}it renames the 'Multiplier' constructor in both (new Multiplier(3))::mul occurrences. The result is (new mulx(3))::mulBut preview during renaming looks good i.e. all occurrences of method name are found well just final renaming fails.Used Eclipse 4.3.2 with Eclipse JDT (Java Development Tools) Patch with Java 8 support (for Kepler SR2) 1.0.0.v20140317-1956"
432520,4/10/2014 9:02,srikanth_sankaran,"compiler ""duplicate method"" bug with lamdas and generic interfaces Created attachment 241841failing test caseIf you try to run the attached code in eclipse it will fail with the following stacktrace:Exception in thread ""main"" java.lang.BootstrapMethodError: call site initialization exception	at java.lang.invoke.CallSite.makeSite(CallSite.java:328)	at java.lang.invoke.MethodHandleNatives.linkCallSite(MethodHandleNatives.java:296)	at eclipsebug.DuplicateMethodBug.main(DuplicateMethodBug.java:8)Caused by: java.lang.ClassFormatError: Duplicate method name&signature in class file eclipsebug/DuplicateMethodBug$$Lambda$1	at sun.misc.Unsafe.defineAnonymousClass(Native Method)	at java.lang.invoke.InnerClassLambdaMetafactory.spinInnerClass(InnerClassLambdaMetafactory.java:324)	at java.lang.invoke.InnerClassLambdaMetafactory.buildCallSite(InnerClassLambdaMetafactory.java:194)	at java.lang.invoke.LambdaMetafactory.altMetafactory(LambdaMetafactory.java:473)	at java.lang.invoke.CallSite.makeSite(CallSite.java:301)	... 2 moreCompiling it with standard javac and running it works as expected.The problem is the generic interface Provider<T> which extends ParentProvider<T>.As soon as you remove the extends clause from the Provider<T> interface everything works fine.The version is Eclipse Kepler SR 2 with the Eclipse JDT Patch with Java 8 support version 1.0.0.v20140317-1956.Best regardsFlorian"
432531,4/10/2014 11:13,sasikanth.bharadwaj,"[1.8] VerifyError with anonymous subclass inside of lambda expression in the superclass constructor call The following class will not load with due to:Exception in thread ""main"" java.lang.VerifyError: Bad type on operand stackException Details: Location: Y.<init>()V @2: invokedynamic Reason: Type uninitializedThis (current frame stack[1]) is not assignable to 'Y' Current Frame: bci: @2 flags: { flagThisUninit } locals: { uninitializedThis } stack: { uninitializedThis uninitializedThis } Bytecode: 0000000: 2a2a ba00 0b00 00b7 000c b1 	at java.lang.Class.getDeclaredMethods0(Native Method)	at java.lang.Class.privateGetDeclaredMethods(Class.java:2688)	at java.lang.Class.getMethod0(Class.java:2937)	at java.lang.Class.getMethod(Class.java:1771)	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)The class:import java.util.function.Supplier;class E {	E(Supplier<Object> factory) { }}public class Y extends E {	Y() {		super(() -> new Object() {		});	}	public static void main(String[] args) {		new Y();	}}If I convert the lambda to anonymous class it works."
432574,4/10/2014 22:49,sptaszkiewicz,"[1.8][compiler] Bogus compiler errors with annotations on ellipsis in lambda expression Below code snippet was executed successfully using Java 1.8 b132 using javac but it shows multiple compiler errors in Eclipse.import java.lang.annotation.ElementType;import java.lang.annotation.Target;public class C2 {	FI22 fi33= (String @T1[] @T1... x) -> {};		private void boo() {						FI22 fi333= (String @T1[] @T1... x) -> {};	}	public static void main(String[] args) {		System.out.println(""Compiled and Executed using javac!"");	}}interface FI22 {	void foo(String[]... x);}@Target(ElementType.TYPE_USE)@interface T1 {}"
432575,4/10/2014 23:25,markus.kell.r,"[1.8][quick assist] AFE while invoking quick assist from with in a lambda expression Consider the below code snippet:package p1;import java.io.IOException;import java.util.ArrayList;public class C1 {		FI1 fi11 = (java.util.@T ArrayList<IOException> x) -> { 	};}interface FI1 {	void foo(ArrayList<IOException> x);}Put cursor before -> and invoke Ctrl+1 below exception is thrown:org.eclipse.core.runtime.AssertionFailedException: assertion failed: 	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:110)	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:96)	at org.eclipse.jdt.internal.corext.refactoring.code.ConstantChecks$StaticFinalConstantChecker.visitName(ConstantChecks.java:192)	at org.eclipse.jdt.internal.corext.refactoring.code.ConstantChecks$StaticFinalConstantChecker.visit(ConstantChecks.java:156)	at org.eclipse.jdt.core.dom.QualifiedName.accept0(QualifiedName.java:168)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2759)	at org.eclipse.jdt.core.dom.NameQualifiedType.accept0(NameQualifiedType.java:190)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2759)	at org.eclipse.jdt.core.dom.ParameterizedType.accept0(ParameterizedType.java:175)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2759)	at org.eclipse.jdt.core.dom.SingleVariableDeclaration.accept0(SingleVariableDeclaration.java:422)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2782)	at org.eclipse.jdt.core.dom.LambdaExpression.accept0(LambdaExpression.java:211)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.internal.corext.refactoring.code.ConstantChecks$ExpressionChecker.check(ConstantChecks.java:44)	at org.eclipse.jdt.internal.corext.refactoring.code.ConstantChecks.isStaticFinalConstant(ConstantChecks.java:202)	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractConstantRefactoring.checkAllStaticFinal(ExtractConstantRefactoring.java:320)	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractConstantRefactoring.checkExpression(ExtractConstantRefactoring.java:401)	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractConstantRefactoring.checkSelection(ExtractConstantRefactoring.java:337)	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractConstantRefactoring.checkInitialConditions(ExtractConstantRefactoring.java:290)	at org.eclipse.jdt.internal.ui.text.correction.QuickAssistProcessor.getExtractVariableProposal(QuickAssistProcessor.java:445)	at org.eclipse.jdt.internal.ui.text.correction.QuickAssistProcessor.getAssists(QuickAssistProcessor.java:273)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeAssistCollector.safeRun(JavaCorrectionProcessor.java:403)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:339)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:329)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectAssists(JavaCorrectionProcessor.java:509)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectProposals(JavaCorrectionProcessor.java:287)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.computeQuickAssistProposals(JavaCorrectionProcessor.java:242)	at org.eclipse.jface.text.quickassist.QuickAssistAssistant$ContentAssistProcessor.computeCompletionProposals(QuickAssistAssistant.java:75)	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1861)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:568)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$16(CompletionProposalPopup.java:565)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:500)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:494)	at org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1687)	at org.eclipse.jface.text.quickassist.QuickAssistAssistant.showPossibleQuickAssists(QuickAssistAssistant.java:128)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionAssistant.showPossibleQuickAssists(JavaCorrectionAssistant.java:193)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:195)	at org.eclipse.ui.texteditor.TextOperationAction$1.run(TextOperationAction.java:128)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ui.texteditor.TextOperationAction.run(TextOperationAction.java:126)	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519)	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122)	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229)	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149)	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1112)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108)	at org.eclipse.swt.widgets.Widget.wmKeyDown(Widget.java:1831)	at org.eclipse.swt.widgets.Control.WM_KEYDOWN(Control.java:4975)	at org.eclipse.swt.widgets.Canvas.WM_KEYDOWN(Canvas.java:428)	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4642)	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5020)	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1135)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1016)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:635)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:578)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:125)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:379)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:233)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)	at org.eclipse.equinox.launcher.Main.main(Main.java:1438)"
432593,4/11/2014 4:30,manpalat,"[formatter]Infinite loop in CodeFormatter / Scribe Created attachment 241873Source to Paste into Eclipse with 1.5 Source Project SettingThe following test starts an infinite loop with the attached document in CodeFormatter. I can also paste this into eclipse and get the same problem.If I deactivate the option 1.5 it runs without the loop.the attached file is not syntactically correct but shouldn't create such a loop anyway.I have Kepler SR2 64 bit with JDK 8 extension.void test() throws IOException {		StringBuffer src = new StringBuffer();		for (String line : Files				.readAllLines(Paths						.get("".../reformatExample.txt""))) {			src.append(line);		}		String source = src.toString();		final Map<String String> options = JavaCore.getOptions();		options.put(JavaCore.COMPILER_SOURCE ""1.5"");		final CodeFormatter codeFormatter = ToolFactory.createCodeFormatter(options);		final TextEdit edit = codeFormatter.format(CodeFormatter.K_COMPILATION_UNIT source 0				source.length() 0 ""\r\n"");		assert edit != null;	}"
432605,4/11/2014 6:12,srikanth_sankaran,"[1.8] Incorrect error ""The type ArrayList<T> does not define add(ArrayList<T> Object) that is applicable here"" Created attachment 241880An excerpt showing the errorThe attached code fails to compile with ECJ but compiles successfully using javac. Some type information appears to be lost in the nested method call because extracting part of it into a new local variable makes the error go away.Tested using Eclipse SDKVersion: Luna (4.4)Build id: I20140402-0100and JDT Core built from HEAD yesterday."
432614,4/11/2014 7:58,jarthana,"[1.8] LambdaExpression#resolveMethodBinding() gives parameter type annotation from SAM package test.one;import java.lang.annotation.ElementType;import java.lang.annotation.Target;public class C1 {	FI fi1= (@T2 int i) -> {};}interface FI {	void foo(@T1 int i);}@Target(ElementType.TYPE_USE) @interface T1 {}@Target(ElementType.TYPE_USE) @interface T2 {}-------------------------------------------------------------In the above example lambdaExpression.resolveMethodBinding().getParameterTypes()[0] for the lambda expression gives ""@T1 int"".It should be ""@T2 int"". ""@T1 int"" is the type of the parameter in SAM."
432619,4/11/2014 8:50,srikanth_sankaran,"[1.8] Bogus error from method reference: ""should be accessed in a static way"" Using this code ECJ reports 6 errors all of them of the ""should be accessed in a static way"" kind. Compiling with javac works fine. For some reason removing the unused (not unused in the real version) type parameter E from the top-level interface makes the errors go away.package snippet;import java.util.Map;import java.util.stream.Collector;public interface StreamInterface<E extends Exception> {	static class DoubleCo {		private static class Re2 {			static <K E extends Exception> Map<K double[]> internalToMapToList2() {				Collector<Double double[][] double[][]> toContainer1 = Collector.of(				//The method supply() from the type StreamInterface.DoubleCo.Re2 should be accessed in a static way				 StreamInterface.DoubleCo.Re2::supply				 //The method accumulate(double[][] Double) from the type StreamInterface.DoubleCo.Re2 should be accessed in a static way				 StreamInterface.DoubleCo.Re2::accumulate				 //The method combine(double[][] double[][]) from the type StreamInterface.DoubleCo.Re2 should be accessed in a static way				 StreamInterface.DoubleCo.Re2::combine);				Collector<Double double[][] double[][]> toContainer2 =				//All 3 from above:				 Collector.of(DoubleCo.Re2::supply DoubleCo.Re2::accumulate DoubleCo.Re2::combine);				return null;			}			private static double[][] supply() {				return new double[64][];			}			private static void accumulate(double[][] container Double value) {}			private static double[][] combine(double[][] container double[][] containerRight) {				return new double[container.length + containerRight.length][];			}		}	}}"
432625,4/11/2014 9:35,srikanth_sankaran,"[1.8] VerifyError with lambdas and wildcards The Java 8 compiler that comes with Eclipse generates invalid bytecode for the following code:------------import java.util.stream.Stream;public class MainClass{ public static void main(String[] args) { Stream<?> stream = Stream.of(""A""); stream.map(x -> (String) x); }}------------Running this program immediately fails with a ""bad return type"" VerifyError:------------Exception in thread ""main"" java.lang.VerifyError: Bad return typeException Details: Location: MainClass.lambda$0(Ljava/lang/Object;)Ljava/lang/String; @1: areturn Reason: Type 'java/lang/Object' (current frame stack[0]) is not assignable to 'java/lang/String' (from method signature) Current Frame: bci: @1 flags: { } locals: { 'java/lang/Object' } stack: { 'java/lang/Object' } Bytecode: 0000000: 2ab0 	at java.lang.Class.getDeclaredMethods0(Native Method)	at java.lang.Class.privateGetDeclaredMethods(Class.java:2688)	at java.lang.Class.getMethod0(Class.java:2937)	at java.lang.Class.getMethod(Class.java:1771)	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)------------Compiling this class from the command line with jdk8 works fine.Also the problem does not occur in Eclipse if we replace the type ""Stream<?>"" with ""Stream<? extends Object>""."
432626,4/11/2014 9:55,srikanth_sankaran,[1.8] Type mismatch error after removing redundant type arguments Created attachment 241891Example code showing the bug before and afterThis bug may be a duplicate of either bug 432605 or bug 432619 but it involves a compiler warning so maybe not. Using the attached code it shows two versions of the same method. The first one has redundant type arguments on the indicated line which causes a warning to be shown which is fine. The second version is the same method after using Quick Assist to remove the arguments. The second version doesn't compile with ECJ but both versions compile with javac.
432628,4/11/2014 10:30,mateusz.matela,"[formatter] Add option ""Insert new line after annotations on enum constants"" The formatter should have an option ""Insert new line after annotations on enum constants"".With this option enabled code should look like this:public enum SomeEnum { @XmlEnumValue(""val1"") VAL_1(""val1"") @XmlEnumValue(""val2"") VAL_2(""val2""); ...}Currently formatting enums with line wrapping on enum constants set to ""Wrap all elements every element on a new line"" the output looks like this:public enum SomeEnum { @XmlEnumValue(""val1"") VAL_1(""val1"") @XmlEnumValue(""val2"") VAL_2(""val2""); ...}"
432759,4/14/2014 12:41,srikanth_sankaran,"[1.8][compiler] Some differences between Javac and ECJ regarding wildcards and static methods Please see the summary within the source code for differences and agreements between the compilers. I tried asking in lambda-dev about what the ground truth should be but didn't really get any answers so these are the those examples with some additional cleanup. Personally I don't think any one of these should be an error but that's not here or now.Tested with the ECJ from latest JDT Core built from HEAD today inside Eclipse IDE and javac from java.runtime.version=1.8.0-b132 running on java.vm.version=25.0-b70 launched from Maven with the following configuration:				<configuration>					<source>1.8</source>					<target>1.8</target>					<verbose>false</verbose>					<forceJavacCompilerUse>true</forceJavacCompilerUse>					<fork>true</fork>					<debuglevel>linesvarssource</debuglevel>					<showDeprecation>true</showDeprecation>					<showWarnings>true</showWarnings>					<compilerArgs>						<arg>-version</arg>						<arg>-Xlint:all</arg>						<arg>-Xdiags:verbose</arg>						<arg>-Xstdout</arg>						<arg>C:\Users\Timo\workspaceI\Java8Tests2\libfilename.txt</arg>					</compilerArgs>				</configuration>The source code:package differences;import java.util.function.BinaryOperator;import java.util.function.Consumer;/*Q*/@FunctionalInterface interface Subsumer<T> {	void accept(T t); default Subsumer<T> andThe1( Subsumer<? super T> afterT) { return (T t) -> { accept(t); afterT.accept(t); }; } default Subsumer<T> andThe2(Subsumer<T> this Subsumer<? super T> afterT) { return (T t) -> { this.accept(t); afterT.accept(t); }; } static <U> Subsumer<U> andThe3(Subsumer<U> tihs Subsumer<? super U> afterU) { return (U u) -> { tihs.accept(u); afterU.accept(u); }; } static <S extends ISSUPER_S ISSUPER_S> Subsumer<S> andThe4(Subsumer<S> tihs Subsumer<ISSUPER_S> afterS) { return (S s) -> { tihs.accept(s); afterS.accept(s); }; }}public class JavacECJDiffer {	static <T extends ISSUPER_T ISSUPER_T> void method() {		BinaryOperator<Consumer<? super T>> attempt_X_0 = Consumer::andThen;		BinaryOperator<Subsumer<? super T>> attempt_X_1 = Subsumer::andThe1;		BinaryOperator<Subsumer<? super T>> attempt_X_2 = Subsumer::andThe2;		BinaryOperator<Subsumer<? super T>> attempt_X_3 = Subsumer::andThe3;		BinaryOperator<Subsumer<? super T>> attempt_X_4 = Subsumer::andThe4;		BinaryOperator<Consumer<ISSUPER_T>> attempt_n_0 = Consumer::andThen;		BinaryOperator<Subsumer<ISSUPER_T>> attempt_n_1 = Subsumer::andThe1;		BinaryOperator<Subsumer<ISSUPER_T>> attempt_n_2 = Subsumer::andThe2;		BinaryOperator<Subsumer<ISSUPER_T>> attempt_n_3 = Subsumer::andThe3;		BinaryOperator<Subsumer<ISSUPER_T>> attempt_n_4 = Subsumer::andThe4;		// Summary:		// ECJ error #1 javac no error		// ECJ error #2 javac no error		// ECJ error #3 javac no error		// ECJ error #4 javac error #1		// ECJ error #5 javac error #2		// ECJ no error javac no error		// ECJ no error javac no error		// ECJ no error javac no error		// ECJ no error javac no error		// ECJ no error javac no error	}/*ECJ errors:1: The type Consumer does not define andThen(Consumer<? super T> Consumer<? super T>) that is applicable here2: The type Subsumer does not define andThe1(Subsumer<? super T> Subsumer<? super T>) that is applicable here3: The type Subsumer does not define andThe2(Subsumer<? super T> Subsumer<? super T>) that is applicable here4: The type Subsumer does not define andThe3(Subsumer<? super T> Subsumer<? super T>) that is applicable here5: The type Subsumer does not define andThe4(Subsumer<? super T> Subsumer<? super T>) that is applicable herejavac errors:1: C:\Users\Timo\workspaceI\Java8Tests2\src\differences\JavacECJDiffer.java:18: error: incompatible types: invalid method reference		BinaryOperator<Subsumer<? super T>> attempt_X_3 = Subsumer::andThe3;		 ^ method andThe3 in interface Subsumer<T#2> cannot be applied to given types required: Subsumer<U>Subsumer<? super U> found: Subsumer<? super T#1>Subsumer<? super T#1> reason: inference variable U has incompatible bounds equality constraints: CAP#1 upper bounds: T#1Object where UT#1ISSUPER_TT#2 are type-variables: U extends Object declared in method <U>andThe3(Subsumer<U>Subsumer<? super U>) T#1 extends ISSUPER_T declared in method <T#1ISSUPER_T>method() ISSUPER_T extends Object declared in method <T#1ISSUPER_T>method() T#2 extends Object declared in interface Subsumer where CAP#1 is a fresh type-variable: CAP#1 extends Object super: T#1 from capture of ? super T#12: C:\Users\Timo\workspaceI\Java8Tests2\src\differences\JavacECJDiffer.java:19: error: incompatible types: invalid method reference		BinaryOperator<Subsumer<? super T>> attempt_X_4 = Subsumer::andThe4;		 ^ method andThe4 in interface Subsumer<T#2> cannot be applied to given types required: Subsumer<S>Subsumer<ISSUPER_S> found: Subsumer<? super T#1>Subsumer<? super T#1> reason: inference variable ISSUPER_S has incompatible bounds equality constraints: CAP#1 lower bounds: SCAP#2 where SISSUPER_ST#1ISSUPER_TT#2 are type-variables: S extends ISSUPER_S declared in method <SISSUPER_S>andThe4(Subsumer<S>Subsumer<ISSUPER_S>) ISSUPER_S extends Object declared in method <SISSUPER_S>andThe4(Subsumer<S>Subsumer<ISSUPER_S>) T#1 extends ISSUPER_T declared in method <T#1ISSUPER_T>method() ISSUPER_T extends Object declared in method <T#1ISSUPER_T>method() T#2 extends Object declared in interface Subsumer where CAP#1CAP#2 are fresh type-variables: CAP#1 extends Object super: T#1 from capture of ? super T#1 CAP#2 extends Object super: T#1 from capture of ? super T#1*/ /*E*/}"
432771,4/14/2014 20:08,noopur_gupta,"[quick assist] NPE in LocalCorrectionsSubProcessor.getUnusedObjectAllocationProposals inside a constructor I have a warning for unused object allocations turned on. Trying to invoke Quick Assist on such a warning inside a constructor causes NPE at org.eclipse.jdt.internal.ui.text.correction.LocalCorrectionsSubProcessor.getUnusedObjectAllocationProposals(LocalCorrectionsSubProcessor.java:1264)The line in question is: 				ITypeBinding returnTypeBinding= method.getReturnType2().resolveBinding();The hover for method getReturnType2 says:		Returns: 				the return type possibly the void primitive type or null if noneSince this happens inside a constructor I believe this is the reason for getting null from that method call. I can create reduced version for reproduction if necessary.The full stack trace:java.lang.NullPointerException	at org.eclipse.jdt.internal.ui.text.correction.LocalCorrectionsSubProcessor.getUnusedObjectAllocationProposals(LocalCorrectionsSubProcessor.java:1264)	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.process(QuickFixProcessor.java:706)	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.getCorrections(QuickFixProcessor.java:313)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:378)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:339)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:335)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:468)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectProposals(JavaCorrectionProcessor.java:280)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.computeQuickAssistProposals(JavaCorrectionProcessor.java:242)	at org.eclipse.jface.text.quickassist.QuickAssistAssistant$ContentAssistProcessor.computeCompletionProposals(QuickAssistAssistant.java:75)	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1861)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:568)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$16(CompletionProposalPopup.java:565)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:500)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:494)	at org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1687)	at org.eclipse.jface.text.quickassist.QuickAssistAssistant.showPossibleQuickAssists(QuickAssistAssistant.java:128)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionAssistant.showPossibleQuickAssists(JavaCorrectionAssistant.java:193)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:195)	at org.eclipse.ui.texteditor.TextOperationAction$1.run(TextOperationAction.java:128)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ui.texteditor.TextOperationAction.run(TextOperationAction.java:126)	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519)	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122)	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)	at sun.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229)	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149)	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1112)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108)	at org.eclipse.swt.widgets.Widget.wmKeyDown(Widget.java:1831)	at org.eclipse.swt.widgets.Control.WM_KEYDOWN(Control.java:4975)	at org.eclipse.swt.widgets.Canvas.WM_KEYDOWN(Canvas.java:428)	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4642)	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5033)	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1135)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1016)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:379)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:233)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)"
432781,4/15/2014 2:48,daniel_megert,"[common navigator] Java Elements content extension shows non-Java projects in Project Explorer Delete and Copy context menu options in Project Explorer get disabled for a project on deselecting ""Resource"" contents1. Create a normal project without any facet applied(File->New->Project... and selecting General->Project)2. Right click on the Project in the Project Explorer: Observe that the Delete Menu is visible3. Select: Project Explorer->Customize View->Content 4. Deselect: Resources. 5. Right click on the Project in the Project Explorer: Observe that the Delete and Copy Menu is no longer visibleNote: This issue doesn't occur with Java Projects."
432977,4/17/2014 3:42,srikanth_sankaran,"[1.8][null] Incorrect 'type is not visible' compiler error My project is using java 1.8 and null annotations. In some of my classes whenever I make any change to the code the compiler gives one or more ""The type ... is not visible"" errors on places where this is not correct (in some cases the 'invisible' type is String!).I've also seen the error ""The method ... is undefined for the type ..."" appear.The errors disappear when rebuilding the entire project (Project -> Clean...).These errors only appear if ""annotation-based null analysis"" is enabled."
433011,4/17/2014 10:39,jarthana,"[1.8][search] for references to method reference expression: match range too long Blocker for bug 432515. Search for references to method reference expressions should report a MethodReferenceMatch whose range starts with the method name and doesn't include the qualifier. That's how all other kinds of method reference matches are reported.package com.test;import java.util.function.*;public class Snippet<E> { String searchForRefs() { return """"; } /** * @see Snippet#searchForRefs() */ public void bar() { this.searchForRefs(); Supplier<String> v1 = new Snippet<Integer>()::searchForRefs; Supplier<String> v2 = this::searchForRefs; Function<Snippet<Integer> String> v3 = Snippet<Integer>::searchForRefs; Function<Snippet<Integer> String> v4 = Snippet::searchForRefs; }}class Sub extends Snippet<Object> { Supplier<String> hexer3 = super::searchForRefs;}"
433026,4/17/2014 12:31,markus.kell.r,"[1.8][quick fix] Conversion to Lambda is not appearing when it should Let say we have a piece of code containing an anonymous class:		Runnable runner = new Runnable() {			public void run() {				System.out.println(""Hello runner!"");			}		};- Clicking anywhere in these lines- Selecting all the lines- selecting the first line+ Quick Fix does not show the ""Convert to lambda expression"" fix.This makes this conversion fix difficult to discover.Ideally we could have a warning associated to this Lambda conversion."
433060,4/17/2014 20:50,sasikanth.bharadwaj,"[1.8][compiler] enum E<T>{I;} causes NPE in AllocationExpression.checkTypeArgumentRedundancy Trying to write a generic enum leads to error message popup the file being marked with internal compiler error and lots of errors being logged. To reproduce just uncomment the rest of the line in this test-case:package npe_oejica_AllocationExpression_checkTypeArgumentRedundancy_line_621;public enum AutoCloser//<T> {	OBJ;}Here's the full stack trace:java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.checkTypeArgumentRedundancy(AllocationExpression.java:621)	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolvePart3(AllocationExpression.java:548)	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:488)	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.resolve(FieldDeclaration.java:264)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1143)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1317)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1204)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:135)	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:114)	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)"
433084,4/18/2014 10:55,jarthana,NPE in AnnotationMirrorImpl.equals in Java 8 Patch for Kepler I am not sure about the version. It is the Java 8 Patch for Kepler.I tried to use annnotation processor that worked before but now I get an NPE in AnnotationMirrorImpl.equals()Looking into git repository I assume that the following commit is the reason:http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=dc36142c1b691365c62ee525109945bae71724d2 since this change is not null safe:+ return obj.equals(this); // obj could be wrapped by a proxy.
433178,4/22/2014 5:12,jarthana,[1.8] [content assist] should propose keyword 'new' after 'Type::' (CreationReference) Content Assist should propose keyword 'new' after 'Type::' e.g. here: IntFunction<Integer> s= Integer::new;
433246,4/22/2014 15:29,markus.kell.r,"[content assist] BadLocationException when trying to complete generic type at end of file - Have this CU *without* a newline at the end:package p;import java.util.function.IntFunction;public class C implements IntFun- Invoke Content Assist at the very end of the fileorg.eclipse.jface.text.BadLocationException	at org.eclipse.jface.text.AbstractDocument.addPosition(AbstractDocument.java:355)	at org.eclipse.core.internal.filebuffers.SynchronizableDocument.addPosition(SynchronizableDocument.java:236)	at org.eclipse.jface.text.AbstractDocument.addPosition(AbstractDocument.java:376)	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.installLinkedMode(LazyGenericTypeProposal.java:765)	at org.eclipse.jdt.internal.ui.text.java.LazyGenericTypeProposal.apply(LazyGenericTypeProposal.java:246)	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:497)	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.apply(LazyJavaCompletionProposal.java:489)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:963)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$21(CompletionProposalPopup.java:927)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:512)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:499)	at org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1687)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:183)..."
433373,4/24/2014 5:14,noopur_gupta,"[1.8][rename] NPE on renaming the functional method package p1;public class C1 {	FI fi1 = (int i) -> {};}interface FI {	void foo(int i); // Rename 'foo' to 'foo1' using Alt+Shift+R}class Test {	void foo1(int c){}	}--------------------------------------------------------In the above example rename 'foo' to 'foo1' using Alt+Shift+R as mentioned in the comment. Renaming fails and we get the following exception:java.lang.reflect.InvocationTargetException	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:423)	at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2075)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2071)	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:191)	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:151)	at org.eclipse.jdt.ui.refactoring.RenameSupport.perform(RenameSupport.java:198)	at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameLinkedMode.doRename(RenameLinkedMode.java:362)	at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameLinkedMode$EditorSynchronizer.left(RenameLinkedMode.java:119)	at org.eclipse.jface.text.link.LinkedModeModel.exit(LinkedModeModel.java:341)	at org.eclipse.jface.text.link.LinkedModeUI$4.run(LinkedModeUI.java:1193)	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)......Caused by: java.lang.NullPointerException	at org.eclipse.jdt.core.search.SearchPattern.createPattern(SearchPattern.java:1880)	at org.eclipse.jdt.internal.corext.refactoring.RefactoringSearchEngine.createOrPattern(RefactoringSearchEngine.java:201)	at org.eclipse.jdt.internal.corext.refactoring.rename.RenameMethodProcessor.batchFindNewOccurrences(RenameMethodProcessor.java:590)	at org.eclipse.jdt.internal.corext.refactoring.rename.RenameMethodProcessor.analyzeRenameChanges(RenameMethodProcessor.java:540)	at org.eclipse.jdt.internal.corext.refactoring.rename.RenameMethodProcessor.doCheckFinalConditions(RenameMethodProcessor.java:388)	at org.eclipse.jdt.internal.corext.refactoring.rename.RenameVirtualMethodProcessor.doCheckFinalConditions(RenameVirtualMethodProcessor.java:146)	at org.eclipse.jdt.internal.corext.refactoring.rename.JavaRenameProcessor.checkFinalConditions(JavaRenameProcessor.java:48)	at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:224)	at org.eclipse.ltk.core.refactoring.Refactoring.checkAllConditions(Refactoring.java:162)	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper$Operation.run(RefactoringExecutionHelper.java:80)	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2333)	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5357)	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106)	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)"
433404,4/24/2014 8:52,jarthana,[1.8] ICompilationUnit#findElements(IJavaElement) doesn't find LambdaExpression IType org.eclipse.jdt.internal.core.CompilationUnit#findElements(IJavaElement) doesn't find the corresponding element for a LambdaExpression.The problem is that it calls Member#getType(String int) which doesn't work for LambdaExpressions and returns a nonexistent SourceType. This eventually caused the NPE in bug 433373.In that specific situation the fix for bug 433373 will hide this problem.Nevertheless for 4.5 the findElements API should specify that it can't be used to find ITypes whose #isLambda() returns true and the implementation should return null. It should also specify that it returns null for an ILocalVariable.
433455,4/24/2014 14:58,markus.kell.r,StandardVMType.generateLibraryInfo() failed to detect libraries Oracle JRockit VM [Luna] After upgrading to Luna we notice the JDT code we are using to detect installed VM throw error on Oracle JRockit VM. After some debugging it seems caused by the logic in StandardVMType.generateLibraryInfo() where following command is executed with the JVM to list the libraries:E:\WLS1036\jrockit_160_29_D1.2.0-10\bin\java.exe -Xmx4m -classpath D:\kepler\workspace_luna_src\.metadata\.plugins\org.eclipse.pde.core\New_configuration\org.eclipse.osgi\489\0\.cp\lib\launchingsupport.jar org.eclipse.jdt.internal.launching.support.LibraryDetectorNotice the VM argument -Xmx4m is the one causing problem.On Jrockit it ends up with[ERROR] Argument error: -Xmx4m[ERROR] Specified maximum heap size (4MB) is less than minimum required (16MB).Could not create the Java virtual machine.To Reproduce:- Download and install JRockit from http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-jrockit-2192437.html- In Preference \ Java \ Installed JRE- Add the JRockit from installation location
433458,4/24/2014 15:08,srikanth_sankaran,[1.8][compiler] Eclipse accepts lambda expression with potentially uninitialized arguments Not sure if this is a bug with Eclipse's Java implementation or Oracle's. Former compiler accepts the below code while latter rejects (Test.java:13: error: variable mComparator1 might not have been initialized).--import java.util.Comparator;class Test { // 'final' keyword causes error final Comparator mComparator1; Comparator mComparator2 =// new Comparator() {// public int compare(Object pObj1 Object pObj2) {// return mComparator1.compare(pObj1 pObj2);// }// }; (pObj1 pObj2) -> mComparator1.compare(pObj1 pObj2); Test() {mComparator1 = Comparator.naturalOrder();}}
433500,4/25/2014 5:59,jarthana,[templates] Add variables for inner and outer expressions Created attachment 242323Concept of postfix templatesThis bug discusses the implementation/extension of the Eclipse template system to support postfix code completion.A summary of the concept of postfix code completion is described here: http://goo.gl/UdXIKFI have regularly used IntelliJ for the last two month to determine if postfix code completion enables major increase in productivity. The bottom line is that some of the postfix templates of IntelliJ really save a lot of time and key strokes. Especially the templates .var .field .for and some others lead to a very good developer experience.I'm aware of bugs like https://bugs.eclipse.org/bugs/show_bug.cgi?id=427201 and the discussed solutions using shortcuts for those purposes but...1.) Using shortcuts needs the developer almost every time to leave the home position (asdf jkl; respectively asdf jkl??) of the keyboard which costs a lot of time in the long run and also disrupts the typing flow2.) Remembering dozens of advanced shortcuts is hard3.) Discovering advanced shortcuts is sometimes even harderFurthermore the existing template concept of Eclipse to achieve auto code generation as described in the above-mentioned bug is also inconvenient and not a time saving action (1. selecting the line 2. invoking the content assist using Ctrl+Space 3. selecting and applying the template using arrow keys)Summing up I really would love to see postfix code completion in Eclipse.I am willing to implement this feature and therefore I have already digged into the sources of the template system of Eclipse and JDT.The attached image may be considered as a rough concept of postfix templates. I will try to implement a prototype plug-in which meets these requirements hopefully without the need to touch existing code and I will come up with a prototype/proof of concept or at least new findings within the next week.Sidenote: Analyzing existing code completion techniques in general and Eclipse-specific techniques is the topic of my bachelor thesis which is supervised by Marco Descher. A major part of the bachelor thesis also describes the implementation of a postfix code completion plug-in for Eclipse.
433503,4/25/2014 6:36,markus.kell.r,"Use OrderedTestSuite instead of listing all test methods again Some jdt.core tests use an error-prone method to guarantee test execution order. E.g. JavaSearchBugsTests and JavaSearchBugs8Tests list all test methods again in the suite() method implementation.1. This hack should not be applied without an understanding why the tests fail when they are executed in random order.2. Instead of listing all test methods again you should at least use a utility like return new OrderedTestSuite(JavaSearchBugs8Tests.class);or just return buildModelTestSuite(JavaSearchBugs8Tests.class ALPHABETICAL_SORT)without the ""if (TESTS_PREFIX != null || ..."" before."
433588,4/27/2014 8:45,srikanth_sankaran,"[1.8][compiler] ECJ compiles an ambiguous call in the presence of an unrelated unused method. This is making my head hurt. This bug report was supposed to be about mark occurrences and find references disagreeing about whether a method was called or not but I must have made a mistake preparing the test case because it turned into this instead.Using this code:package mark.occurrences.find.references;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.function.Consumer;import java.util.stream.Stream;public class Disagree {	private interface StreamyBase<T E extends Exception> {		@SuppressWarnings(""unused"")		default void forEachOrdered(Consumer<? super T> action) throws E {}	}	abstract private static class AbstractStream<T E extends Exception STREAM SELF extends AbstractStream<T E STREAM SELF CONSUMER> CONSUMER>	 implements StreamyBase<T E> {		@SuppressWarnings(""unused"")		public void forEachOrdered(CONSUMER action) throws E {}		// remove this method with a warning about it being unused:		public final @SafeVarargs void forEachOrdered(Consumer<? super T> action Consumer<? super T>... actions) throws E {}	}	private static class UnStream<T> extends	 AbstractStream<T RuntimeException Stream<T> UnStream<T> Consumer<? super T>> {}	private static class IOStream<T> extends	 AbstractStream<T IOException Stream<T> IOStream<T> IOConsumer<? super T>> {}	@FunctionalInterface	private interface ExConsumer<T E extends Exception> {		void accept(T t1) throws E;	}	@FunctionalInterface	private interface IOConsumer<T> extends ExConsumer<T IOException> {}	public static void tests1(IOStream<String> lines1 UnStream<String> lines2) throws IOException {		IOConsumer<? super String> action = s -> Files.isHidden(Paths.get(s));		Consumer<? super String> action2 = s -> System.out.println(s);		lines1.forEachOrdered(action);		lines1.forEachOrdered(action2);		lines2.forEachOrdered(action2);		// After removal these two become ambiguous:		lines1.forEachOrdered(s -> Files.isHidden(Paths.get(s)));		lines1.forEachOrdered(s -> System.out.println(s));	}}Removing the method indicated in the code above causes two of the forEachOrdered method calls to become ambiguous.Is there an undiagnosed problem in the code? Or is an unused method that is acting as a tie-breaker truly unused? You decide!"
433591,4/27/2014 9:04,markus.kell.r,"[1.8][clean up][quick assist] ""Convert anonymous to lambda"" considers overridden method as ambiguous target type ""Convert anonymous to lambda"" considers overridden method as ambiguous target type after bug 423439.One example is in org.eclipse.jface.viewers.SWTFocusCellManager#hookListener(ColumnViewer):private void hookListener(final ColumnViewer viewer) {//...	viewer.addSelectionChangedListener(new ISelectionChangedListener() {		@Override		public void selectionChanged(SelectionChangedEvent event) {			if( event.selection.isEmpty() ) {				setFocusCell(null);			}		}	});The addSelectionChangedListener(..) method is declared in ISelectionProvider and overridden in Viewer."
433605,4/27/2014 16:41,Lars.Vogel,[CSS] [dark theme] Provide reasonable JDT defaults for syntax color in the dark theme Dani Markus I can prepare a Gerrit review for JDT based on https://git.eclipse.org/c/platform/eclipse.platform.ui.git/commit/?id=ddc1935b78481a9b74b071390c3a45072485a632Please point me to your preferred plug-ins for adding this.
433715,4/28/2014 17:51,markus.kell.r,"[1.8][inline] NPE when inlining a local variable Trying to inline the local variable indicated in this code causes an Internal Error caused by a NPE to be logged:import java.io.IOException;import java.util.function.Predicate;class DeadBeef {	private interface IOPredicate<T> {		boolean test(T t1) throws IOException;	}	@SuppressWarnings(""unused"")	private static abstract class AbstractStream<T SELF extends AbstractStream<T SELF PREDICATE> PREDICATE> {		@SuppressWarnings(""null"") SELF filter(PREDICATE allowed) {			return null;		} @SuppressWarnings(""null"") final @SafeVarargs SELF filter(Predicate<? super T> allow Predicate<? super T>... allowed) {			return null;		}	}	private static class IOStream<T> extends AbstractStream<T IOStream<T> IOPredicate<? super T>> {}	static IOStream<String> main(IOStream<String> a) {		// Trying to inline this variable causes an Internal Error:		IOPredicate<String> allowed = word -> true;		return a.filter(allowed);	}}Here is the full stack trace:Caused by: java.lang.NullPointerException	at org.eclipse.jdt.internal.corext.dom.ASTNodes$AmbiguousTargetMethodAnalyzer.visit(ASTNodes.java:727)	at org.eclipse.jdt.internal.corext.dom.ASTNodes.isTargetAmbiguous(ASTNodes.java:679)	at org.eclipse.jdt.internal.corext.dom.ASTNodes.getExplicitCast(ASTNodes.java:606)	at org.eclipse.jdt.internal.corext.refactoring.code.InlineTempRefactoring.getModifiedInitializerSource(InlineTempRefactoring.java:383)	at org.eclipse.jdt.internal.corext.refactoring.code.InlineTempRefactoring.getInitializerSource(InlineTempRefactoring.java:349)	at org.eclipse.jdt.internal.corext.refactoring.code.InlineTempRefactoring.inlineTemp(InlineTempRefactoring.java:327)	at org.eclipse.jdt.internal.corext.refactoring.code.InlineTempRefactoring.createChange(InlineTempRefactoring.java:308)	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:124)	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:209)	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2333)	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)Tested with Eclipse SDKVersion: Luna (4.4)Build id: I20140422-0800and JDT UI built from HEAD just now."
433735,4/29/2014 4:49,srikanth_sankaran,"[1.8] Discrepancy with javac when dealing with local classes in lambda expressions The following class is accepted by eclipse while it is rejected by javac with the errorcannot reference this before super type constructor has been called.--------------------->import java.util.function.Supplier;class E {	E(Supplier<Object> factory) { }}public class Y extends E {	Y() {		super( () -> {			class Z extends E {				Z() {					super(new Supplier<Object>() {						@Override						public Object get() {							// TODO Auto-generated method stub							return new Object();						}					});				}			} 			return new Z();			});	}	public static void main(String[] args) {		new Y();	}}----------------------------->Not sure if it's a bug in eclipse or javac."
433747,4/29/2014 6:09,srikanth_sankaran,[compiler] TYPE Annotation allowed in package-info instead of only PACKAGE The Eclipse Java Compiler allows to annotate the package in package-info.java with annotations of ElementType.TYPE. With Java7 this was working fine but alo there the Oracle Java Compiler raised an error.With Java8 the implementation of class Class does no longer load the annotations of ElementType.TYPE for the package-info. Only annotations of ElementType.PACKAGe are found and also accepted from the Oracle Java Compiler.
433754,4/29/2014 8:20,noopur_gupta,"CCE in QuickAssistProcessor#getConvertEnhancedForLoopProposal Taken from bug 426967 comment #2:class E {	private void foo() {		for (String str : new String[1]) {		}	}}Press Ctrl+1 at ""str"" we get the exception:java.lang.ClassCastException: org.eclipse.jdt.core.dom.SimpleType cannot be cast to org.eclipse.jdt.core.dom.ArrayType	at org.eclipse.jdt.internal.ui.text.correction.QuickAssistProcessor.getConvertEnhancedForLoopProposal(QuickAssistProcessor.java:2588)	at org.eclipse.jdt.internal.ui.text.correction.QuickAssistProcessor.getAssists(QuickAssistProcessor.java:281)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeAssistCollector.safeRun(JavaCorrectionProcessor.java:403)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:339)..."
433825,4/30/2014 5:34,sasikanth.bharadwaj,"[1.8][compiler] Internal compiler error: NullPointerException in AllocationExpression#resolvePart3 Created attachment 242527Source fileThe attached java class crashes the compiler with an NPE (in Eclipse 3.8.2 and javac compiling works fine).Compiler Compliance Level has to be set to 1.8.java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolvePart3(AllocationExpression.java:525)	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.checkAgainstFinalTargetType(AllocationExpression.java:728)	at org.eclipse.jdt.internal.compiler.ast.ConditionalExpression.checkAgainstFinalTargetType(ConditionalExpression.java:728)	at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolvePolyExpressionArguments(ASTNode.java:739)	at org.eclipse.jdt.internal.compiler.lookup.Scope.inferInvocationType(Scope.java:5136)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor0(Scope.java:2490)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getConstructor(Scope.java:2429)	at org.eclipse.jdt.internal.compiler.ast.Statement.findConstructorBinding(Statement.java:362)	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolvePart2(AllocationExpression.java:511)	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:486)	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:619)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:299)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:529)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1204)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)"
433879,4/30/2014 13:19,shankhba,"ArrayBinding cannot be cast to ReferenceBinding The following Java code:Class<? extends Exception>[] exceptions;try { // some stuff here} catch (exceptions[0] e) { // some more stuff here}causes the following error:Internal compiler error: java.lang.ClassCastException:org.eclipse.jdt.internal.compiler.lookup.ArrayBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding at org.eclipse.jdt.internal.compiler.ast.TryStatement.verifyDuplicationAndOrder (TryStatement.java:1191)""Help -> About Eclipse -> (Eclipse logo)"" reports ""3.9.1.v20130911-1000"" as the version of the ""Eclipse Java Development Tools (org.eclipse.jdt)"" on my machine but 3.9.1 was not available in the version-menu above so I selected 3.8.2 instead (closest). I am using Kepler SR1."
433932,5/1/2014 9:37,daniel_megert,"Cancel moving a read-only resource error It is not possible to cancel moving a read-only resource.Selecting Cancel or No in the Check Move prompt result in InvocationTargetException wrapping this exception:java.lang.ArrayIndexOutOfBoundsException: 0	at org.eclipse.ltk.internal.core.refactoring.resource.MoveResourcesProcessor.getMoveDescription(MoveResourcesProcessor.java:186)	at org.eclipse.ltk.internal.core.refactoring.resource.MoveResourcesProcessor.createChange(MoveResourcesProcessor.java:220)	at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.createChange(ProcessorBasedRefactoring.java:292)	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:124)It seems there is an error in the implementation of MoveResourcesProcessor.getMoveDescription() - if and else statements must be swapped."
433989,5/2/2014 8:54,sasikanth.bharadwaj,Nested static generic class reference is incorrectly marked as compile error Created attachment 242632Screenshot of incorrect validation in latest stable build of Luna.class A<V> { public static class Container { public static class In<T> { public static class Inner<U> { } } public static <X> void doit() { new In.Inner<X>(); // compilation error } }}Mentioned piece of code is being reported by JDT to contain error with the following message: * The member type A.Container.In must be parameterized since it is qualified with a parameterized type (Java Problem)However the code is syntactically correct and can be compiled via javac. Tested on Eclipse Kepler Juno and Luna (see attached screenshot) builds.Originally asked as a question on StackOverflow - http://stackoverflow.com/questions/23416674/nested-generics-in-java
434159,5/6/2014 1:52,noopur_gupta,"[1.8][quick fix] does not provide a ""correct"" fix when a static and a default method in interface interface I {	public static void bar(int i) { }	public default void bar() {}} class Y implements I{	 public static void main(String[] args) { 	new Y().ba(0);//Use quick assist for this error	}}quick fix changes just the ba to bar (without mentioning / changing the parameter) but bar(int i) being static is not applicable in the context of new Y()."
434173,5/6/2014 4:12,noopur_gupta,"[1.8][quick fix] strictfp ignored for remove method suggestion interface I {	public strictfp void foo() { // Use quick assist -> remove method body		System.out.println(""Hellow""); 	}}quick fix suggests ""remove method body"" [one of the suggestions] for the above issue which would make foo an abstract method for which strictfp modifier is not allowed and hence results in an error"
434188,5/6/2014 6:33,markus.kell.r,"[quick fix] shows sign of quick fix but says no suggestions available. @FunctionalInterfaceinterface I {	public int foo(I i);}public class X {	public static int bar(I i) { return 0;}	public int foo(I i) {		I i1 = X::;// shows probable quick fix but says no suggestions.		return 0;	}}[not java 8 specific]"
434269,5/6/2014 18:12,markus.kell.r,[1.8][hovering] Support showing Javadoc for JavaFX properties - Take 2 In bug 424283 we have added support to copy the JavaDoc from a private field unfortunately the JavaFX people are not consistent on where they put it - looking at BorderPane#center the documentation is on the BorderPane#centerPropertyI guess this is too late to get into Luna SR0?
434307,5/7/2014 6:46,jarthana,M7 Regression. Java 7 no longer supported. I've just upgraded to M7. Disaster.All my Java 6/7 source code complains that JDT annotations are only available with Java 8 or higher and demands that I change projhect compliance and JRE to 1.8I have jdt.annotation 1.1.0.v20140129-1625 installed so surely this should preserve Juno/Kepler functionality.
434352,5/7/2014 12:14,daniel_megert,"[preferences] Store method parameter names preference doesn't capture what's really stored 4.4 M7.This was brought up by Noopur: ""Store method parameter names"" doesn't capture what's really stored e.g. 'final' modifier is also written to the class file.The spec talks about ""information"":""information about the formal parameters of a method such as their names. ""Therefore we should rename our preference to:Store information about method parameters (usable via reflection)"
434394,5/8/2014 5:05,srikanth_sankaran,"[1.8] inference fails in some cases when conditional expression is involved The following code causes compilation error in eclipse but compiles fine with javac.import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;public class InferenceProblem { public void bla() { boolean b = Boolean.TRUE.booleanValue(); List<String> c1 = new ArrayList<>(); Collections.sort(c1 new Foo(new State<>((b ? new Val<>(""AAAA"") : new Val<>(""BBBB""))))); // Cannot infer type arguments for State Collections.sort(c1new Foo(b ? new State<>(new Val<>(""AAAA"")) : new State<>(new Val<>(""BBBB"")))); // this is fine } static class Foo implements Comparator<String>{	 public Foo(State<String> st) {		 //	 }	@Override	public int compare(String o1 String o2) {		// TODO Auto-generated method stub		return 0;	}	 }	static class State<R> {		State(Val<?> o) {		}	}	static class Val<T> {		Val(T t) {}	}}"
434442,5/8/2014 12:24,jarthana,"ClassFormatError when using Enums in Java 8 Default interface methods Created attachment 242860simple switch with enumsException in thread ""main"" java.lang.ClassFormatError: Illegal field modifiers in class ecj/tests/I: 0x100A	at java.lang.ClassLoader.defineClass1(Native Method)	at java.lang.ClassLoader.defineClass(ClassLoader.java:760)	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)	at java.net.URLClassLoader.defineClass(URLClassLoader.java:455)	at java.net.URLClassLoader.access$100(URLClassLoader.java:73)	at java.net.URLClassLoader$1.run(URLClassLoader.java:367)	at java.net.URLClassLoader$1.run(URLClassLoader.java:361)	at java.security.AccessController.doPrivileged(Native Method)	at java.net.URLClassLoader.findClass(URLClassLoader.java:360)	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)	at java.lang.ClassLoader.defineClass1(Native Method)	at java.lang.ClassLoader.defineClass(ClassLoader.java:760)	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)	at java.net.URLClassLoader.defineClass(URLClassLoader.java:455)	at java.net.URLClassLoader.access$100(URLClassLoader.java:73)	at java.net.URLClassLoader$1.run(URLClassLoader.java:367)	at java.net.URLClassLoader$1.run(URLClassLoader.java:361)	at java.security.AccessController.doPrivileged(Native Method)	at java.net.URLClassLoader.findClass(URLClassLoader.java:360)	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495)"
434464,5/8/2014 21:50,het,Resource leak in APT classloader APT uses URLClassLoader which opens streams on its resources and does not ensure they are closed until URLClassLoader.close() is called. When APT clears its cached classloaders (org.eclipse.jdt.apt.core.internal.AnnotationProcessorFactoryLoader.uncacheProject(IJavaProject) org.eclipse.jdt.apt.core.internal.AnnotationProcessorFactoryLoader.resetAll() org.eclipse.jdt.apt.core.internal.AnnotationProcessorFactoryLoader.resetBatchProcessors(IJavaProject)) it only calls close() on the classloader if it is a JarClassLoader (a class which is actually not used anywhere). This means that resources opened by URLClassLoader are never closed.I propose that the code is changed to check if the classloader is a URLClassLoader instead of JarClassLoader.
434507,5/9/2014 10:11,noopur_gupta,"[1.8][clean up][quick assist] ""Convert anonymous to lambda"" results in ambiguous method error package p1;interface ISuper {	void foo(FI1 fi1);}interface ISub extends ISuper {	void foo(FI2 fi2);}// ---@FunctionalInterfaceinterface FI1 {	void abc();}@FunctionalInterfaceinterface FI2 {	void xyz();}// ---class Test1 {	private void test1() {		f1().foo(new FI1() {			@Override			public void abc() {	// [1]				System.out.println();			}		});	}		private ISub f1() {		return null;	}}abstract class Test2 implements ISub {	private void test2() {		foo(new FI1() {			@Override			public void abc() { // [2]				System.out.println();			}		});	}}class Test3 {	void foo(FI1 fi1) {}	void foo(FI2 fi2) {}	private void test3() {		foo(new FI1() {			@Override			public void abc() { // [3]				System.out.println();			}		});	}}-----------------------------------------------------------------------Apply the quick assist / cleanup at [1] [2] [3] in the above example.Bug 423439 handles only case [3].[1] and [2] result in ambiguous method error.ASTNodes.isTargetAmbiguous(Expression) uses methodBinding.getDeclaringClass() to look for overloaded methods.For [1] the type of the expression in invocation should be used and for [2] the enclosing type should be used.We should find the correct type to be visited by AmbiguousTargetMethodAnalyzer."
434527,5/9/2014 12:00,jarthana,Unable to create ecj.jar from ecjsrc.jar When bug 421017 was fixed the compliance and target platform for jdt.core bundle were moved to 1.6. These changes should reflect in the scripts/build.xml. Right now creating ecj.jar from the source jar fails with compiler errors because of lack of support for annotations (we started using annotations since bug 421017 was fixed). This should be addressed in Luna.
434556,5/9/2014 18:15,sasikanth.bharadwaj,"Broken class file generated for incorrect annotation usage This came up in AspectJ bug 377096 but appears to be a JDT issue. Basically create a project with this source inside:import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Retention(RetentionPolicy.RUNTIME)@interface C {	int i(); }public class A {	 @C(b={}i=42) public void xxx() {} public static void main(String []argv) throws Exception {	System.out.println(A.class.getDeclaredMethod(""xxx"").getAnnotations()[0]); }}There is a compile error against 'b={}' because b doesn't exist in the annotation. However a class file is generated regardless (that's ok). The body of the method 'xxx()' includes the message but the RuntimeVisibleAnnotation on xxx() is not correct. It breaks javap when attempting to decompile the class. Or to see the problem you can run the class above which fails with:Exception in thread ""main"" java.lang.reflect.GenericSignatureFormatError: Signature Parse error: Expected Field Type Signature	Remaining input: i	at sun.reflect.generics.parser.SignatureParser.error(SignatureParser.java:124)	at sun.reflect.generics.parser.SignatureParser.parseFieldTypeSignature(SignatureParser.java:297)	at sun.reflect.generics.parser.SignatureParser.parseFieldTypeSignature(SignatureParser.java:283)	at sun.reflect.generics.parser.SignatureParser.parseTypeSignature(SignatureParser.java:485)	at sun.reflect.generics.parser.SignatureParser.parseTypeSig(SignatureParser.java:188)	at sun.reflect.annotation.AnnotationParser.parseSig(AnnotationParser.java:436)	at sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:241)	at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120)	at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72)	at java.lang.reflect.Executable.declaredAnnotations(Executable.java:546)	at java.lang.reflect.Executable.getDeclaredAnnotations(Executable.java:539)	at java.lang.reflect.Method.getDeclaredAnnotations(Method.java:615)	at java.lang.reflect.AccessibleObject.getAnnotations(AccessibleObject.java:206)	at A.main(A.java:14)Although the code does have an error in it I don't believe we want to generate illegal class files.javap produces: public void xxx(); descriptor: ()V flags: ACC_PUBLICError: java.lang.reflect.InvocationTargetException RuntimeVisibleAnnotations: length = 0x7 00 01 00 12 49 00 13 The first bit of the data is correct '00 01' => 1 annotationThe remaining data is for the 'i=42' (00 12 49 00 13).The data is missing between them for the annotation type itself something like '00 0d 00 01' => annotation type A (#0d in constant pool) and there is 1 annotation value."
434582,5/10/2014 16:51,shankhba,[1.8][compiler][null] @Nullable annotation in type parameter causes NullPointerException in JDT core Created attachment 242935Example project with stack tracesI was trying to create a visitor for an AST which determines whether two trees are equal. Turns out adding @Nullable to a type parameter in some cases results in a NullPointerException somewhere in the JDT core.The intended class header waspublic class EqualsVisitor extends ConcreteNodeVisitor<Boolean @Nullable Object>But Eclipse doesn't like the @Nullable there.I attached an example project with a text file with the stack traces. Most of the errors that showed up in the error log were repeats of these or so they seemed.
434612,5/12/2014 2:38,sarika.sinha,JDIModelPresentation can remove IDebugModelPresentation in implements section JDIModelPresentation extends IDebugModelPresentationExtension which extends IDebugModelPresentation so IDebugModelPresentation can be removed from JDIModelPresentation's implements section
434693,5/13/2014 3:08,noopur_gupta,"[1.8][clean up] convert nested anonymous to lambdas results in code with conflicting variable names (This issue is related to bug 424223)When a ""Clean-up"" converting anonymous to lambda is applied on this use case:public class Test {	interface FIOther {		void run(int x);	}	public class TestOther {		void init(String e) {			String x;			m(new FIOther() {				@Override				public void run(int e) {					FIOther fi = new FIOther() {						@Override						public void run(int e) {							return;						}					};				}			});		}		void m(FIOther fi) {		};	}}... one get:public class Test {	interface FIOther {		void run(int x);	}	public class TestOther {		void init(String e) {			String x;			m(e1 -> {				FIOther fi = e1 -> { // Error					return;				};			});		}		void m(FIOther fi) {		};	}}"
434722,5/13/2014 6:13,Michael_Rennie,"error in ConditionalJump Instruction Created attachment 243009Bug ConditionalJump InstructionThe ASTEvaluationEngine failed to execute the ConditionalJump instructions when the condition is an instance of java.lang.Boolean object (not a primitive value).Example (add TestHCR.java to any project) and apply the following steps:1- add a breakpoint on the first line of the main method2- open Display view in eclipse 3- copy the block if (ifCondition) {		System.out.println(""if condition true""); } and execute it. A new ClassCastException will be thrown./** * * @author j.Saoumi * */package java8;public class TestHCR {		public static Boolean ifCondition = Boolean.TRUE;			public static void main(String[] args) {		System.out.println(""begin main"");		if (ifCondition) {			System.out.println(""if condition true"");		}		System.out.println(""end main"");	}	}"
434788,5/13/2014 13:24,noopur_gupta,[1.7][clean up] Remove unnecessary type arguments Add Clean Up options for one or both of- Remove unnecessary type arguments- Insert inferred type argumentsSee bug 351956 and UI discussions there.
434791,5/13/2014 13:57,daniel_megert,"[inline][quick assist] Delete key does not work after Inline local variable If the command Quick Assist - Inline local variable is bound to Ctrl+Alt+Right in Preferences->General->Keys and that combination is activated and a local variable is thus inlined pressing the Delete key afterwards has no effect. Delete key starts working again after some characters are selected with Shift+Any arrow key or the caret jumps to a different location by pressing Ctrl+Right Ctrl+Left Home End.To reproduce the bug take this source:import java.util.ArrayList;import java.util.function.Supplier;import java.util.stream.Collector;import java.util.stream.Collectors;class DeleteKey<T> {	public void inline() {		// inline collectionFactory by pressing Ctrl+Alt+Right with the caret within it:		Supplier<ArrayList<T>> collectionFactory = ArrayList<T>::new;		Collector<T ? ArrayList<T>> collection = Collectors.toCollection(collectionFactory);	}}Steps:1. Open Preferences -> General -> Keys and find Quick Assist - Inline local variable bind it to the key combination Ctrl+Alt+Right Arrow and press OK.2. Move the caret in the middle of the name of the variable collectionFactory.3. Press Ctrl+Alt+Right Arrow key combination.4. Press Delete but it doesn't delete anything.Tested with Eclipse SDK Version: Luna (4.4) Build id: I20140510-1500"
434884,5/14/2014 12:43,noopur_gupta,"[1.8][clean up] Converting nested anonymous classes to lambda does not convert inner anonymous class Place the following files in respective packages:////////////////////////////////package p4a;@FunctionalInterfacepublic interface FI1<R> { public R foo1();}////////////////////////////////package p4a;@FunctionalInterfacepublic interface FI2 { public void foo2();}////////////////////////////////package p4b;import p4a.FI1;import p4a.FI2;public class Test {	{		FI1 fi1 = new FI1<FI2>() { @Override public FI2 foo1() { return new FI2() { @Override public void foo2() {} }; } };	}}////////////////////////////////Apply clean-up on Test.java to use lambda where possible.The result is:////////////////////////////////package p4b;import p4a.FI1;public class Test {	{		FI1 fi1 = () -> new FI2() {		 @Override		 public void foo2() {}		};	}}////////////////////////////////The issues are:- Only the outer anonymous class is converted to lambda- Import statement for FI2 is removed.- Hovering on FI2 in the resultant code does not provide the quick fix to import FI2."
434935,5/15/2014 5:14,Michael_Rennie,"Java 7u45/8 fails to launch Java processes from UNC paths [PATCH IN GERRIT] When the host Eclipse workbench is running with a Java 8 VM Eclipse's java launching process fails on Windows if the Java executable is on a UNC path.--- 8< ---This occurs because of a change to the argument processing in Java 8http://hg.openjdk.java.net/jdk8/jdk8/jdk/diff/5ea5f5dfb96a/src/windows/classes/java/lang/ProcessImpl.javaIf the JVM property jdk.lang.Process.allowAmbigousCommands is set to false then it works as expected.--- 8< ---The problem is that running a quoted command succeeds iff the command is not on a unc path and is not on Java 8:J7: c:\foo worksJ7: ""c:\foo"" worksJ7: \\host\share\foo worksJ7: ""\\host\share\foo"" worksJ8: c:\foo worksJ8: ""c:\foo"" worksJ8: \\host\share\foo worksJ8: ""\\host\share\foo"" failsThe solution which fixes it (other than the above system property) is not to escape the command itself in AbstractVMRunner.java:	private static String[] quoteWindowsArgs(String[] cmdLine) {		// see https://bugs.eclipse.org/387504 workaround for http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6511002		if (Platform.getOS().equals(Constants.OS_WIN32)) {			String[] winCmdLine = new String[cmdLine.length];			for (int i = 0; i < cmdLine.length; i++) {				winCmdLine[i] = winQuote(cmdLine[i]);			}			cmdLine = winCmdLine;Changing it to ""for(int i=1 ...)"" fixes the issue."
434941,5/15/2014 6:10,markus.kell.r,"Sort members has different behavior in eclipse 4.4 Consider the following:public class BugExample{	public static final int CONSTANT = 5;		public static void main(final String[] args)	{//...}}In eclipse Kepler when sorting the members (Source -> Sort Members...) it would stay as is.In eclipse Luna (4.4M7) it changes to:public class BugExample{			public static void main(final String[] args)	{//...} public static final int CONSTANT = 5;}The same workspace/project settings are used with both luna and kepler. I tried switching back and forth between kepler and luna and kepler always prefers the first variant while luna always prefers the second. My Java->Appearance->Members Sort Order is like this:TypesStatic FieldsStatic initializersStatic methodsFieldsInitializersConstructorsMethodsAssuming ""static"" and ""static final"" fields are encompassed in ""Static Fields"" I think the correct behavior is the one in Kepler."
435219,5/19/2014 11:48,srikanth_sankaran,"[1.8][content assist] No proposals for some closure cases Here are a few cases where i don't get any code completion in closures using Luna M7I've written the places where i trigger code completion in the line above.n means no proposals.y means completion works fine Case 1 .n .n .y new Thread(() -> System.out.println(""foo"")).start();Case 2 List<Integer> list = Arrays.asList(1 2 3); .y :n list.stream().map((x) -> x * x.hashCode()).forEach(System.out::println);Case 3 List<Integer> costBeforeTax = Arrays.asList(100 200 300); double bill = costBeforeTax.stream().map((cost) -> cost + 0.19 * cost) .y .n .y .reduce((sum cost) -> sum.doubleValue() + cost.doubleValue()).get();That last case is particulary interesting as i don't even get an empty list of proposals. JDT doesn't seem to think you can trigger code completion here."
435279,5/20/2014 7:55,manju656,[Hover] NPE when Annotation not visible on classpath +++ This bug was initially created as a clone of Bug #435213 +++> The hover is not shown. Instead of that a NPE is shown in the errorlog.Manju please prepare a patch that avoids the NPE in JavadocHover#addAnnotation(..). It's OK if the link is not resolvable but an unresolvable link should not block the Javadoc hover.
435281,5/20/2014 8:00,srikanth_sankaran,"[1.8][code assist] No import or completion proposal for anonymous class inside lambda Place the following files in respective packages:////////////////////////////////package p4a;@FunctionalInterfacepublic interface FI1<R> { public R foo1();}////////////////////////////////package p4a;@FunctionalInterfacepublic interface FI2 { public void foo2();}////////////////////////////////package p4b;import p4a.FI1;public class Test {	{ new FI2() {};		FI1 fi1 = () -> new FI2() {		 @Override		 public void foo2() {}		};	}}////////////////////////////////In class Test hover on the error at second 'FI2'. No quick fix is provided to import 'FI2'.Also see bug 434884 comment #3:org.eclipse.jdt.internal.ui.text.correction.SimilarElementsRequestor#findSimilarElement(ICompilationUnit Name int) does get an anonymous class completion proposal with the caret after the first ""new FI2"" but not after the second one inside the lambda."
435348,5/20/2014 22:32,shankhba,"[1.8][compiler] NPE in JDT Core during AST creation Consider the below code snippet:package p1;import java.util.function.Consumer;public class Test { static void run(Consumer<Integer> consumer) { // type '@' before Consumer<Integer> System.out.println(""consumer""); } static { run(new Consumer<Integer>() { @Override public void accept(Integer integer) { System.out.println(andThen(null)); } }); }}Type '@' as mentioned in the code and there are multiple NPE thrown.java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding.anonymousOriginalSuperType(LocalTypeBinding.java:89)	at org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding.sourceName(LocalTypeBinding.java:282)	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.illegalModifierForLocalClass(ProblemReporter.java:2776)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.checkAndSetModifiers(ClassScope.java:638)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.buildLocalType(ClassScope.java:204)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.buildAnonymousTypeBinding(ClassScope.java:62)	at org.eclipse.jdt.internal.compiler.lookup.BlockScope.addAnonymousType(BlockScope.java:94)	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveTypeForQualifiedAllocationExpression(QualifiedAllocationExpression.java:538)	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.resolveType(QualifiedAllocationExpression.java:283)	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:619)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:299)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:529)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1204)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:470)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)"
435419,5/21/2014 11:54,sasikanth.bharadwaj,Instantiating needs outer constructor Eclipse Version: Kepler Service Release 2Build id: 20140224-0627I am interested to know why new CompositeStatement() and new Expr2() {} can be created at lines 17 and 31 but not at line 40. import java.util.ArrayList; public class Demo { static class ExprFactoryList extends ArrayList<Object> { class Expr {} class Expr2 extends Expr {} } final static ExprFactoryList arith = new ExprFactoryList() { { add(new Object() {public Expr generate() {return new Expr() {};} }); // OK add(new Object() {public Expr generate() {return new Expr2() {};} }); // Ok } }; final static ExprFactoryList statementFactory = new ExprFactoryList() { class Statement extends Expr {} void m() { add(new Object() { public void generate() { new Statement(){}; // OK } }); } { add (new Statement()); // OK add(new Object() { public void generate() { new Statement(); // OK // No enclosing instance of type new // Demo.ExprFactoryList(){} is accessible to invoke the // super constructor. Must define a constructor and // explicitly qualify its super constructor invocation with // an instance of new Demo.ExprFactoryList(){} (e.g. // x.super() where x is an instance of new // Demo.ExprFactoryList(){}). new Statement(){}; // cannot compile } }); } }; }See formatted http://pastebin.com/61gyGE02I would be surprised if this is not a bug.
435444,5/21/2014 16:09,noopur_gupta,Update Tips & Tricks for Luna (4.4) Update JDT T&T document with relevant items from Luna (4.4) N&N documents.
435480,5/22/2014 4:49,manpalat,[1.8][search] search in method reference expressions finds annotation element name package bug;import java.lang.annotation.Documented;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value={})public @interface Ann1 {}----------------------------------------------- Place the above code in a 1.8 java project.- Select the file and press Ctrl+H to bring up the Search dialog.- In Java Search give Search string as '*' Search For as 'Method' Limit To as 'Match Locations' with ''::' method references' selected and Scope as 'Selected resources'. Click Search.- The result shows 'value' in the result from the given example.
435544,5/22/2014 12:50,shankhba,"[compiler][null] Enum constants not recognised as being NonNull (take2) According to bug 411771 enum constants should not lead to warnings but it looks like this only works when the enum is declared in the same class as the usage happens.package bla;public enum Bla {	A	B}package bla;import org.eclipse.jdt.annotation.NonNull;public class Blo {	public enum Bli {		A		B	}		@NonNull	public Bla bla = Bla.A; // warning		@NonNull	public Bli bli = Bli.A; // no warning}"
435571,5/22/2014 17:39,markus.kell.r,"ImportReferencesCollector needs to support old AST levels ImportReferencesCollector needs to support old AST levels see bug 435540.org.eclipse.jdt.ui.actions.OverrideMethodsAction#createRunnable(..) is a legal way to create an AddUnimplementedMethodsOperation and there's no restriction on the AST level there. Most of JDT UI only uses the latest AST level but in this case we have to support older levels as well.org.eclipse.jst.j2ee.ejb.annotation.modelErrorThu May 22 19:26:03 EEST 2014Operation only supported in JLS8 and later ASTjava.lang.UnsupportedOperationException: Operation only supported in JLS8 and later AST	at org.eclipse.jdt.core.dom.ASTNode.unsupportedIn2_3_4(ASTNode.java:1968)	at org.eclipse.jdt.core.dom.AnnotatableType.annotations(AnnotatableType.java:99)	at org.eclipse.jdt.internal.corext.codemanipulation.ImportReferencesCollector.visit(ImportReferencesCollector.java:203)	at org.eclipse.jdt.core.dom.SimpleType.accept0(SimpleType.java:197)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2782)	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:469)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2782)	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:212)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.internal.corext.codemanipulation.ImportReferencesCollector.collect(ImportReferencesCollector.java:68)	at org.eclipse.jdt.internal.corext.codemanipulation.ImportReferencesCollector.collect(ImportReferencesCollector.java:62)	at org.eclipse.jdt.internal.corext.codemanipulation.ContextSensitiveImportRewriteContext.getImportedNames(ContextSensitiveImportRewriteContext.java:226)	at org.eclipse.jdt.internal.corext.codemanipulation.ContextSensitiveImportRewriteContext.findInContext(ContextSensitiveImportRewriteContext.java:99)	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.internalAddImport(ImportRewrite.java:941)	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.addImport(ImportRewrite.java:639)	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility2.createThrownExceptions(StubUtility2.java:509)	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility2.createImplementationStub(StubUtility2.java:349)	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility2.createImplementationStub(StubUtility2.java:315)	at org.eclipse.jdt.internal.corext.codemanipulation.AddUnimplementedMethodsOperation.run(AddUnimplementedMethodsOperation.java:213)	at org.eclipse.jst.j2ee.ejb.annotations.internal.classgen.EjbBuilder.createInheritedMethods(EjbBuilder.java:221)..."
435639,5/23/2014 9:32,noopur_gupta,Update F1 Help and documentation for new JDT features in Luna Update the F1 help and documentation for JDT features from Luna M1-M7 N&N documents.
435682,5/23/2014 16:36,srikanth_sankaran,"[1.8] content assist not working inside lambda expression Version: Luna M7 Release (4.4.0M7)Build id: 20140508-1440In the code below on the second line code assist shows ""no default proposal"" when invoked at the |.List<String> words = Arrays.asList(""hi"" ""hello"" ""hola"" ""bye"" ""goodbye"");List<String> list1 = words.stream().map(s -> s.|).collect(Collectors.toList());Also no code assist when the type is specified like in this line.List<String> list2 = words.stream().map((String s) -> s.|).collect(Collectors.toList());Note that in the second example the code assist worked in Kepler (Version: 4.3.2 Build id: M20140221-1700) with Eclipse Java Development Tools Patch for Java 8 Support (BETA)	1.0.0.v20131108-0105_BETA_JAVA8.But a compilation error (Type mismatch: cannot convert from List<Object> to List<String>) was given in kepler when the line was completed as List<String> list = words.stream().map((String s) -> s.toUpperCase()).collect(Collectors.toList());In Luna this line compiles ok."
435869,5/27/2014 4:44,shankhba,"[1.8][compiler]AIOOB with annotated intersection cast Created attachment 243519TestCompile the attached code to get the following stack trace:java.lang.ArrayIndexOutOfBoundsException: 800	at org.eclipse.jdt.internal.compiler.ClassFile.generateBootstrapMethods(ClassFile.java:2962)	at org.eclipse.jdt.internal.compiler.ClassFile.addAttributes(ClassFile.java:385)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:577)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:635)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:368)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1210)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)"
436125,5/28/2014 16:59,markus.kell.r,"JDT repo contains an old notice.html in the root binary +++ This bug was initially created as a clone of Bug #436048 +++Bug 436048 fixed all major cases but a few left in JDT: eclipse.jdt/org.eclipse.jdt-feature/rootfiles/notice.htmleclipse.jdt/org.eclipse.jdt/notice.htmlMarking as minor since these are probably not needed or maybe one is but I think very rare if not impossible for a user to ""see"" it (I think would only surface if someone created a product with JDT as the _primary_ root feature? Attachment in bug 436048 (or the URL there0 could be used as source of the new notice.html."
436139,5/29/2014 2:30,manpalat,"[1.8][search][model] Hierarchy search involving lambda and anonymous class do not find the anonymous class Tested using Build id: I20140522-1330Consider the below code snippet:package p1;interface FI {	void foo(ArrayList<IOException> x); // Invoke F4 on foo}package p3;import java.io.IOException;import java.util.ArrayList;public class C1 {	private Object patternChanged(ArrayList<IOException> x1) {		FI f1 = new FI() {			public void foo(ArrayList<IOException> x) {			}		};		return null;	}	private void someOtherMethod() {		FI f2 = (x) -> {			patternChanged(x);		};		FI f3 = new FI() {			public void foo(ArrayList<IOException> x) {			}		};	}}Invoking 'F4' to compute the Type Hierarchy of 'FI#foo' returns only 2 implementation expected was 3.If 'f2' is commented out then 'f3' is revealed in the search."
436141,5/29/2014 2:39,noopur_gupta,[quick fix] Make Configure Problem Severity a quick fix Users can configure problem severity from the problem marker if they press F2. However it seems that users are unaware of this [1]. Can we consider making this action a quick-fix?[1] http://dev.eclipse.org/mhonarc/lists/ide-dev/msg00515.html
436155,5/29/2014 7:36,jarthana,"[type hierarchy] No type hierarchy shown for org.eclipse.swt.widgets.Text package bug;import org.eclipse.swt.widgets.Text;class T2 {	Text text = new Text(null 0);	private void bar() {		text.setSelection(0);	}}--------------------------------------------------Place the caret at #setSelection in the above example and press Ctrl+T.The resulting quick type hierarchy pop-up is empty.Place caret at ""Text"" and press F4. Type Hierarchy view shows only ""Object"".This used to work before Java 8 related code changes (up to I20140311-1200)."
436301,5/31/2014 19:49,daniel_megert,"astview has (apparently old) buildnotes While fixing bug 436219 and then testing it and finding buildnotes were no longer collected I also happened to notice that the astview bundle has (and apparently old) ""buildnotes"" file: .../eclipse.jdt.ui/org.eclipse.jdt.astview/buildnotes_astview.htmlI suspect this is not worth fixing for ""the last week of Luna"" simply because that'd change the qualifier which would effect the feature qualifier etc. ... and we all know what trouble that's been lately. But suggest that it be removed (or .. updated?) in maintenance (and master) after we release Luna."
436347,6/2/2014 6:04,shankhba,"Regression: NegativeArraySizeException at org.eclipse.jdt.internal.core.ClassFileInfo.generateMethodInfos Helloupdating a complex Maven Project leads to the following error:java.lang.NegativeArraySizeException	at org.eclipse.jdt.internal.core.ClassFileInfo.generateMethodInfos(ClassFileInfo.java:273)	at org.eclipse.jdt.internal.core.ClassFileInfo.readBinaryChildren(ClassFileInfo.java:420)	at org.eclipse.jdt.internal.core.ClassFile.buildStructure(ClassFile.java:98)	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)	at org.eclipse.jdt.internal.core.SourceRefElement.generateInfos(SourceRefElement.java:107)	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)	at org.eclipse.jdt.internal.core.BinaryType.getElementInfo(BinaryType.java:287)	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:280)	at org.eclipse.jdt.internal.core.JavaElement.exists(JavaElement.java:198)	at org.jboss.tools.common.util.EclipseJavaUtil.findType(EclipseJavaUtil.java:116)	at org.jboss.tools.common.java.ParametedTypeFactory.getParametedType(ParametedTypeFactory.java:128)	at org.jboss.tools.common.java.ParametedTypeFactory.getParametedType(ParametedTypeFactory.java:80)	at org.jboss.tools.cdi.internal.core.impl.definition.ParameterDefinition.init(ParameterDefinition.java:43)	at org.jboss.tools.cdi.internal.core.impl.definition.AbstractMemberDefinition.setAnnotatable(AbstractMemberDefinition.java:64)	at org.jboss.tools.cdi.internal.core.impl.definition.ParameterDefinition.setLocalVariable(ParameterDefinition.java:37)	at org.jboss.tools.cdi.internal.core.impl.definition.MethodDefinition.loadParamDefinitions(MethodDefinition.java:87)	at org.jboss.tools.cdi.internal.core.impl.definition.MethodDefinition.init(MethodDefinition.java:63)	at org.jboss.tools.cdi.internal.core.impl.definition.AbstractMemberDefinition.setAnnotatable(AbstractMemberDefinition.java:64)	at org.jboss.tools.cdi.internal.core.impl.definition.MethodDefinition.setMethod(MethodDefinition.java:48)	at org.jboss.tools.cdi.internal.core.impl.definition.TypeDefinition.init(TypeDefinition.java:70)	at org.jboss.tools.cdi.internal.core.impl.definition.AbstractMemberDefinition.setAnnotatable(AbstractMemberDefinition.java:64)	at org.jboss.tools.cdi.internal.core.impl.definition.AbstractTypeDefinition.setType(AbstractTypeDefinition.java:69)	at org.jboss.tools.cdi.internal.core.impl.CDIProject.rebuildBeans(CDIProject.java:1310)	at org.jboss.tools.cdi.internal.core.impl.CDIProject.update(CDIProject.java:1172)	at org.jboss.tools.cdi.internal.core.impl.CDIProject.update(CDIProject.java:1199)	at org.jboss.tools.cdi.internal.core.impl.definition.DefinitionContext.applyWorkingCopy(DefinitionContext.java:419)	at org.jboss.tools.cdi.core.CDICoreBuilder.build(CDICoreBuilder.java:247)	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)I have seen bug fixes for ArrayOutOfBoundsExceptions in this way but it seems the problem has not been fixed completely.RegardsHeikoeclipse.buildId=4.4.0.I20140601-2000java.fullversion=JRE 1.7.0 IBM J9 2.6 Windows 7 amd64-64 Compressed References 20140106_181350 (JIT enabled AOT enabled)J9VM - R26_Java726_SR6_20140106_1601_B181350JIT - r11.b05_20131003_47443.02GC - R26_Java726_SR6_20140106_1601_B181350_CMPRSSJ9CL - 20140106_181350BootLoader constants: OS=win32 ARCH=x86_64 WS=win32 NL=de_DECommand-line arguments: -os win32 -ws win32 -arch x86_64"
436350,6/2/2014 7:08,srikanth_sankaran,"[1.8][compiler] Missing bridge method in interface results in AbstractMethodError Created attachment 243774Code that demonstrates the bugIn the attached sample I have a Generic Interface which accepts generic objects and a specialised subinterface which accepts specialised objects and provides a default method for the generic interface's method which delegates to the specialised implementation.If I implement the specialised method in an anonymous class and pass it to some code that calls the generic method then the code correctly executes and passed through to the specialised method.However if rather than implementing the anonymous class I use a lambda expression the code compiles fine but at runtime I get an AbstractMethodError ""java.lang.AbstractMethodError: Method LambdaBugDemo$$Lambda$1.reduce(Ljava/util/Iterator;)Ljava/lang/Object"". Apparently the default method is not picked up.This code compiles and runs fine on Oracle JDK 1.8_05 for OsX. It compiles fine in eclipse but the generated code throughs the error as specified.The attached java file contains a full demonstration of the problem."
436486,6/3/2014 12:09,jarthana,AnnotationDiscoveryVisitor.resolveAnnotations causes unhappy processing order From bug 421601 comment 6:It seems that the following call stack is disturbing evaluation of null annotations: at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:776) at org.eclipse.jdt.internal.compiler.ast.ASTNode.resolveAnnotations(ASTNode.java:767) at org.eclipse.jdt.internal.compiler.apt.dispatch.AnnotationDiscoveryVisitor.resolveAnnotations(AnnotationDiscoveryVisitor.java:233) at org.eclipse.jdt.internal.compiler.apt.dispatch.AnnotationDiscoveryVisitor.visit(AnnotationDiscoveryVisitor.java:217) at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1338) at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:745) at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:706) at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundEnvImpl.<init>(RoundEnvImpl.java:58) at org.eclipse.jdt.internal.compiler.apt.dispatch.BaseAnnotationProcessorManager.processAnnotations(BaseAnnotationProcessorManager.java:148) at org.eclipse.jdt.internal.compiler.Compiler.processAnnotations(Compiler.java:818) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:434) at org.eclipse.jdt.internal.compiler.batch.Main.performCompilation(Main.java:4129) at org.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1694) at org.eclipse.jdt.internal.compiler.batch.Main.main(Main.java:1405) Normally in the compiler ASTNode.resolveAnnotations would be invoked from STB.getAnnotationTagBits() and during this call we would also invoke STB.evaluateNullAnnotations().With APT in the loop however ASTNode.resolveAnnotations sets TagBits.AnnotationResolved and whenever STB.getAnnotationTagBits() is called we do nothing so STB.evaluateNullAnnotations() is never invoked.
436542,6/4/2014 4:13,sasikanth.bharadwaj,"Eclipse 4.4 compiler generates ""bad class file"" according to javac This bug has been reproduced with Eclipse 4.4RC3 both on Linux and on Mac. Here are the steps to reproduce. Make a new project called test in your workspace. In a test.Utility class paste this code (I trimmed the class down as best I could to just the problematic part)://///package test;import java.util.Collection;import java.util.List;import java.util.function.Function;import java.util.stream.Collectors;import javafx.collections.ListChangeListener;import javafx.collections.ObservableList;public class Utility{ public static <T R> List<R> mapList(Collection<T> original Function<T R> func) { return original.stream().map(func).collect(Collectors.toList()); } /** * ""Binds"" the destination list to the observable source list with a transformation function applied. * Whenever the source list changes the destination list is altered to match by applying * the given function to each element in the source list. */ public static <S T> void bindMap(List<T> dest ObservableList<S> src Function<S T> func) { dest.clear(); dest.addAll(mapList(src func)); src.addListener((ListChangeListener<S>) changes -> { while (changes.next()) { if (changes.wasPermutated() || changes.wasUpdated()) { // Same code for updated replaced and permutation just recalc the range: for (int i = changes.getFrom(); i < changes.getTo(); i++) dest.set(i func.apply(src.get(i))); } else { for (int i = 0; i < changes.getRemovedSize(); i++) dest.remove(changes.getFrom()); for (int i = 0; i < changes.getAddedSubList().size();i++) dest.add(i + changes.getFrom() func.apply(changes.getAddedSubList().get(i))); } } }); }}//////Let eclipse compile that class -- it should compile successfully once your source level is set to Java 8. In a terminal window create this simple Import.java file://////import test.Utility;class Import{}//////Then ask javac (I am using 8u5 the current latest javac release) to compile it giving the classpath to the .class files from the Eclipse project:javac Import.java -cp ~/workspace/test/bin/I get back the following response:Import.java:1: error: cannot access Utilityimport test.Utility; ^ bad class file: /home/neil/workspace/test/bin/test/Utility.class undeclared type variable: T Please remove or make sure it appears in the correct subdirectory of the classpath.If I get javac to compile both classes everything works fine. If I get eclipse to compile both classes everything works fine. But if eclipse compiles the Utility class and javac the Import class (which I need to do in my workflow) I get this message. My best guess is that this is an eclipse bug (generating a bad class file) so I am filing it here. If you think it is instead a javac bug (rejecting a valid class file) then let me know and I will file it against javac instead."
436563,6/4/2014 8:01,jarthana,Several tests in TypeHierarchyTests fail Build: http://download.eclipse.org/eclipse/downloads/drops4/I20140603-2300/testResults.phpThere are failures in Linux as well as Windows all appear to be in TypeHierarchyTests. Perhaps related to the fix went for bug 436155 ?
436832,6/6/2014 7:38,noopur_gupta,[1.8] Add quick fix for 'Duplicate default methods' error 4.4 RC4.We should add quick fixes for 'Duplicate default methods' error which override the method and calls one of the available default methods.
436997,6/9/2014 15:43,markus.kell.r,"[move method] incorrect precondition of checking references to enclosing instances in generic declaring class. When the declaring class of enclosing instances is ""generic"" the precondition for checking references to enclosing instances does not work.Applying move-instance-method to method m() results in an error below.------------------------------BEFORE------------------------------class A<T> {	int i;	class C {		B b = null;		void m() {			i = 0;		}	}}------------------------------AFTER------------------------------class A<T> {	int i;	class C {		B b = null;	}}import p.A.C;class B{	void m(C c) {		i = 0;	//ERROR	}}------------------------------Here is the error location.JDT Classic version: 4.2.2Class Name: org.eclipse.jdt.internal.corext.refactoring.structure.MoveInstanceMethodProcessorSource code:...public final class EnclosingInstanceReferenceFinder extends AstNodeFinder {		...		@Override		public final boolean visit(final SimpleName node) {			Assert.isNotNull(node);			final IBinding binding= node.resolveBinding();			ITypeBinding declaring= null;			if (binding instanceof IVariableBinding) {				final IVariableBinding variable= (IVariableBinding) binding;				if (Flags.isStatic(variable.getModifiers()))					return false;				declaring= variable.getDeclaringClass(); //getDeclaringClass() returns NULL when the declaring class is ""generic"".		..."
437398,6/13/2014 13:03,noopur_gupta,[ccp] Don't select extension when asking for new file name on paste Follow-up to bug 391389. There are other scenarios where Eclipse asks for a new file name and those should behave the same as the Rename dialog.E.g. when you copy/paste a file in the Package Explorer the dialog should also pre-select the file name without the extension.
437414,6/13/2014 14:43,jarthana,Annotation processing is broken when build is batched Created attachment 244239test case exposing the bugIn a batched build annotation processing may not run on all compilation units. Please take a look at the attached test case that exposes the problem.In the test case there are 2 classes Foo and Bar that have references to each other. The batch size is set to 1. Suppose that Foo is in the first batch. Foo has a reference to Bar so both Foo and Bar are compiled in the first batch but only Foo was actually passed to the compiler so only Foo has annotation processing run on it. Then in the second batch we detect that Bar was compiled in the first batch so we are done with compiling. The problem is that then Bar never has annotation processing run on it.
437522,6/16/2014 8:11,shankhba,"[1.8][compiler] Missing compile error in Java 8 mode for Interface.super.field access Both javac and ECJ are missing a compile error in Java 8 mode for a field access of the form Interface.super.field:interface T { int f = 0; void foo(); default String def() { return ""T.def""; }}class S { public static final int f = 0;}class C extends S implements T { @Override public void foo() { System.out.println(T.super.f); // no error in Java 8 (wrong) System.out.println(T.super.def()); // new JLS8 15.12.1 form (OK) System.out.println(S.super.f); // compile error (correct) }}class Test { T f = new T() { @Override public void foo() { System.out.println(T.super.f); // no error in Java 8 (wrong) } };}JLS 8 15.11.2 only defines T.super.f for cases where T is a lexically enclosing class so the Interface.super.field form still needs to trigger a compile error. JLS 8 15.12.1 is not applicable here.Thanks Noopur for coming up with the initial example for this problem.Jay/Srikanth/Stephan: If you agree with my analysis then we should report this to Oracle as well."
437639,6/18/2014 2:20,manpalat,"[formatter] ArrayIndexOutOfBoundsException while formatting source code While formatting the source code it gives following exception -java.lang.ArrayIndexOutOfBoundsException: -1	at org.eclipse.jdt.internal.formatter.Scribe.getNewLineString(Scribe.java:1137)	at org.eclipse.jdt.internal.formatter.Scribe.getEmptyLines(Scribe.java:1062)	at org.eclipse.jdt.internal.formatter.Scribe.printEmptyLines(Scribe.java:3050)	at org.eclipse.jdt.internal.formatter.Scribe.preserveEmptyLines(Scribe.java:1584)	at org.eclipse.jdt.internal.formatter.Scribe.printComment(Scribe.java:2584)	at org.eclipse.jdt.internal.formatter.Scribe.printComment(Scribe.java:2414)	at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.format(CodeFormatterVisitor.java:714)	at org.eclipse.jdt.internal.formatter.CodeFormatterVisitor.visit(CodeFormatterVisitor.java:3294)With analysis I found out the root cause to be commented import statement as shown below -import org.hibernate.validator.HibernateValidator;import org.hibernate.validator.HibernateValidatorConfiguration;//import javax.validation.*;import javax.validation.Configuration;"
437847,6/20/2014 16:48,noopur_gupta,[type hierarchy] invoking Quick Type Hierarchy between import declarations yields an error Attempting to trigger Quick Type Hierarchy (Ctrl+T) on a blank line (or a line containing only comments) between two import declarations results in an empty Quick Type Hierarchy popup and an Error event in the log.I would expect Quick Type Hierarchy triggered in this location either a) to display the type hierarchy of the compilation unit's main type as is done when QTH is triggered on other blank linesb) to display the type hierarchy of one of the adjacent imports orc) to do nothing (show no popup)I've attached a minimal Java file where this issue occurs.I've reproduced this on 4.3.2 and 4.4.RC4.Here are the Event Details for the event that gets logged:Severity:ErrorMessage:Element unsupported by the hierarchy: class org.eclipse.jdt.internal.core.ImportContainerException Stack Trace:An exception stack trace is not available.
437973,6/23/2014 16:04,shankhba,"[1.8][compiler] Missing implementation of JLS 15.12.2.5 Third Bullet - Part 2 (Varargs & Overload) The following code compiles cleanly under JDK8 but has a compile error use the Eclipse compiler:package junk;public class Junk16 { public static String junk(String format Object... args) { return null; } public static String junk(String... s) { return null; } public static void main(String[] args) { // COMPILE ERROR IN ECLIPSE (none in JDK) junk(""fred""); //NO COMPILE ERROR junk(""fred"" 12); }}"
438390,6/27/2014 8:39,markus.kell.r,"[hovering][javadoc] Javadoc hover not showing inherited document if the type parameter name differs between interface and implementation I don't know if this is intentional but when I have the following code the IDE doesn't show the javadoc text if I hover over the getEnum() call in the main method:public class JdocTest {	interface Param {		/**		 * Returns an enumeration.		 * @param name the name		 * @param clazz the class		 * @return the enumeration		 */		<T extends Enum<T>> T getEnum(String name Class<T> clazz);	}	static class ParamImpl implements Param {		@Override		public <E extends Enum<E>> E getEnum(String name Class<E> clazz) {			return clazz.getEnumConstants()[0];		}	}	enum E1 {		A B C	}	public static void main(String[] args) {		new ParamImpl().getEnum(""abc"" E1.class);	}}The hover just shows the method name and the @Override tag but no other text or parameter list. If I change the interface parameter name to E:<E extends Enum<E>> E getEnum(String name Class<E> clazz);the javadoc hover properly shows the documentation ""Returns an enumeration."" etc."
438437,6/27/2014 17:49,shankhba,"[1.8][compiler] Annotations on enum constants interpreted only as type annotations if the annotation type specifies ElementType.TYPE_USE in @Target along with others Annotations on enum constants are interpreted by ECJ as type annotations when the annotation type specifies ElementType.TYPE_USE in @Target.Being so ECJ throws error ""Syntax error type annotations are illegal here"" in this annotated code:@ImprimirMensaje(""Tipo enumerado."") // OKpublic enum TipoEnumerado {		@ImprimirMensaje(""Constante Tipo enumerado ConstanteEnum1."") // ERROR!	ConstanteEnum1	@ImprimirMensaje(""Constante Tipo enumerado ConstanteEnum2."") // ERROR!	ConstanteEnum2	ConstanteEnum3;	// ... remaining code ...}Initially surprised I've checked this strange behavior with the JLS and I've not found that incompatibility.I've compiled my code against javac compiler and it has been worked as expected: compiling and printing the right output in the annotation processor (simply printing elements including the new parameter types annotations).I'm including an attachment zipped with the 3 basic classes to reproduce the bug:- ImprimirMensaje.java -> annotation type- ImprimirMensajeClaseAnotada.java -> annotated class- ImprimirMensajeProcessor.java -> annotation processorThank you very much."
438464,6/28/2014 16:47,markus.kell.r,"Links to Javadoc broken in org.eclipse.jdt.doc.user/tasks/task-using_null_type_annotations.htm On e.g. http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Ftasks%2Ftask-using_null_type_annotations.htm the hyperlink to JDT JavaDoc in ""JDT's null type annotations _@NonNull_"" which currently points to http://help.eclipse.org/help/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/annotation/NonNull.html is broken (that redirects to https://www.eclipse.org/documentation/).This problem only affects the website (help.eclipse.org) - if you try the same in the InfoCenter in a Luna Help > Help Contents the links works as expected (points to http://127.0.0.1:38506/help/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/annotation/NonNull.html)."
438471,6/29/2014 0:07,sasikanth.bharadwaj,"[1.8][compiler] Java 1.8 functional interface rejected if it extends an interface which overrides another interface's method When a functional interface extends another interface which overrides a method in a parent interface eclipse tags the functional interface with an error ""Invalid '@FunctionalInterface' annotation; Bar is not a functional interface""Ran into this with an interface which extended BaseStream (which redefines the close() method from AutoCloseable without providing an implementation).Simple code which reproduces the issue:// ""Invalid '@FunctionalInterface' annotation; Bar is not a functional interface""@FunctionalInterfacepublic interface Bar extends Overridden {	void foo();	@Override	default void close() {	}}interface Overridden extends AutoCloseable {	// Works without this overridden method	@Override	void close();}Removing the overridden close() method from the interface 'Overridden' makes 'Bar' compile correctly.This code compiles correctly with javac."
438621,7/1/2014 6:01,Michael_Rennie,[step filtering] Provide an extension point to enhance methods step filtering. JDT provides ability to filter out synthetic methods static initializers constructors and so on during debugging. We need to filter out some methods which are generated by Xtend compiler. Our first attempt was to mark such methods as synthetic and enable Step Filtering -> Filter synthetic methods. But this approach does not work because these methods actually are not synthetic. They can be called from java files.We would like to have an extension point to enhance methods step filtering. org.eclipse.jdt.internal.debug.core.model.JDIThread.StepHandler.locationIsFiltered(Method) method can delegate to such extension point if step filtering is enabled.
438812,7/3/2014 6:34,sasikanth.bharadwaj,Missing bridge methods in indirect child classes with ECJ 3.10.0 ECJ 3.10.0 (JDT 4.4) no longer generates the bridge methods expected when a method defined in an interface is overridden with a different return type in its indirect child classes.For example with the following code: public interface A { Iterable getIterable(); } class B implements A { public Collection getIterable() { return null; } } class C extends B { public List getIterable() { return null; } }According to javap ECJ 3.9.0 and javac generate these class files: public interface A { public abstract java.lang.Iterable getIterable(); } class B implements A { B(); public java.util.Collection getIterable(); public java.lang.Iterable getIterable(); } class C extends B { C(); public java.util.List getIterable(); public java.lang.Iterable getIterable(); public java.util.Collection getIterable(); }with ECJ 3.10.0 we now get: public interface A { public abstract java.lang.Iterable getIterable(); } class B implements A { B(); public java.util.Collection getIterable(); public java.lang.Iterable getIterable(); } class C extends B { C(); public java.util.List getIterable(); public java.util.Collection getIterable(); }The bridge method returning an Iterable is missing from C.class. It's only present in the .class file of its direct child B.
438875,7/3/2014 14:51,markus.kell.r,Set correct project/file encodings and use Unix line delimiter The org.eclipse.jdt.core project doesn't specify a file encoding and different files in the project already use different encodings.All projects should use UTF-8 see bug 399451 comment 4.
438877,7/3/2014 15:03,markus.kell.r,manpage for ecj has tons of formatting errors +++ This bug was initially created as a clone of Bug #408653 +++The manpage for ecj has tons of formatting errors and a few content bugs.
438923,7/4/2014 7:21,srikanth_sankaran,"[compiler] nested type is inappropriately considered ""indirectly referenced"" In Eclipse 4.4 a possible compiler bug affects our codebase.The trigger conditions seems to be (every class is declared in an exported packaged named the same as the bundle): 1. In bundle org.example.a: a. Declare an interface A b. Declare a nested interface A.Inner 2. In bundle org.example.b: a. Import package org.example.a b. Declare a class B c. Use the type A.Inner as a type parameter in a private method return type or argument e.g. Iterable<A.Inner> 3. In bundle org.example.c: a. Import package org.example.b b. Call a function in class BExpected behavior:Since the type A.Inner is not exposed in the public interface of the class B it should not be necessary to import org.example.a to use B.Actual behavior:Compiler error: The type org.example.a.A$Inner cannot be resolved. It is indirectly referenced from required .class filesI have created a small project that illustrates this problem: https://github.com/glerup/eclipse-pde-indirectly-referenced-bug"
438952,7/4/2014 18:41,srikanth_sankaran,"[1.8][content assist] StackOverflowError at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.traverse(SingleTypeReference.java:108) Created attachment 244836Eclipse plugins configurationCode: (https://github.com/ceefour/gggettingstarted/tree/stackoverflow-traverse branch stackoverflow-traverse)public static void main(String[] args) throws GridException {	try (Grid grid = GridGain.start(		System.getProperty(""user.home"") + ""/gridgain-platform-os-6.1.9-nix/examples/config/example-cache.xml"")) {	final String msg = ""Java GridGain MapReduce"";	int tot = grid.compute().execute(new GridComputeTaskSplitAdapter<String Integer>() {		@Override		protected Collection<? extends GridComputeJob> split(				int gridSize String arg) throws GridException {			String[] words = arg.split("" "");			return FluentIterable.from(Arrays.asList(words))				.<GridComputeJob>transform((it) -> new GridComputeJob() {					@Override					public Object execute() throws GridException {						log.info(""Length of '{}' is {}"" it it.length());						return it.length();							}										@Override					public void cancel() {					}				}).toList();		}				@Override		public Integer reduce(List<GridComputeJobResult> results)						throws GridException {			int total = 0;			for (GridComputeJobResult res : results) {				total += (int) res.getData();			}			return total;		}	} msg).get();	log.info(""Tot: {}"" tot);}Ctrl+Space inside main() shows in Error Log:org.eclipse.e4.core.di.InjectionException: java.lang.StackOverflowError	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:62)	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229)	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149)	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1574)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1387)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1412)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1397)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1424)	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:824)	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:3269)	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:777)	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2098)	at org.eclipse.swt.widgets.Control.windowProc(Control.java:5510)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4700)	at org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(Native Method)	at org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:9074)	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1253)	at org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method)	at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:2473)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3439)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:382)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:236)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)	at org.eclipse.equinox.launcher.Main.main(Main.java:1438)Caused by: java.lang.StackOverflowError	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.traverse(SingleTypeReference.java:108)	at org.eclipse.jdt.internal.compiler.ast.MarkerAnnotation.traverse(MarkerAnnotation.java:40)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:324)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1434)	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse(QualifiedAllocationExpression.java:603)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.traverse(LambdaExpression.java:649)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse(MessageSend.java:1015)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:347)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1434)...repeats over and over...eclipse.buildId=4.4.0.I20140606-1215java.version=1.8.0_05java.vendor=Oracle CorporationBootLoader constants: OS=linux ARCH=x86_64 WS=gtk NL=en_USFramework arguments: -product org.eclipse.epp.package.jee.productCommand-line arguments: -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.jee.productThis is a continuation of log file /home/ceefour/space_spring/.metadata/.bak_3.logCreated Time: 2014-07-04 18:00:21.550"
438956,7/5/2014 4:09,noopur_gupta,"[1.8][quick fix] Surround with try/catch quick fix on lambda expression surrounds wrong method This code:for (int ruleId : ruleIds) {	grid.compute().affinityRun(cache.name() ruleId		() -> log.info(""Processing rule #{} {}"" ruleId cache.get(ruleId)) );}will generate compiler error: Unhandled exception type GridExceptionwith 1 quick fix: Surround with try/catch.However when surround with try/catch quick fix is selected it becomes:try {	grid.compute().affinityRun(cache.name() ruleId		() -> log.info(""Processing rule #{} {}"" ruleId cache.get(ruleId)) );} catch (GridException e1) {	throw new RuntimeException(""Cannot compute"" e1);}which won't work (i.e. the code still won't compile) as quick fix is surrounding the outer method affinityRun() which doesn't throw checked Exception while the inner lambda still throw GridException.What JDT should do is convert the lambda into a Runnable (as it's inferred from the context) then surround the Runnable's method body with try/catch."
438960,7/5/2014 6:29,markus.kell.r,"Update versions of org.eclipse.jdt.annotation bundles and references in feature.xml master> Re: [platform-releng-dev] 4.5.0 N-Build: N20140704-2000 - BUILD FAILED> This was because the jdt.feature was expecting jdt.annotation version to be> from 2.0.0 - 2.0.1 but found to be 2.0.100. >> I have fixed the version to be 2.0.1. I don't think 2.0.1 would be any different from 2.0.100 (but it would not adhere the versioning rules). AFAIK the /org.eclipse.jdt-feature/feature.xml can either contain version=""0.0.0"" which will be replaced with one of the versions available at build time. Or it can have a version number that exactly matches an available bundle.I'll revert this to 2.0.100 and adjust the feature."
439158,7/8/2014 13:00,srikanth_sankaran,"[1.8][compiler][null] Adding null annotation to return type causes IllegalStateException and sometimes InvocationTargetException It seems that adding a null annotation to the return type A in the following code causes issues for my machine:import java.util.Collection;import java.util.List;import java.util.Set;public class Test {	class X {			}		public static <C extends Collection<?> A extends C B extends C>			A transform(B arg) { // Add @Nullable to A		return null;	}		public static void main(String[] args) {		List<X> list = null;		Set<X> result = transform(list);	}}This occurs regardless of whether I have null annotations enabled although the ""'Rebuilding' has encountered a problem"" popup only seems to appear when I have null analysis on. The InvocationTargetException seems to occur when I try to use Command-Shift-O to organize imports after the IllegalStateException even when null annotations are off.Eclipse 4.4 ID I20140701-0800 OS X 10.9.3 Java 1.8.0_05. Here are the stack traces:java.lang.IllegalStateException: TypeBinding#clone() should have been overridden	at org.eclipse.jdt.internal.compiler.lookup.TypeBinding.clone(TypeBinding.java:228)	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:339)	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:268)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createAnnotatedType(LookupEnvironment.java:988)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.substitute(ParameterizedGenericMethodBinding.java:742)	at org.eclipse.jdt.internal.compiler.lookup.Scope$Substitutor.substitute(Scope.java:490)	at org.eclipse.jdt.internal.compiler.lookup.Scope.substitute(Scope.java:435)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.<init>(ParameterizedGenericMethodBinding.java:502)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createParameterizedGenericMethod(LookupEnvironment.java:831)	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:533)	at org.eclipse.jdt.internal.compiler.lookup.Scope.inferInvocationType(Scope.java:5150)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findDefaultAbstractMethod(Scope.java:1297)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1767)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1662)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2621)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:866)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:698)	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:250)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:619)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:299)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:529)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1204)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:480)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)java.lang.reflect.InvocationTargetException	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:479)	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:374)	at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2144)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2140)	at org.eclipse.ui.internal.progress.ProgressManager$RunnableWithStatus.run(ProgressManager.java:1380)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ui.internal.progress.ProgressManager$5.run(ProgressManager.java:1214)	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:187)	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:156)	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4721)	at org.eclipse.ui.internal.progress.ProgressManager.runInUI(ProgressManager.java:1211)	at org.eclipse.jdt.ui.actions.OrganizeImportsAction.run(OrganizeImportsAction.java:291)	at org.eclipse.jdt.ui.actions.OrganizeImportsAction.run(OrganizeImportsAction.java:204)	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:279)	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251)	at org.eclipse.jface.action.Action.runWithEvent(Action.java:519)	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122)	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229)	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149)	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1087)	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4184)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1467)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1490)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1475)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1504)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1500)	at org.eclipse.swt.widgets.Canvas.sendKeyEvent(Canvas.java:496)	at org.eclipse.swt.widgets.Control.doCommandBySelector(Control.java:1060)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5719)	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method)	at org.eclipse.swt.internal.cocoa.NSResponder.interpretKeyEvents(NSResponder.java:68)	at org.eclipse.swt.widgets.Composite.keyDown(Composite.java:594)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5629)	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:221)	at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2105)	at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2329)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5691)	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)	at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:5128)	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5277)	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method)	at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:128)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3655)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:382)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:236)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)Caused by: java.lang.IllegalArgumentException: AST must not be null	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.create(ImportRewrite.java:192)	at org.eclipse.jdt.ui.CodeStyleConfiguration.createImportRewrite(CodeStyleConfiguration.java:70)	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility.createImportRewrite(StubUtility.java:1503)	at org.eclipse.jdt.internal.corext.codemanipulation.OrganizeImportsOperation.createTextEdit(OrganizeImportsOperation.java:427)	at org.eclipse.jdt.internal.corext.codemanipulation.OrganizeImportsOperation.run(OrganizeImportsOperation.java:398)	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313)	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5358)	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106)	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:466)	... 83 more"
439234,7/9/2014 8:53,shankhba,"[1.8][navigation] Clicking F3 on a lambda arrow and Double Colon operator doesn't work Consider the following code: Runnable runnable = () -> {};When ctrl-clicking on the arrow (""->"") Eclipse intuitively opens the Runnable.run() declaration. That doesn't work with F3"
439285,7/9/2014 15:49,jarthana,java.lang.NullPointerException on JDK9 Version: Luna (4.4)Build id: I20140606-1215Few tests are failed in org.eclipse.jdt.core.tests.compiler.regression with JDK9:junit.framework.AssertionFailedError: Unexpected problems [out: ][err: java.lang.NullPointerExceptionat org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.concatFiles(EclipseFileManager.java:204)at org.eclipse.jdt.internal.compiler.apt.util.EclipseFileManager.handleOption(EclipseFileManager.java:677)at org.eclipse.jdt.internal.compiler.apt.dispatch.BatchProcessingEnvImpl.<init>(BatchProcessingEnvImpl.java:88)at org.eclipse.jdt.internal.compiler.apt.dispatch.BatchAnnotationProcessorManager.configure(BatchAnnotationProcessorManager.java:69)at org.eclipse.jdt.internal.compiler.batch.Main.initializeAnnotationProcessorManager(Main.java:3996)at org.eclipse.jdt.internal.compiler.batch.Main.performCompilation(Main.java:4114)at org.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1694)at org.eclipse.jdt.core.tests.compiler.regression.BatchCompilerTest.invokeCompiler(BatchCompilerTest.java:648)at org.eclipse.jdt.core.tests.compiler.regression.BatchCompilerTest.runTest(BatchCompilerTest.java:572)at org.eclipse.jdt.core.tests.compiler.regression.BatchCompilerTest.runConformTest(BatchCompilerTest.java:437)at org.eclipse.jdt.core.tests.compiler.regression.BatchCompilerTest.test405225_extdirs(BatchCompilerTest.java:13797)at org.eclipse.jdt.core.tests.util.CompilerTestSetup.run(CompilerTestSetup.java:55)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310)at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36)at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32)at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:382)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:236)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)at org.eclipse.equinox.launcher.Main.run(Main.java:1465)at org.eclipse.equinox.launcher.Main.main(Main.java:1438)at org.eclipse.core.launcher.Main.main(Main.java:34)Effected tests:test405225_extdirs - 1.5test405225_extdirs - 1.6test405225_extdirs - 1.7test405225_extdirs - 1.8test009 - 1.8How to reproduce:1. eclipse-Automated-Tests-4.4 from http://download.eclipse.org/eclipse/downloads/drops4/R-4.4-201406061215/2. jdk9 from http://jdk9.java.net/download3. run jdkcorecompiler to reproduce the failures.It's not platform specific.
439431,7/11/2014 8:18,srikanth_sankaran,"[compiler][1.8] AIOOBE in ClassFile#dumpTargetTypeContents() All of a sudden my workspace stopped building and I keep getting ""Building workspace has encountered a problem. Errors occured during the build."" errors.The stack trace is:java.lang.ArrayIndexOutOfBoundsException: 3000	at org.eclipse.jdt.internal.compiler.ClassFile.dumpTargetTypeContents(ClassFile.java:2279)	at org.eclipse.jdt.internal.compiler.ClassFile.generateTypeAnnotation(ClassFile.java:4682)	at org.eclipse.jdt.internal.compiler.ClassFile.generateRuntimeTypeAnnotations(ClassFile.java:3876)	at org.eclipse.jdt.internal.compiler.ClassFile.generateTypeAnnotationsOnCodeAttribute(ClassFile.java:1449)	at org.eclipse.jdt.internal.compiler.ClassFile.completeCodeAttribute(ClassFile.java:1391)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:338)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:270)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:566)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:635)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:368)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:935)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:974)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
439515,7/14/2014 5:52,sasikanth.bharadwaj,"[1.8] ECJ reports error at method reference to overloaded instance method Example from JLS8: 15.13.1.--------------------------------------------------------------------package meth.refs;interface Fun<T R> {	R apply(T arg);}class C {	int size() {		return 0;	}	int size(Object arg) {		return 0;	}	int size(C arg) {		return 0;	}	void test() {		Fun<C Integer> f1 = C::size;		// OK: reference is to instance method size()	}}--------------------------------------------------------------------The code compiles with javac b132 but ECJ reports an error at method reference: ""Cannot make a static reference to the non-static method size(C) from the type C""."
439579,7/15/2014 1:17,markus.kell.r,"Creating an ""Installed JRE"" doesn't associate javafx-src.zip to jfxrt.jar When I add a Java 8 JRE to the ""Installed JREs"" in Eclipse the jfxrt.jar isn't associated with the javafx-src.zip but most other jars are associated with the src.zip available in JDK 8.-- Configuration Details --Product: Eclipse 4.4.0.20140612-0500 (org.eclipse.epp.package.jee.product)Installed Features: org.eclipse.jdt 3.10.0.v20140606-1536"
439582,7/15/2014 2:15,noopur_gupta,"[typing] Correct indentation indents too much Created attachment 245056Test source fileWhen in project ""Save Actions"" enabled are:- Format Source code Format all lines- Additional actions Correct identationthen saving file from attachment adding a space to end file and saving again. Formatting of the source is changing."
439594,7/15/2014 5:11,srikanth_sankaran,"[1.8][compiler] nested lambda type incorrectly inferred vs javac Maybe related to bug 432110 but since the fix for this should already be part of the Luna release I'm creating a separate bug report.The following code compiles using javac 1.8.05 but fails to compile in Eclipse (error message is ""Type mismatch: cannot convert from Object to List<NestedLambdaTest.ImmutableRecord>"" ):-----------------------------------------------------------------import java.util.ArrayList;import java.util.List;import java.util.function.Function;import java.util.function.Predicate;import java.util.stream.Collectors;import java.util.stream.Stream;public class NestedLambdaTest {	protected static interface IListEntry {		public <T> T visitRecordsWithResult(Function<Stream<Record>T> func);			}		protected static final class ImmutableRecord {		public ImmutableRecord(Record r) { }	}		protected static final class Record {}		public List<ImmutableRecord> compilesWithEclipseAndJavac() 	{		return visitEntriesWithResult( stream -> {			return stream.map( entry -> {				final List<ImmutableRecord> result1 = entry.visitRecordsWithResult( stream2 -> stream2						.filter( somePredicate() )						.map( ImmutableRecord::new )						.collect( Collectors.toList() )					);					return result1;			}).flatMap( List::stream ).collect( Collectors.toCollection( ArrayList::new ) );		});			}				public List<ImmutableRecord> compilesWithJavacButNotEclipse1() 	{		return visitEntriesWithResult( stream -> {			return stream.map( entry -> {				return entry.visitRecordsWithResult( stream2 -> stream2						.filter( somePredicate() )						.map( ImmutableRecord::new )						.collect( Collectors.toList() )					);				}).flatMap( List::stream ).collect( Collectors.toCollection( ArrayList::new ) );		});			}				public List<ImmutableRecord> compilesWithJavacButNotEclipse2() 	{		return visitEntriesWithResult( stream -> {			return stream.map( entry -> entry.visitRecordsWithResult( stream2 -> stream2						.filter( somePredicate() )						.map( ImmutableRecord::new )						.collect( Collectors.toList() ) )			).flatMap( List::stream ).collect( Collectors.toCollection( ArrayList::new ) );		});			}			public List<ImmutableRecord> compilesWithJavacButNotEclipse3() 	{		return visitEntriesWithResult( stream -> stream.map( entry -> entry.visitRecordsWithResult( stream2 -> stream2						.filter( somePredicate() )						.map( ImmutableRecord::new )						.collect( Collectors.toList() ) )			)			.flatMap( List::stream )			.collect( Collectors.toCollection( ArrayList::new ) )		);			}			private static Predicate<Record> somePredicate() {		return record -> true;	}				private <T> T visitEntriesWithResult(Function<Stream<IListEntry>T> func) {		return func.apply( new ArrayList<IListEntry>().stream() );	}}"
439601,7/15/2014 6:27,noopur_gupta,[1.8][quick assist] convert lambda expression to method reference Refer bug 428741 comment #0.A quick assist can be added to convert lambda expression to method reference.
439707,7/16/2014 8:49,srikanth_sankaran,[1.8][compiler] Lambda can be passed illegally to invisible method argument Take the following programme:------------------------------public class T1 { public static void main(String[] args) { T2.run(() -> {}); }}public class T2 { public static void run(InvisibleInterface i) { } private interface InvisibleInterface { void run(); }}------------------------------T1 should not compile and indeed it doesn't with javac:------------------------------C:\Users\Lukas\workspace\jOOQ\jOOQ-test\src\main\resources>javac T1.java T2.javaT1.java:45: error: InvisibleInterface has private access in T2 T2.run(() -> {}); ^1 error------------------------------Intuitively this shouldn't compile as there is no way T1 can call T2.run() prior to Java 8
439750,7/16/2014 16:15,jarthana,"New compiler option for Unused exception parameter warning/error Since upgrading to Eclipse 4.5 integration build ID I20140715-0800 the following code snippet now triggers a compiler warning/error: try { ... } catch (Exception e)??{ // do nothing }The error is: The value of the exception parameter e is not usedTurning off the setting ""Value of parameter is not used"" in the compiler settings removes this error. We have that setting enabled for example to warn of unused parameters in private methods. Is it a design decision to have this setting also apply to exception parameters or is just a bug?"
439874,7/18/2014 5:39,markus.kell.r,Increase BREE for JDT UI Platform requires Java 1.6 since Luna and I think it would be nice to be able to use @Override for interfaces also in JDT.ui
439889,7/18/2014 8:55,aclement,"[1.8][compiler] [lambda] Deserializing lambda fails with IllegalArgumentException: ""Invalid lambda deserialization"" This looks suspiciously like bug 428642 (currently marked as fixed) is not really fixed. I tested this on Eclipse 4.4.0 (Luna release version) using 64-bit JDK 1.8.05.The following code works as expected with javac but fails to execute correctly (throwing an IllegalArgumentException instead) when run from inside Eclipse.-----------------------------package com.vodecc.voipmng.boundary.wicket.alarming;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class SerializationTest implements Serializable{	interface SerializableRunnable extends Runnable Serializable {	}	SerializableRunnable runnable;	public SerializationTest() {		final SerializationTest self = this;		// runnable = () -> self.doSomething(); // WORKING		runnable = () -> this.doSomething(); // FAILS }	public void doSomething() {		System.out.println(""Helloworld!"");	}	public static void main(String[] args) throws Exception	{		final ByteArrayOutputStream buffer = new ByteArrayOutputStream();		try (ObjectOutputStream out = new ObjectOutputStream(buffer) ) {			out.writeObject(new SerializationTest());		}		try (ObjectInputStream in = new ObjectInputStream( new ByteArrayInputStream(buffer.toByteArray())))		{			final SerializationTest s = (SerializationTest) in.readObject();			s.doSomething();		}	}}"
439936,7/19/2014 6:00,jarthana,[model] testRemoveExternalProject Failure Build ID: N20140718-2000The test testRemoveExternalProject Failed.junit.framework.AssertionFailedError: Should receive changeat org.eclipse.jdt.core.tests.model.TypeHierarchyNotificationTests.testRemoveExternalProject(TypeHierarchyNotificationTests.java:1110)at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:104)at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:88)at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$1.protect(SuiteOfTestCases.java:76)at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:85)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310)at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36)at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32)at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:382)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:236)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)at org.eclipse.equinox.launcher.Main.run(Main.java:1465)at org.eclipse.equinox.launcher.Main.main(Main.java:1438)at org.eclipse.core.launcher.Main.main(Main.java:34)
440000,7/21/2014 8:54,manpalat,"[1.8][dom] MethodReference#resolveMethodBinding() API should return null for CreationReference of an ArrayType import java.util.function.*;public class Snippet {	Function<Integer int[]> m1 = int[]::new;}In the above example CreationReference#resolveMethodBinding() returns a synthetic method binding for the constructor of int[] i.e. > method binding: Snippet.lambda$0(int)The binding is ""private static"" and has ""IS CONSTRUCTOR: false"" hence it cannot be used to identify if the method is a constructor.The DOM APIs should not create a fake constructor binding for array types in CreationReference as it cannot tell anything interesting to the API clients.Instead CreationReference#resolveMethodBinding() should return null if the type is an array type."
440152,7/22/2014 14:07,sasikanth.bharadwaj,"[codegen]""Missing code implementation in the compiler"" on cascaded inner class references The following valid code is rejected by Eclipse compiler:import java.util.function.Function;interface Foo {void alpha(Bar pBar);}class Bar {Object bravo() {return null;}}class Test { Test(Function pFunction) { class Baz {public Baz(Object pObj) {pFunction.apply(pObj);}} delta(pBar -> charlie(new Baz(pBar.bravo()))); } void charlie(Object pRemovals) {} void delta(Foo pListener) {}}"
440203,7/23/2014 6:55,markus.kell.r,"[search] Extra Find Declarations hits Given the following source file in a plugin with an OSGI import:import org.osgi.framework.Bundle;public class MyClass {	Bundle getBundle() { return null; }}select getBundle() and do Declarations->Project.Expect: 1 resultActual: 42 resultsIf I want results outside my project I would do Declarations->Workspace but even there the result should be 1 since MyClass has no super/subclass other than Object so the only candidate second declaration is Object::getBundle() that does not exist.(I think it was about 3 years ago that Find Declarations became so overenthusiastic and consequently useless. I'm generally forced into a text search.)"
440285,7/24/2014 1:29,shankhba,[1.8] Compiler allows array creation reference with type arguments Both ECJ and javac compile the following incorrect code (array type constructor reference with type arguments):Function<Integer int[]> m1 = int[]::<Runnable>new;The code specifies <Runnable> as a type argument for the array creation expression which is not correct.
440470,7/25/2014 22:55,markus.kell.r,"debugger source lookup is much slower than 4.3 I have a project with a rather long classpath more than 400 entries. When the debugger first stops at a breakpoint it takes more than 30 seconds before it shows the source. I used visualvm to capture some thread dumps during that 30 seconds and most of them look like this:""Worker-54"" #503 prio=5 os_prio=0 tid=0x000000001a794800 nid=0x41ce4 runnable [0x00000000327de000] java.lang.Thread.State: RUNNABLE	at java.io.WinNTFileSystem.getLastModifiedTime(Native Method)	at java.io.File.lastModified(Unknown Source)	at java.util.zip.ZipFile.<init>(Unknown Source)	at java.util.zip.ZipFile.<init>(Unknown Source)	at java.util.zip.ZipFile.<init>(Unknown Source)	at org.eclipse.jdt.internal.core.JavaModelManager.getZipFile(JavaModelManager.java:2712)	at org.eclipse.jdt.internal.core.util.Util.getJdkLevel(Util.java:846)	at org.eclipse.jdt.internal.core.JarPackageFragmentRoot.<init>(JarPackageFragmentRoot.java:76)	at org.eclipse.jdt.internal.core.JavaProject.getPackageFragmentRoot(JavaProject.java:1810)	at org.eclipse.jdt.internal.core.JavaProject.computePackageFragmentRoots(JavaProject.java:615)	at org.eclipse.jdt.internal.core.JavaProject.computePackageFragmentRoots(JavaProject.java:708)	at org.eclipse.jdt.internal.core.JavaProject.computePackageFragmentRoots(JavaProject.java:672)	at org.eclipse.jdt.internal.core.JavaProject.getAllPackageFragmentRoots(JavaProject.java:1430)	at org.eclipse.jdt.internal.core.JavaProject.getAllPackageFragmentRoots(JavaProject.java:1425)	at org.eclipse.jdt.internal.core.JavaProject.findPackageFragmentRoot0(JavaProject.java:1228)	at org.eclipse.jdt.internal.core.JavaProject.findPackageFragmentRoot(JavaProject.java:1220)	at org.eclipse.jdt.internal.launching.JavaSourceLookupUtil.getPackageFragmentRoot(JavaSourceLookupUtil.java:157)	at org.eclipse.jdt.internal.launching.JavaSourceLookupUtil.translate(JavaSourceLookupUtil.java:57)	at org.eclipse.jdt.launching.JavaRuntime.getSourceContainers(JavaRuntime.java:2449)	at org.eclipse.jdt.launching.sourcelookup.containers.JavaSourcePathComputer.computeSourceContainers(JavaSourcePathComputer.java:58)	at org.eclipse.debug.internal.core.sourcelookup.SourcePathComputer.computeSourceContainers(SourcePathComputer.java:71)	at org.eclipse.debug.core.sourcelookup.containers.DefaultSourceContainer.createSourceContainers(DefaultSourceContainer.java:117)	at org.eclipse.debug.core.sourcelookup.containers.CompositeSourceContainer.getSourceContainers(CompositeSourceContainer.java:133)	- locked <0x00000000fa6ee7a8> (a org.eclipse.debug.core.sourcelookup.containers.DefaultSourceContainer)	at org.eclipse.debug.core.sourcelookup.containers.CompositeSourceContainer.findSourceElements(CompositeSourceContainer.java:48)	at org.eclipse.debug.core.sourcelookup.AbstractSourceLookupParticipant.findSourceElements(AbstractSourceLookupParticipant.java:70)	at org.eclipse.debug.core.sourcelookup.AbstractSourceLookupDirector$SourceLookupQuery.run(AbstractSourceLookupDirector.java:142)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.debug.core.sourcelookup.AbstractSourceLookupDirector.doSourceLookup(AbstractSourceLookupDirector.java:505)	at org.eclipse.debug.core.sourcelookup.AbstractSourceLookupDirector.getSourceElement(AbstractSourceLookupDirector.java:785)	at org.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility.lookup(SourceLookupFacility.java:346)	- locked <0x00000000ae4fd858> (a org.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility$LRU)	at org.eclipse.debug.internal.ui.sourcelookup.SourceLookupFacility$SourceLookupJob.run(SourceLookupFacility.java:737)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)When I do the exact same thing with the exact same project in eclipse 4.3.x the source lookup takes just a second or so - very fast. I suspect the problem is in the JarPackageFragmentRoot constructor where it is calling Util.getJdkLevel -- it looks like older versions of JarPackageFragmentRoot didn't have that but I'm just speculating -- I don't really know that much about it."
440482,7/26/2014 12:00,shankhba,"NullPointerException in JDT Core during reconcile Hello A NPE exception occurs when source code contains some lambda expressions. Isn't easy for me to extract/identify the code that cause the problem but I'm confident it's bc of lambdas. ThanksEnvironment:MAC OSXeclipse.buildId=4.4.0.I20140606-1215JDT.core: 3.10.0.v20140604-1726JDT.ui: 3.10.0.v20140604-1403Stack Trace:Java Model Exception: java.lang.NullPointerException	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:249)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
440486,7/26/2014 19:00,manpalat,"[1.8][search][test] JavaSearchBugs8Tests.testBug400899g38() succeeds by accident When adding one more type to jclMin1.8.jar I observed a mysterious failure in JavaSearchBugs8Tests.testBug400899g38(): two of the expected exact matches turned into potential matches.At a closer look that new result is actually ""better"".Here's what I see: Object r = (@Marker java. @Marker util.@Marker Map<@Marker String @Marker String>.@Marker Entry @Marker []) null;This line contains 2 annotations in illegal positions (trying to annotate a package).Q: Why does it succeed in HEAD?A: Because java.util.Map cannot be resolved (lacking from jclMin1.8.jar)Oops?Q: Why does a missing type help to get ""better"" search results?A: Because java.util.Map did *not* consist of two packages and a type but only of unresolved tokens.So adding Map to the jar revealed that two occurrences are not kosher hence they're flagged as potential matches. Makes sense?Note that the same also applies to java.util.List one line above (just I didn't add that to jclMin1.8.jar so nothing changed here)."
440592,7/28/2014 17:05,srikanth_sankaran,"[1.8][reconciler] Cannot easily launch application in case of certain usage of lambda expressions What steps will reproduce the problem?1. Create java 8 project2. Create two java files (note that the classes must be in separate java files otherwise bug does not show up):First file://-------------------------//file BugTest.javapublic class BugTest {	public void baz(InterfaceForBugTest arg) {	}	public void bar() {		baz(InterfaceForBugTest.instance);	} 	public Runnable returningLambda() {		return () -> {		};	}	public static void main(String[] args) {		//	}} //-------------------------Second file://-------------------------//file InterfaceForBugTest.javapublic interface InterfaceForBugTest {	public static InterfaceForBugTest creator1(Runnable simpleInstance){		return null;	}		public static void methodWithAnonymousImplementation() {		new InterfaceForBugTest() {			@Override			public void fun1() {			}			@Override			public void fun2() {			}			@Override			public void fun3() {			}			@Override			public void fun4() {			}			@Override			public void fun5() {			}		};	} 	public static void methodWithAnonymousImplementation2() {		new InterfaceForBugTest() {			@Override			public void fun1() {			}			@Override			public void fun2() {			}			@Override			public void fun3() {			}			@Override			public void fun4() {			}			@Override			public void fun5() {			}		};	}	public static InterfaceForBugTest instance = creator1(() -> {	});	void fun1();	void fun2();	void fun3();	void fun4();	void fun5();}//-------------------------3. Observe bugs:	- Go to the file BugTest.java right-click anywhere in the editor to bring pop-up menu click ""Run as"". Nothing will happen (the sub-menu should appear)	- While still in BugTest.java mouse-over ""Run"" button in toolbar. The error message will appear (the attached exception stack is from this error)	- Try to modify ""BugTest.java"". Three exceptions will appear in Eclipse Error Log:	 - Error in JDT Core during reconcile	 - Problems occurred when invoking code from plug-in: ""org.eclipse.jdt.ui"".	 - Exception occurred during problem detection:All stack traces for mentioned errors are similar to attached one - everything begins in ""org.eclipse.jdt.internal.compiler.ast.LambdaExpression.copy(LambdaExpression.java:946)"".The error occurs not only when you try to run code with ""main"" function but also when you try to run it as unit-tests so actually it prevents me from running affected unit tests in any convenient way.Please note that above example java files are minimal that I was able to produce. There must be at least five methods in InterfaceForBugTest and there must be at least two methods with anonymous interface implementations. The instance in InterfaceForBugTest must be created from function with lambda expression argument and there must be methods similar to bar/baz in BugTest. Very strange but true :).-- Error Details --Date: Mon Jul 28 22:30:16 CEST 2014Message: An internal error occurred during: ""Compute launch button tooltip"".Severity: ErrorProduct: Eclipse 4.4.0.20140612-0500 (org.eclipse.epp.package.jee.product)Plugin: org.eclipse.core.jobsSession Data:eclipse.buildId=4.4.0.I20140606-1215java.version=1.8.0_05java.vendor=Oracle CorporationBootLoader constants: OS=win32 ARCH=x86_64 WS=win32 NL=en_USFramework arguments: -product org.eclipse.epp.package.jee.productCommand-line arguments: -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.productException Stack Trace:java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.copy(LambdaExpression.java:946)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.isCompatibleWith(LambdaExpression.java:715)	at org.eclipse.jdt.internal.compiler.lookup.Scope.compatibilityLevel18FromInner(Scope.java:887)	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel18(Scope.java:794)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:756)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:695)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1761)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1662)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2621)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:866)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:698)	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.resolve(FieldDeclaration.java:264)	at org.eclipse.jdt.internal.compiler.lookup.FieldBinding.constant(FieldBinding.java:210)	at org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.getOtherFieldBindings(QualifiedNameReference.java:728)	at org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(QualifiedNameReference.java:1078)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:648)	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:619)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:299)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:529)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:587)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:826)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:628)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyBuilder.buildSupertypes(HierarchyBuilder.java:116)	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:136)	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:301)	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1268)	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:741)	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:693)	at org.eclipse.jdt.internal.launching.JavaLaunchableTester.hasSuperclass(JavaLaunchableTester.java:467)	at org.eclipse.jdt.internal.launching.JavaLaunchableTester.test(JavaLaunchableTester.java:610)	at org.eclipse.core.internal.expressions.Property.test(Property.java:58)	at org.eclipse.core.internal.expressions.TestExpression.evaluate(TestExpression.java:99)	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateOr(CompositeExpression.java:68)	at org.eclipse.core.internal.expressions.OrExpression.evaluate(OrExpression.java:21)	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)	at org.eclipse.core.internal.expressions.AndExpression.evaluate(AndExpression.java:29)	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)	at org.eclipse.core.internal.expressions.IterateExpression.evaluate(IterateExpression.java:150)	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)	at org.eclipse.core.internal.expressions.WithExpression.evaluate(WithExpression.java:72)	at org.eclipse.core.internal.expressions.CompositeExpression.evaluateAnd(CompositeExpression.java:53)	at org.eclipse.core.internal.expressions.EnablementExpression.evaluate(EnablementExpression.java:53)	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchShortcutExtension.evalEnablementExpression(LaunchShortcutExtension.java:281)	at org.eclipse.debug.internal.ui.contextlaunching.LaunchingResourceManager.getShortcutsForSelection(LaunchingResourceManager.java:455)	at org.eclipse.debug.internal.ui.contextlaunching.LaunchingResourceManager.computeLabels(LaunchingResourceManager.java:240)	at org.eclipse.debug.internal.ui.contextlaunching.LaunchingResourceManager$1$1.run(LaunchingResourceManager.java:142)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)"
440731,7/30/2014 5:40,shankhba,"[1.8][code select] Hover F3 doesn't work for method reference in method invocation of overloaded method See bug 424110 also.In the following example press F3 or hover over 'isFile' at [1] and [2].It works at [1] but not at [2].-----------------------------------------------------------------------package p;import java.io.File;import java.io.FileFilter;public class Snippet {	{		File dir = new File(""C:\\TEST"");		FileFilter filter = File::isFile; // [1] works		dir.listFiles(File::isFile); // [2] does not work	}}-----------------------------------------------------------------------"
440804,7/30/2014 13:41,markus.kell.r,"[javadoc wizard] Generate Javadoc should keep generated javadoc-arguments temp file The ""Generate Javadoc"" wizard should keep the generated javadoc-arguments temp file for a while to allow debugging.The file is mentioned in the command line on the ""Process properties"" page e.g:C:\java\jdk8\bin\javadoc.exe -J-showversion @C:\Users\xxx\AppData\Local\Temp\javadoc-arguments2359803814154564317.tmpThe file should not be deleted when the process terminates but only when it is removed from the debug view (or on shutdown)."
440930,7/31/2014 17:05,markus.kell.r,Java member types which are implicitly static should have consistent icons Member classes are non-static by default (unless they are members of interfaces or annotation types in which case they are static by default) but they may be marked static explicitly.Member enums member interfaces and member annotation types are static by default but they may be marked static explicitly. However Eclipse displays a different type icon for these if they are marked static explicitly. Since the addition of the modifier does not change the meaning of the code it should not change the icon. class C { class C1 {} static class C2 {} enum E1 { X } static enum E2 { X } interface I1 {} static interface I2 {} @interface A1 {} static @interface A2 {} } interface I { class C3 {} static class C4 {} enum E3 { X } static enum E4 { X } interface I3 {} static interface I4 {} @interface A3 {} static @interface A4 {} }In this example types C1 E1 I1 A1 have no 'S' in their icon. Types C2 E2 I2 A2 have an 'S' in their icon. However E1 I1 A1 are static too so they should also have the 'S' in their icon. For comparison all of the *3 and *4 types (the members of I) are static and do consistently display the 'S' even though the *3 are only static implicitly.Note that the only member type in the example code that is not static is C1.
441133,8/5/2014 3:14,jarthana,New DISCOURAGED ACCESS WARNINGS in org.eclipse.jdt.apt.ui Warnings can be seen here:http://download.eclipse.org/eclipse/downloads/drops4/I20140804-2000/compilelogs/plugins/org.eclipse.jdt.apt.ui_3.3.500.v20140704-0625/@dot.htmlThis has started happening since this commit:http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=4388c0ac2a341f1edd7db6cb0966477c51abd917
441217,8/5/2014 22:54,noopur_gupta,"[move method] incorrect update of references inherited by anonymous class declaration When the following code is run the output is '0' which is the original value of C.i.public class A extends C {	public A() {		i = 1;	}		public int m(D d) {		B b = new B() {			public int n() {				return i; // Output is C.i			}		};				return b.n();	}		public static void main(String[] args) {		System.out.println(new A().m(new D()));	}}public class B extends C {	public int n() {		return -1;	}}public class C {	public int i = 0;}When A.m(D) is moved to D without delegate two bug fixed are required.1. Argument A of D.m(A) should be 'final'.public class D {	public int m(A a) { // ERROR #1: should add 'final'		B b = new B() {			public int n() {				return a.i; // ERROR #2: should be just 'i'			}		};				return b.n();	}}2. After move-refactoring the output is changed to '1' due to incorrect update of reference (a.i is wrong)."
441273,8/6/2014 12:30,markus.kell.r,Typo in new API: org.eclipse.jdt.core.compiler.IProblem.NotAnnoationType Typo in new API: org.eclipse.jdt.core.compiler.IProblem.NotAnnoationType
441495,8/11/2014 6:41,daniel_megert,"PreTVT44: (bidi) ""Original Source"" and ""Refactored Source"" in API Tools Javadoc Conversion panel are not mirrored and incorrect text orientation is found Created attachment 245874PDE ProjectSteps to recreate problem:Open eclipse on bidi environments e.g. Arabic localeImport the PDE projectRight click on the project PDESelect Plug-in ToolsClick Convert API Tools Javadoc Tags...Click Next buttonProblem description:1) ""Original Source"" and ""Refactored Source"" in API Tools Javadoc Conversion panel are not mirrored 2) Suggest to fix: The text order of displaying the contents of build.properties should be LTRExpected result:Panels should be mirrored correctly and the text order and alignment of displaying source code should be correct on bidi loaclesPII Information:N/A"
441725,8/13/2014 14:15,daniel_megert,"[spell checking] Maximum number of problems reported is too small by default I was always amazed when I saw spelling errors in Javadocs since spell checking is available and enabled by default in the Eclipse SDK.Only today I think I found the real reason: The default setting for ""Maximum number of problems reported per file"" is only 100. In a *.java file with many technical comments this limit is quickly exceeded and you're running blind for the rest of the file.Either the default needs to be increased (I run with 1000) or it needs to be changed in *.java files to apply per comment and not per file."
441731,8/13/2014 15:49,sasikanth.bharadwaj,"JDT reports unnecessary cast using the Quickfix to remove it creates syntax error In org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer I see the following code:public void processContents(MElementContainer<MUIElement> me) {		if (!(((MUIElement) me) instanceof MWindow))			return;...more}JDT marks (MUIElement) me as unnecessary cast but if I remove this cast I get an syntax error. Is this a wrong warning message?"
441790,8/14/2014 8:03,het,"AnnotationValue.toString is creating incorrect and truncated text that cannot be used in source code Created attachment 245994Example project showing the difference between javac reference apt and jdt aptI am using annotations containing multiple attributes. In an AnnotationProcessor I create a copy of the class together with all ist annotations.According to the APT specs the method AnnotationValue#toString() should:""Returns a string representation of this value.This is returned in a form suitable for representing this valuein the source code of an annotation.""http://docs.oracle.com/javase/7/docs/api/javax/lang/model/element/AnnotationValue.html#toString()In the standard javac processor this works as expected. However the jdt apt implementation is not really creating such text.I created an example hello world application with an Annotation processor that creates and shows the differences between javac apt and eclipse jdt apt.The eclipse apt is run implicitly using a local lib/....jar of the processor. The javac apt is run using Junit-Run.There are threee examples in that test project. The first Looks like this:@CreateCopy@TestAnnotation1( annotationValue = @SuppressWarnings(""unused"") booleanValue = true enumValue = RoundingMode.UP intValue = 1 stringValue = ""hello"" typeValue = ArrayList.class)public class TestClass1 {}javac apt generates valid source code:@org.eclipse.apt.example.TestAnnotation1( annotationValue = @java.lang.SuppressWarnings({""unused""}) booleanValue = true enumValue = java.math.RoundingMode.UP intValue = 1 stringValue = ""hello"" typeValue = java.util.ArrayList.class)public class TestClass1CopyByJavacProcessingEnvironment{}eclipse apt generates invalid source code:@org.eclipse.apt.example.TestAnnotation1( annotationValue = @java.lang.SuppressWarnings booleanValue = true enumValue = UP intValue = 1 stringValue = hello typeValue = java.util.ArrayList)public class TestClass1CopyByIdeBuildProcessingEnvImpl{}"
441907,8/16/2014 14:22,srikanth_sankaran,[1.8][compiler] Eclipse 4.4.x compiler generics bugs with streams and lambdas Eclipse 4.4.x has problems finding relevant methods passed as lambdas in streams if the methods have generic parameters. Here is a reproducible test case which compiles fine with Oracle JDK 8:import java.util.*;public class EclipseJava8StreamLambdaGenerics { public static class FooBar<V> { } public interface FooBarred { public <V> boolean hasFooBar(final FooBar<V> fooBar); } public interface Widget extends FooBarred { } public static void test() { Set<FooBar<?>> foobars = new HashSet<>(); Set<Widget> widgets = new HashSet<>(); boolean anyWidgetHasFooBar = widgets.stream().anyMatch( widget -> foobars.stream().anyMatch(widget::hasFooBar) ); }}This bug appears in Eclipse 4.4 and Eclipse 4.4.1 M20140813-0800.See also Bug 441905 Bug 434044 and Bug 431408 which may nor may not be related (but which make me think that our company's use of generics must be unusually intense if no one else picked up on these earlier).
441929,8/17/2014 16:32,srikanth_sankaran,"[1.8][compiler] @SuppressWarnings(""unchecked"") not accepted on local variable Given the following code Eclipse gives a warning of ""Unnecessary @SuppressWarnings(""unchecked"")"". However if I remove that annotation I get ""Type safety: Unchecked cast from Class<capture#10-of ?> to Class<? extends T>"". public <T> ClasspathScanner matchClassesImplementing(final Class<T> iface final InterfaceMatchProcessor<T> interfaceMatchProcessor) { if (!iface.isInterface()) { throw new RuntimeException(iface.getName() + "" is not an interface""); } classMatchers.add(() -> { // Call class loader for all classes implementing the specified interface and call classMatchProcessor with these classes ArrayList<String> classesImplementingIface = interfaceToClasses.get(iface.getName()); if (classesImplementingIface != null) { for (String implClass : classesImplementingIface) { try { @SuppressWarnings(""unchecked"") Class<? extends T> klass = (Class<? extends T>) Class.forName(implClass); interfaceMatchProcessor.processMatch(klass); } catch (ClassNotFoundException | NoClassDefFoundError e) { throw new RuntimeException(e); } } } else { Log.info(""No classes found implementing interface "" + iface.getName()); } }); return this; }"
441933,8/18/2014 0:55,markus.kell.r,[preferences] Introduce new UI preference for reporting unused exception parameter Fix to Bug 412119 introduced an optional warning to report unused exception parameters but optional warning uses the same JavaCore.COMPILER_PB_UNUSED_PARAMETER that we use for unused method parameter. And this has resulted in some unhappy users who do not like new warnings in their code and that both these warnings have been combined with the same preference (see bug 439750). This bug is raised to track the UI side of the new preference and of course to discuss if we want to do that in first place.
441983,8/18/2014 11:22,mistria,Gerrit job test failures due to missing dependency on both versions of o.e.jdt.annotation We had it in the platform build where for some time we needed a p2kludge feature (see bug 414444 comment 31) to pull in both versions of o.e.jdt.annotation into the build.Then we moved the dependencies into the jdt feature which now depends on both versions.Unfortunately in pure-testing situations like gerrit we don't use that feature hence a lot a tests fail because only one version is resolved (running on 1.7 we get 1.1.0 on 1.8 we get the higher version 2.0.0).It seems we need to introduce yet another test-only kludge to allow us to run tests with both bundle versions installed.
442245,8/21/2014 6:59,srikanth_sankaran,[1.8][compiler?] These source files lead eclipse to hang (even just on copy/paste) Created attachment 246188Source files which cause the problemThese two files lead eclipse to hang when building the workspace.Even if automatic build is turned off and a portion of text is copied to the clipboard within the java editor eclipse hangs.Project setup:- please create a new Java project source level: java 8- copy the attached files to src/testThanks for your helpDaniel
442416,8/22/2014 15:26,aclement,[1.8][compiler] $deserializeLambda$ missing cases for nested lambdas Created attachment 246267Code triggering the bug.The synthetic $deserializeLambda$ method may be generated before the synthetic methods for nested lambdas. When this happens the $deserializeLambda$ only handles the lambdas that have already been encountered but is missing subsequent lambdas.For example with the attached source code only two of the three lambdas are handled in $deserializeLambda$.The code in org.eclipse.jdt.internal.compiler.ClassFile already hints at this issue with the todo:// TODO [andy] do we need to do this after the loop to ensure it is done last?The synthesis loop should be restructured to ensure the $deserializeLambda$ method is produced only after all the nested lambdas have been discovered.
442418,8/22/2014 15:56,aclement,"$deserializeLambda$ off-by-one error when deserializing the captured arguments of a lambda that also capture this Created attachment 246271Code triggering the bug.When $deserializeLambda$ deserializes the captured arguments of a serializable lambda that captures the enclosing instance it does not account for the captured instance when computing argument indexes.The $deserializeLambda$ method for example code attached passes twice index 0 to java.lang.invoke.SerializedLambda.getCapturedArg to obtain either the capture instance or the captured integer.It looks like a simple coding mistake in org.eclipse.jdt.internal.compiler.codegen.CodeStream. In method generateSyntheticBodyForDeserializeLambda in loop ""for (int p=0max=outerLocalVariables.length;p<max;p++)"" the loop index ""p"" is used in place of the argument index ""index"" to generated the argument to ""java.lang.invoke.SerializedLambda.getCapturedArg""."
442452,8/25/2014 0:52,srikanth_sankaran,"[compiler][regression] Bogus error: The interface Comparable cannot be implemented more than once with different arguments Reproduced the following problem using HEAD: (reported in https://bugs.eclipse.org/bugs/show_bug.cgi?id=434326#c67)0.) Use either N20140820-2000 or N20140821-2000(1.) Create a new Java 8 project(2.) Paste the following classes and interfaces to distict files://----public class Entity implements IEntity<Entity> {	public int compareTo(IBasicItem o) {		return 0;	}}public interface IEntity<T extends IEntity<T>> extends IBasicItem {}public interface IBasicItem extends Comparable<IBasicItem> {}public interface IAdvancedItem extends Comparable<IBasicItem> {}//----(3.) Edit ""Entity"" to also implement IAdvancedItem i.e. change the first line to""public class Entity implements IEntity<Entity> IAdvancedItem {""You should now see the initially quoted error occur (can anybody confirm?).(4.) Clean the project and start a complete build -> the error disappears.(5.) Rename (Alt-Shift-R) the ""Entity"" class to something else -> the error re-appears.(6.) Undo renaming the class -> the error is still present."
442500,8/25/2014 10:43,sarika.sinha,Breakpoints are not hit if there is an alternate stratum When a Java class has more than just the Java stratum (e.g it was generated by Xtend so it also has an Xtend stratum) breakpoints in the Java file are not hit.To reproduce:- download Eclipse for Java and DSL developers- new -> Examples -> Xtend Introductory Examples- Open xtend-gen/example1/HelloWorld.java- set a breakpoint in the main method- debug as Java application the breakpoint is not hitThe reason lies in JavaLineBreakpoint#determineLocations which calls ReferenceTypeImpl#locationsOfLine(int). This one-argument version tries to look up the Java line number in the default stratum which in our case is Xtend. This leads to either no or wrong locations.Plain JavaLineBreakpoints should always use the Java stratum by calling ReferenceTypeImpl#locationsOfLine(String String int).
442528,8/25/2014 15:49,jarthana,"We should not have empty performance targets See bug 442455 for more detail but it is confusing (at best) for us to some tests marked as having performance tests when they really don't. From what I could see the following have an empty performance target: eclipse.jdt.core/org.eclipse.jdt.apt.pluggable.tests/test.xmleclipse.jdt.core/org.eclipse.jdt.compiler.apt.tests/test.xmleclipse.jdt.core/org.eclipse.jdt.compiler.tool.tests/test.xmleclipse.jdt.core/org.eclipse.jdt.core.tests.builder/test.xmleclipse.jdt.core/org.eclipse.jdt.core.tests.compiler/test.xmleclipse.jdt.core/org.eclipse.jdt.core.tests.model/test.xmleclipse.jdt.ui/org.eclipse.ltk.core.refactoring.testseclipse.jdt.ui/org.eclipse.ltk.ui.refactoring.testsHope you don't find me combining ""core"" with ""ui"". Would appreciate either removing empty targets or ""comment them out"" so they are not detected by the CBI-tool (and test framework) that mark them as ""performance tests)."
442534,8/25/2014 16:04,srikanth_sankaran,"Eclipse's Run button does not work. I use Eclipse Luna and everything was working fine until today when I saw this error message while trying to run my Java code:http://i.stack.imgur.com/l0U4M.pngWhen I dismissed the message clicking the run and debug buttons did nothing at all. I restarted Eclipse but that did nothing.After trying to find the source of the error it seems that restarting the whole computer seems to ""reset"" everything. The first time I open Eclipse after a restart the run button works fine for one run but after that first run if I hover the cursor over the run button I get the above error message and the run button stops working. Strangely clicking the down arrow next to the run button and selecting my project works all the time regardless of the error message.Reinstalling did not fix anything. In fact the error only occurs when one certain source file is open in the Editor... I tried removing class members one by one and the error only occurs if one specific method is present. This method is pretty long (176 LOC) and everything works fine if I remove at least 70 LOC. Breaking the method up into several helper methods does not help."
442614,8/26/2014 12:58,markus.kell.r,"Extract merge and fix string and char literal escaping Required for bug 441790.jdt.core has several implementation of string and char literal escaping. They should be combined into one and bugs should be fixed.org.eclipse.jdt.core.dom.StringLiteral#setLiteralValue(String) andorg.eclipse.jdt.internal.core.util.Disassembler#escapeChar(StringBuffer char) both escape \0 to \7 wrongly when they are followed by more octal numbers. E.g. ""\0041"" is the char sequence { '\4' '1' } but such a sequence is currently escaped to ""\41"" which is equivalent to ""!"".I don't see a reason why we should only escape \0 to \7 and not all chars below 0x20. We can't know how these chars were represented in source but it makes sense to escape them all so that the user knows what's going on and doesn't run into trouble with tools that don't properly display these characters. As JLS8 3.10.6 says Unicode escapes are usually preferred."
442627,8/26/2014 16:35,Michael_Rennie,Honour the stepFilters extension point in the Java debugger FUP to bug 438621 we should add the hook in the Java debugger to allow 3rd parties to contribute step filters for the Java debug model.
442645,8/27/2014 1:55,sarika.sinha,Missing Java project context in stratum breakpoints Before the fix for Bug 368212 there was this fallback code in JavaLineBreakpoint#getJavaProjectif (sourceElement instanceof IJavaElement) { return ((IJavaElement) sourceElement).getJavaProject();} else if (sourceElement instanceof IResource) { IJavaProject project = JavaCore.create(((IResource) sourceElement).getProject()); if (project.exists()) { return project; }}This fallback code was deleted even though the bug only required deleting a block further up in that method.This is critical because for stratum line breakpoints (e.g. Xtend) the source will generally be some IFile and not an IJavaElement. This blocks conditional breakpoints in Xtend in Eclipse 4.3+
442755,8/28/2014 2:16,shankhba,"[compiler] NPE at ProblemHandler.handle NPE at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:129)---The issue is present on 4.4.1 as well. (Version: Luna SR1 (4.4.1)Build id: M20140827-0800)The issue is reproducible on master branch tip code.---Test Case://Descriptor.java package test;public interface Descriptor <UNMARSHAL_RECORD extends UnmarshalRecord OBJECT_BUILDER extends CoreObjectBuilder> {	public default OBJECT_BUILDER getObjectBuilder() { return null; }}//Unmarshaller.javapackage test;public abstract class Unmarshaller<CONTEXT extends Context DESCRIPTOR extends Descriptor> { public CONTEXT getContext() {	 return null; }}---Call stack:java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:129)	at org.eclipse.jdt.internal.compiler.problem.ProblemHandler.handle(ProblemHandler.java:208)	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.handle(ProblemReporter.java:2369)	at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.rawTypeReference(ProblemReporter.java:7141)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:503)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:574)	at org.eclipse.jdt.internal.compiler.lookup.Scope.connectTypeVariables(Scope.java:949)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:1099)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:323)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:229)	at org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:746)	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:383)	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:428)	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:367)	at org.eclipse.jdt.internal.core.builder.IncrementalImageBuilder.compile(IncrementalImageBuilder.java:330)	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:304)	at org.eclipse.jdt.internal.core.builder.IncrementalImageBuilder.build(IncrementalImageBuilder.java:135)	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:267)	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:195)	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:729)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:204)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:244)	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:297)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:300)	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:356)	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:379)	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:239)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)"
442781,8/28/2014 6:16,Michael_Rennie,Wrong hyperlinks in stack trace console for entries with method signature SAP JVM adds JNI-style method signatures in stack traces as additional info. Those entries are not properly recognized in stack trace console leading to wrong hyperlinks.Example stack entry: at java.util.concurrent.locks.LockSupport.parkNanos(Ljava/lang/Object;J)V(LockSupport.java:215)as opposed to at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:196) Change https://git.eclipse.org/r/#/c/32400/ adds support for these entries as well as tests for hyperlink detection.
442868,8/29/2014 6:09,jarthana,"[content assist] No type completion on 2nd+ parameter in anonymous classes While running some smoke tests I found that triggering JDT content assist on the second argument of m() marked with a '$' JDT does not propose any types. Whereas when I trigger content assist on the first type I get all types as expected.package __test;import java.util.List;public class Weird {	private static void weird() {		new Other() {			@Override			public void m(String s L$ist l Object o) {			}		};	}}abstract class Other {	public abstract void m(String s List l Object o);}"
442983,9/1/2014 2:52,srikanth_sankaran,"[1.8] NPE in Scope.findDefaultAbstractMethod package meth.refs;import java.util.function.Function;public class CL<T> {	<F> String method1(CL<T> ie) {		return ""b"";	}	public void bar() {				Function<CL<Integer> String> v5 = CL::method1;		v5 = t -> t.method1();		}	}---------------------------------------------------Edit anything and save the Java editor with above code.We get the following exception:java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.lookup.Scope.findDefaultAbstractMethod(Scope.java:1301)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1770)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1665)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2939)	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.resolveType(ReferenceExpression.java:476)	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:250)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:530)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1204)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)..."
443011,9/1/2014 8:32,daniel_megert,org.eclipse.ui.trace.traceComponents extensions should not be in jdt.debug.ui
443191,9/3/2014 6:31,noopur_gupta,"[1.8][quick fix] Quick fix for ""for loop"" is not shown for bare local variable/argument/field After bug 430336 we need to adapt the quick assist again. Bug 430818 adapted the quick assist to 4.4.0 but the AST in master is slightly different."
443232,9/3/2014 11:51,sasikanth.bharadwaj,"IAE in ASTNode.setSourceRange with broken code package p1;class E21 {	{private int[] nums;	void foo() { nums	}	}---------------------------------------In the above example type anything and save.We get the following exception:java.lang.IllegalArgumentException	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1250)	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:423)	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:544)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:537)..."
443309,9/4/2014 8:46,markus.kell.r,"tearDownAfterClass() in NewTestCaseCreationWizard gets disabled when something else is clicked on Steps to reproduce:1. Open New JUnit Test Case Wizard (NewTestCaseCreationWizard)2. See that tearDownAfterClass() checkbox is enabled.3. FAIL Click on any checkbox in ""Which method stubs would you like to create?"" section -> tearDownAfterClass() checkbox turns disabled.I think that this is not desired behavior."
443341,9/4/2014 12:30,markus.kell.r,"[1.8][quick fix] ""Convert lambda to anonymous"" should be a quick fix below 1.8 ""Convert lambda to anonymous"" should be a quick fix below 1.8"
443410,9/5/2014 9:38,markus.kell.r,RenameTypePerfAcceptanceTests#testCold fails (In reply to David Williams from bug 374441 comment #48)> org.eclipse.jdt.ui.tests.refactoring 49 tests - 1 failureThe failing test is RenameTypePerfAcceptanceTests#testCold
443456,9/7/2014 0:42,srikanth_sankaran,"[1.8][compiler][lambda] $NON-NLS$ in lambda statement used as argument does not work If ??Non-externalized strings (missing/unused $NON-NLS$ tag)?? warning is enabled the following code compiles with invalid ??Non-externalized string literal; it should be followed by //$NON-NLS-<n>$?? warning.import java.util.concurrent.Callable;public class Test { Callable<String> c; void setC(Callable<String> c) { this.c = c; } Test() { setC(() -> ""ee""); //$NON-NLS-1$ }}The same issue in Luna Luna SR1-RC2 and Mars M1."
443596,9/9/2014 8:56,srikanth_sankaran,"[1.8][compiler] Failure for overload resolution in case of Generics and Varags Please see Bug 437973 Comment 17.public final class Collections2 { static interface Predicate<T> { boolean test(T object); } public static <T> Predicate<T> in(Predicate<? extends T> arg) { return null; } public static <T> Predicate<T> and(Predicate<? super T>... arg) { return null; } public static <T> Predicate<T> and(Predicate<? super T> arg0 Predicate<? super T> arg1) { return null; } static class FilteredCollection<E> { Predicate<? super E> predicate; public void error(Predicate<?> arg) { and(predicate in(arg)); } // no compile }}---1. WARNING in Collections2.java (at line 4)\r\n	public static <T> Predicate<T> and(Predicate<? super T>... arg) { return null; }\r\n	 ^^^\nType safety: Potential heap pollution via varargs parameter arg\n2. ERROR in Collections2.java (at line 8)\r\n	public void error(Predicate<?> arg) { and(predicate in(arg)); } // no compile\r\n	 ^^^\nThe method and(Collections2.Predicate<capture#1-of ? super E> Collections2.Predicate<capture#2-of ?>) is undefined for the type Collections2.FilteredCollection<E>\n---javac 1.8 compiles the code without any issues."
443727,9/10/2014 11:42,Michael_Rennie,"NPE in JDIDebugTarget$ThreadStartHandler.handleEvent Hello CommittersI found round about 150 events (all from a single user) in the error logs and though it may be worth reporting it. Maybe you can quickly spot the issue based on this stacktrace?Please let me know what else we could (automatically) collect from a user to help you tracking that issue.BestMarcel@message timestamp=Wed Sep 10 09:48:04 EDT 2014 anonymousId=bac41314-e68f-499e-a691-4b75137e6066 eventId=8e22b97a-1659-4696-80d4-9a37cee8ccc4 eclipseBuildId=4.4.0.I20140606-1215 eclipseProduct=org.eclipse.epp.package.standard.product javaRuntimeVersion=1.8.0_20-b26 osgiWs=win32 osgiOs=Windows8 osgiOsVersion=6.3.0 osgiArch=x86_64 presentBundles={com.codetrails.stats.stacktraces.server.eclipse.Bundle@4a6d15ca[ name=org.eclipse.core.jobs version=3.6.0.v20140424-0053]Bundle[ name=org.eclipse.jdt.debug version=3.8.100.v20140522-1618]Bundle[ name=org.eclipse.jdt version=3.10.0.v20140606-1215]} status=com.codetrails.stats.stacktraces.server.eclipse.Status@a8136b88[ pluginId=org.eclipse.core.jobs pluginVersion=3.6.0.v20140424-0053 code=2 severity=4 message=An internal error occurred during: ""JDI Event Dispatch"". fingerprint=3d0ae8a9 exception=java.lang.NullPointerException: null at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget$ThreadStartHandler.handleEvent(JDIDebugTarget.java:1955) at org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch(EventDispatcher.java:152) at org.eclipse.jdt.internal.debug.core.EventDispatcher.access$0(EventDispatcher.java:100) at org.eclipse.jdt.internal.debug.core.EventDispatcher$1.run(EventDispatcher.java:249) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54) children={}]https://dev.eclipse.org/recommenders/errors/8e22b97a-1659-4696-80d4-9a37cee8ccc4.txt"
443769,9/10/2014 20:32,shankhba,Bogus error caused by resolving a variable twice Created attachment 246938Example project that shows problemIn projects with annotation processors it is possible to get bogus error messages.Please try out the example project I have attached and see that there is an error message in Anno.java saying that A.X cannot be resolved to a variable. A.X is defined and you can even navigate to it using F3.Here's what I believe is happening:1. In the annotation processor there is a call to Elements#getElementValuesWithDefaults()2. This causes type resolution for A.X since A.X is the default value for the foo() attribute for Anno.java using the method org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(BlockScope)3. The type resolution of A.X causes the 'RestrictiveFlags' part of the 'bits' field of the binding for A.X to change from Binding.VARIABLE to Binding.FIELD4. After the annotation processing the normal build begins.5. A.X is again resolved but since the 'RestrictiveFlags' part of the 'bits' field for the A.X binding is Binding.FIELD it does not match any of the cases in org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.resolveType(BlockScope) and so an error is reported.I don't really understand how the JDT compiler works so I haven't been able to find a fix for this issue.
443854,9/11/2014 12:07,Olivier_Thomann,"\u205f should not be a valid Java Identifier Part The following program compiles fine under Eclipse but does not compile under javac:public enum HelloWorld {	Hello\u205fworld;	public static void main(String[] args) {		System.out.println(Hello\u205fworld);		System.out.println(Character.isJavaIdentifierPart('\u205f')); // false	}}Output from javac:>javac HelloWorld.javaHelloWorld.java:2: error: illegal character: \8287 Hello\u205fworld; ^Tested in Eclipse 4.4.0 with Eclipse Java Development ToolsVersion: 3.10.0.v20140606-1536Build id: I20140606-1215"
443928,9/12/2014 7:07,jarthana,Building large Java element deltas is really slow Created attachment 246998Sample Java projectBuilding large Java element deltas is really slow.Steps to reproduce:1. Import the attached Java project.2. Open the file Functions.java with the Java editor.3. Select and delete all methods in the class Functions (15000 Java elements).It will take many seconds before the Outline view is refreshed.Most of the time is spent in JavaElementDeltaBuilder#buildDeltaswhich is called from ReconcileWorkingCopyOperation#makeConsistent.4. Undo the deletion above.Again #buildDeltas will take most of the reconciling time.As an aside this problem (building large deltas being really slow)was first observed in Handly (http://eclipse.org/handly/) while conductingscalability tests. Since HandleDelta and HandleDeltaBuilder code in Handlywas originally adapted from JDT I thought it might affect JDT too andso it did.In Handly I was able to fix the problem with the introduction of childIndexa HashMap in HandleDelta to speed up child delta searches. It provided a significant performance boost on large deltas. Please see the bug 443813for more details.I could try to make a similar patch for JDT if you are interested.Best RegardsVladimir
443932,9/12/2014 8:04,srikanth_sankaran,"[1.8][code complete] method reference proposals not applied when caret inside method name Follow-up to bug 402081 and bug 433178.Have this code: IntFunction<String> ts= Integer::toString;Set caret after ""Integer::to"" and press Ctrl+Space. Try to apply e.g. ""toBinaryString(int)"".=> The proposal is not inserted. The problem is that the replaceRange is wrong.This code in CompletionEngine.findLocalMethods(..) line 8750 looks wrong:	if (completionOnReferenceExpressionName)		proposal.setReplaceRange(this.endPosition - this.offset - methodLength this.endPosition - this.offset);	elseWhen I remove that change from bug 402081 then the proposals work as expected."
443942,9/12/2014 8:46,manpalat,"Reconciler reports AST with wrong node range (with comment after return type) 4.5.0.I20140909-1315 already happens with 4.4.0.I20140606-1215- Launch Eclipse with these debug options enabled:org.eclipse.jdt.core/debug=trueorg.eclipse.jdt.core/debug/dom/ast=true- Paste the source cited in the error message to the Package Explorer.- Set caret after ""{""- Press Space wait for the reconciler.=> Error in the log.=> The range of the first method parameter is ""/*int*/ realpath(byte[] path"".A visible effect of this is that ""Edit > Expand Selection To > Enclosing Element"" always selects the whole bad range. A normal ASTParser#createAST(..) call doesn't exhibit this problem.org.eclipse.jdt.coreErrorFri Sep 12 14:33:03 CEST 2014Bad AST node structure:- parent [59 138] org.eclipse.jdt.core.dom.MethodDeclaration previous [99 107] org.eclipse.jdt.core.dom.SimpleName parameters [91 119] org.eclipse.jdt.core.dom.SingleVariableDeclaration----------------------------------- SOURCE BEGIN -------------------------------------package org.eclipse.swt.internal.gtk;public class OS { public static final native long /*int*/ realpath(byte[] path byte[] realPath);} ----------------------------------- SOURCE END -------------------------------------java.lang.IllegalStateException: Bad AST node structure	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1419)	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
444045,9/14/2014 8:24,stefan.ocke,Messager does not support nested AnnotationMirrors When using messager to report an APT error to the user nested annotations are ignored and only the element is marked in the editor but not the annotation.Javac supports nested annotations in its messager and correctly prints the proper annotation in the command line.The reason is that in Eclipse BaseMessagerImpl does only look for top level annotations but not recursively for annotations contained within them (as javac does).I have a patch available and will provide it via gerrit.
444236,9/16/2014 7:15,noopur_gupta,"[quick assist] Create 'for' loop quick assists produce incorrect result for multidimensional arrays import java.util.List;class E21 {	private int[][] nums;	void foo() {		nums	}	}-------------------------------------Press Ctrl+1 at 'nums' in #foo and select ""Create 'for' loop"" or ""Create enhanced 'for' loop"" quick assist. The type to loop over does not contain any array dimension:class E21 {	private int[][] nums;	void foo() {		for (int i : nums) {					}	}	}Looks like it was not handled in the initial patch itself in GenerateForLoopAssistProposal.extractElementType(AST ast)."
444300,9/16/2014 14:30,srikanth_sankaran,"[1.8] content assist not working inside lambda expression in case of fields Please See Bug 435682 Comment 2.---import java.util.Arrays;import java.util.List;import java.util.stream.Collectors;public class X1 {	List<String> words = Arrays.asList(""hi"" ""hello"" ""hola"" ""bye"" ""goodbye"");	List<String> list1 = words.stream().map(so -> so.[1]).collect(Collectors.toList());}---[1] No proposals offered."
444334,9/17/2014 4:30,srikanth_sankaran,"[1.8][compiler] Compiler generates error instead of warning on unchecked conversion Created attachment 247143Testproject reproducing the described behaviorConsider the following Code:public class TestGenericUncheckedConversion { public static void main(String[] args) { doSomething(returnClassType(Class.class)); doSomething(returnListType(new ArrayList<List>())); } public static <T> void doSomething(Class<T> clazz) { System.out.println(clazz.getSimpleName()); } public static <T> T returnClassType(Class<T> clazz) { return null; } public static <T> void doSomething(List<T> list) { System.out.println(list.getClass().getSimpleName()); } public static <T> T returnListType(List<T> list) { return null; }}The Eclipse JavaSE-1.7 compiler issues warnings for both doSomething() calls in the class's main method which can be suppressed by adding the @SuppressWarnings({ ""unchecked"" ""rawtypes"" }) annotation to the method:- Type safety: The expression of type Class needs unchecked conversion to conform to Class<Object>- Type safety: The expression of type List needs unchecked conversion to conform to List<Object>- Type safety: Unchecked invocation doSomething(Class) of the generic method doSomething(Class<T>) of type TestGenericUncheckedConversion- Type safety: Unchecked invocation doSomething(List) of the generic method doSomething(List<T>) of type TestGenericUncheckedConversion- (List is a raw type. References to generic type List<E> should be parameterized)Using the JavaSE-1.8 compiler however instead of the warnings mentioned above an error is generated for each doSomething() call:- The method doSomething(Class<T>) in the type TestGenericUncheckedConversion is not applicable for the arguments (Class)- The method doSomething(Class<T>) in the type TestGenericUncheckedConversion is not applicable for the arguments (List)Using Java8's javac the code just compiles fine.On the second invocation of doSomething() the error goes away when the generic type argument for List is specified. However in the first example this solution is not possible because the generic type argument for Class.class is just Class and not Class<Class> (which would be recursive :D).Although this seems like a bit of a constructed example we are actually facing this problem during transition from JavaSE-1.7 to JavaSE-1.8. Many of our unit tests for a registry like object contain jMock code similar to the following example:allowing(registry).getObject(with(any(Class.class));I tested this with the following Eclipse releases all yielding the same result:- Kepler with Java8 Support Patch applied- Luna 4.4- Luna 4.4 SR1 RC3- Mars 4.5 M1I also checked the Java - Compiler - Errors/Warnings Preferences but no option in the ""Generic types"" section is set to ""Error"".You can find my test project attached to this bug."
444354,9/17/2014 8:00,kalyan_prasad,"[pull up] pull up refactoring doesn't add the required 'public' modifier Works fine in Eclipse 4.4.Looks like a regression from bug 71627.-------------------------package p1;import java.util.List;public class PullUpBaz implements PullUpToInterfaceBug.Foo {	public void b() {		List<Object> l = null;	}}-------------------------package p1;public class PullUpToInterfaceBug {	interface Foo {	}	static class Bar implements Foo {		/** baz it! */		void baz(final String s) {		}	}}-------------------------Pull up the method PullUpBaz.b() to PullUpToInterfaceBug.Foo.The method added in PullUpToInterfaceBug.Bar doesn't have the required 'public' modifier and results in compiler error."
444430,9/18/2014 4:09,markus.kell.r,"org.eclipse.jdt.launching.ui.macosx mentions 32bit mac in p2.inf file. See bug 443650 comment 5 for similar issue. But while searching our repo tonight for other ""hidden mentions"" of the MacOSX 32 bit platform I did see the launching bundle has a p2.inf file that saysrequires.1.namespace = org.eclipse.equinox.p2.iurequires.1.name = org.eclipse.swt.cocoa.macosx#requires.1.range = [$version$$version$]requires.1.filter = (&(osgi.os=macosx)(osgi.ws=cocoa)(osgi.arch=x86))I think under normal conditions this would not hurt anything but might when a user ends up with several ""repos"" enabled some of which have the fragment and some that don't (such as Luna vs. Mars) I think complications could arise? I'd recommend that be removed .. on semantic grounds alone ... since it does not accurate state the requirements in mars stream."
444665,9/20/2014 6:35,srikanth_sankaran,[1.8] Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.invalidMethod Internal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.problem.ProblemReporter.invalidMethod(ProblemReporter.java:4022)when compilingclass Foo { static void foo(java.util.Map<Long Long> map) { java.util.function.Consumer<int[]> c = array -> map.compute(array.get(0) (k v) -> null); }}
444772,9/22/2014 14:23,srikanth_sankaran,"[1.8][compiler] NullPointerException in ReferenceExpression.shouldGenerateImplicitLambda Summary:When using a method reference inside a constructor call the following issue is reported on project build:java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.shouldGenerateImplicitLambda(ReferenceExpression.java:182)The below code will demonstrate the issue in Eclipse 4.4// https://gist.github.com/NeQuissimus/1986029efa51e5b18111 See Error #2import java.util.ArrayList;import java.util.List;import java.util.Optional; public class WillNotWork { static class Container { final private String s; public Container(String s) { this.s = s; } } public static void main(String[] args) { final List<Container> list = new ArrayList<>(); final Optional<String> optStr = Optional.of(""foo""); list.add(new Container(optStr.orElseThrow(IllegalStateException::new))); // Error here // This will work: final String s = optStr.orElseThrow(IllegalStateException::new); list.add(new Container(s));	 }}I am doing this with Java 1.8.0_11 on OSX 10.9.4 but it can be reproduced with 1.8.0_05 and OSX 10.9.3 as well. I suspect that the Java/OS versions have no impact here. Just mentioning it for additional information."
444773,9/22/2014 14:28,srikanth_sankaran,"[1.8][compiler] NullPointerException in LambdaExpression.analyseCode Summary:When using a method reference in a constructor call a NPE will be throws from inside LambdaExpression.analyseCode:java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.analyseCode(LambdaExpression.java:469)The following code reproduces the issue:// https://gist.github.com/NeQuissimus/1986029efa51e5b18111 Error #1import java.util.ArrayList;import java.util.List;import java.util.Optional; public class WillNotWork { static class Container { final private String s; public Container(String s) { this.s = s; } } public static void main(String[] args) { final List<Container> list = new ArrayList<>(); final Optional<String> optStr = Optional.of(""foo""); list.add(new Container(optStr.orElseThrow(() -> new IllegalStateException()))); // Error here // This will work: final String s = optStr.orElseThrow(IllegalStateException::new); list.add(new Container(s));	 }}This is most likely related to https://bugs.eclipse.org/bugs/show_bug.cgi?id=444772I am submitting a separate issue because I am unsure whether the two are related or just coincidental."
444803,9/23/2014 4:39,srikanth_sankaran,"Exception in thread ""main"" java.lang.VerifyError: Bad local variable type package net.xyz.control.dispatcher;import java.util.ArrayList;import java.util.List;import com.amazonaws.services.ec2.AmazonEC2;import com.amazonaws.services.ec2.model.TerminateInstancesRequest;public class Abc { private AmazonEC2 ec2; public static void main(String[] args) { new Abc(); } private void doSth() { final List<String> l = new ArrayList<>(); try { System.out.println(""ok""); } finally { Runnable r = () -> ec2.terminateInstances(new TerminateInstancesRequest().withInstanceIds(l)); } }}Exception in thread ""main"" java.lang.VerifyError: Bad local variable typeException Details: Location: net/xyz/control/dispatcher/Abc.lambda$0(Ljava/util/List;)V @11: aload_2 Reason: Type top (current frame locals[2]) is not assignable to reference type Current Frame: bci: @11 flags: { } locals: { 'net/control/dispatcher/Abc' 'java/util/List' } stack: { 'com/amazonaws/services/ec2/AmazonEC2' 'com/amazonaws/services/ec2/model/TerminateInstancesRequest' } Bytecode: 0000000: 2ab4 0038 bb00 3a59 b700 3c2c b600 3db9 0000010: 0041 0200 b1 	at java.lang.Class.getDeclaredMethods0(Native Method)	at java.lang.Class.privateGetDeclaredMethods(Class.java:2688)	at java.lang.Class.getMethod0(Class.java:2937)	at java.lang.Class.getMethod(Class.java:1771)	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)if I comment out // System.out.println(""ok""); situation changes for better... private void doSth() { final List<String> l = new ArrayList<>(); try { // System.out.println(""ok""); } finally { Runnable r = () -> ec2.terminateInstances(new TerminateInstancesRequest().withInstanceIds(l)); }"
444809,9/23/2014 5:36,sptaszkiewicz,The resource tree is locked for modifications. Hello committerswe received a new error report for Eclipse 4.4.0.I20140606-1215.General Information: anonymous-id: f8087d7b-9d38-4c73-aeb1-6991603c2a84 eclipse-build-id: 4.4.0.I20140606-1215 eclipse-product: org.eclipse.epp.package.standard.product operating system: MacOSX 10.9.4 (x86_64) - cocoa java-runtime-version: 1.8.0_20-b26The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.commands_3.6.100.v20140528-1422 2. org.eclipse.core.databinding.observable_1.4.1.v20140210-1835 3. org.eclipse.core.databinding_1.4.1.v20140214-0004 4. org.eclipse.core.resources_3.9.0.v20140514-1307 5. org.eclipse.core.runtime_3.10.0.v20140318-2214 6. org.eclipse.e4.core.commands_0.10.2.v20140424-2344 7. org.eclipse.e4.core.contexts_1.3.100.v20140407-1019 8. org.eclipse.e4.core.di_1.4.0.v20140414-1837 9. org.eclipse.e4.ui.bindings_0.10.200.v20140424-2042 10. org.eclipse.e4.ui.workbench_1.1.0.v20140528-1949 11. org.eclipse.e4.ui.workbench.swt_0.12.100.v20140530-1436 12. org.eclipse.equinox.app_1.3.200.v20130910-1609 13. org.eclipse.equinox.launcher_1.3.0.v20140415-2008 14. org.eclipse.jdt_3.10.0.v20140606-1215 15. org.eclipse.jdt.ui_3.10.0.v20140604-1403 16. org.eclipse.jface_3.10.0.v20140604-0740 17. org.eclipse.ltk.core.refactoring_3.6.100.v20140520-1248 18. org.eclipse.osgi_3.10.0.v20140606-1445 19. org.eclipse.recommenders.stacktraces.rcp_2.1.10.v20140922-1455 20. org.eclipse.swt_3.103.0.v20140605-2008 21. org.eclipse.ui_3.106.0.v20140519-0906 22. org.eclipse.ui.editors_3.8.200.v20140401-1310 23. org.eclipse.ui.ide.application_1.0.500.v20140514-2033 24. org.eclipse.ui.ide_3.10.0.v20140521-1937Error Status: code: 380 message: The resource tree is locked for modifications. fingerprint: b5bdbf3b exception class: java.lang.RuntimeException exception message: Stand-In Stacktrace supplied by Eclipse Stacktraces & Error Reporting Tool number of children: 0Topmost Stacktrace: java.lang.RuntimeException: Stand-In Stacktrace supplied by Eclipse Stacktraces & Error Reporting Tool at org.eclipse.recommenders.internal.stacktraces.rcp.LogListener.insertDebugStacktraceIfEmpty(LogListener.java:104) at org.eclipse.recommenders.internal.stacktraces.rcp.LogListener.logging(LogListener.java:81) at org.eclipse.core.internal.runtime.RuntimeLog.logToListeners(RuntimeLog.java:160) at org.eclipse.core.internal.runtime.PlatformLogWriter.logged(PlatformLogWriter.java:100) at org.eclipse.osgi.internal.log.ExtendedLogReaderServiceFactory.safeLogged(ExtendedLogReaderServiceFactory.java:86) at org.eclipse.osgi.internal.log.ExtendedLogReaderServiceFactory.logPrivileged(ExtendedLogReaderServiceFactory.java:205) at org.eclipse.osgi.internal.log.ExtendedLogReaderServiceFactory.log(ExtendedLogReaderServiceFactory.java:178) at org.eclipse.osgi.internal.log.ExtendedLogServiceFactory.log(ExtendedLogServiceFactory.java:65) at org.eclipse.osgi.internal.log.ExtendedLogServiceImpl.log(ExtendedLogServiceImpl.java:87) at org.eclipse.osgi.internal.log.LoggerImpl.log(LoggerImpl.java:54) at org.eclipse.core.internal.runtime.Log.log(Log.java:62) at org.eclipse.core.internal.utils.Policy.log(Policy.java:133) at org.eclipse.core.internal.resources.Workspace.checkpoint(Workspace.java:545) at org.eclipse.ltk.internal.core.refactoring.UndoableOperation2ChangeAdapter.aboutToNotify(UndoableOperation2ChangeAdapter.java:289) at org.eclipse.core.commands.operations.TriggeredOperations.aboutToNotify(TriggeredOperations.java:363) at org.eclipse.core.commands.operations.DefaultOperationHistory$1.run(DefaultOperationHistory.java:923) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.core.commands.operations.DefaultOperationHistory.notifyListeners(DefaultOperationHistory.java:912) at org.eclipse.core.commands.operations.DefaultOperationHistory.notifyNotOK(DefaultOperationHistory.java:1029) at org.eclipse.core.commands.operations.DefaultOperationHistory.notifyNotOK(DefaultOperationHistory.java:1013) at org.eclipse.core.commands.operations.DefaultOperationHistory.flushUndo(DefaultOperationHistory.java:673) at org.eclipse.core.commands.operations.DefaultOperationHistory.dispose(DefaultOperationHistory.java:336) at org.eclipse.ui.internal.ide.undo.WorkspaceUndoMonitor.flushWorkspaceHistory(WorkspaceUndoMonitor.java:260) at org.eclipse.ui.internal.ide.undo.WorkspaceUndoMonitor.checkOperationHistory(WorkspaceUndoMonitor.java:246) at org.eclipse.ui.internal.ide.undo.WorkspaceUndoMonitor.access$4(WorkspaceUndoMonitor.java:209) at org.eclipse.ui.internal.ide.undo.WorkspaceUndoMonitor$1.resourceChanged(WorkspaceUndoMonitor.java:132) at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:291) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:285) at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:149) at org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:378) at org.eclipse.core.internal.resources.Workspace.checkpoint(Workspace.java:540) at org.eclipse.ltk.internal.core.refactoring.UndoableOperation2ChangeAdapter.aboutToNotify(UndoableOperation2ChangeAdapter.java:289) at org.eclipse.core.commands.operations.TriggeredOperations.aboutToNotify(TriggeredOperations.java:363) at org.eclipse.core.commands.operations.DefaultOperationHistory$1.run(DefaultOperationHistory.java:923) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.core.commands.operations.DefaultOperationHistory.notifyListeners(DefaultOperationHistory.java:912) at org.eclipse.core.commands.operations.DefaultOperationHistory.notifyAboutToExecute(DefaultOperationHistory.java:953) at org.eclipse.core.commands.operations.DefaultOperationHistory.openOperation(DefaultOperationHistory.java:1335) at org.eclipse.ltk.internal.core.refactoring.UndoManager2.aboutToPerformChange(UndoManager2.java:139) at org.eclipse.jdt.internal.corext.fix.CleanUpPostSaveListener.saved(CleanUpPostSaveListener.java:364) at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$5.run(CompilationUnitDocumentProvider.java:1598) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.notifyPostSaveListeners(CompilationUnitDocumentProvider.java:1593) at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy(CompilationUnitDocumentProvider.java:1380) at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$4.execute(CompilationUnitDocumentProvider.java:1458) at org.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run(TextFileDocumentProvider.java:132) at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:69) at org.eclipse.ui.actions.WorkspaceModifyOperation$1.run(WorkspaceModifyOperation.java:106) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313) at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:118) at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:75) at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:65) at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:456) at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:772) at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:5076) at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1247) at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1301) at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7209) at org.eclipse.ui.Saveable.doSave(Saveable.java:216) at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:355) at org.eclipse.ui.internal.SaveableHelper$3.run(SaveableHelper.java:199) at org.eclipse.ui.internal.SaveableHelper$5.run(SaveableHelper.java:283) at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:466) at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:374) at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2144) at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2140) at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:291) at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:269) at org.eclipse.ui.internal.SaveableHelper.saveModels(SaveableHelper.java:211) at org.eclipse.ui.internal.SaveableHelper.savePart(SaveableHelper.java:146) at org.eclipse.ui.internal.WorkbenchPage.saveSaveable(WorkbenchPage.java:3851) at org.eclipse.ui.internal.WorkbenchPage.saveEditor(WorkbenchPage.java:3865) at org.eclipse.ui.internal.handlers.SaveHandler.execute(SaveHandler.java:54) at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:294) at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90) at sun.reflect.GeneratedMethodAccessor228.invoke(null:-1) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:483) at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55) at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247) at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229) at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132) at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:149) at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499) at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86) at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1087) at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4184) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1467) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1490) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1475) at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1504) at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1500) at org.eclipse.swt.widgets.Canvas.sendKeyEvent(Canvas.java:496) at org.eclipse.swt.widgets.Control.doCommandBySelector(Control.java:1060) at org.eclipse.swt.widgets.Display.windowProc(Display.java:5719) at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(OS.java:-2) at org.eclipse.swt.internal.cocoa.NSResponder.interpretKeyEvents(NSResponder.java:68) at org.eclipse.swt.widgets.Composite.keyDown(Composite.java:594) at org.eclipse.swt.widgets.Display.windowProc(Display.java:5629) at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(OS.java:-2) at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:221) at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2105) at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2329) at org.eclipse.swt.widgets.Display.windowProc(Display.java:5691) at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(OS.java:-2) at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:5128) at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5277) at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(OS.java:-2) at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:128) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3655) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:382) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:236) at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-2) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:483) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1465) Messages stacktraces and nested status objects may be shortened. Please visit http://dev.eclipse.org/recommenders/reports/54213f0ce4b0f1322ab5159ffor the complete error log.The list of all reported error reports belonging to this error group can befetched from http://dev.eclipse.org/recommenders/states/54213f0ce4b0f1322ab515a0/reportsThe Error Log Reporter presents the current processing state of this error to new reporters. This state can be updated by modifying the values of this bug.To update the error log database call the link below after each change made tothis bug report: http://dev.eclipse.org/recommenders/states/54213f0ce4b0f1322ab515a0/syncThank you for caring.Your friendly error reports bot.--* Note: The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.
444823,9/23/2014 7:33,noopur_gupta,"[1.8] Overriding default method results in Exception Eclipse crashes when overriding a default method. The happens either when using content assist (ctrl+space) or when choosing Source->Override/Implement Methods from the Menu (or via pop-up menu). See a stack trace below.Reproduce this by creating a class that implements java.util.Collection. Try overriding a default method (e.g. #parallelStream) by using one of the methods described above. An unhandled event loop exception will occur.java.lang.IllegalArgumentException: Invalid identifier : >Collection<E><	at org.eclipse.jdt.core.dom.SimpleName.setIdentifier(SimpleName.java:199)	at org.eclipse.jdt.core.dom.AST.newSimpleName(AST.java:2202)	at org.eclipse.jdt.core.dom.AST.newName(AST.java:1929)	at org.eclipse.jdt.internal.corext.dom.ASTNodeFactory.newName(ASTNodeFactory.java:96)	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility2.createImplementationStub(StubUtility2.java:374)	at org.eclipse.jdt.internal.corext.codemanipulation.StubUtility2.createImplementationStub(StubUtility2.java:315)	at org.eclipse.jdt.internal.ui.text.java.OverrideCompletionProposal.updateReplacementString(OverrideCompletionProposal.java:158)	at org.eclipse.jdt.internal.ui.text.java.JavaTypeCompletionProposal.apply(JavaTypeCompletionProposal.java:107)	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:497)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertProposal(CompletionProposalPopup.java:963)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.insertSelectedProposalWithMask(CompletionProposalPopup.java:914)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$27(CompletionProposalPopup.java:910)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$5.widgetDefaultSelected(CompletionProposalPopup.java:674)	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:119)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4353)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:636)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:579)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:135)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:382)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:236)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)"
444891,9/23/2014 21:46,srikanth_sankaran,[1.8][spec] Track specification change in JLS 18.5.2: Invocation Type Inference This bug is track the specification change in JLS 18.5.2: Invocation Type Inference(https://bugs.openjdk.java.net/browse/JDK-8038747)https://bugs.eclipse.org/bugs/show_bug.cgi?id=432682 and its dozen cousin areaffected by this. Javac ATM does extra constitutional stuff and compiles thiscode.The cited Oracle bug has proposed amendments - this needs to be investigated andtaken to completion.
445231,9/26/2014 16:22,shankhba,"[compiler] IllegalAccessError running Eclipse-compiled class Created attachment 247419whole Eclipse project with 4 source files and their compiled .classes as wellThe code below when compiled by Eclipse (4.4.1) causes an IllegalAccessError to be thrown by ""clazz.isAnonymousClass()"" when it's run. The same code can be successfully compiled and runs properly by java's javac (java 1.7.0).I encountered this problem on my project and then did my best to trim it down to a minimal reproduceable case but I still need 4 classes in 2 java packages. Just about anything that I try to trim down any further makes the problem disappear.Be careful tinkering with this: incremental compile sometimes does not toggle the thing to go good/bad (i.e. when making any change to the code do a full clean and re-run).I attach here the entire project as a zip including the .classes as I see them.BTW here's a few examples of things that make the problem go away:1. Stop calling .setJobName on Buggered2. Make Base public3. put all classes in the same package4. simplify the generic type of Base.Builder"
445669,10/1/2014 10:24,srikanth_sankaran,"java.lang.IllegalStateException at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.clone(UnresolvedReferenceBinding.java:43) When compiling classes I frequently get the error below. It happens when the compiled source contains an error (e.g. a syntax error). Unfortunately I can't isolate a piece of code to reproduce the bug. Maybe it has something to do with the state of my eclipse project.I'm using 4.4.1 and java 8.java.lang.IllegalStateException	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.clone(UnresolvedReferenceBinding.java:43)	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:339)	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getAnnotatedType(AnnotatableTypeSystem.java:268)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createAnnotatedType(LookupEnvironment.java:989)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.scanFieldForNullAnnotation(BinaryTypeBinding.java:1482)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.cachePartsFrom(BinaryTypeBinding.java:493)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:696)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:679)	at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:299)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:140)	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:99)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:180)	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:186)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findImport(CompilationUnitScope.java:468)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findSingleImport(CompilationUnitScope.java:522)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInImports(CompilationUnitScope.java:399)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.faultInTypes(CompilationUnitScope.java:447)	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:763)	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137)	at java.lang.Thread.run(Thread.java:744)"
445725,10/1/2014 18:35,srikanth_sankaran,[1.8][inference] Type inference not occurring with lambda expression and constructor reference Created attachment 247553example of compiler errorsSimilar to https://bugs.eclipse.org/bugs/show_bug.cgi?id=435689 and others it seems that it's not picking up the type for a constructor that extends a parameterized class. Eclipse gives a compiler error but javac compiles it just fine.Note - I'm still seeing this with 4.4.1 but that version isn't in the list of choices yet.
445949,10/4/2014 15:04,shankhba,"Lambda parameter not shadowing in nested scope producing non-existent compilation error I came across this after importing vert.x code into Eclipse Luna. Line 297 below causes JDT to report a ""Lambda expression's parameter future cannot redeclare another local variable defined in an enclosing scope."" compilation error:https://github.com/eclipse/vert.x/blob/master/vertx-core/src/main/java/io/vertx/core/http/impl/HttpClientImpl.java#L297I think the compiler is confused by the nested enclosing scopes. The ""future"" parameter on line 297 is considered to collide with the declaration of future on line 286. I understand lambdas do not define a nested scope but it seems like the JDK considers this not to be the case (the code compiles and runs fine with Oracle JDK 1.8.0_20).One can easily reproduce this by using this snippet:import java.util.function.Consumer;public class LambdaScopeTest {	void methodInFirstLevel(int y) {		class Second {			int t = y;			Consumer<Integer> myConsumer1 = (z) -> {				System.out.println(""z = "" + z);				System.out.println(""y = "" + y);				System.out.println(""t = "" + t);			};			Consumer<Integer> myConsumer2 = (y) -> {				System.out.println(""y = "" + y);				System.out.println(""t = "" + t);			};		}		new Second().myConsumer1.accept(10);		new Second().myConsumer2.accept(20);	}		public static void main(String[] args) {		new LambdaScopeTest().methodInFirstLevel(5);	}}In the snippet above you will get the same behavior for parameter y in myConsumer2."
446040,10/6/2014 8:33,sarika.sinha,"Invalid thread access in RuntimeClasspathViewer$1.preferenceChange (err_grp: 87791828) Hello committerswe received a new error report for Eclipse 4.4.1.M20140925-0400.General Information: anonymous-id: 24ad43ce-0a9e-4ffd-a544-d73b21063102 eclipse-build-id: 4.4.1.M20140925-0400 eclipse-product: org.eclipse.epp.package.jee.product operating system: Windows7 6.1.0 (x86_64) - win32 java-runtime-version: 1.8.0_20-b26The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.runtime_3.10.0.v20140318-2214 2. org.eclipse.jdt.debug.ui_3.6.300.v20140512-1926 3. org.eclipse.jdt.debug_3.8.101.v20140902-1548 4. org.eclipse.jdt_3.10.0.v20140925-0400 5. org.eclipse.jface_3.10.1.v20140813-1009 6. org.eclipse.swt_3.103.1.v20140903-1938Error Status: code: 2 plugin: org.eclipse.equinox.preferences_3.5.200.v20140224-1527 message: Problems occurred when invoking code from plug-in: ""org.eclipse.equinox.preferences"". fingerprint: 87791828 exception class: org.eclipse.swt.SWTException exception message: Invalid thread access number of children: 0 org.eclipse.swt.SWTException: Invalid thread access at org.eclipse.swt.SWT.error(SWT.java:4441) at org.eclipse.swt.SWT.error(SWT.java:4356) at org.eclipse.swt.SWT.error(SWT.java:4327) at org.eclipse.swt.widgets.Widget.error(Widget.java:476) at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:367) at org.eclipse.swt.widgets.Tree.getSelection(Tree.java:3446) at org.eclipse.jface.viewers.TreeViewer.getSelection(TreeViewer.java:232) at org.eclipse.jface.viewers.TreeViewer.setSelection(TreeViewer.java:311) at org.eclipse.jface.viewers.AbstractTreeViewer.setSelectionToWidget(AbstractTreeViewer.java:2524) at org.eclipse.jface.viewers.StructuredViewer.setSelectionToWidget(StructuredViewer.java:1751) at org.eclipse.jface.viewers.AbstractTreeViewer.setSelectionToWidget(AbstractTreeViewer.java:2977) at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1443) at org.eclipse.jface.viewers.TreeViewer.preservingSelection(TreeViewer.java:366) at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1397) at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1525) at org.eclipse.jface.viewers.ColumnViewer.refresh(ColumnViewer.java:533) at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1481) at org.eclipse.jdt.internal.debug.ui.classpath.RuntimeClasspathViewer$1.preferenceChange(RuntimeClasspathViewer.java:58) at org.eclipse.core.internal.preferences.EclipsePreferences$3.run(EclipsePreferences.java:896) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.core.internal.preferences.EclipsePreferences.firePreferenceEvent(EclipsePreferences.java:899) at org.eclipse.core.internal.preferences.EclipsePreferences.put(EclipsePreferences.java:912) at org.eclipse.jdt.internal.debug.ui.jres.JREsUpdater$1.run(JREsUpdater.java:91) at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122) Messages stacktraces and nested status objects may be shortened. Please visit http://dev.eclipse.org/recommenders/committers/confess/0.5/reports/54328c1ee4b0a33678b204b7for the complete error log.Some general information and guidelines about how to use this bug report:1. Feel free to move this bug to your own product and components. Please note that this bug is only accessible to Eclipse committers. If you move this bug please make sure that it's still in the ""Security Advisor"" group.2. The bug contents of the fields status resolution keywords and whitelist are presented to reporters. If you needs more information please set the keyword ""needinfo"". This will trigger a specialized dialog asking the user to provide further details.3. Use the following resolutions for the following situations: * CLOSED / FIXED: This bug has been fixed. Please provide additional information in the whiteboard field. * CLOSED / WORKSFORME: Use this resolution if you can't reproduce this issue and request further information. Please use the whiteboard text to specify more details what a user should provide and how. * CLOSED / INVALID: Use this resolution if the reported problem is a 'user-configuration' problem. Please consider giving hints how to fix these issues in the whiteboard field. * CLOSED / NOT ECLIPSE: Use this if the problem is caused by another plugin not developed at Eclipse.org * CLOSED / MOVED: If this bug has been moved else where. Please provide more information (e.g. a link) in the whiteboard field.4. Please remember that only committers can view and comment on this bug. You may however manually add the reporting user to the bug's cc list. But keep in mind that the report may contains sensitive information.5. If you are missing a feature please file a enhancement request here: https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Recommenders.Incubator&component=Stacktraces Thank you for your assistance.Your friendly error-reports-inbox.--* Note: The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality."
446055,10/6/2014 9:57,manpalat,"Background Indexer Crash Recovery (err_grp: 6675354d) Hello committerswe received a new error report for Eclipse 4.4.1.M20140925-0400.General Information: anonymous-id: 07a45dd4-f95f-478f-a15e-4000ce15f73a eclipse-build-id: 4.4.1.M20140925-0400 eclipse-product: org.eclipse.epp.package.standard.product operating system: Windows8 6.2.0 (x86_64) - win32 java-runtime-version: 1.8.0_20-b26The following plug-ins were present on the execution stack (*): 1. org.eclipse.jdt.core_3.10.0.v20140902-0626 2. org.eclipse.jdt_3.10.0.v20140925-0400Error Status: code: 4 plugin: org.eclipse.jdt.core_3.10.0.v20140902-0626 message: Background Indexer Crash Recovery fingerprint: 6675354d exception class: java.util.zip.ZipError exception message: jzentry == 0 jzfile = 466081616 total = 341 name = D:\_DEVEL_\facebook-android-sdk-3.17.1\facebook\bin\facebooksdk.jar i = 1 message = null number of children: 0 java.util.zip.ZipError: jzentry == 0 jzfile = 466081616 total = 341 name = D:\_DEVEL_\facebook-android-sdk-3.17.1\facebook\bin\facebooksdk.jar i = 1 message = null at java.util.zip.ZipFile$ZipEntryIterator.next(null:-1) at java.util.zip.ZipFile$ZipEntryIterator.nextElement(null:-1) at java.util.zip.ZipFile$ZipEntryIterator.nextElement(null:-1) at org.eclipse.jdt.internal.core.search.indexing.AddJarFileToIndex.execute(AddJarFileToIndex.java:228) at org.eclipse.jdt.internal.core.search.processing.JobManager.run(JobManager.java:405) at java.lang.Thread.run(null:-1) Messages stacktraces and nested status objects may be shortened. Please visit http://dev.eclipse.org/recommenders/committers/confess/0.5/reports/54329fb9e4b0a33678b204cafor the complete error log.Some general information and guidelines about how to use this bug report:1. Feel free to move this bug to your own product and components. Please note that this bug is only accessible to Eclipse committers. If you move this bug please make sure that it's still in the ""Security Advisor"" group.2. The bug contents of the fields status resolution keywords and whitelist are presented to reporters. If you needs more information please set the keyword ""needinfo"". This will trigger a specialized dialog asking the user to provide further details.3. Use the following resolutions for the following situations: * CLOSED / FIXED: This bug has been fixed. Please provide additional information in the whiteboard field. * CLOSED / WORKSFORME: Use this resolution if you can't reproduce this issue and request further information. Please use the whiteboard text to specify more details what a user should provide and how. * CLOSED / INVALID: Use this resolution if the reported problem is a 'user-configuration' problem. Please consider giving hints how to fix these issues in the whiteboard field. * CLOSED / NOT ECLIPSE: Use this if the problem is caused by another plugin not developed at Eclipse.org * CLOSED / MOVED: If this bug has been moved else where. Please provide more information (e.g. a link) in the whiteboard field.4. Please remember that only committers can view and comment on this bug. You may however manually add the reporting user to the bug's cc list. But keep in mind that the report may contains sensitive information.5. If you are missing a feature please file a enhancement request here: https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Recommenders.Incubator&component=Stacktraces Thank you for your assistance.Your friendly error-reports-inbox.--* Note: The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality."
446255,10/8/2014 4:20,manpalat,[save actions] The save participant 'org.eclipse.jdt.ui.postsavelistener.cleanup' caused an exception: org.eclipse.text.edits.MalformedTreeException: Overlapping text edits Created attachment 247706Event detailsError occurred when editing/refactoring a class having saved it at the end of the previous day when it still had syntax errors/did not compile. Next morning the error occurred when saving (code still not ready to compile).Clean up settings:Add 'this' qualifier to unqualified field accessesAdd 'this' qualifier to unqualified method accessesConvert control statement bodies to blockConvert 'for' loops to enhanced 'for' loopsAdd final modifier to private fieldsAdd final modifier to method parametersAdd final modifier to local variablesRemove unnecessary parenthesesRemove unused importsAdd missing '@Override' annotationsAdd missing '@Override' annotations to implementations of interface methodsAdd missing '@Deprecated' annotationsAdd missing serial version ID (default 1L)Remove unnecessary '$NON-NLS$' tagsAdd unimplemented methodsSort members excluding fields enum constants and initializersOrganize importsFormat source codeRemove trailing white spaces on all linesCorrect indentation
446317,10/8/2014 9:49,sasikanth.bharadwaj,"[1.8][compiler] java.lang.VerifyError: Bad type on operand stack with Lambdas and/or inner classes Similar to https://bugs.eclipse.org/bugs/show_bug.cgi?id=444803 we found slightly different variants using Lambdas/Inner Classes etc. where the ECJ generates invalid bytecode and causes following Exception during verifying:Exception in thread ""main"" java.lang.VerifyError: Bad type on operand stackException Details: Location: java8/ecjissues/AnotherEcjProblem$Sub.<init>(Ljava8/ecjissues/AnotherEcjProblem;)V @8: invokedynamic Reason: Type uninitializedThis (current frame stack[2]) is not assignable to 'java8/ecjissues/AnotherEcjProblem$Sub'See following code:// ----------------------------------------------------------------------import java.util.function.Consumer;@SuppressWarnings(""all"")public class AnotherEcjProblem { private final String text = ""Bug?""; public static void main(String[] args) { new AnotherEcjProblem().doIt(); } private void doIt() { new Sub(); } private class Super<T> { public Super(Consumer<T> consumer) { } } private class Sub extends Super<String> { public Sub() { super(s -> System.out.println(text)); // super(s -> System.out.println(""miep"")); } }}// ----------------------------------------------------------------------import java.util.HashMap;import java.util.Map;import java.util.function.Function;public class EclipseCompilerAndLambdaCrash { public static void main(String[] args) { new EclipseCompilerAndLambdaCrash().run(); } public void run() { class Inner { public Inner() { System.out.println(""miep""); } } Map<String Inner> map = new HashMap<>(); Function<String Inner> function = (name) -> { Inner i = map.get(name); if (i == null) { i = new Inner(); map.put(name i); } return i; }; function.apply(""test""); }}// ----------------------------------------------------------------------Tested with 4.4.1 and eclipse-SDK-N20141007-2000-win32-x86_64"
446446,10/9/2014 7:58,manpalat,[quick fix] 'Remove argument' produces invalid code if comments are present 1. Create the following class:public class RemoveArgumentBug { public static void main(String[] args) { RemoveArgumentBug bug = new RemoveArgumentBug( 1.0e-3 // some comment null); } RemoveArgumentBug(double d) { }}2. The class contains a compiler error a superfluous 'null' argument. The quick fix suggests to remove that so let's do it. The resulting code is however invalid:public class RemoveArgumentBug { public static void main(String[] args) { RemoveArgumentBug bug = new RemoveArgumentBug( 1.0e-3 // some comment); } RemoveArgumentBug(double d) { }}Note that the closing parenthesis and the semicolon are not being added after the 1.0e-3 but at the end of the comment line which is an error.
446604,10/10/2014 6:49,daniel_megert,"[implementation] IOOBE in OptionalMessageDialog.buttonPressed Hello committerswe received a new error report for Eclipse 4.3.2.M20140221-1700.General Information: anonymous-id: 23ca87fb-325b-4150-8ad8-f1a99999d769 eclipse-build-id: 4.3.2.M20140221-1700 eclipse-product: org.eclipse.epp.package.rcp.product operating system: Linux 3.15.0 (x86_64) - gtk java-runtime-version: 1.8.0_20-b26The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.databinding.observable_1.4.1.v20130515-1857 2. org.eclipse.core.databinding_1.4.1.v20130515-1857 3. org.eclipse.core.runtime_3.9.100.v20131218-1515 4. org.eclipse.e4.ui.workbench_1.0.2.v20131202-1739 5. org.eclipse.e4.ui.workbench.swt_0.12.2.v20140117-1939 6. org.eclipse.equinox.app_1.3.100.v20130327-1442 7. org.eclipse.equinox.launcher_1.3.0.v20130327-1440 8. org.eclipse.jdt.ui_3.9.2.v20131106-1600 9. org.eclipse.jdt_3.9.1.v20140221-1700 10. org.eclipse.jface_3.9.1.v20130725-1141 11. org.eclipse.jface.text_3.8.101.v20130802-1147 12. org.eclipse.swt_3.102.1.v20140206-1334 13. org.eclipse.ui_3.105.0.v20130522-1122 14. org.eclipse.ui.ide.application_1.0.401.v20131105-1007 15. org.eclipse.ui.ide_3.9.2.v20131004-0923Error Status: code: 0 plugin: org.eclipse.ui_3.105.0.v20130522-1122 message: Unhandled event loop exception fingerprint: 22ac62c5 exception class: java.lang.ArrayIndexOutOfBoundsException exception message: 1034 number of children: 0 java.lang.ArrayIndexOutOfBoundsException: 1034 at org.eclipse.jdt.internal.ui.dialogs.OptionalMessageDialog.buttonPressed(OptionalMessageDialog.java:116) at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:628) at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1392) at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3742) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3363) at org.eclipse.jface.window.Window.runEventLoop(Window.java:826) at org.eclipse.jface.window.Window.open(Window.java:802) at org.eclipse.jface.dialogs.MessageDialog.open(MessageDialog.java:334) at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.informUserAboutEmptyDefaultCategory(ContentAssistProcessor.java:602) at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.getDefaultCategories(ContentAssistProcessor.java:504) at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.getCategoryIteration(ContentAssistProcessor.java:492) at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.setCategoryIteration(ContentAssistProcessor.java:487) at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor.access$3(ContentAssistProcessor.java:486) at org.eclipse.jdt.internal.ui.text.java.ContentAssistProcessor$CompletionListener.assistSessionStarted(ContentAssistProcessor.java:117) at org.eclipse.jface.text.contentassist.ContentAssistant.fireSessionBeginEvent(ContentAssistant.java:2221) at org.eclipse.jface.text.contentassist.ContentAssistant.prepareToShowCompletions(ContentAssistant.java:1696) at org.eclipse.jface.text.contentassist.ContentAssistant.access$6(ContentAssistant.java:1687) at org.eclipse.jface.text.contentassist.ContentAssistant$2.run(ContentAssistant.java:376) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3717) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3366) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1113) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:997) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:140) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:611) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:567) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:124) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:354) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:181) at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-2) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:483) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:636) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:591) at org.eclipse.equinox.launcher.Main.run(Main.java:1450) at org.eclipse.equinox.launcher.Main.main(Main.java:1426) Messages stacktraces and nested status objects may be shortened. Please visit http://dev.eclipse.org/recommenders/committers/confess/0.5/reports/5437b9a9e4b08c25446233eefor the complete error log.Some general information and guidelines about how to use this bug report:1. Feel free to move this bug to your own product and components. Please note that this bug is only accessible to Eclipse committers. If you move this bug please make sure that it's still in the ""Security Advisor"" group.2. The bug contents of the fields status resolution keywords and whitelist are presented to reporters. If you needs more information please set the keyword ""needinfo"". This will trigger a specialized dialog asking the user to provide further details.3. Use the following resolutions for the following situations: * CLOSED / FIXED: This bug has been fixed. Please provide additional information in the whiteboard field. * CLOSED / WORKSFORME: Use this resolution if you can't reproduce this issue and request further information. Please use the whiteboard text to specify more details what a user should provide and how. * CLOSED / INVALID: Use this resolution if the reported problem is a 'user-configuration' problem. Please consider giving hints how to fix these issues in the whiteboard field. * CLOSED / NOT ECLIPSE: Use this if the problem is caused by another plugin not developed at Eclipse.org * CLOSED / MOVED: If this bug has been moved else where. Please provide more information (e.g. a link) in the whiteboard field.4. Please remember that only committers can view and comment on this bug. You may however manually add the reporting user to the bug's cc list. But keep in mind that the report may contains sensitive information.5. If you are missing a feature please file a enhancement request here: https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Recommenders.Incubator&component=Stacktraces Thank you for your assistance.Your friendly error-reports-inbox.--* Note: The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality."
446715,10/11/2014 0:18,srikanth_sankaran,"[compiler] org.eclipse.jdt.internal.compiler.lookup.TypeSystem.cacheDerivedType(TypeSystem.java:268) eclipse.buildId=4.4.1.M20140925-0400java.version=1.8.0_20java.vendor=Oracle CorporationBootLoader constants: OS=win32 ARCH=x86_64 WS=win32 NL=it_ITorg.eclipse.jdt.coreErrorFri Oct 10 22:45:58 CEST 2014Errors running builder 'Java Builder' on project 'ntools'.java.lang.IllegalStateException	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.cacheDerivedType(TypeSystem.java:268)	at org.eclipse.jdt.internal.compiler.lookup.TypeSystem.cacheDerivedType(TypeSystem.java:298)	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getArrayType(AnnotatableTypeSystem.java:87)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTypeFromSignature(LookupEnvironment.java:1323)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createFields(BinaryTypeBinding.java:547)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.cachePartsFrom(BinaryTypeBinding.java:473)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:696)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:679)	at org.eclipse.jdt.internal.compiler.Compiler.accept(Compiler.java:299)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:164)	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:201)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findImport(CompilationUnitScope.java:468)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.findSingleImport(CompilationUnitScope.java:522)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.resolveSingleImport(CompilationUnitScope.java:735)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3310)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:3042)	at org.eclipse.jdt.internal.compiler.ast.SingleTypeReference.getTypeBinding(SingleTypeReference.java:51)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.internalResolveType(TypeReference.java:472)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:571)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:567)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType(TypeReference.java:541)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype(ClassScope.java:1287)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperInterfaces(ClassScope.java:1038)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:1096)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectMemberTypes(ClassScope.java:906)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:1104)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:323)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:227)	at org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:746)	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:383)	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:428)	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:367)	at org.eclipse.jdt.internal.core.builder.IncrementalImageBuilder.compile(IncrementalImageBuilder.java:330)	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:304)	at org.eclipse.jdt.internal.core.builder.IncrementalImageBuilder.build(IncrementalImageBuilder.java:135)	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:267)	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:195)	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:206)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:246)	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:299)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:302)	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:358)	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:381)	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)"
446746,10/11/2014 18:31,manpalat,[ast dom] Wrong node range for enum constant declaration with body Browse the following snipped in ASTView:enum A{B(){void c(){}}}The EnumConstantDeclaration range does not include its closing brace.It works fine if there's a space added before the closing brace.
446765,10/12/2014 13:51,srikanth_sankaran,"[1.8][content assist] Completion does not work with both lambdas and anonymous classes in the picture I have a mass of lambdas and internal classes that I'm working with. It's reached a point now where I get the following stack overflow.This is with org.eclipse.jdt.core 3.10.0.v20140902-026""main"" #1 prio=6 os_prio=31 tid=0x0000000102807800 nid=0x707 runnable [0x00007fff5f87b000] java.lang.Thread.State: RUNNABLE at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:510) at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:510) at org.eclipse.jdt.internal.core.SourceMethod.hashCode(SourceMethod.java:202) at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:510) at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:510) at org.eclipse.jdt.internal.core.SourceMethod.hashCode(SourceMethod.java:202) at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:510) at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:510) at org.eclipse.jdt.internal.core.SourceMethod.hashCode(SourceMethod.java:202) at org.eclipse.jdt.internal.core.JavaElement.hashCode(JavaElement.java:510)...."
446953,10/13/2014 13:35,manpalat,Mismatched braces in SwitchStatement JavaDoc
447062,10/14/2014 7:16,manpalat,"[1.8][dom/ast] lambda as a class member - IllegalArgumentException I use Eclipse 4.4.1 and JDK 1.8.0.5.I have a class with lambda as a class member:public class LambdaTest {	Runnable foo = () -> {	};}When I save this class the following error occurs (in error log):java.lang.IllegalArgumentException	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2252)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1789)	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3317)	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3204)	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:438)	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:889)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:585)	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:896)	at org.eclipse.jdt.apt.core.internal.env.BaseProcessorEnv.createASTs(BaseProcessorEnv.java:857)	at org.eclipse.jdt.apt.core.internal.env.ReconcileEnv.openPipeline(ReconcileEnv.java:108)	at org.eclipse.jdt.apt.core.internal.env.AbstractCompilationEnv.newReconcileEnv(AbstractCompilationEnv.java:97)	at org.eclipse.jdt.apt.core.internal.APTDispatchRunnable.reconcile(APTDispatchRunnable.java:219)	at org.eclipse.jdt.apt.core.internal.APTDispatchRunnable.runAPTDuringReconcile(APTDispatchRunnable.java:167)	at org.eclipse.jdt.apt.core.internal.AptCompilationParticipant.reconcile(AptCompilationParticipant.java:223)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation$1.run(ReconcileWorkingCopyOperation.java:258)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.notifyParticipants(ReconcileWorkingCopyOperation.java:245)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:95)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:178)	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:114)	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:136)	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:105)	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:406)	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:173)As a result the project can not be complied properly.When I put 'foo' variable in any method everything works as expected.Making 'foo' variable does not help."
447119,10/14/2014 10:40,sasikanth.bharadwaj,[1.8][compiler] method references lost generic type information (4.4 -> 4.4.1 regression) Created attachment 247862test class that shows the regressionIn 4.4.1 generic type information is lost for lambdas. The attached test class shows the problem. The output is:Eclipse 4.4.1-------------Lambda binds to: Testbed.lambda$0Methods (with generics):- java.util.List<java.lang.String> noop(java.util.List<java.lang.String>)- interface java.util.List lambda$0(interface java.util.List)Eclipse 4.4.0-------------Lambda binds to: Testbed.lambda$0Methods (with generics):- java.util.List<java.lang.String> noop(java.util.List<java.lang.String>)- java.util.List<java.lang.String> lambda$0(java.util.List<java.lang.String>)jdk 1.8.0_11------------Lambda binds to: Testbed.noopMethods (with generics):- java.util.List<java.lang.String> noop(java.util.List<java.lang.String>)
447573,10/16/2014 10:23,srikanth_sankaran,[1.8][compiler] Rename IntersectionCastTypeBinding as IntersectionTypeBinding18 ICTB is used for two purposes in JDT/Core:1. To support the special intersection cast introduced for lambda serialization2. In type inference.While this abstraction serves the purposes for (1) fairly adequately[*] it isnot hooked up properly into various type compatibility APIs (isCompatibleWithisEquivalentTo findSuperTypeOriginatingFrom etc) and as a result does notserve well the requirements of (2)For 1.7 we use a modified wildcard binding that serves as an intersectiontype. Either we should move all uses of ICTB to that or factor out theintersection type part of wildcard into a separate abstraction and startusing that. [*] Even there we have problems: See https://bugs.eclipse.org/bugs/show_bug.cgi?id=424410
447767,10/18/2014 10:04,srikanth_sankaran,"[1.8][compiler] Spurious method not applicable error due to interaction between overload resolution and type inference Master:interface I {	void bar(String t);}public class X<T> {	X(String x) {}	X(T x) {}	X(T x String ...strings) {}		public void one(X<I> c){}		public void two() {		one(new X<>((String s) -> { }));	}}javac compiles this while we reject it on master. Problem is that Scope.mSMBcalls parameterCompatibilityLevel on only-applicability inferred methodswith jlO substitutions. So we are checking for lambda compatibility againsta target type of Object incorrectly.We should consult the shallowOriginal also.See also https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444#c121 -https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444#c127"
447931,10/20/2014 10:02,sarika.sinha,Add Open from Clipboard to Tips & Tricks
447983,10/20/2014 15:24,markus.kell.r,"[performance] Mac OS X: ScrollEditorTest must not press Ctrl+Arrow_Down/Up Mac OS X org.eclipse.jdt.text.tests.performance.ScrollEditorTest must not press Ctrl+Arrow_Down/Up for Scroll Line Down/Up.These shortcuts have been hijacked by Apple by default for system-wide ""Mission Control"" and ""Application Windows"" commands. The effects when running e.g. ScrollAnnotatedJavaEditorTest#testScrollJavaEditorLineWise1() is an endless flickering that is hard to cancel (hint: try Command+Q).I guess we best remove the shortcuts for Scroll Line Down/Up on the Mac and change the tests to set custom shortcuts."
448043,10/21/2014 5:56,manpalat,"IllegalStateException: Bad AST node structure at ASTConverter package p2;public class MainScreen {	public MainScreen() {}	/**	 * m1	 */	void m1() {}			syso//this.m2();	}		void m2() {}}----------------------------------------In the above example press Ctrl+space after ""syso"" and press Enter.We get the following exception:java.lang.IllegalStateException: Bad AST node structure:- parent [176 177] org.eclipse.jdt.core.dom.Initializer body [-1 -1] org.eclipse.jdt.core.dom.Block----------------------------------- SOURCE BEGIN -------------------------------------package p2;public class MainScreen {	public MainScreen() {}	/**	 * m1	 */	void m1() {}			private void syso() {			// TODO Auto-generated method stub		}//this.m2();	}		void m2() {}}----------------------------------- SOURCE END -------------------------------------	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1421)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1209)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.rewriteImports(ImportRewrite.java:1051)	at org.eclipse.jdt.internal.ui.text.java.JavaTypeCompletionProposal.apply(JavaTypeCompletionProposal.java:116)	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.apply(AbstractJavaCompletionProposal.java:497)..."
448112,10/21/2014 12:50,Olivier_Thomann,"[compiler] Compiler crash (ArrayIndexOutOfBoundsException at StackMapFrame.addStackItem()) with unused variable This error was originally reported at users <at> tomcat.apache.org mailing list as ""Tomcat 7.0: Unused primitive long or double variables prevent Tomcat from compiling JSP"" today (2014-10-21). The thread can be found in archives e.g. here:http://tomcat.markmail.org/thread/jblxumvub6o7nusrApache Tomcat uses Eclipse ECJ compiler to compile JSP pages. This issue happens when it compiles java code generated for a JSP page.Steps to reproduce:1) Download Tomcat 8 zip or tar.gz binary distributive fromhttp://tomcat.apache.org/download-80.cgi2) Unpack the archive3) Set JAVA_HOME environment variable to home directory of Java 7 or later JDK. (Details if needed can be found in RUNNING.txt in the archive).4) Create a jsp page file ""webapps/ROOT/test.jsp"" with the following text:======<%session.setAttribute(""v1"" 1L);session.setAttribute(""v2"" 2L);long v1 = (Long) session.getAttribute(""v1"");long v2 = (Long) session.getAttribute(""v2"");out.write(String.valueOf(v1));//out.write(String.valueOf(v2));%>======5) At the time of this writing Tomcat includes ecj 4.4. To test with a later version of ECJ replace file lib/ecj-4.4.jar with a different version of ""JDT Core Batch Compiler"" as can be downloaded fromhttp://download.eclipse.org/eclipse/downloads/6) Start Tomcat by running bin/startup.bat or bin/startup.sh7) Open the following page in a Web Browser:http://localhost:8080/test.jsp8)Expected output: ""1""Actual output: Compilation error.9) Stop Tomcat (Ctrl+C or run bin/shutdown.bat bin/shutdown.sh)- This issue is reproducible with ecj-4.4.1.jar and with the current nightly ecj-N20141020-2000.jar.- Stacktrace of the error is the following(using current dev version of Tomcat 8 close to next 8.0.15 releaseand nightly ecj-N20141020-2000.jar):======java.lang.ArrayIndexOutOfBoundsException: -1	org.eclipse.jdt.internal.compiler.codegen.StackMapFrame.addStackItem(StackMapFrame.java:92)	org.eclipse.jdt.internal.compiler.ClassFile.traverse(ClassFile.java:5560)	org.eclipse.jdt.internal.compiler.ClassFile.generateStackMapTableAttribute(ClassFile.java:4319)	org.eclipse.jdt.internal.compiler.ClassFile.completeCodeAttribute(ClassFile.java:1387)	org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:339)	org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:271)	org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:566)	org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:635)	org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:368)	org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:781)	org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:470)	org.apache.jasper.compiler.JDTCompiler.generateClass(JDTCompiler.java:440)	org.apache.jasper.compiler.Compiler.compile(Compiler.java:361)	org.apache.jasper.compiler.Compiler.compile(Compiler.java:336)	org.apache.jasper.compiler.Compiler.compile(Compiler.java:323)	org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:564)	org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:357)	org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:396)	org.apache.jasper.servlet.JspServlet.service(JspServlet.java:340)	javax.servlet.http.HttpServlet.service(HttpServlet.java:725)	org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)======- If the last line of the above fragment is uncommented the JSP page compiles successfully and prints ""12""."
448556,10/23/2014 16:59,sasikanth.bharadwaj,"[1.8][compiler] Invalid compiler error about effectively final variable outside the context of a lambda. In the example code below ecj gives the invalid error ""Local variable i defined in an enclosing scope must be final or effectively final."" It's invalid because the variable i is not being closed over by the lambda rather the value returned by get() is being closed over. Oddly the fact that MyPredicate extends Serializable seems to matter. If I delete that the compiler error goes away.public class MyTest{ private static final List<Integer> INTEGERS = Arrays.asList(1 2 3 4); public static void main(String[] args) { for (int i = 0; i < INTEGERS.size(); i++) { MyPredicate<Integer> predicate = INTEGERS.get(i)::equals; } } public interface MyPredicate<T> extends Serializable { boolean accept(T each); }}"
448914,10/26/2014 22:18,srikanth_sankaran,[1.8][compiler] CaptureBinding18 clones don't share type id. Opening this bug to track the tasks outlined in https://bugs.eclipse.org/bugs/show_bug.cgi?id=430686#c16.Commit http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=c454077fd72f14a026b898d3b50aaf59d2a0517c made on behalf ofhttps://bugs.eclipse.org/bugs/show_bug.cgi?id=430686 solves theproblem there but only short circuiting the route to someproblem spots that are still unaddressed - they can be tackled here.
448954,10/27/2014 9:12,srikanth_sankaran,"[1.8][compiler] Incorrect error: ""The method foo(String String X::goo) is undefined for the type X"" Compiling this program on master I see an error while javac compilesthis fine and prints ""Right!""// --interface I<T U V> {	T goo(U u V v);}interface J {	void foo();}public class X {	static String goo(String s String s2) {		return null;	}	static <T U V> T foo(T t U u J j) { System.out.println(""Wrong!""); return null; }	static <T U V> V foo(T t U u I<T U V> i) {		System.out.println(""Right!"");		return null;	}	public static void main(String[] args) {		String s = goo(foo(""String"" ""String"" X::goo));	}	static <T> T goo(T t) {	 return t;		}}"
449063,10/28/2014 9:56,sasikanth.bharadwaj,[1.8][compiler] Bring back generic signatures for Lambda Expressions Until Eclipse 4.4 the generic signature of a Lambda Expression was stored within the class file which made it possible to extract type information for creating type-safe programs. With the merge of the patch for Bug 436542 (https://bugs.eclipse.org/bugs/show_bug.cgi?id=436542) this feature has been completely thrown away.The following snippet shows an example where a generic signature is a very valuable feature://///public class Test { public static interface Map<IN OUT> { public OUT map(IN in); } public static class Tuple<T1 T2> { private T1 field1; private T2 field2; } public static void main(String[] strings) throws Exception { Map<Tuple<String Double> Tuple<Integer String>> map = (in) -> new Tuple<>(); SerializedLambda sl = getSerializedLambda(lambda); Method m = getLambdaMethod(sl); // Use the type information stored in signature System.out.println(m.getGenericReturnType()); for (Type t : m.getGenericParameterTypes()) { System.out.println(t); } }}/////Another discussion on this topic can be found here: http://stackoverflow.com/questions/21887358/reflection-type-inference-on-java-8-lambdasIt would be a great enhancement to bring the functionality back (by default or at least with help of a compiler option).
449066,10/28/2014 10:17,sarika.sinha,"[jdt] Unexpected runtime error while computing a text hover Hello committerswe received a new error report for Eclipse 4.3.2.M20140221-1700.General Information: anonymous-id: 18be9654-9a91-4680-9666-9eb864bd11d4 eclipse-build-id: 4.3.2.M20140221-1700 eclipse-product: org.eclipse.epp.package.jee.product operating system: Windows7 6.1.0 (x86) - win32 java-runtime-version: 1.7.0_51-b13The following plug-ins were present on the execution stack (*): 1. org.eclipse.jdt.debug.ui_3.6.200.v20130514-0841 2. org.eclipse.jdt.debug_3.8.0.v20130514-0841 3. org.eclipse.jdt_3.9.1.v20140221-1700 4. org.eclipse.jdt.ui_3.9.2.v20131106-1600 5. org.eclipse.jface.text_3.8.101.v20130802-1147 6. org.eclipse.jface_3.9.1.v20130725-1141Error Status: code: 0 plugin: org.eclipse.jface.text_3.8.101.v20130802-1147 message: Unexpected runtime error while computing a text hover fingerprint: 9b432cbe exception class: java.lang.NullPointerException exception message: - number of children: 0 java.lang.NullPointerException: null at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:362) at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163) at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129) at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85) at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166) Messages stacktraces and nested status objects may be shortened. Please visit http://dev.eclipse.org/recommenders/committers/confess/0.5/reports/-for the complete error log.Some general information and guidelines about how to use this bug report:1. Feel free to move this bug to your own product and components. Please note that this bug is only accessible to Eclipse committers. If you move this bug please make sure that it's still in the ""Security Advisor"" group.2. The bug contents of the fields status resolution keywords and whitelist are presented to reporters. If you needs more information please set the keyword ""needinfo"". This will trigger a specialized dialog asking the user to provide further details.3. Use the following resolutions for the following situations: * CLOSED / FIXED: This bug has been fixed. Please provide additional information in the whiteboard field. * CLOSED / WORKSFORME: Use this resolution if you can't reproduce this issue and request further information. Please use the whiteboard text to specify more details what a user should provide and how. * CLOSED / INVALID: Use this resolution if the reported problem is a 'user-configuration' problem. Please consider giving hints how to fix these issues in the whiteboard field. * CLOSED / NOT ECLIPSE: Use this if the problem is caused by another plugin not developed at Eclipse.org * CLOSED / MOVED: If this bug has been moved else where. Please provide more information (e.g. a link) in the whiteboard field.4. Please remember that only committers can view and comment on this bug. You may however manually add the reporting user to the bug's cc list. But keep in mind that the report may contains sensitive information.5. If you are missing a feature please file a enhancement request here: https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Recommenders.Incubator&component=Stacktraces Thank you for your assistance.Your friendly error-reports-inbox.--* Note: The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality."
449098,10/28/2014 14:47,noopur_gupta,"[quick assist] ""Convert to lambda expression"" should enter linked mode for parameters The ""Convert to lambda expression"" quick assist should enter linked mode for the newly created parameters so that the user can easily modify the names and references.Example:	<T S> BiFunction<java.util.List<S> S Object> foo() {		return List<S>::add;	}"
449107,10/28/2014 15:58,noopur_gupta,"[quick assist] ""Convert to lambda expression"" should avoid redundant 'this' or class name The ""Convert to lambda expression"" quick assist should avoid redundant 'this' or class names in the generate lambda.In the example below the first 3 method references can be converted into a lambda that doesn't refer to 'this' or 'Claxx'. If the method name is not ambiguous we should use the short form.import java.util.function.Consumer;public class Claxx {	void doInBackground() throws Exception {		post(Claxx::execute);		absorb(Claxx::executeGiven);		post(this::executeObject);				absorb(Claxx::executeObject);		post(() -> execute());		post(() -> executeGiven(this)); // not convertible		post(() -> executeObject());	}		void post(Runnable r) {		r.run();	}	void absorb(Consumer<Claxx> c) throws Exception {		c.accept(this);	}		static void execute() {		System.out.println(""exec!"");	}	static void executeGiven(Object o) {		System.out.println(""exec "" + o);	}	void executeObject() {		System.out.println(""exec "" + this);	}}"
449222,10/29/2014 12:14,sarika.sinha,"[regression] ValidBreakpointLocationLocator.getLineLocation() returns 0 as location for LOCATION_METHOD Steps:1. create simple class with main method2. add method entry bp to main3. make noop change to file -> save4. method bp is removedPart of the fix for bug 216098 made a small change to the logic in getLineLocation which is now returning a line location of 0 for LOCATION_METHOD which ends up causing an exception in our marker updater which ends up removing the breakpoint.org.eclipse.jface.text.BadLocationException	at org.eclipse.jface.text.ListLineTracker.getLineOffset(ListLineTracker.java:201)	at org.eclipse.jface.text.AbstractLineTracker.getLineOffset(AbstractLineTracker.java:169)	at org.eclipse.jface.text.AbstractDocument.getLineOffset(AbstractDocument.java:922)	at org.eclipse.jdt.debug.ui.breakpoints.JavaBreakpointConditionEditor.setBreakpoint(JavaBreakpointConditionEditor.java:281)	at org.eclipse.jdt.debug.ui.breakpoints.JavaBreakpointConditionEditor.setInput(JavaBreakpointConditionEditor.java:215)	at org.eclipse.jdt.internal.debug.ui.breakpoints.CompositeBreakpointEditor.setInput(CompositeBreakpointEditor.java:137)	at org.eclipse.jdt.internal.debug.ui.breakpoints.AbstractDetailPane.display(AbstractDetailPane.java:283)	at org.eclipse.debug.internal.ui.views.variables.details.DetailPaneProxy.display(DetailPaneProxy.java:117)	at org.eclipse.debug.internal.ui.views.variables.VariablesView.refreshDetailPaneContents(VariablesView.java:1218)	at org.eclipse.debug.internal.ui.views.variables.VariablesView$2.runInUIThread(VariablesView.java:398)	at org.eclipse.ui.progress.UIJob$1.run(UIJob.java:97)	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3983)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:638)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:582)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)	at org.eclipse.equinox.launcher.Main.main(Main.java:1438)To fix the regression we can simply change the getLineLocation method to:if (fLocationType == LOCATION_NOT_FOUND || fLocationType == LOCATION_METHOD) { return -1;}return fLineLocation;or properly compute the line locations for LOCATION_METHOD (rather than leaving it at 0)"
449262,10/29/2014 19:57,het,"[formatter] Allow the use of third-party Java code formatters JDT should allow overriding of the built-in formatter via extension point so that users can supply their own Java formatters.The built-in Eclipse formatter works great but sometimes there are codebase-specific formatting options that the Eclipse formatter cannot do. At Google specifically we have an internal Java formatter that is specifically tailored to Google style that we would like to integrate into Eclipse. This is the approach that is used in CDT where one can plug-in one of the popular C/C++ formatters such as clang-format easily with an extension point.I propose that JDT adds an extension point that allows a client to extend org.eclipse.jdt.core.formatter.CodeFormatter so that Eclipse will use their custom formatter. The selection between the various formatters can happen in the ""Formatting"" preference page where the combo box for selecting formatters is hidden if no custom formatters are provided. This mirrors CDT behavior."
449330,10/30/2014 6:11,shankhba,"[1.6] Eclipse compiler doesn't compile annotations in class files Created attachment 248272ant and eclipse builded class filesI using class files with hibernate annotations and after 4.3 to 4.4 upgrade i found this annoying bug. The host os using java 7 (""1.7.0_60"") and inside eclipse i define different java runtime (windows - preferences - java - installed jre): jdk1.6.0_39I configure default compilance settings to 1.6 and doesn't using any project specific setup. The project contains all the required dependencies on the classpath and build successfuly by and and eclipse internal compiler but...The example java file is: @javax.persistence.SequenceGenerator(		name=""AOK_AGENT_LOG_SEQ"" sequenceName=""HB_AOK_AGENT_LOG_SEQ"" allocationSize=100)package hu.ardinsys.det.dal.hibernate.aokagentlog.dao;The eclipse builded class file is java 6 versioned class file but doesn't contain any of AOK_AGENT_LOG_SEQ HB_AOK_AGENT_LOG_SEQ etc. and my project doesnt work... When i build the classes with ant javac compiler the classes contains all the required notations..."
449453,10/31/2014 6:59,jarthana,[1.8][compiler] Lambda deserialization fails with ClassCastException Created attachment 248297Test codeWe've run into a similar issue as previously reported (and fixed) in #439889.This however is a sightly different case. The code works fine as long as it is compiled using javac (tested with 1.8.0_25). If it's compiled using eclipse's compiler (Version: Luna SR1 (4.4.1) Build id: M20140925-0400) deserialization fails.As our application (using Apacke Wicket) heavily relies on serialization this effectively prevents us from using lambdas in our project. It would be great if this could also be fixed in future 4.4.x releases.The test code is attached.
449467,10/31/2014 8:20,aclement,[1.8][compiler] Invalid lambda deserialization with anonymous class Created attachment 248301Test code illustrating the problemIn addition to the lambda deserialization issues reported in bug 439889 and bug 449453 we've identified yet another issue this time involving an anonymous class.As in the other bugs the code works fine as long as it is compiled using javac (tested with 1.8.0_25). If it's compiled using eclipse's compiler (Version: Luna SR1 (4.4.1) Build id: M20140925-0400) deserialization fails. Note that this even fails with Version: Mars (4.5) Build id: I20141029-2000.Again it would be great if this could also be fixed in future 4.4.x releases.The test code is attached.
449619,11/2/2014 5:07,srikanth_sankaran,"[1.8][compiler] Qualified <> allocation fails to compile. Master:// --public class X {	public class Y<T> {	}	static void foo(Y<String> ys) {	}	public static void main(String[] args) {		foo(new X().new Y<>());	}}fails to compile with: The method foo(X.Y<String>) in the type X is not applicable for the arguments (X.Y<Object>)"
449824,11/3/2014 13:31,sasikanth.bharadwaj,[1.8] Difference in behaviour with method references and lambdas The following code fails to compile in Java 1.8.0_11 but succeeds in Eclipse 4.5M3 and 4.4.1; however converting the method reference to a lambda (or uncommenting the line) results in a compile error for both:public class Bug { public static void main(String[] args) { Concrete<Target> fl = new Concrete<Target>(); // fl.call(each -> each.doSomething()); // fails fl.call(Target::doSomething); // succeeds in Eclipse 4.5M3 and 4.4.1 // but fails in Java 8 1.8.0_11 } public static class Target { public void doSomething() { } } public static class Concrete<T> implements Left<T> Right<T> { public void call(RightHand<? super T> p) { } } public interface Left<T> { default void call(LeftHand<? super T> p) { } } public interface LeftHand<T> { public void left(T t); } public interface Right<T> { public void call(RightHand<? super T> p); } public interface RightHand<T> { public void right(T t); }}
450208,11/5/2014 16:29,markus.kell.r,"[quick fix] Create method quickfix not working for methods using type variables Normally when I have an error because my code is calling a non-existant method then CTRL+1 will show me a quickfix to create the method.This is mighty useful :-)Unfortunately when the method that needs to be created has a generic method signature than the quickfix is not suggested. This is fairly annoying if you have gotten used to having this quickfix available.To reproduce here is a concrete example:---------------------------------------------------------------->8package bork.it;public class Bork<T> {		Class<T> type;		private Help help = new Help();		public void method() {		help.help(this);	}}class Help {		<T> void help(T requestor) {		return;	}	}---------------------------------------------------------------->8Comment the method Help.help. Try to invoke quick fixes on the error that appears on the call to help.help. You will see the option to create the methodis missing."
450286,11/6/2014 7:13,markus.kell.r,Introduce Parameter dialog: table of parameters does not scroll into view If the 'Introduce Parameter' dialog is opened for a method with a large number of parameters (~7 or more) the to-be-created parameter should be scrolled into view.
450380,11/6/2014 12:12,markus.kell.r,"[1.8][compiler] NPE in Scope.getExactConstructor(..) for bad constructor reference The snippet below doesn't make sense at all. I ran into this while trying to edit code. The only thing I expect of the compiler is not to throw an exception.The call at Scope.getExactConstructor(Scope.java:2285) is from bug 437444. I think a simple null check is all we need.!ENTRY org.eclipse.jdt.core 4 4 2014-11-06 18:03:35.685!MESSAGE Exception occurred during problem detection:----------------------------------- SOURCE BEGIN -------------------------------------package xy;public class NpeInCompiler { IntFunction<ArrayList<String>> noo() { return System::new; }}----------------------------------- SOURCE END -------------------------------------!STACK 0java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.lookup.Scope.getExactConstructor(Scope.java:2285)	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.resolveType(ReferenceExpression.java:438)	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve(ReturnStatement.java:331)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:621)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:307)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:929)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:974)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:178)	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:114)	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:136)	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:105)	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:406)	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:173)"
450415,11/6/2014 21:23,srikanth_sankaran,"[1.8][compiler] Failure to resolve overloaded call. This bug has perhaps existed forever:// --import java.util.List;interface I {	String foo();}interface J {	List<String> foo();}public class X { static void goo(I i) { 	System.out.println(""goo(I)""); } static void goo(J j) { 	System.out.println(""goo(J)""); } static <T> List<T> loo() { 	return null; } public static void main(String[] args) {		goo(()->loo());	}}// --This program fails to compile with ECJ while compiling alright with8u20.Problem is a mistaken assumption on my part that we can reuse result expressions having computed them against one particular target type.(If you reverse the order of the goo methods the code compiles fine)"
450417,11/6/2014 22:06,srikanth_sankaran,[1.8][compiler] Lambda caching sometimes rendered ineffective. See https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444#c50 onwards.
450442,11/7/2014 4:30,srikanth_sankaran,"[1.8] NPE at HandleFactory.createElement on hover package meth.refs;import java.util.function.Consumer;public class Claxx {	void post(Runnable r) {		r.run();	}	void absorb(Consumer<Claxx> c) throws Exception {		c.accept(this);	}		static void execute() {		System.out.println(""exec!"");	}	static void executeGiven(Object o) {		System.out.println(""exec "" + o);	}	void executeObject() {		System.out.println(""exec "" + this);	}	}class ClaxxTest {	Claxx claxx = new Claxx();		void doInBackground() throws Exception {		claxx.post(Claxx::execute); // Hover over ""post""		absorb(Claxx::executeGiven);		post(this::executeObject);				absorb(Claxx::executeObject);		post(() -> execute());		post(() -> executeGiven(this)); // not convertible		post(() -> executeObject());	}	}------------------------------------------------------In the above example hover over ""post"" at the specified location.We get the following exception:java.lang.NullPointerException	at org.eclipse.jdt.internal.core.util.HandleFactory.createElement(HandleFactory.java:177)	at org.eclipse.jdt.internal.core.util.HandleFactory.createLambdaTypeElement(HandleFactory.java:168)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.rememberAllTypes(HierarchyResolver.java:495)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:829)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:628)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyBuilder.buildSupertypes(HierarchyBuilder.java:116)	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:136)	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:301)	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1268)	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:743)	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:695)	at org.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getTypeHierarchy(SuperTypeHierarchyCache.java:144)..."
450454,11/7/2014 4:44,srikanth_sankaran,"[1.8] CCE at TypeBinding.getInterfaces package meth.refs;import java.util.function.Consumer;public class Claxx {	void post(Runnable r) {		r.run();	}	void absorb(Consumer<Claxx> c) throws Exception {		c.accept(this);	}		static void execute() {		System.out.println(""exec!"");	}	static void executeGiven(Object o) {		System.out.println(""exec "" + o);	}	void executeObject() {		System.out.println(""exec "" + this);	}	}class ClaxxTest {	Claxx claxx = new Claxx();		void doInBackground() throws Exception {		claxx.post(Claxx::execute);		absorb(Claxx::executeGiven); // Press Ctrl+1 at the beginning of stmt		post(this::executeObject);				absorb(Claxx::executeObject);		post(() -> execute());		post(() -> executeGiven(this)); // not convertible		post(() -> executeObject());	}	}-----------------------------------------------------------In the above example press Ctrl+1 to select the suggested quick fix at the location specified in comment.We get the following exception:java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding	at org.eclipse.jdt.core.dom.TypeBinding.getInterfaces(TypeBinding.java:509)	at org.eclipse.jdt.internal.ui.text.correction.ASTResolving.collectRelaxingTypes(ASTResolving.java:1049)..."
450490,11/7/2014 6:25,pisv,"Thread safety of OpenableElementInfo Here's another finding from Handly (see bug 441430). It may apply to JDT too.It is entirely possible for getChildren() to be called in one thread while addChild/removeChild is being executed in another in which case the getChildren might be ""spying"" on the optimized execution of addChild/removeChild and it is possible for it to return a 'surprising' value due to reordering.Since it is known that only one thread can change the children field but many other threads are allowed to read it at any time declaring this field as volatile can be sufficient to attain the desired thread safety guarantees.Will push the proposed patch to Gerrit soon.Best RegardsVladimir"
450604,11/7/2014 18:14,srikanth_sankaran,"[1.8] CCE at InferenceContext18.getParameter line 1377 TypeVariableBinding cannot be cast to ArrayBinding This looks like a recent regression. To reproduce add this code to an editor:package repro;import java.io.IOException;import java.util.List;import java.util.function.Function;public class UsedToWork<T E extends Exception> {	public static <T> List<T> of(T one) { return null; }	public @SafeVarargs static <T> List<T> of(T... items) { return null; }	public static void printDependencyLoops() throws IOException {		Function<? super String ? extends List<String>> mapping = UsedToWork::of;	}}The error is logged immediately in the Error Log view.Tested with Eclipse SDKVersion: Mars (4.5)Build id: I20141104-0800Here is the stack trace:java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ArrayBinding	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.getParameter(InferenceContext18.java:1377)	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.isMoreSpecificThan(InferenceContext18.java:610)	at org.eclipse.jdt.internal.compiler.lookup.Scope.mostSpecificMethodBinding(Scope.java:4289)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findDefaultAbstractMethod(Scope.java:1161)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1781)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1520)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2791)	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.resolveType(ReferenceExpression.java:491)	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.internalResolveTentatively(ReferenceExpression.java:738)	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.findCompileTimeMethodTargeting(ReferenceExpression.java:710)	at org.eclipse.jdt.internal.compiler.lookup.ConstraintExpressionFormula.reduceReferenceExpressionCompatibility(ConstraintExpressionFormula.java:230)	at org.eclipse.jdt.internal.compiler.lookup.ConstraintExpressionFormula.reduce(ConstraintExpressionFormula.java:186)	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:840)	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:387)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod18(ParameterizedGenericMethodBinding.java:216)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:80)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:730)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:687)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1619)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1520)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2791)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:880)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:701)	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1022)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:621)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:307)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:929)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:557)	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1082)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
450684,11/8/2014 22:25,jarthana,"Javadoc URL that redirects from http to https yields: Unknown javadoc format for <type from Oracle JRE rt.jar> Hello committerswe received a new error report for Eclipse 4.4.1.M20140925-0400.General Information: anonymous-id: f5797253-73aa-41ed-8998-5690655dd0a5 eclipse-build-id: 4.4.1.M20140925-0400 eclipse-product: org.eclipse.epp.package.jee.product operating system: Windows8 6.2.0 (x86_64) - win32 java-runtime-version: 1.8.0_25-b18The following plug-ins were present on the execution stack (*): 1. org.eclipse.jdt.core_3.10.0.v20140902-0626 2. org.eclipse.jdt_3.10.0.v20140925-0400 3. org.eclipse.jdt.ui_3.10.1.v20140817-1500 4. org.eclipse.jface.text_3.9.1.v20140827-1810 5. org.eclipse.jface_3.10.1.v20140813-1009Error Status: code: 10.001 plugin: org.eclipse.jdt.ui_3.10.1.v20140817-1500 message: Internal Error fingerprint: 7a304c08 exception class: org.eclipse.jdt.core.JavaModelException exception message: Unknown javadoc format for Integer {key=Ljava/lang/Integer;} [in Integer.class [in java.lang [in C:\Program Files\Java\jre1.8.0_25\lib\rt.jar]]] number of children: 1 org.eclipse.jdt.core.JavaModelException: Unknown javadoc format for Integer {key=Ljava/lang/Integer;} [in Integer.class [in java.lang [in C:\Program Files\Java\jre1.8.0_25\lib\rt.jar]]] at org.eclipse.jdt.internal.core.JavadocContents.getTypeDoc(JavadocContents.java:81) at org.eclipse.jdt.internal.core.BinaryType.getAttachedJavadoc(BinaryType.java:999) at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:500) at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:689) at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:607) at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:599) at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163) at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129) at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85) at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166) --- code: 1.009 plugin: org.eclipse.jdt.core_3.10.0.v20140902-0626 message: Unknown javadoc format for Integer {key=Ljava/lang/Integer;} [in Integer.class [in java.lang [in C:\Program Files\Java\jre1.8.0_25\lib\rt.jar]]] fingerprint: 00000000 number of children: 0 Messages stacktraces and nested status objects may be shortened. Please visit http://dev.eclipse.org/recommenders/committers/confess/0.5/reports/-for the complete error log.Some general information and guidelines about how to use this bug report:1. Feel free to move this bug to your own product and components. Please note that this bug is only accessible to Eclipse committers. If you move this bug please make sure that it's still in the ""Security Advisor"" group.2. The bug contents of the fields status resolution keywords and whitelist are presented to reporters. If you needs more information please set the keyword ""needinfo"". This will trigger a specialized dialog asking the user to provide further details.3. Use the following resolutions for the following situations: * CLOSED / FIXED: This bug has been fixed. Please provide additional information in the whiteboard field. * CLOSED / WORKSFORME: Use this resolution if you can't reproduce this issue and request further information. Please use the whiteboard text to specify more details what a user should provide and how. * CLOSED / INVALID: Use this resolution if the reported problem is a 'user-configuration' problem. Please consider giving hints how to fix these issues in the whiteboard field. * CLOSED / NOT ECLIPSE: Use this if the problem is caused by another plugin not developed at Eclipse.org * CLOSED / MOVED: If this bug has been moved else where. Please provide more information (e.g. a link) in the whiteboard field.4. Please remember that only committers can view and comment on this bug. You may however manually add the reporting user to the bug's cc list. But keep in mind that the report may contains sensitive information.5. If you are missing a feature please file a enhancement request here: https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Recommenders.Incubator&component=Stacktraces Thank you for your assistance.Your friendly error-reports-inbox.--* Note: The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality."
450841,11/10/2014 9:45,markus.kell.r,Update default URLs for attached Javadoc for JREs to https (via bug 450684)Looks like Oracle has permanently moved JRE Javadocs to https so we should update the default URLs in org.eclipse.jdt.internal.launching.StandardVMType.$ wget -S http://docs.oracle.com/javase/8/docs/api/--2014-11-10 15:32:16-- http://docs.oracle.com/javase/8/docs/api/Resolving docs.oracle.com (docs.oracle.com)... 104.66.181.23Connecting to docs.oracle.com (docs.oracle.com)|104.66.181.23|:80... connected.HTTP request sent awaiting response... HTTP/1.1 301 Moved Permanently Server: AkamaiGHost Content-Length: 0 Location: https://docs.oracle.com/javase/8/docs/api/ Date: Mon 10 Nov 2014 14:32:16 GMT Connection: keep-aliveLocation: https://docs.oracle.com/javase/8/docs/api/ [following]
450858,11/10/2014 11:20,noopur_gupta,"[organize imports] Wrongly adds import for qualifier of SuperFieldAccess I20141104-0800Organize Imports wrongly adds an import for the qualifier of the SuperFieldAccess here:package bug;class S {	public /*static*/ final int f = 0;}class X {	class C extends S {		public void foo() {			System.out.println(C.super.f);		}	}}The added import is unused:import bug.X.C;"
450859,11/10/2014 11:36,markus.kell.r,"[1.8] IJavaElement#getAttachedJavadoc(..) fails for 1.8-style package-summary.html In https://docs.oracle.com/javase/8/docs/api/java/math/package-summary.html the package description starts with:<a name=""package.description"">In Java SE 7 and earlier it was:<a name=""package_description"">The effect is that package descriptions from attached Javadoc don't show up in Javadoc hovers."
451289,11/13/2014 4:30,jarthana,[test][model]AttachedJavadocTests.test025 failed N20141112-2000Failed on all platformshttp://download.eclipse.org/eclipse/downloads/drops4/N20141112-2000/testresults/html/org.eclipse.jdt.core.tests.model_win32.win32.x86_7.0.htmlError : java.lang.IllegalArgumentException: protocol = http host = nulljava.lang.RuntimeException: java.lang.IllegalArgumentException: protocol = http host = nullat sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1242)at sun.net.www.protocol.http.HttpURLConnection.getHeaderField(HttpURLConnection.java:2714)at java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:477)at org.eclipse.jdt.internal.core.JavaElement.getURLContents(JavaElement.java:848)at org.eclipse.jdt.internal.core.BinaryType.getJavadocContents(BinaryType.java:1039)at org.eclipse.jdt.internal.core.BinaryField.getAttachedJavadoc(BinaryField.java:121)at org.eclipse.jdt.core.tests.model.AttachedJavadocTests.test025(AttachedJavadocTests.java:592)at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:104)at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:88)at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$1.protect(SuiteOfTestCases.java:76)at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:85)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310)at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36)at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32)at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)at org.eclipse.equinox.launcher.Main.run(Main.java:1465)at org.eclipse.equinox.launcher.Main.main(Main.java:1438)at org.eclipse.core.launcher.Main.main(Main.java:34)Caused by: java.lang.IllegalArgumentException: protocol = http host = nullat sun.net.spi.DefaultProxySelector.select(DefaultProxySelector.java:170)at sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:926)at sun.net.www.protocol.http.HttpURLConnection.connect(HttpURLConnection.java:850)at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1300)at java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:468)
451416,11/13/2014 17:21,daniel_megert,"[jdt] PSE in LaunchConfigurationQueryParticipant.search Hello committerswe received a new error report for Eclipse 4.4.1.M20140925-0400.General Information: anonymous-id: aab621e9-4026-41d7-956e-ea5aef723587 eclipse-build-id: 4.4.1.M20140925-0400 eclipse-product: org.eclipse.epp.package.rcp.product operating system: Windows7 6.1.0 (x86) - win32 java-runtime-version: 1.7.0_72-b14The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.jobs_3.6.0.v20140424-0053 2. org.eclipse.core.runtime_3.10.0.v20140318-2214 3. org.eclipse.jdt.debug.ui_3.6.300.v20140512-1926 4. org.eclipse.jdt.debug_3.8.101.v20140902-1548 5. org.eclipse.jdt_3.10.0.v20140925-0400 6. org.eclipse.jdt.ui_3.10.1.v20140817-1500Error Status: code: 2 plugin: org.eclipse.jdt.ui_3.10.1.v20140817-1500 message: Problems occurred when invoking code from plug-in: ""org.eclipse.jdt.ui"". fingerprint: 0d04955e exception class: java.util.regex.PatternSyntaxException exception message: Unclosed group near index 10CEP\.free( ^ number of children: 0 java.util.regex.PatternSyntaxException: Unclosed group near index 10CEP\.free( ^ at java.util.regex.Pattern.error(null:-1) at java.util.regex.Pattern.accept(null:-1) at java.util.regex.Pattern.group0(null:-1) at java.util.regex.Pattern.sequence(null:-1) at java.util.regex.Pattern.expr(null:-1) at java.util.regex.Pattern.compile(null:-1) at java.util.regex.Pattern.<init>(null:-1) at java.util.regex.Pattern.compile(null:-1) at org.eclipse.jdt.internal.debug.ui.search.LaunchConfigurationQueryParticipant.search(LaunchConfigurationQueryParticipant.java:127) at org.eclipse.jdt.internal.ui.search.JavaSearchQuery$2.run(JavaSearchQuery.java:164) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:170) at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54) Messages stacktraces and nested status objects may be shortened. Please visit http://dev.eclipse.org/recommenders/committers/confess/0.5/reports/-for the complete error log.Some general information and guidelines about how to use this bug report:1. Feel free to move this bug to your own product and components. Please note that this bug is only accessible to Eclipse committers. If you move this bug please make sure that it's still in the ""Security Advisor"" group.2. The bug contents of the fields status resolution keywords and whitelist are presented to reporters. If you needs more information please set the keyword ""needinfo"". This will trigger a specialized dialog asking the user to provide further details.3. Use the following resolutions for the following situations: * CLOSED / FIXED: This bug has been fixed. Please provide additional information in the whiteboard field. * CLOSED / WORKSFORME: Use this resolution if you can't reproduce this issue and request further information. Please use the whiteboard text to specify more details what a user should provide and how. * CLOSED / INVALID: Use this resolution if the reported problem is a 'user-configuration' problem. Please consider giving hints how to fix these issues in the whiteboard field. * CLOSED / NOT ECLIPSE: Use this if the problem is caused by another plugin not developed at Eclipse.org * CLOSED / MOVED: If this bug has been moved else where. Please provide more information (e.g. a link) in the whiteboard field.4. Please remember that only committers can view and comment on this bug. You may however manually add the reporting user to the bug's cc list. But keep in mind that the report may contains sensitive information.5. If you are missing a feature please file a enhancement request here: https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Recommenders.Incubator&component=Stacktraces Thank you for your assistance.Your friendly error-reports-inbox.--* Note: The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality."
451418,11/13/2014 17:38,srikanth_sankaran,"[1.8][compiler] NPE at ParameterizedGenericMethodBinding.computeCompatibleMethod18 This following source code causes lots of NPE's being thrown:package any;class Repro { public static <T> FieldSet<T> emptySet() { return null; } /** * {@link #emptySet} */ public int i;}Here's the full stack trace:java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod18(ParameterizedGenericMethodBinding.java:195)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:80)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:730)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:687)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1619)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1520)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2478)	at org.eclipse.jdt.internal.compiler.ast.JavadocFieldReference.internalResolveType(JavadocFieldReference.java:85)	at org.eclipse.jdt.internal.compiler.ast.JavadocFieldReference.resolveType(JavadocFieldReference.java:128)	at org.eclipse.jdt.internal.compiler.ast.Javadoc.resolveReference(Javadoc.java:386)	at org.eclipse.jdt.internal.compiler.ast.Javadoc.resolve(Javadoc.java:281)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveJavadoc(AbstractMethodDeclaration.java:598)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:525)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:929)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:974)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1247)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:178)	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:114)	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:136)	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:105)	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:406)	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:173)"
451540,11/14/2014 8:27,sptaszkiewicz,Add org.eclipse.jdt.core plugin to General > Tracing preference page If a plugin provides .options file it is possible to enable tracing for this plugin via General > Tracing preference page. This bug covers adding the org.eclipse.jdt.core plugin to this preference page to make it easier to debug problems in runtime without restarting Eclipse.
451840,11/17/2014 5:39,sasikanth.bharadwaj,"[1.8] java.lang.BootstrapMethodError when running code with constructor reference The following code when run results in a java.lang.BootstrapMethodError.public class MyTest{ public static void main(String[] args) { 	MyTest test = new MyTest(); 	MySupplier<MyTest> s = test::new; } public interface MySupplier<T> { T create(); }}The above code is rejected by javac because the lhs of the constructor reference isn't a class."
451901,11/17/2014 8:55,sptaszkiewicz,Add all JDT/Core plugins to General > Tracing preference page If a plugin provides .options file it is possible to enable tracing for this plugin via General > Tracing preference page. We should add all JDT/Core plugins to this preference page to make it easier to debug it.This is an umbrella bug all the work will be done in dependent bugs on a one bug per one plugin basis.
451902,11/17/2014 8:58,sptaszkiewicz,Add org.eclipse.jdt.apt.core plugin to General > Tracing preference page If a plugin provides .options file it is possible to enable tracing for this plugin via General > Tracing preference page. This bug covers adding the org.eclipse.jdt.apt.core plugin to this preference page to make it easier to debug problems in runtime without restarting Eclipse.
451903,11/17/2014 9:00,sptaszkiewicz,Add org.eclipse.jdt.apt.pluggable.core plugin to General > Tracing preference page If a plugin provides .options file it is possible to enable tracing for this plugin via General > Tracing preference page. This bug covers adding the org.eclipse.jdt.apt.pluggable.core plugin to this preference page to make it easier to debug problems in runtime without restarting Eclipse.
452129,11/18/2014 10:26,sptaszkiewicz,Add all JDT/UI plugins to General > Tracing preference page If a plugin provides .options file it is possible to enable tracing for this plugin via General > Tracing preference page. We should add all JDT/UI plugins to this preference page to make it easier to debug it.This is an umbrella bug all the work will be done in dependent bugs on a one bug per one plugin basis.
452134,11/18/2014 10:30,sptaszkiewicz,Add org.eclipse.jdt.ui plugin to General > Tracing preference page If a plugin provides .options file it is possible to enable tracing for this plugin via General > Tracing preference page. This bug covers adding the org.eclipse.jdt.ui plugin to this preference page to make it easier to debug problems in runtime without restarting Eclipse.
452457,11/20/2014 5:28,jarthana,"Long running performance tests don't run on baseline (4.4) +++ This bug was initially created as a clone of Bug #452336 +++I've studied the logs in bug 452336 and can summarize the issue below. It primarily comes down to several ""prereq"" ranges in jdt test bundles ... both Core and UI ... being ""too tight"" to install into 4.4. To explain the ""big picture"" what we are trying to do is run the ""4.5 performance unit tests compiled against 4.5 but ran against 4.4 as ""the baseline measurements"". The ""long running"" set of performance tests consist of 5 suites and 4 of them will not install into 4.4 due to ""tight prereq ranges"" in the 4.5 stream. They are probably correct in the ""pure"" sense of semantic versioning -- I'm assuming they were ""tighten up for a reason? -- BUT ... I'm not sure we need them to be ""exactly right"" for test bundles (for several reasons) and the issue mostly comes down to if we did ""loosen the range"" would the test still (mostly) run? Or would they be ""completely broken at runtime time"" due to changes between 4.4 and 4.5? This effects the follwing 4 test suites: org.eclipse.jdt.core.tests.performanceorg.eclipse.jdt.text.testsorg.eclipse.jdt.ui.tests.refactoringorg.eclipse.pde.api.tools.testsWhen trying to install them into 4.4 to test them the p2 operation fails with the error: ""Cannot complete the install because one or more required items could not be found.""The following give a little more detail and a specific proposed ""fix"" marked with ""**"". = = = = = Software being installed: JDT Core Performance Tests 3.9.4.v20141105-1025 (org.eclipse.jdt.core.tests.performance 3.9.4.v20141105-1025)Missing requirement: Java Compiler Tests 3.11.0.v20141116-0700 (org.eclipse.jdt.core.tests.compiler 3.11.0.v20141116-0700) requires 'bundle org.eclipse.jdt.core [3.11.04.0.0)' but it could not be found** Can org.eclipse.jdt.core.tests.compiler be changed to ""prereq"" org.eclipse.jdt.core [3.10.04.0.0) instead of [3.11.04.0.0)?= = = = Software being installed: JDT Text Test Plug-in 3.10.100.v20141113-1557 (org.eclipse.jdt.text.tests 3.10.100.v20141113-1557)Missing requirement: Java Test Plug-in 3.10.100.v20141114-1947 (org.eclipse.jdt.ui.tests 3.10.100.v20141114-1947) requires 'bundle org.eclipse.jdt.ui [3.10.1004.0.0)' but it could not be found** Can org.eclipse.jdt.ui.tests be change to ""prereq"" org.eclipse.jdt.ui [3.10.14.0.0) instead of [3.10.1004.0.0)?= = = = Software being installed: Refactoring Tests Plug-in 3.10.100.v20141113-1557 (org.eclipse.jdt.ui.tests.refactoring 3.10.100.v20141113-1557)Missing requirement: Refactoring Tests Plug-in 3.10.100.v20141113-1557 (org.eclipse.jdt.ui.tests.refactoring 3.10.100.v20141113-1557) requires 'bundle org.eclipse.jdt.ui [3.10.1004.0.0)' but it could not be found** Can org.eclipse.jdt.ui.tests.refactoring be change to ""prereq"" org.eclipse.jdt.ui [3.10.14.0.0) instead of [3.10.1004.0.0)? = = = = Software being installed: API Tools Tests 1.0.500.v20140811-1958 (org.eclipse.pde.api.tools.tests 1.0.500.v20140811-1958)Missing requirement: Java Compiler Tests 3.11.0.v20141116-0700 (org.eclipse.jdt.core.tests.compiler 3.11.0.v20141116-0700) requires 'bundle org.eclipse.jdt.core [3.11.04.0.0)' but it could not be found** Can org.eclipse.jdt.core.tests.compiler be changed to ""prereq"" org.eclipse.jdt.core [3.10.04.0.0) instead of [3.11.04.0.0)?= = = ="
452587,11/20/2014 17:16,sasikanth.bharadwaj,Java 8: Method references to the same method do not share BootstrapMethod (Using JDT-core version 3.9.5 which is not listed)Compiling the java code below using ECJ results in two identical bootstrap methods in the class file. Constant pool entries are also duplicated. This results in duplicate objects and excessive symbol resolution by the run-time constant pool. The class files are also bloated.Compiling the same java code with javac only produces one bootstrap method.The attached tests (Test.zip) demonstrate the difference in compiler behaviour using five method references to the same method.==JAVA CODE== public class Test { public static void main(String[] args) { Runnable m = Test::m; Runnable n = Test::m; } public static void m() {} }==ECJ byte codes== 0: #35 invokestatic java/lang/invoke/LambdaMetafactory.metafactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; Method arguments: #36 ()V #39 invokestatic mhiCount/Test.m:()V #40 ()V 1: #35 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; Method arguments: #41 ()V #42 invokestatic mhiCount/Test.m:()V #43 ()VDuplicated constant pool entries: - #36 #40 #41 #43 - #39 #42==JAVAC byte codes== 0: #20 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; Method arguments: #21 ()V #22 invokestatic Test_javac.m:()V #21 ()V
453253,11/25/2014 17:34,daniel_megert,"Long running performance tests don't run on baseline (4.4) +++ This bug was initially created as a clone of Bug #452457 ++++++ This bug was initially created as a clone of Bug #452336 +++I've studied the logs in bug 452336 and can summarize the issue below. It primarily comes down to several ""prereq"" ranges in jdt test bundles ... both Core and UI ... being ""too tight"" to install into 4.4. To explain the ""big picture"" what we are trying to do is run the ""4.5 performance unit tests compiled against 4.5 but ran against 4.4 as ""the baseline measurements"". The ""long running"" set of performance tests consist of 5 suites and 4 of them will not install into 4.4 due to ""tight prereq ranges"" in the 4.5 stream. They are probably correct in the ""pure"" sense of semantic versioning -- I'm assuming they were ""tighten up for a reason? -- BUT ... I'm not sure we need them to be ""exactly right"" for test bundles (for several reasons) and the issue mostly comes down to if we did ""loosen the range"" would the test still (mostly) run? Or would they be ""completely broken at runtime time"" due to changes between 4.4 and 4.5? = = = = = There remains 2 suites to fix: org.eclipse.jdt.text.testsorg.eclipse.jdt.ui.tests.refactoringWhen trying to install them into 4.4 to test them the p2 operation fails with the error: ""Cannot complete the install because one or more required items could not be found.""The following give a little more detail and a specific proposed ""fix"" marked with ""**"". = = = = = Software being installed: JDT Text Test Plug-in 3.10.100.v20141113-1557 (org.eclipse.jdt.text.tests 3.10.100.v20141113-1557)Missing requirement: Java Test Plug-in 3.10.100.v20141114-1947 (org.eclipse.jdt.ui.tests 3.10.100.v20141114-1947) requires 'bundle org.eclipse.jdt.ui [3.10.1004.0.0)' but it could not be found** Can org.eclipse.jdt.ui.tests be change to ""prereq"" org.eclipse.jdt.ui [3.10.14.0.0) instead of [3.10.1004.0.0)?= = = = Software being installed: Refactoring Tests Plug-in 3.10.100.v20141113-1557 (org.eclipse.jdt.ui.tests.refactoring 3.10.100.v20141113-1557)Missing requirement: Refactoring Tests Plug-in 3.10.100.v20141113-1557 (org.eclipse.jdt.ui.tests.refactoring 3.10.100.v20141113-1557) requires 'bundle org.eclipse.jdt.ui [3.10.1004.0.0)' but it could not be found** Can org.eclipse.jdt.ui.tests.refactoring be change to ""prereq"" org.eclipse.jdt.ui [3.10.14.0.0) instead of [3.10.1004.0.0)? = = = ="
453527,11/28/2014 8:11,sptaszkiewicz,Consider disabling all org.eclipse.jdt.apt.core debug options if general debug option is disabled This is a follow up of bug 451902 comment 1: it would be good to adjust the behavior of debug flags so that disabling the general flag org.eclipse.jdt.apt.core/debug disables all debug flags like it is done in other bundles.
453552,11/28/2014 12:46,sasikanth.bharadwaj,"Invalid '@FunctionalInterface error when two interfaces extend the same functional interface. package test;@FunctionalInterfaceinterface FunctionalInterface1 { void methodWithoutDefault();}@FunctionalInterfaceinterface FunctionalInterface2 extends FunctionalInterface1{}@FunctionalInterfaceinterface FunctionalInterface3 extends FunctionalInterface1{}@FunctionalInterfaceinterface FunctionalInterface4 extends FunctionalInterface2 FunctionalInterface3{}@FunctionalInterfaceinterface RunnableFunctionalInterface extends Runnable FunctionalInterface4{	default void methodWithoutDefault(){		// implements methodWithoutDefault	}}------------------------------------------------------The above interface hierarchy results in the error ""Invalid '@FunctionalInterface' annotation; RunnableFunctionalInterface is not a functional interface""although RunnableFunctionalInterface only has the single abstract method ""run"" inherited from Runnable. The error seems to be caused by FunctionalInterface4 extending both FunctionalInterface2 and FunctionalInterface3 which in turn both extend FunctionalInterface1 which declares the single abstract method ""methodWithoutDefault""."
453687,12/1/2014 0:33,sasikanth.bharadwaj,"[1.8][compiler]Incorrect errors when compiling code with Method References In Eclipse 4.5.0M3 the following code----------------------import static java.util.stream.Collectors.*;...... Map<String Set<String>> countryLanguagesMap = Stream.of(Locale.getAvailableLocales()) .collect( groupingBy(Locale::getDisplayCountry mapping(Locale::getDisplayLanguage toSet()) ) );----------------------Gives errors ""The type Locale does not define getDisplayCountry(Object) that is applicable here"" and ""The type Locale does not define getDisplayLanguage(Object) that is applicable here""It compiles and runs fine in maven."
454028,12/3/2014 10:14,sarika.sinha,"Many debug features break with alternate strata Many debug features rely on finding the Java source element for the current debug element.These include:- Change Variable- Logical Structure- Content Assist in Display View- Evaluate Expressionand probably some more I'm missing.Currently all these eventually call JavaDebugUtils#getSourceName(Object). This uses the default stratum of the current StackFrame. But the callers listed above always need Java no matter what other Strata are available. As a result all these features are broken in Xtend and other Xbase languages which add additional Strata.Instead this function should really be getSourceName(Object o String stratum) and be called with the ""Java"" argument by all clients that need Java source elements."
454401,12/8/2014 4:50,manpalat,"[search] Search unable to find references package bugzilla;public class TestSearch {	private class X {		private class P {					}		private void t1(P p) {			t2(p);		}		protected void t2(P p) {					}	}}---------------------------------Press Ctrl+Shift+G at method declaration of #t2 to search for its references.0 references are found though it is being invoked in #t1.It used to work in Eclipse 3.8.1."
454411,12/8/2014 6:32,manpalat,"[1.8][search] NPE while searching for method references package bug;import java.util.function.UnaryOperator;public class Test02 {	private static class Multiplier {		private final long mMul;		public Multiplier(long iMul) {			this.mMul = iMul;		}		public <T V> Long mul(Long iItem) {			return iItem * mMul;		}	}	private static void test(UnaryOperator<Long> iFn) {	}	public static <T V> void main(String[] args) {		UnaryOperator<Long> mul = (new Multiplier(3))::<T V> mul;		Test02.test((new Multiplier(3))::<T V> mul);	}}-------------------------------------------In the Search dialog's ""Java Search"" tab enter search string ""mul"" and search for method references in the above file.We get the following exception:java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.copy(ReferenceExpression.java:129)	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.cachedResolvedCopy(ReferenceExpression.java:740)	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isCompatibleWith(ReferenceExpression.java:983)	at org.eclipse.jdt.internal.compiler.lookup.PolyTypeBinding.isCompatibleWith(PolyTypeBinding.java:37)	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4736)	at org.eclipse.jdt.internal.compiler.lookup.Scope.parameterCompatibilityLevel(Scope.java:4703)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:755)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:689)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1621)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1522)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2797)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:885)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:703)	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1024)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:638)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:307)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:548)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1207)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1320)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1843)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1259)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1300)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1432)	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:122)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516)	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584)	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144)	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)"
454650,12/9/2014 17:24,jarthana,[1.9] Eclipse cannot resolve java.lang.* classes Version: Luna (4.4)Build id: I20140606-1215Some changes have been made in JDK9 b41 (see http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8049367) and there are numerous new failures in:org.eclipse.jdt.core.tests.builder package (253 tests)org.eclipse.jdt.core.tests.compiler package (563 tests)org.eclipse.jdt.core.tests.model (145 tests)[java] ---------- [java] 1. ERROR in p\X.java (at line 1) [java] package p; [java] ^ [java] The type java.lang.Object cannot be resolved. It is indirectly referenced from required .class files [java] ---------- [java] 2. ERROR in p\X.java (at line 2) [java] public class X { [java] ^ [java] Implicit super constructor Object() is undefined for default constructor. Must define an explicit constructorUse the following to reproduce:1. eclipse-Automated-Tests-4.4 from http://download.eclipse.org/eclipse/downloads/drops4/R-4.4-201406061215/2. jdk9 from http://jdk9.java.net/download (b41)
455146,12/14/2014 7:51,platform-ui-triaged,[Navigator] Name suggestion for copied file is useless Quite often you want to copy-paste a file into the same directory because you want to create a file that is similar to the other one. When you do that assuming that the filename is 'Foo.txt' eclipse suggest 'Copy of Foo.txt' for the new file. I find that completely useless since no one ever wants a file named like that. It would be less hassle to just leave the original filename in there with the error notification that a rename is required to avoid duplicate filenames.Also when this happens the cursor is not in the textfield. This means that whenever you copy-paste a file into the same directory you must then click into the cursor field which is quite annoying.So to summarize: please suggest the original filename instead of 'Copy of filename' and put the cursor in the textfield.It's a minor thing but something that happens quite a lot. From a UI perspective it's good to make these small annoyances go away :-)Thanks a lot!GJ
455427,12/17/2014 0:57,jarthana,[test] Make compiler test run with APT enabled See bug 436486 for context. At times having APT enabled affects the compiler behavior as seen in the given bug.This bug is to investigate the options to run the compiler tests with APT enabled possibly with dummy annotations processors.
455882,12/21/2014 3:07,pisv,[jdt] AIOOB in JavaElementDelta.addAffectedChild The following error was reported via the automated error reporting: code: 10001 plugin: org.eclipse.jdt.ui_3.10.100.v20141208-1433 message: Internal Error fingerprint: 64e6d81a exception class: java.lang.reflect.InvocationTargetException exception message: - number of children: 0 java.lang.reflect.InvocationTargetException: null at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:420) at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2137) at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2133) at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:191) at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:151) at org.eclipse.jdt.ui.refactoring.RenameSupport.perform(RenameSupport.java:198) at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameLinkedMode.doRename(RenameLinkedMode.java:362) at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameLinkedMode$EditorSynchronizer.left(RenameLinkedMode.java:119) at org.eclipse.jface.text.link.LinkedModeModel.exit(LinkedModeModel.java:341) at org.eclipse.jface.text.link.LinkedModeUI$4.run(LinkedModeUI.java:1193) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3983) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:648) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:592) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-2) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:483) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1465)caused by: java.lang.ArrayIndexOutOfBoundsException: 4 at org.eclipse.jdt.internal.core.JavaElementDelta.addAffectedChild(JavaElementDelta.java:147) at org.eclipse.jdt.internal.core.JavaElementDelta.addAffectedChild(JavaElementDelta.java:180) at org.eclipse.jdt.internal.core.JavaElementDelta.addAffectedChild(JavaElementDelta.java:180) at org.eclipse.jdt.internal.core.JavaElementDelta.addAffectedChild(JavaElementDelta.java:180) at org.eclipse.jdt.internal.core.JavaElementDelta.insertDeltaTree(JavaElementDelta.java:519) at org.eclipse.jdt.internal.core.DeltaProcessor.mergeDeltas(DeltaProcessor.java:1656) at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1462) at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:770) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313) at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5409) at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106) at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:119) General Information: reported-by: Marcel Bruch anonymous-id: f8087d7b-9d38-4c73-aeb1-6991603c2a84 eclipse-build-id: 4.5.0.I20141210-2000 eclipse-product: org.eclipse.epp.package.committers.product operating system: MacOSX 10.10.1 (x86_64) - cocoa jre-version: 1.8.0_20-b26The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.databinding.observable_1.4.1.v20140910-2107 2. org.eclipse.core.databinding_1.4.100.v20141002-1314 3. org.eclipse.core.resources_3.9.100.v20141128-1217 4. org.eclipse.core.runtime_3.10.0.v20140724-1132 5. org.eclipse.e4.ui.workbench_1.3.0.v20141126-1637 6. org.eclipse.e4.ui.workbench.swt_0.12.100.v20141126-1500 7. org.eclipse.equinox.app_1.3.200.v20130910-1609 8. org.eclipse.equinox.launcher_1.3.0.v20140415-2008 9. org.eclipse.jdt.core_3.11.0.v20141209-1931 10. org.eclipse.jdt_3.11.0.v20141210-2000 11. org.eclipse.jdt.ui_3.10.100.v20141208-1433 12. org.eclipse.jface_3.11.0.v20141118-1320 13. org.eclipse.jface.text_3.10.0.v20141027-1716 14. org.eclipse.swt_3.104.0.v20141210-0658 15. org.eclipse.ui_3.107.0.v20141112-1026 16. org.eclipse.ui.ide.application_1.0.600.v20141107-1428 17. org.eclipse.ui.ide_3.10.100.v20141126-1713Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality. Please visit http://goo.gl/MWFSff for further details. Thank you for your assistance.Your friendly error-reports-inbox.
455986,12/22/2014 13:38,Olivier_Thomann,"ASTParser ignores call to super() in K_STATEMENTS mode Run this code snippet:ASTParser parser = ASTParser.newParser(AST.JLS8);parser.setKind(ASTParser.K_STATEMENTS);parser.setSource(""super();"".toCharArray());ASTNode astNode = parser.createAST(null);The resulting astNode is a Block without any statements but it should contain a SuperConstructorInvocation.I've looked into ASTParser code and around line 1350 it seems that constructorDeclaration is converted using only its statements field but constructorCall field should be used as well."
456481,1/1/2015 9:40,sasikanth.bharadwaj,"[1.8] VerifyError on constructor reference inside lambda This example from http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8044737 //--- public class Test { interface Constructor { MyTest execute(); } class MyTest { MyTest() { System.out.println(""Constructor executed""); } } public Constructor getConstructor() { return getConstructor(() -> { return MyTest::new; }); } public static void main(String argv[]) { Test t = new Test(); MyTest mytest = t.getConstructor().execute(); } Constructor getConstructor(Wrapper arg) { return arg.unwrap(); } interface Wrapper { Constructor unwrap(); }}//---compiles fine using ecj head but at runtime the program throws:Exception in thread ""main"" java.lang.VerifyError: Bad local variable typeException Details: Location: Test.lambda$0()LTest$Constructor; @0: aload_0 Reason: Type top (current frame locals[0]) is not assignable to reference type Current Frame: bci: @0 flags: { } locals: { } stack: { } Bytecode: 0x0000000: 2aba 0026 0000 b0 at java.lang.Class.getDeclaredMethods0(Native Method) at java.lang.Class.privateGetDeclaredMethods(Class.java:2693) at java.lang.Class.privateGetMethodRecursive(Class.java:3040) at java.lang.Class.getMethod0(Class.java:3010) at java.lang.Class.getMethod(Class.java:1776) at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544) at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)The compiled method lambda$0 looks like this: private static Test$Constructor lambda$0(); flags: ACC_PRIVATE ACC_STATIC ACC_SYNTHETIC Code: stack=1 locals=1 args_size=0 0: aload_0 1: invokedynamic #38 0 // InvokeDynamic #1:execute:(LTest;)LTest$Constructor; 6: areturn LineNumberTable: line 12: 0aload_0 in a static argumentless methods doesn't look right ..."
456861,1/7/2015 3:26,sasikanth.bharadwaj,"[recovery] NPE in RecoveryScanner since Mars M4 I get a NullPointerException during compilation of a class that has a syntax error. This happens since Mars M4 previous milestone releases were fine.Here is a code snippet that reproducibly triggers the error public class Test {		public void foo() {		String s1 = """";		s1.;	} }Subsequently the error log is spammed with the same error when hovering over the highlighted syntax error.This also breaks a lot of our tests in our build. One example of a test class with failures is at http://git.eclipse.org/c/recommenders/org.eclipse.recommenders.git/tree/tests/org.eclipse.recommenders.completion.rcp.tests/src/org/eclipse/recommenders/completion/rcp/it/RecommendersCompletionContextTest.xtendStacktrace for the error:java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.parser.RecoveryScanner.insertTokenAhead(RecoveryScanner.java:100)	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeLocalVariableDeclarationStatement(Parser.java:4868)	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:6589)	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11111)	at org.eclipse.jdt.internal.compiler.parser.Parser.parseStatements(Parser.java:11716)	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisitMethod(Parser.java:12015)	at org.eclipse.jdt.internal.compiler.parser.Parser$1MethodVisitor.endVisit(Parser.java:12001)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:358)	at org.eclipse.jdt.internal.compiler.parser.Parser.recoverStatements(Parser.java:12109)	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11174)	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:11460)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.parseStatements(MethodDeclaration.java:192)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.parseMethods(TypeDeclaration.java:873)	at org.eclipse.jdt.internal.compiler.parser.Parser.getMethodBodies(Parser.java:10149)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1159)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1183)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:809)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:119)	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:221)	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getCompletionProposals(ProblemHover.java:199)	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.deferredCreateContent(AbstractAnnotationHover.java:285)	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setInput(AbstractAnnotationHover.java:186)	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1181)	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)	at org.eclipse.jface.text.AbstractHoverInformationControlManager.presentInformation(AbstractHoverInformationControlManager.java:902)	at org.eclipse.jface.text.TextViewerHoverManager.doPresentInformation(TextViewerHoverManager.java:243)	at org.eclipse.jface.text.TextViewerHoverManager$5.run(TextViewerHoverManager.java:233)	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136)	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3983)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:648)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:592)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)	at org.eclipse.equinox.launcher.Main.main(Main.java:1438)"
456960,1/7/2015 14:18,Olivier_Thomann,"Broken classfile generated for incorrect annotation usage - case 2 This is another variant of bug 434556. Testcode:===import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Bar(String)public class Code2 { }@Retention(RetentionPolicy.RUNTIME)@interface Bar {	Class<?>[] value();}===If the annotation is correctly specified as '@Bar(String.class)' then the generated classfile is valid. If just @Bar(String) is used we get an error as expected but the generated class file has an invalid attribute for the annotation. Javap cannot understand it so just prints the bytes: RuntimeVisibleAnnotations: length = 0xA 00 01 00 16 00 01 00 17 00 00 00 01 = there is one annotation00 16 = the nameindex for the annotation is 0x16: 'LBar;'00 01 = the annotation has one name value pair00 17 = the name of the name value pair is at index 0x17: 'value'00 00 = ????? it should be one byte for the type of the annotation value and then a pair for the annotation value index.This appears to be due to the handling in ClassFile.generateAnnotation() as with that other bug. That fix only got applied to the case of an annotation with multiple values this time we have an annotation with only one value which is treated differently (as a SingleMemberAnnotation rather than a NormalAnnotation). Similar logic to what was used in the NormalAnnotation case under that bug fix needs applying here. We should be not including the invalid member value. From a cursory look it *might* be slightly different here as the 'if (this.contentsOffset == memberValuePairOffset)' may be triggering."
456986,1/7/2015 17:48,het,"Bogus error when annotation processor generates annotation types. I have attached a small project that shows the bug. In order to see for yourself please import the project into a workspace right click on ""processor.jardesc"" and select ""Create JAR"" then do ""Project > Clean..."".You should see the error:Description	Resource	Path	Location	TypeGeneratedAnno cannot be resolved to a type	Foo.java	/brokenanno/src/a	line 7	Java ProblemThe bug occurs when an annotation processor generates annotation types. In the example project the processor is generating a file that looks like:public class A { public @interface Anno {}}(notice how the declared @Anno annotation is a nested type Eclipse works correctly if @Anno is the top-level type in the generated class)Then when a (non-generated) source file uses the @Anno annotation Eclipse reports an error:import A.Anno; // <-- NO ERROR on the importpublic class B { public void foo(@Anno int x) { // <-- ERROR on the use of @Anno here }}The error marker will go away if a trivial whitespace change is made to the file and it is saved."
457051,1/8/2015 11:41,eclipse,"comment is discarded when reducing imports to an on-demand import With on-demand threshold set to 2 uncommenting the Formatter line and auto-completing it (to java.util.Formatter) causes the comment to be discarded:	package pack1;		import java.util.Queue;		/* floating comment */		import java.util.concurrent.BlockingQueue;		public class C {		Queue<?> q;		BlockingQueue<?> bq;		// Formatter f;	}I expect ""/* floating comment */"" to be preserved between java.util.* and java.util.concurrent.BlockingQueue.I observe that the comment is removed entirely."
457089,1/8/2015 17:27,eclipse,"imports are improperly reordered in the presence of a floating comment With configured import order [""java"" ""javax""] running Organize Imports on the following compilation unit moves the javax.sql.DataSource import above the java.util.List import. (Running Organize Imports a subsequent time moves DataSource back to its correct position below List.)I expect Organize Imports to leave these import declarations in their existing (already sorted) order.	package pack1;		import java.io.Serializable;		/* floating comment */		import java.util.List;		import javax.sql.DataSource;		public class C {		Serializable s;		List<?> l;		DataSource ds;	}"
457100,1/9/2015 1:14,mateusz.matela,[formatter] Failures with the patch of new formatter design See bug 303519 comment 110Failures and errors found in some unit test cases - Run a) RunDOMTests - ASTRewritingStatementsTests.testBug413592 8 NPE errors pointing to one single error - few formatter failures) and b) RunFormatterRegressionTests (tests 447 and 451)Additional tests /failure found while testing will be added in this bug rather than the parent bug to avoid clutter
457143,1/9/2015 9:03,sarika.sinha,Installed JREs preference page keeps asking to Apply Created attachment 249820EE description fileI20150106-0800- Preferences > Installed JREs > Add... > Execution Environment Description- select the attached .ee file Finish- switch to JUnit page=> dialog asks about applying changes (good)- click Apply- go back to Installed JREs and then switch to JUnit again=> dialog asks again to Apply (not good). Same if you close/reopen the preferences dialog and then switch away from the Installed JREs page.
457426,1/14/2015 4:38,Olivier_Thomann,"VerifyError on massive declared variables in method Created attachment 249924reproducer java filepublic final class Issue { public void show() { String s1 = """"; String s2 = """"; String s3 = """"; String s4 = """"; String s5 = """"; String s6 = """"; String s7 = """"; String s8 = """"; String s9 = """"; String s10 = """"; String s11 = """"; String s12 = """"; String s13 = """"; String s14 = """"; String s15 = """"; String s16 = """"; String s17 = """"; String s18 = """"; String s19 = """"; String s20 = """"; String s21 = """"; String s22 = """"; String s23 = """"; String s24 = """"; String s25 = """"; String s26 = """"; String s27 = """"; String s28 = """"; String s29 = """"; String s30 = """"; String s31 = """"; String s32 = """"; String s33 = """"; String s34 = """"; String s35 = """"; String s36 = """"; String s37 = """"; String s38 = """"; String s39 = """"; String s40 = """"; String s41 = """"; String s42 = """"; String s43 = """"; String s44 = """"; String s45 = """"; String s46 = """"; String s47 = """"; String s48 = """"; String s49 = """"; String s50 = """"; String s51 = """"; String s52 = """"; String s53 = """"; String s54 = """"; String s55 = """"; String s56 = """"; String s57 = """"; String s58 = """"; String s59 = """"; String s60 = """"; String s61 = """"; String s62 = """"; String s63 = """"; String s64 = """"; String s65 = """"; String s66 = """"; String s67 = """"; String s68 = """"; String s69 = """"; String s70 = """"; String s71 = """"; String s72 = """"; String s73 = """"; String s74 = """"; String s75 = """"; String s76 = """"; String s77 = """"; String s78 = """"; String s79 = """"; String s80 = """"; String s81 = """"; String s82 = """"; String s83 = """"; String s84 = """"; String s85 = """"; String s86 = """"; String s87 = """"; String s88 = """"; String s89 = """"; String s90 = """"; String s91 = """"; String s92 = """"; String s93 = """"; String s94 = """"; String s95 = """"; String s96 = """"; String s97 = """"; String s98 = """"; String s99 = """"; String s100 = """"; String s101 = """"; String s102 = """"; String s103 = """"; String s104 = """"; String s105 = """"; String s106 = """"; String s107 = """"; String s108 = """"; String s109 = """"; String s110 = """"; String s111 = """"; String s112 = """"; String s113 = """"; String s114 = """"; String s115 = """"; String s116 = """"; String s117 = """"; String s118 = """"; String s119 = """"; String s120 = """"; String s121 = """"; String s122 = """"; String s123 = """"; String s124 = """"; String s125 = """"; String s126 = """"; String s127 = """"; String s128 = """"; String s129 = """"; String s130 = """"; String s131 = """"; String s132 = """"; String s133 = """"; String s134 = """"; String s135 = """"; String s136 = """"; String s137 = """"; String s138 = """"; String s139 = """"; String s140 = """"; String s141 = """"; String s142 = """"; String s143 = """"; String s144 = """"; String s145 = """"; String s146 = """"; String s147 = """"; String s148 = """"; String s149 = """"; String s150 = """"; String s151 = """"; String s152 = """"; String s153 = """"; String s154 = """"; String s155 = """"; String s156 = """"; String s157 = """"; String s158 = """"; String s159 = """"; String s160 = """"; String s161 = """"; String s162 = """"; String s163 = """"; String s164 = """"; String s165 = """"; String s166 = """"; String s167 = """"; String s168 = """"; String s169 = """"; String s170 = """"; String s171 = """"; String s172 = """"; String s173 = """"; String s174 = """"; String s175 = """"; String s176 = """"; String s177 = """"; String s178 = """"; String s179 = """"; String s180 = """"; String s181 = """"; String s182 = """"; String s183 = """"; String s184 = """"; String s185 = """"; String s186 = """"; String s187 = """"; String s188 = """"; String s189 = """"; String s190 = """"; String s191 = """"; String s192 = """"; String s193 = """"; String s194 = """"; String s195 = """"; String s196 = """"; String s197 = """"; String s198 = """"; String s199 = """"; String s200 = """"; String s201 = """"; String s202 = """"; String s203 = """"; String s204 = """"; String s205 = """"; String s206 = """"; String s207 = """"; String s208 = """"; String s209 = """"; String s210 = """"; String s211 = """"; String s212 = """"; String s213 = """"; String s214 = """"; String s215 = """"; String s216 = """"; String s217 = """"; String s218 = """"; String s219 = """"; String s220 = """"; String s221 = """"; String s222 = """"; String s223 = """"; String s224 = """"; String s225 = """"; String s226 = """"; String s227 = """"; String s228 = """"; String s229 = """"; String s230 = """"; String s231 = """"; String s232 = """"; String s233 = """"; String s234 = """"; String s235 = """"; String s236 = """"; String s237 = """"; String s238 = """"; String s239 = """"; String s240 = """"; String s241 = """"; String s242 = """"; String s243 = """"; String s244 = """"; String s245 = """"; String s246 = """"; String s247 = """"; String s248 = """"; String s249 = """"; String s250 = """"; String s251 = """"; String s252 = """"; int size1 = 1; int size2 = 2; int size3 = 3; int[][][] intArray = new int[size1][size2][size3]; for (int i = 0; i < size1; i++) { for (int j = 0; j < size2; j++) { boolean on = false; for (int k = 0; k < size3; k++) { intArray[i][j][k] = on ? 0 : 1; } } } } public static void main(String[] args) { new Issue().show(); }}When build and run the Issue.java in Eclipse 4.4.1 and Oracle JDK 8 java.lang.VerifyError is reported:Exception in thread ""main"" java.lang.VerifyError: Inconsistent stackmap frames at branch target 1086Exception Details: Location: Issue.show()V @1086: iconst_1 Reason: Type '[I' (current frame stack[0]) is not assignable to '[[[[I' (stack map stack[0])......... It seems this issue is related to the number of the declared variables in the method if remove some declared variables the Issue.java can be run successfully without error."
457515,1/14/2015 23:40,register.eclipse,"eclipse JUnit runner hangs when @Parameters name attribute contains a newline Problem can be reproduced using a simplified ""stringified"" version of the example in the junit docs: https://github.com/junit-team/junit/wiki/Parameterized-testsAttached screenshot shows what the hang screen looks like. No errors in the error log. Test works fine on the command line.```@RunWith(Parameterized.class)public class BugDemoTest {	@Parameters(name = ""{index}: fib({0})={1}"")	public static Iterable<Object[]> data() {		return Arrays.asList(new Object[][] { { ""0"" ""0"" } { ""1"" ""1"" }				{ ""2"" ""1"" } { ""3"" ""2"" } { ""4"" ""3"" } { ""5"" ""5\n"" } // any newline in any one of these will cause the debugger to hang indefinitely				{ ""6"" ""8"" } });	}	private String input;	private String expected;	public BugDemoTest(String input String expected) {		this.input = input;		this.expected = expected;	}	@Test	public void test() {		assertEquals(expected new BugDemo().compute());	}}```"
457523,1/15/2015 3:22,noopur_gupta,[hovering] Javadoc following @link to a constant does not show its value Consider the following example:/** * {@link #MSA_CONSTANT} */public interface IMsaTest { int MSA_CONSTANT = 42;}If I hover on IMsaTest to get its Javadoc and click on the link i won't see the constant value. If I do the same in the Javadoc view it works as expected.The same behaviour can be found for Javadoc on Methods.
457538,1/15/2015 4:42,daniel_megert,Enable Label Decoration: Java Type Decorator by default Enabling the java type decorator by default would be very useful.
457547,1/15/2015 5:15,noopur_gupta,"[quick assist] extract number with quick assist doesn't replace all the occurrences When I use quick fix both in a magic number or in a string the following options appear in the popup: Extract to local variable (replace all ocurrences) Extract to local variable Extract to local constantWhen a string is being selected both the first and the third option replace all the ocurrences of the string.But when a number is being selected it only replaces the selected occurrence selecting any of those options.I found a workaround: using the shortcut Ctrl+T A then checking ""replace all the occurrences"".RegardsJorge"
457871,1/19/2015 13:53,manpalat,"[Performance] Java compiler CPU time regression compared to 4.2.2 Our product which is starting to consume Eclipse 4.4.1 is noticing a performance degradation with the Java compiler of 37% (measured over 5 runs) as compared to our previous product version which consumes Eclipse 4.2.2.For example using a sample Java project we are seeing the following times:Java Builder (Browser Client)	Eclipse 4.4.1: 6818ms	Eclipse 4.2.2: 4966ms	Difference: -1852ms (-37.00%)Machine specs:OS: Windows 7 Professional - 64 bit OSCPU: Intel i7-2600 CPU @ 3.40GHz (8 cores)Memory: 8GBJRE:java full version JRE 1.7.0 IBM Windows AMD 64 build pwa6470sr8ifix-20141106_01(SR8+IV66375)VM args: -Xms100m -Xmx1024m -Xmnx64m -Xgcpolicy:gencon"
457926,1/20/2015 7:17,markus.kell.r,[JUnit] Update to JUnit 4.12 Junit 4.12 was released it would be good to update the version of junit in jdt to the latest version.Upstream's release notes:https://github.com/junit-team/junit/blob/master/doc/ReleaseNotes4.12.md
458208,1/23/2015 0:19,mateusz.matela,[formatter] Follow-up bug for comments Follow up bug for bug 303519 comment 122 attachment 250097Ref https://bugs.eclipse.org/bugs/attachment.cgi?id=250097
458332,1/24/2015 8:25,sasikanth.bharadwaj,"[1.8][compiler] only 409 method references/lambda expressions per class possible Created attachment 250202Failing snippet.It seems the compilation of method references has a limit if used as in the given testcase. The snippet works if there are only 200 Test::main method references each. With 250 as in the snippet running the compiled class fails with:Exception in thread ""main"" java.lang.NoSuchMethodError: Test$Data.access$0()[LTest$MethodRef;	at Test.main(Test.java:8)Expected output (javac works): 250This is a blocking bug for me because for my automatic Java code generation this initialization layout is the only one that works around various Java javac compiler and ecj compiler limitations. At least I thought so.This bug would probably be fixed by fixinghttps://bugs.eclipse.org/bugs/show_bug.cgi?id=430157But the same might happen with lambda expressions again."
458563,1/27/2015 12:53,sasikanth.bharadwaj,"invalid ambiguous method error on Java 8 that isn't seen on Java 7 (or with javac) I paste this into a source file X.java in eclipse:===interface IStoredNode<T> extends INodeHandle<DocumentImpl> NodeHandle { }interface NodeHandle extends INodeHandle<DocumentImpl> { }class DocumentImpl implements INodeHandle<DocumentImpl> {	public Object getNodeId() {return null;}}interface INodeHandle<D> { public Object getNodeId();}	 public class X {	public void foo(IStoredNode bar) {		bar.getNodeId();	}	}===It builds with compliance 1.7 fails with compliance 1.8 (on the call getNodeId I get ""The method getNodeId() is ambiguous for the type IStoredNode""). It compiles fine with javac with -source 1.8."
458614,1/28/2015 4:04,manpalat,"[1.8][search] Constructor reference not found in search package p1;import java.util.function.Function;@SuppressWarnings(""unused"")public class CL<T> {	private void newMeth() {		Function<Integer int[]> a1 = int[]::new;	}}----------------------------------------------In the Java Search tab of Search dialog set:Search string: *Search For: MethodLimit To: Match locations > '::' method referencesScope: Workspaceand click ""Search"" with the above file in workspace.The result shows the constructor reference.Now comment the annotation line ""@SuppressWarnings(""unused"")"" and save.Search again with the same settings as above.The result does not contain the constructor reference.Also change the search string to: *new and search with or without the annotation. The result does not contain the constructor reference."
458763,1/29/2015 12:37,noopur_gupta,"[typing] Method declared inside an enum declaration is not indented It seems that declarations of methods inside an enum declaration should be indented as they are inside regular classes. In this example the method ""opposite()"" is indented here in my bug report but it is not indented in my actual code window in the Eclipse editor (and the very last line is not outdented below though it should be): public enum Direction {NORTH SOUTH EAST WEST; // note semicolon here	public Direction opposite() { // method to return the opposite compass direction		switch (this) {		case NORTH:			return SOUTH;		case SOUTH:			return NORTH;		case EAST:			return WEST;		case WEST:			return EAST;		default: return null;		} // switch	} // opposite()	} // enum Direction-- Configuration Details --Product: Eclipse 4.4.1.20150109-0740 (org.eclipse.epp.package.java.product)Installed Features: org.eclipse.platform 4.4.0.v20140925-0400"
458795,1/30/2015 4:02,jarthana,"Hexadecimal floating-point literals without digits like 0XP00 should not be accepted as valid literals The JDT lexer allows hexadecimal floating-point literals without digits. For example 0XP00 is accepted as a valid literal by Eclipse. Javac correctly reports an error for this literal:tests/lex/num_10f/Test.java:2: error: hexadecimal numbers must contain at least one hexadecimal digit double _ = 0XP00;The JDT should give a similar error. For other malformed literals such as 0X0P (missing exponent) JDT gives the error message ""Invalid float literal number""."
458865,1/30/2015 21:20,daniel_megert,"many epl-v10.html files in Git repo are ""old style"" MS Word documents and are not needed +++ This bug was initially created as a clone of Bug #407585 +++Two features in JDT have obsolete ""legal files"" in them. org.eclipse.jdt-feature in eclipse.jdt repoepl-v10.htmlnotice.htmlAppears this ""jdt.jeview.feature"" is a ""nested"" feature? And it appears it is no longer used? (or at least not actively). If so I'd recommend just removing it from ""master"" (in addition to deleting those to obsolete files. org.eclipse.jdt.jeview.feature in jdt.ui repoepl-v10.htmllicense.html"
459092,2/4/2015 0:48,jarthana,Intermittent failures in CopyMoveElementsTests Failed in the latest I build:http://download.eclipse.org/eclipse/downloads/drops4/S-4.5M5a-201502031300/testresults/html/org.eclipse.jdt.core.tests.model_win32.win32.x86_7.0.htmljunit.framework.AssertionFailedError: Destination container not changedat org.eclipse.jdt.core.tests.model.CopyMoveTests.copyPositive(CopyMoveTests.java:110)at org.eclipse.jdt.core.tests.model.CopyMoveElementsTests.testCopyInitializerWithPositioningInDifferentProject(CopyMoveElementsTests.java:877)at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:104)at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:88)at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$1.protect(SuiteOfTestCases.java:76)at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:85)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310)at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36)at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32)at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)at org.eclipse.equinox.launcher.Main.run(Main.java:1465)at org.eclipse.equinox.launcher.Main.main(Main.java:1438)at org.eclipse.core.launcher.Main.main(Main.java:34)And test in local environment run alright.
459189,2/5/2015 1:44,manpalat,"[1.8][content assist] keyword return not proposed inside lambda for code completion interface I <TR> {	R apply(T t);}public class X {		Integer bar(Integer x) { return null;}		Integer foo(){						I <Integer X> i2 = (x) -> {ret /* type ctrl-space after ret */};		return 0;	}}"
459305,2/6/2015 7:28,jarthana,[1.8][compiler] wrong local variable redeclaration error The code below should compile fine but gives the error:Lambda expression's parameter arg1 cannot redeclare another local variable defined in an enclosing scope.import java.io.Serializable;import java.util.function.BiConsumer;import java.util.function.Consumer;public class Snippet{ public static void main(String[] args) { foo(arg1 -> bar(Snippet::baz)); } private static <A1> void foo(Consumer<A1> c) { } private static void baz(String s1 String s2) { } private static void bar(VoidMethodRef2<String String> mr2) { } private static interface VoidMethodRef2<A1 A2> extends BiConsumer<A1 A2> Serializable { }}
459320,2/6/2015 9:40,markus.kell.r,[ImportRewrite] adds import for declared package when pasting to CU outside of classpath Created attachment 250583Fix in old ImportRewriteAnalyzerFollow-up to bug 454914 comment 3.ImportRewrite adds an unused import for the declared package when pasting into a compilation unit that is outside of the project's classpath.Steps:- check out SWT from Git and set the project up for your platform (copy .classpath file)- open MenuItem#setToolTipText(String) from the classpath- copy doc line to clipboard: * {@link Shell#setMenuBar(Menu) shell menubar} on Windows Mac and Ubuntu Unity desktop.- Open Resource... open a MenuItem.java that is not on classpath- set caret to first line of class Javadoc- Paste=> bad import added:import org.eclipse.swt.widgets.*;The attached fix is for the old ImportRewriteAnalyzer (before bug 430303). I still had this in my workspace and need to save it somewhere. Didn't release since it would conflict with bug 430303 and I guess it's better to get that one done first.
459323,2/6/2015 10:26,daniel_megert,"Remove org.eclipse.jdt.ui.examples.projects from Maven build Patch contains some improvements for o.e.jdt.ui.examples.projects: * Set ""strictly compatible JRE"" pref to warning (so it works out of the box for everyone) * Bump BREE to 1.5 (this is highest BREE used by any eclipse.jdt.ui bundle) * Drop useless non-javadoc comments * Avoid use of nested jar (prevents workspace ""dirt"" at build time)"
459344,2/6/2015 13:17,manpalat,"CompilationUnit#findDeclaringNode(..) finds ExpressionMethodReference instead of MethodDeclaration masterCompilationUnit#findDeclaringNode(..) finds ExpressionMethodReference instead of MethodDeclarationSnippet:public class E1 { void foo(Object arg) { IntSupplier s1 = arg::hashCode; }}In the ASTView show the ExpressionMethodReference for arg::hashCode. Double-clicking its child node ""> method binding: Object.hashCode()"" calls findDeclaringNode(..) and that API wrongly returns the enclosing ExpressionMethodReference which consequently gets selected.findDeclaringNode(..) should return null in this case since Object#hashCode() is not declared in the given AST."
459415,2/9/2015 4:43,jarthana,[1.9] Support modular run time images in JDT The JEP 220 of the project jigsaw defines the new module run-time images. This needs to be supported in JDT.At the moment this is the list (not complete by any means) of things that need to evolve:1. First and foremost loading classes from a JDK9. JDT should be able to read classes from the new jrt format. We need to come up with a strategy for this - whether to use the provided jrt-fs that will be bundled with the JDK9 (even when eclipse itself runs on <= JRE 8) or something else (home-grown?). Without this it's impossible to use JDK9 in project build path.2. JREContainer should evolve to support the new VM installs. Some of the changes known at this point are removal of /ext and /endorsed. Instead the new module system will be used for extensions.3. Removal of certain JAR files: rt.jar and tools.jar have been removed. If we are hard-coding dependency anywhere that should be addressed.
459601,2/10/2015 14:46,het,"[clean up] Use CompilationParticipant.buildFinished() in AptCompilationParticipant AptCompilationParticipant registers a ResourceChangeListener with this comment:		// Bug 180107: there is no CompilationParticipant.buildComplete() method		// so we have to use a resource change listener instead.		IResourceChangeListener listener = new IResourceChangeListener() {			public void resourceChanged(IResourceChangeEvent event) {				buildComplete();			}		};I think at the time this code was written there was no CompilationParticipant.buildFinished() so this workaround was necessary. Now we can use CompilationParticipant.buildFinished()"
459739,2/12/2015 3:30,manpalat,"[test][compiler]NullTypeAnnotationTest.testDefault06() failed buildId: N20150211-2000platform: linuxurl: https://hudson.eclipse.org/hudson/job/ep45N-unit-lin64/201/stacktrace: junit.framework.ComparisonFailure: Invalid problem log .----------- Expected ----------------------\n1. ERROR in X.java (at line 7)\n	return null; // ERR\n	 ^^^^\nNull type mismatch: required '@NonNull T' but the provided value is null\n----------\n2. ERROR in X.java (at line 11)\n	@NonNull Number nnn = inum.process(null); // ERR on argument\n	 ^^^^\nNull type mismatch: required '@NonNull Number' but the provided value is null\n----------\n------------ but was ----------------------\n1. ERROR in X.java (at line 7)\n	return null; // ERR\n	 ^^^^\nNull type mismatch: required '@NonNull T' but the provided value is null\n----------\n2. ERROR in X.java (at line 10)\n	void test(Inner<Number> inum) {\n	 ^^^^^^\nNull constraint mismatch: The type 'Number' is not a valid substitute for the type parameter '@NonNull T'\n----------\n3. ERROR in X.java (at line 11)\n	@NonNull Number nnn = inum.process(null); // ERR on argument\n	 ^^^^\nNull type mismatch: required '@NonNull Number' but the provided value is null\n----------\n--------- Difference is ---------- expected:<...in X.java (at line 1[]1)\n	@NonNull Numbe...> but was:<...in X.java (at line 1[0)\n	void test(Inner<Number> inum) {\n	 ^^^^^^\nNull constraint mismatch: The type 'Number' is not a valid substitute for the type parameter '@NonNull T'\n----------\n3. ERROR in X.java (at line 1]1)\n	@NonNull Numbe...>	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:259)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:235)	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.checkCompilerLog(AbstractRegressionTest.java:946)	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2499)	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2297)	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runNegativeTest(AbstractRegressionTest.java:2881)	at org.eclipse.jdt.core.tests.compiler.regression.AbstractNullAnnotationTest.runNegativeTestWithLibs(AbstractNullAnnotationTest.java:130)	at org.eclipse.jdt.core.tests.compiler.regression.AbstractNullAnnotationTest.runNegativeTestWithLibs(AbstractNullAnnotationTest.java:140)	at org.eclipse.jdt.core.tests.compiler.regression.NullTypeAnnotationTest.testDefault06(NullTypeAnnotationTest.java:4839)	at org.eclipse.jdt.core.tests.util.CompilerTestSetup.run(CompilerTestSetup.java:56)	at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657)	at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310)	at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36)	at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32)	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)	at org.eclipse.equinox.launcher.Main.main(Main.java:1438)	at org.eclipse.core.launcher.Main.main(Main.java:34)"
460008,2/16/2015 6:58,markus.kell.r,"[formatter] Inserts wrong line breaks on ASTRewrite (Extract Constant Extract Local Variable) Created attachment 250823FormatterTest projectWith the formatter settings in the attached project apply Extract Constant or Extract Local Variable to the integer literals '1' here:public class MyTest {	int i= 1;		{		if (hashCode() == 1) {					}	}}Result has too many line breaks:public class MyTest {	private static final int _1= 1;	int i= _1;		{		int j= 1;		if (hashCode() == j) {					}	}}"
460085,2/17/2015 5:23,manpalat,"org.eclipse.jdt.internal.compiler.tool.EclipseFileManager.getDefaultBootclasspath() doesn't work on Mac with a new JDK Hey guysDetecting the lib folders on a Mac with a newer (Post 1.6) JDK doesn't seem to work well.EclipseFileManager.getDefaultBootclasspath has the following code:if (System.getProperty(""os.name"").startsWith(""Mac"")) {	directoriesToCheck = new File[] { new File(javaHomeFile ""../Classes"")};} else {	directoriesToCheck = new File[] { new File(javaHomeFile ""lib"")};}If I recall correctly there was a '../Classes' back in the day (I have no computer with the old Apple Java 1.6) but now I have just a lib folder.I think this whole construction only applies to Java 1.6 on a Mac"
460186,2/18/2015 0:54,sasikanth.bharadwaj,"IAE in ASTNode.setSourceRange with broken code case 2 Extracted from bug 443232 comment 6 the following code throws IllegalArgumentExceptionpublic class NPE {	void foo(String[] args) throws Exception {		if (args == null) error(); 		error();[]	}		void error() throws Exception {		throw new Exception();	}}------------------------------------------------------The exception here is:java.lang.IllegalArgumentException	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)	at org.eclipse.jdt.core.dom.ASTConverter.setTypeAnnotationsAndSourceRangeOnArray(ASTConverter.java:3420)	at org.eclipse.jdt.core.dom.ASTConverter.convertToArray(ASTConverter.java:3166)	at org.eclipse.jdt.core.dom.ASTConverter.convertType(ASTConverter.java:3628)	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:3439)	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:458)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:633)	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2958)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:292)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1210)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:810)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)..."
460234,2/18/2015 7:48,daniel_megert,Properties dialog opened via Package Explorer is missing project name in it's title Created attachment 250911Picture of Properties dialog with missing project nameSteps to reproduce:1. Create some project2. Open Package Explorer3. Open Properties for project created in step1FAIL: Properties dialog is missing project name in its title. See attached screenshot.
460350,2/19/2015 10:37,markus.kell.r,"[1.4] Javadoc compiler wrongly reports reference to parameterized method in 1.4 project In bug 442021 org.eclipse.equinox.common moved to 1.6 and the IAdaptable method got changed to:	public <T> T getAdapter(Class<T> adapter);Now org.eclipse.compare which is still at 1.4 has 5 Javadoc compile errors for references like this:	 * @see IAdaptable#getAdapter(Class)Error: Javadoc: Invalid referenceThis is a bug in org.eclipse.jdt.internal.compiler.ast.Javadoc#resolveReference(..). I have a fix that I'll release shortly."
460359,2/19/2015 11:54,markus.kell.r,Fix compiler problems from generified IAdaptable#getAdapter(..) See bug 442021 comment 25.
460416,2/20/2015 4:21,sarika.sinha,Fix compiler problems from generified IAdaptable#getAdapter(..) See bug 442021 comment 25.
460422,2/20/2015 5:14,manpalat,"IllegalStateException: Bad AST node structure at ASTConverter - In Debug configurations enable Tracing for org.eclipse.jdt.core.- Check ""debug"" and ""debug/dom/ast"" on the right pane.- Click Apply and Debug.- Paste the code snippet from the error message below to Package explorer.- Edit the file. Following exception is logged in Error Log view:eclipse.buildId=4.5.0.N20150216-2000java.version=1.8.0java.vendor=Oracle CorporationBootLoader constants: OS=win32 ARCH=x86_64 WS=win32 NL=en_USFramework arguments: -product org.eclipse.sdk.ideCommand-line arguments: -product org.eclipse.sdk.ide -data C:\ProjectWork\Workspace6/../runtime-J8 -dev file:C:/ProjectWork/Workspace6/.metadata/.plugins/org.eclipse.pde.core/Runtime-J8/dev.properties -debug C:\ProjectWork\Workspace6\.metadata\.plugins\org.eclipse.pde.core\Runtime-J8/.options -os win32 -ws win32 -arch x86_64 -consoleLogorg.eclipse.jdt.coreErrorFri Feb 20 13:20:27 IST 2015Bad AST node structure:- parent [75 119] org.eclipse.jdt.core.dom.EnumConstantDeclaration arguments [109 120] org.eclipse.jdt.core.dom.ArrayCreation----------------------------------- SOURCE BEGIN -------------------------------------package p1;public enum TestEnum { FIRST_ENUM(""a"" null) FOURTH_ENUM(""b"" new X[] { });	private TestEnum(String s Object o) {	}}class X {	Runnable r= new R 	}----------------------------------- SOURCE END -------------------------------------java.lang.IllegalStateException: Bad AST node structure	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1419)	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:202)	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)"
460484,2/20/2015 16:54,eclipse,"ImportRewrite throws SIOOBE when trying to add import follow-up to bug 430303The slightly strange behavior that has been swept under the rug by modifying org.eclipse.jdt.core.tests.rewrite.describing.ImportRewriteTest#testAddImports1()left me a bit uneasy.On addImport when the existing imports were properly grouped but not properly sorted within an import group I would not have expected the group to be split into two.When I tried to reproduce the test case in master I found the following bug:- have a project with default Organize Imports preferences- create class p.A- create this CU:package pack1;import java.util.Set;import java.util.Vector;import java.util.Map;import pack.List;import pack.List2;public class C { java.net.Socket s; p.A a; com.sun.beans.TypeResolver t; Object[] coll = { Set.class Vector.class Map.class };}- select ""p.A"" in C.java and execute Source > Add Import- result:!ENTRY org.eclipse.jdt.ui 4 10001 2015-02-20 22:35:19.336!MESSAGE Internal Error!STACK 0java.lang.reflect.InvocationTargetException	at [..]Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: 1	at java.lang.String.charAt(String.java:646)	at org.eclipse.jdt.internal.core.dom.rewrite.imports.OrderPreservingImportAdder.countMatchingPrefixSegments(OrderPreservingImportAdder.java:62)	at org.eclipse.jdt.internal.core.dom.rewrite.imports.OrderPreservingImportAdder.shouldGroupWithSucceeding(OrderPreservingImportAdder.java:170)	at org.eclipse.jdt.internal.core.dom.rewrite.imports.OrderPreservingImportAdder.determineAdjacentNewImports(OrderPreservingImportAdder.java:142)	at org.eclipse.jdt.internal.core.dom.rewrite.imports.OrderPreservingImportAdder.addImports(OrderPreservingImportAdder.java:91)	at org.eclipse.jdt.internal.core.dom.rewrite.imports.ImportRewriteAnalyzer.computeImportOrder(ImportRewriteAnalyzer.java:588)	at org.eclipse.jdt.internal.core.dom.rewrite.imports.ImportRewriteAnalyzer.analyzeRewrite(ImportRewriteAnalyzer.java:540)	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.rewriteImports(ImportRewrite.java:1178)	at org.eclipse.jdt.internal.corext.codemanipulation.AddImportsOperation.run(AddImportsOperation.java:182)	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313)	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5409)	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106)	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:463)	... 45 moreRoot exception:java.lang.StringIndexOutOfBoundsException: String index out of range: 1	at java.lang.String.charAt(String.java:646)	at org.eclipse.jdt.internal.core.dom.rewrite.imports.OrderPreservingImportAdder.countMatchingPrefixSegments(OrderPreservingImportAdder.java:62)	at org.eclipse.jdt.internal.core.dom.rewrite.imports.OrderPreservingImportAdder.shouldGroupWithSucceeding(OrderPreservingImportAdder.java:170)	at org.eclipse.jdt.internal.core.dom.rewrite.imports.OrderPreservingImportAdder.determineAdjacentNewImports(OrderPreservingImportAdder.java:142)	at org.eclipse.jdt.internal.core.dom.rewrite.imports.OrderPreservingImportAdder.addImports(OrderPreservingImportAdder.java:91)	at org.eclipse.jdt.internal.core.dom.rewrite.imports.ImportRewriteAnalyzer.computeImportOrder(ImportRewriteAnalyzer.java:588)	at org.eclipse.jdt.internal.core.dom.rewrite.imports.ImportRewriteAnalyzer.analyzeRewrite(ImportRewriteAnalyzer.java:540)	at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.rewriteImports(ImportRewrite.java:1178)	at org.eclipse.jdt.internal.corext.codemanipulation.AddImportsOperation.run(AddImportsOperation.java:182)	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313)	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5409)	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106)	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:463)	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:371)	at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2138)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2134)	at org.eclipse.ui.internal.progress.ProgressManager$RunnableWithStatus.run(ProgressManager.java:1394)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ui.internal.progress.ProgressManager$5.run(ProgressManager.java:1228)	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:187)	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:145)	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4753)	at org.eclipse.ui.internal.progress.ProgressManager.runInUI(ProgressManager.java:1225)	at org.eclipse.jdt.internal.ui.javaeditor.AddImportOnSelectionAction.run(AddImportOnSelectionAction.java:138)	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)	at org.eclipse.ui.actions.RetargetAction.runWithEvent(RetargetAction.java:239)	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:233)	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:595)	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:511)	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:420)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4354)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:651)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:595)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:483)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)	at org.eclipse.equinox.launcher.Main.main(Main.java:1438)"
460521,2/21/2015 12:42,noopur_gupta,"[1.8][override method] Override / Implement methods should offer to generate default methods In Java 8 I may want to define my DefaultSpliterator:-----------------------------------------------interface DefaultSpliterator<T> extends Splitarator<T> { @Override default Spliterator<T> trySplit() { return null; } // ...}-----------------------------------------------When implementing the above I'd like to be able to ""override/implement"" methods from the super interface(s) as default methods but this is currently (in 4.5.0 M5) not possible."
460588,2/23/2015 6:32,jarthana,Move JDT Core project to 1.7 compliance Bug 459415 requires JDT to be able to use java.nio.* APIs which were introduced only in 1.7. We need to move the JDT Core source projects and if possible test projects to 1.7 source level.This should not be a problem in Mars since the minimum supported JRE since Mars is 1.7.
460672,2/24/2015 5:19,manpalat,"[1.8][compiler] java.lang.IllegalArgumentException: info cannot be null at org.eclipse.jdt.internal.compiler.codegen.StackMapFrame.addStackItem(StackMapFrame.java:81) Created attachment 251053zip of a simple java 8 project with the exampleI'm getting this error trying to compile certain string-switch-blocks for Java 8. The simplest example I can provide is this one:package mooh;public class Blubb {	void mooh(String blubb) {		switch (blubb) {		case ""blah"":			int i = 0;			System.out.println(i++);		}	}}The error occurs when the following setting is present in .settings/org.eclipse.jdt.coreprefs:org.eclipse.jdt.core.compiler.codegen.unusedLocal=optimize out"
460799,2/25/2015 8:49,markus.kell.r,"[compare] Structured compare editor tree doesn't properly format qualified types The Java structured compare editor doesn't properly format qualified types that appear as type arguments.Example: Compare the class below with a version that has no members. The tree says that elements Try sd : Date> foo(int String>)have been added/removed.package xy;import java.util.ArrayList;import java.util.Set;class Try {	void foo(int i ArrayList<java.lang.String> ls) {}	Set<java.util.Date> sd;}"
460919,2/26/2015 6:35,markus.kell.r,"[perf] EventDrivenTestSuite times out because GTK thinks the Ctrl key is down org.eclipse.jdt.text.tests.performance.EventDrivenTestSuite times out because GTK thinks the Ctrl key is down. I don't know why.The timeout screenshot show that the KeyboardProbe shell is open and the Key Assist is on top. The test passes locally but I can reproduce the effect when I hold down the Ctrl key wile the test is running.Extract from http://download.eclipse.org/eclipse/downloads/drops4/I20150224-0800/performance/consolelogs/linux.gtk.x86_64_8.0_consolelog.txt : [java] java.lang.Exception: main [java] 	at java.lang.Thread.sleep(Native Method) [java] 	at org.eclipse.jdt.text.tests.performance.KeyboardProbe.driveEventQueue(KeyboardProbe.java:359) [java] 	at org.eclipse.jdt.text.tests.performance.KeyboardProbe.postShiftKeyPress(KeyboardProbe.java:335) [java] 	at org.eclipse.jdt.text.tests.performance.KeyboardProbe.probe(KeyboardProbe.java:193) [java] 	at org.eclipse.jdt.text.tests.performance.KeyboardProbe.initialize(KeyboardProbe.java:65) [java] 	at org.eclipse.jdt.text.tests.performance.TextPerformanceTestCase.getKeyboardProbe(TextPerformanceTestCase.java:408) [java] 	at org.eclipse.jdt.text.tests.performance.NonInitialTypingTest.dirtyEditor(NonInitialTypingTest.java:84) [java] 	at org.eclipse.jdt.text.tests.performance.NonInitialTypingTest.setUp(NonInitialTypingTest.java:54) [java] 	at junit.framework.TestCase.runBare(TestCase.java:139)..."
460993,2/26/2015 15:25,markus.kell.r,"[compiler] Incremental build not always reports the same errors (type cannot be resolved - indirectly referenced) Created attachment 2511542 test projectsWe're seeing a strange ping-pong effect when trying to compile master of org.eclipse.releng.tools and org.eclipse.jgit.On every second incremental compilation we see this error in org.eclipse.releng.tools.git.GitCopyrightAdapter:""The type java.lang.AutoCloseable cannot be resolved. It is indirectly referenced from required .class files""The attached self-contained projects reproduce the problem (needs a 1.5 and a 1.7 Installed JRE). Just open GitCopyrightAdapter add a space and save. Hint: It's easier to debug without a reconciler thread: Use Open With > Text Editor.In this code path we get the IProblem#IsClassPathCorrect as expected:	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:104)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:187)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.superInterfaces(BinaryTypeBinding.java:1805)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethodInSuperInterfaces(Scope.java:1834)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findDefaultAbstractMethod(Scope.java:1113)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1630)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1525)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2800)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:890)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:704)	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:638)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:307)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:548)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:803)	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:141)	at java.lang.Thread.run(Thread.java:745)In the next incremental compile pass the builder decides to build the Messages class as well. That already looks wrong to me. But as a side effect this computes the supertypes of type String.In MethodScope(Scope).findExactMethod(ReferenceBinding char[] TypeBinding[] InvocationSite) line: 1215 the code reads:		if (isPossibleSubtypeOfRawType(argumentTypes[i]))		return null;In the case where the Messages class has not been compiled before the isPossibleSubtypeOfRawType(..) call returns true for argumentType=String (because the supertypes of String have not been resolved yet). As a consequence Scope#findExactMethod(..) return null and the findMethod0(..) shown above eventually resolves the type Repository and reports the missing supertype AutoCloseable.In the other case where the compilation of class Messages already resolved the supertypes of String the isPossibleSubtypeOfRawType(..) call returns false and the findExactMethod(..) call returns the ""resolve"" method binding without ever checking the supertypes of type Repository.=> Error is not reported in this case.Two questions to investigate:1. Why does incremental compilation compile class Messages again? Is it because the previous compilation aborted due to an incomplete build path so the next build will be a full build?2. Why does findMethod0(..) resolve the receiver type and report errors but findExactMethod(..) sometimes returns without ever having resolved the receiver type? If the error is worth reporting at all then it should be reported all the time."
460997,2/26/2015 16:12,markus.kell.r,[hovering] Report fallback mode in Javadoc view / hover when SWT Browser widget is not available Bug 456786 comment 0 tells that it's hard for users to find the real issue when Javadoc view and hovers only have degraded functionality because the Browser widget couldn't be created.Bug 73558 tried to convey this information in a dialog but that was too intrusive. A middle way is to show it at the end of the view or enriched hover.
461004,2/26/2015 18:03,sasikanth.bharadwaj,"Multiple spurious errors compiling FunctionalJava project The functionaljava project compiles successfully using gradle on the command-line but the eclipse compiler reports many errors. It appears that type inference in Eclipse is not as good as the Oracle java compiler.To reproduce:1. Make sure you are using a Java 8 JDK with compatibility set to Java 1.82. Clone the github repo at https://github.com/functionaljava/functionaljava3. Run ""gradlew eclipse"" in the functionaljava folder to compile the project and generate eclipse .project files4. Create a new eclipse workspace5. ""File > Import > Existing Projects"" select the functionaljava folder.6. Import all projectsObserve that type inference fails in many places. I have tested this in Eclipse Luna and in a milestone build of Eclipse Mars and both fail to compile FunctionalJava.These are the errors I am seeing:<pre><code>Description	Resource	Path	Location	TypeThe method of(List.Buffer::new List.Buffer::snoc (<no type> acc1 <no type> acc2) -> {} (<no type> buf) -> {}) is undefined for the type Collector	Collectors.java	/java8/src/main/java/fj/data	line 20	Java ProblemThe method of(List.Buffer::new List.Buffer::snoc (<no type> acc1 <no type> acc2) -> {} (<no type> buf) -> {}) is undefined for the type Collector	Collectors.java	/java8/src/main/java/fj/data	line 29	Java ProblemThe method of(List.Buffer::new List.Buffer::snoc (<no type> acc1 <no type> acc2) -> {} List.Buffer::toList) is undefined for the type Collector	Collectors.java	/java8/src/main/java/fj/data	line 11	Java ProblemThe method parMap(Stream<Object> F<Stream<A>Stream<B>>) is undefined for the type ParModule	ParModule.java	/core/src/main/java/fj/control/parallel	line 503	Java ProblemThe parameterized method <A>list(A...) of type List is not applicable for the arguments (Object[])	Java.java	/core/src/main/java/fj/data	line 1484	Java ProblemType mismatch: cannot convert from Either<LObject> to Either<LOption<B>>	Option.java	/core/src/main/java/fj/data	line 420	Java ProblemType mismatch: cannot convert from IO<Object> to IO<Option<B>>	Option.java	/core/src/main/java/fj/data	line 424	Java ProblemType mismatch: cannot convert from IO<Object> to IO<Validation<EC>>	Validation.java	/core/src/main/java/fj/data	line 839	Java ProblemType mismatch: cannot convert from List<Object> to List<Option<B>>	Option.java	/core/src/main/java/fj/data	line 428	Java ProblemType mismatch: cannot convert from List<Object> to List<Validation<EC>>	Validation.java	/core/src/main/java/fj/data	line 821	Java ProblemType mismatch: cannot convert from Object to int	ReaderTest.java	/core/src/test/java/fj/data	line 34	Java ProblemType mismatch: cannot convert from Object[] to A	Java.java	/core/src/main/java/fj/data	line 1484	Java ProblemType mismatch: cannot convert from Option<Object> to Option<Validation<EC>>	Validation.java	/core/src/main/java/fj/data	line 833	Java ProblemType mismatch: cannot convert from P1<Object> to P1<Option<B>>	Option.java	/core/src/main/java/fj/data	line 440	Java ProblemType mismatch: cannot convert from P1<Object> to P1<Validation<EC>>	Validation.java	/core/src/main/java/fj/data	line 845	Java ProblemType mismatch: cannot convert from Seq<Object> to Seq<Option<B>>	Option.java	/core/src/main/java/fj/data	line 444	Java ProblemType mismatch: cannot convert from Stream<Object> to Stream<Option<B>>	Option.java	/core/src/main/java/fj/data	line 436	Java ProblemType mismatch: cannot convert from Stream<Object> to Stream<Validation<EC>>	Validation.java	/core/src/main/java/fj/data	line 827	Java ProblemType mismatch: cannot convert from Validation<EObject> to Validation<EOption<B>>	Option.java	/core/src/main/java/fj/data	line 457	Java Problem</pre></code>"
461025,2/27/2015 4:12,manpalat,"[1.8][search] Search for constructor reference expressions reports other constructors also package snippet;import java.util.function.Supplier;public class Snippet {	public Snippet(int i) {	}	private void m1() {		Supplier<String> s1 = String::new;		Supplier<String> s2 = new Supplier<String>() {			@Override			public String get() {				return null;			}		};	}}----------------------------------------In the Java Search tab of Search dialog set:Search string: *Search For: ConstructorLimit To: Match locations > '::' method referencesScope: Workspaceand click ""Search"" with the above file in a new workspace.The result shows 3 references in the above file though there is only one constructor reference expression (String::new)."
461074,2/27/2015 12:13,sasikanth.bharadwaj,"indirectly referenced from required .class files error for unreachable reference of type in overriding method declaration in a library on classpath Created attachment 251178Sample projects to reproduce the bugHiI've attached an archive containing 3 dependent projects that reproduces the bug. You can directly import it via:File -> Import -> Existing Projects into Workspace -> Select archive fileDetailed description:This test tries to compile pack.test.SubClass.This class extends pack.lib.SuperClass which can be found on the classpath but in a different package.pack.lib.SuperClass defines the following method:MissingType get() {}the return type pack.missing.MissingType is not on the classpath to compile pack.test.SubClass.But this method visibility is set to ""package"" and thus it is invisible for pack.test.SubClass.Finally pack.lib.SuperClass.get() actually overrides a method of pack.lib.TopClass which is the parent of pack.lib.SuperClass:Object get() {}This test is compiled by javac but the following error is reported by ecj (3.11.0 v20140806-1653):----------1. ERROR in pack/lib/SubClass.java (at line 1) /* ^The type pack.missing.MissingObject cannot be resolved. It is indirectly referenced from required .class files----------1 problem (1 error)Thanks"
461372,3/4/2015 5:12,manpalat,[1.9][search] Support modular run time images in JDT search
461529,3/5/2015 15:09,sasikanth.bharadwaj,"Abstract class extending interface with default impl won't compile but does compile from cmd line Created attachment 251339Example project demonstrating the problemWe ran into a bug internally with some fairly complex code that has an interface with a default function implementation an abstract class inheriting that interface and narrowing the return type and another abstract class extending that one. Eclipse is refusing to compile the child-most class complaining that:The type ChildFoo must implement the inherited abstract method Foo.createBar() to override IBarable<Foo>.createBar()	ChildFoo.java	/foo/src/foo	line 3	Java ProblemBut ChildFoo is abstract so by definition there should be no requirement for it to implement anything. Maven can compile this from the command line just fine. I'm attaching a project for reference.Note this is blocking us from being able to develop with this code the only workaround we could find was to install the ""Java 8 support for Eclipse Kepler SR2"" from the marketplace even though this is Luna SR2. Maybe there has been a regression?"
461682,3/9/2015 3:19,sarika.sinha,Move JDT Debug project to 1.7 compliance Java 9 Support requires JDT to be able to use java.nio.* APIs which were introduced only in 1.7. We need to move the Debug source and test projects from 1.5 to 1.7 compliance level.This should not be a problem in Mars since the minimum supported JRE since Mars is 1.7.
461706,3/9/2015 9:01,sasikanth.bharadwaj,"[1.8][compiler] ""Unnecessary cast"" problems for necessary cast in lambda expression If I call the cleanup-feature for the following code then the cast x -> (ICondition) xis removed and the function is reduced to Identity: x -> x which causes Compiler-Errors in the subsequent reduce invokation. Obviously the cast is NOT unneccessary since the code works fine with the cast but cant be compiled without.public class Bug {	private static class AndCondition implements ICondition {		public AndCondition(ICondition cond1 ICondition cond2) {			// todo		}	}	private static class SimpleCondition implements ICondition {	}	private static interface ICondition {		ICondition TRUE = new SimpleCondition();		default ICondition and(final ICondition cond) {			return new AndCondition(this cond);		}	}	public static void main(final String[] args) {		final List<SimpleCondition> conditions = new ArrayList<>();		conditions.stream()				.map(x -> (ICondition) x)				.reduce((x y) -> x.and(y))				.orElse(ICondition.TRUE);	}}"
461863,3/10/2015 13:39,eclipse,"[import rewrite] addImport creates .ypename for unqualified type from default package master- copy the following to the clipboard:------------------------------public class Default {	Default d;}package p;public class C {	C c;	}------------------------------- open the Package Explorer clear the selection paste- go to Default.java- select line ""Default d;""- copy- go to C.java- set caret to the empty line- paste=> expected: as in 4.4 you should get an ""import Default;""=> was: you get an ""import .efault;""If you copied multiple type references from the default package and the preferences are set to create star-imports then you can produce ""import .*;""."
461969,3/12/2015 2:38,markus.kell.r,"[test][apt] org.eclipse.jdt.compiler.apt.tests.ModelUtilTests.testTypesWithSystemCompiler failed build: I20150311-1300platform: linuxhttp://download.eclipse.org/eclipse/downloads/drops4/I20150311-1300/testresults/html/org.eclipse.jdt.compiler.apt.tests_linux.gtk.x86_64_8.0.htmlstacktrace: junit.framework.ComparisonFailure: expected:<[succeeded]> but was:<[NoType has the wrong name: none]>	at org.eclipse.jdt.compiler.apt.tests.ModelUtilTests.internalTest(ModelUtilTests.java:105)	at org.eclipse.jdt.compiler.apt.tests.ModelUtilTests.testTypesWithSystemCompiler(ModelUtilTests.java:76)	at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657)	at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310)	at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36)	at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32)	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)	at org.eclipse.equinox.launcher.Main.main(Main.java:1438)	at org.eclipse.core.launcher.Main.main(Main.java:34)"
462118,3/13/2015 22:47,sarika.sinha,Compile log warning in JDT Debug build after 1.7 BREE change http://download.eclipse.org/eclipse/downloads/drops4/N20150313-2000/testResults.php/jdi/org/eclipse/jdi/internal/spy/TcpipSpy.java : 2 warnings :OTHER WARNINGS 1. WARNING in /jdi/org/eclipse/jdi/internal/spy/TcpipSpy.java (at line 101)ServerSocket serverSock = new ServerSocket(inPort);Resource leak: 'serverSock' is never closed2. WARNING in /jdi/org/eclipse/jdi/internal/spy/TcpipSpy.java (at line 103)Socket outSock = new Socket(InetAddress.getByName(serverHost)Resource leak: 'outSock' is never closed
462147,3/14/2015 15:11,jarthana,Documentation for new compiler options added during the Mars cycle I suggest to cover all relevant documentation for preferences and batch compiler options in this bug.One recent candidate: bug 408815
462158,3/15/2015 0:10,jarthana,[type hierarchy] Type hierarchy doesn't produce expected results with CU with more than 10 annotations and with compiler errors Created attachment 251559Minimized source file with anonymous class declarations and inner Iterable classIt appears that a certain combination of an inner Iterable class and many (at least 10) anonymous class declarations prevents the 'foreach' template from working. Attached is a minimized source file.When invoked in front of the final List list = new List();statement the 'foreach' template produces the well-known output: for (iterable_type iterable_element : iterable) { }However when invoked after that statement the 'foreach' template doesn't do anything.-- Configuration Details --Product: Eclipse 4.4.2.20150219-0708 (org.eclipse.epp.package.java.product)Installed Features: org.eclipse.jdt 3.10.1.v20150204-1700
462756,3/21/2015 8:33,jarthana,IAE in ThreadJob.illegalPush (134) The following incident was reported via the automated error reporting: code: 2 plugin: org.eclipse.equinox.preferences_3.5.200.v20140224-1527 message: HIDDEN fingerprint: 70e2bf12 exception class: java.lang.IllegalArgumentException exception message: HIDDEN number of children: 0 java.lang.IllegalArgumentException: HIDDEN at org.eclipse.core.runtime.Assert.isLegal(Assert.java:63) at org.eclipse.core.internal.jobs.ThreadJob.illegalPush(ThreadJob.java:134) at org.eclipse.core.internal.jobs.ThreadJob.push(ThreadJob.java:333) at org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:63) at org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:298) at org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:118) at org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:2251) at org.eclipse.core.internal.resources.Project.touch(Project.java:1427) at org.eclipse.jdt.internal.core.JavaModelManager$EclipsePreferencesListener.preferenceChange(JavaModelManager.java:1531) at org.eclipse.core.internal.preferences.EclipsePreferences$3.run(EclipsePreferences.java:896) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.core.internal.preferences.EclipsePreferences.firePreferenceEvent(EclipsePreferences.java:899) at org.eclipse.core.internal.preferences.EclipsePreferences.put(EclipsePreferences.java:912) at org.eclipse.jdt.internal.core.JavaModelManager.storePreference(JavaModelManager.java:4888) at org.eclipse.jdt.internal.core.JavaModelManager.setOptions(JavaModelManager.java:4940) at org.eclipse.jdt.core.JavaCore.setOptions(JavaCore.java:5672) at org.eclipse.jdt.launching.JavaRuntime.updateCompliance(JavaRuntime.java:2817) at org.eclipse.jdt.launching.JavaRuntime.initializeVMs(JavaRuntime.java:2776) at org.eclipse.jdt.launching.JavaRuntime.getVMInstallTypes(JavaRuntime.java:537) at org.eclipse.jdt.internal.launching.JREPreferenceModifyListener.preApply(JREPreferenceModifyListener.java:128) at org.eclipse.core.internal.preferences.PreferencesService$4.run(PreferencesService.java:448) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.core.internal.preferences.PreferencesService.firePreApplyEvent(PreferencesService.java:451) at org.eclipse.core.internal.preferences.PreferencesService.applyPreferences(PreferencesService.java:121) at org.eclipse.core.internal.resources.ProjectPreferences.read(ProjectPreferences.java:206) at org.eclipse.core.internal.resources.ProjectPreferences.updatePreferences(ProjectPreferences.java:274) at org.eclipse.core.internal.resources.File.updateMetadataFiles(File.java:415) at org.eclipse.core.internal.localstore.RefreshLocalVisitor.visit(RefreshLocalVisitor.java:297) at org.eclipse.core.internal.localstore.UnifiedTree.accept(UnifiedTree.java:109) at org.eclipse.core.internal.localstore.FileSystemResourceManager.refreshResource(FileSystemResourceManager.java:922) at org.eclipse.core.internal.localstore.FileSystemResourceManager.refresh(FileSystemResourceManager.java:906) at org.eclipse.core.internal.resources.Resource.refreshLocal(Resource.java:1710) at org.eclipse.core.internal.refresh.RefreshJob.runInWorkspace(RefreshJob.java:169) at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:39) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55) General Information: reported-by: ice anonymous-id: a8d37249-4f86-42bc-8659-1eeb82823d5c eclipse-build-id: 4.5.0.I20141210-2000 eclipse-product: org.eclipse.epp.package.committers.product operating system: Windows8 6.2.0 (x86_64) - win32 jre-version: 1.8.0_31-b13The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.jobs_3.7.0.v20141128-1953 2. org.eclipse.core.resources_3.9.100.v20141128-1217 3. org.eclipse.core.runtime_3.10.0.v20140724-1132 4. org.eclipse.jdt.core_3.11.0.v20141209-1931 5. org.eclipse.jdt_3.11.0.v20141210-2000 6. org.eclipse.jdt.launching_3.7.200.v20141110-1449Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.Other Resources:* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/54d63202e4b05aab71ce6027 * Manual: https://dev.eclipse.org/recommenders/community/confess/#/guideThank you for your assistance.Your friendly error-reports-inbox.
462783,3/22/2015 10:00,david_williams,"New certificate conflict for org.eclipse.jdt.internal.compiler.lookup.AptSourceLocalVariableBinding Similar to bug 462431 bug 461634 caused most likely by bug 450783 (updated certificates).The compile of org.eclipse.core.databinding.observable fails because of:[ERROR] Failed to execute goal org.eclipse.tycho:tycho-compiler-plugin:0.23.0-SNAPSHOT:compile (default-compile) on project org.eclipse.core.databinding.observable: Fatal error compiling: class ""org.eclipse.jdt.internal.compiler.lookup.AptSourceLocalVariableBinding""'s signer information does not match signer information of other classes in the same packageSee https://hudson.eclipse.org/platform/job/eclipse.platform.ui-Gerrit/5095/consoleFull"
462932,3/24/2015 6:20,sarika.sinha,Gracefully handle partial absence of line information Classes generated at run-time or processed by byte code manipulators may contain source line information for some but not all methods.For this reason ReferenceType.allLineLocations() should return all available line locations from all methods that do provide line locations rather than throwing an AbsentInformationException for the first method without line locations.The exception should only be thrown when no method of the given class provides any line locations. This is the behaviour observed with the JDI implementation of the Oracle JDK.
462948,3/24/2015 8:18,noopur_gupta,"[render] Abstract method in content assist should show ""A"" adornment Abstract method from interface or abstract class should show the ""A"" adornment in content assist proposal.For example:package test;abstract class C1 {	public abstract void abst();}class C2 extends C1 {	abs|}interface I {	void abst();	default void def() {}}class C implements I {	abs|}"
462998,3/24/2015 12:36,daniel_megert,Enable unit tests on gerrit We should enable the unit tests to run automatically for gerrit submissions.
463062,3/25/2015 5:36,jarthana,Annotation processing runs when annotation is on an incompatible target element We encountered this with AndroidAnnotations (https://github.com/excilys/androidannotations/issues/1346). So basically the user added an annotation which has @Target(ElementType.TYPE) to a field. This is of course invalid and produces a compilation error. However in JDT APT annotation processing still runs for the added annotation. I think this not makes sense since the processor handling the annotation expects that it is put on a type element and not on a field element. Also javac does not run annotation processing for this added annotation. I know JDT is an incremental compiler but we at AndroidAnnotations still think the processing should not be called for this annotation.Full example:@Retention(RetentionPolicy.CLASS)@Target(ElementType.TYPE)public @interface EBean {}public class MyClass { @MyAnnotation // cannot be on a field Object field;}
463070,3/25/2015 6:20,akurtakov,Update maven antrun plugin configuration As continuation of bug#458043. Don't define maven-antrun-plugin version but rely on parent's pluginManagement version.Drop the unneeded additional dependencies for antrun plugin.
463153,3/26/2015 4:11,markus.kell.r,"[test][builder] test failures in BasicBuildTests and BuildPathTests Platforms: allbuild Id: N20150325-2000http://download.eclipse.org/eclipse/downloads/drops4/N20150325-2000/testResults.phptestbBug386901	Failure	Invalid problem(s)!!!. ----------- Expected ------------ Problem : AZ cannot be resolved to a type [ resource : </Project/src/p/AB.java> range : <3638> category : <40> severity : <2>] ------------ but was ------------ --------- Difference is ---------- expected:<[Problem : AZ cannot be resolved to a type [ resource : </Project/src/p/AB.java> range : <3638> category : <40> severity : <2>]]> but was:<[]>junit.framework.ComparisonFailure: Invalid problem(s)!!!.----------- Expected ------------Problem : AZ cannot be resolved to a type [ resource : </Project/src/p/AB.java> range : <3638> category : <40> severity : <2>]------------ but was --------------------- Difference is ----------expected:<[Problem : AZ cannot be resolved to a type [ resource : </Project/src/p/AB.java> range : <3638> category : <40> severity : <2>]]> but was:<[]>at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:268)at org.eclipse.jdt.core.tests.junit.extension.TestCase.assumeEquals(TestCase.java:288)at org.eclipse.jdt.core.tests.builder.BuilderTests.expectingProblemsFor(BuilderTests.java:333)at org.eclipse.jdt.core.tests.builder.BuilderTests.expectingProblemsFor(BuilderTests.java:326)at org.eclipse.jdt.core.tests.builder.BasicBuildTests.testbBug386901(BasicBuildTests.java:600)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310)at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36)at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32)at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)at org.eclipse.equinox.launcher.Main.run(Main.java:1465)at org.eclipse.equinox.launcher.Main.main(Main.java:1438)at org.eclipse.core.launcher.Main.main(Main.java:34)testMissingLibrary2	Failure	missing expected problem: Problem : The type java.lang.Object cannot be resolved. It is indirectly referenced from required .class files [ resource : </Project/src/p1/Test1.java> range : <-1-1> category : <-1> severity : <2>]junit.framework.AssertionFailedError: missing expected problem: Problem : The type java.lang.Object cannot be resolved. It is indirectly referenced from required .class files [ resource : </Project/src/p1/Test1.java> range : <-1-1> category : <-1> severity : <2>]at org.eclipse.jdt.core.tests.junit.extension.TestCase.assumeTrue(TestCase.java:350)at org.eclipse.jdt.core.tests.builder.BuilderTests.expectingSpecificProblemsFor(BuilderTests.java:389)at org.eclipse.jdt.core.tests.builder.BuilderTests.expectingSpecificProblemFor(BuilderTests.java:354)at org.eclipse.jdt.core.tests.builder.BuildpathTests.testMissingLibrary2(BuildpathTests.java:670)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:657)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:310)at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36)at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32)at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)at org.eclipse.equinox.launcher.Main.run(Main.java:1465)at org.eclipse.equinox.launcher.Main.main(Main.java:1438)at org.eclipse.core.launcher.Main.main(Main.java:34)"
463236,3/26/2015 15:43,markus.kell.r,Scrapbook evaluations fail in pre-1.7 projects Since org.eclipse.jdt.debug.ui was moved to 1.7 scrapbook evaluations fail in 1.5 and 1.6 projects because the snippetsupport.jar is not compiled with 1.7 as well. This JAR should stay at a compliance level that is as low as possible.
463252,3/27/2015 2:50,sarika.sinha,Compile log warning in JDT Debug ui in N20150326-2000 Compile log warning http://download.eclipse.org/eclipse/downloads/drops4/N20150326-2000/compilelogs/plugins/org.eclipse.jdt.debug.ui_3.7.0.N20150326-2000/@dot.html
463332,3/27/2015 20:15,noopur_gupta,"[1.8][quick fix] No quick fix to resolve 'default method conflicts' error public interface Interface1 {	public default void x() {		//...	}}public interface Interface2 {	public void x();}//The below class has an compile error because it must pick which x() to inherit.public abstract class Helper implements Interface1 Interface2 {}There doesn't seem to be a quick fix for this. I was expecting to see a menu with a few options:1. Override x() completely (empty body with TODO statement this is like redefining the method).2. Override x() by using the default implementation in Interface1 (Interface1.super.x();). In fact Eclipse would not code-complete this code. I'll file another bug for that."
463372,3/28/2015 20:34,mateusz.matela,"Code formatting on JDT not respecting ""Never join already wrapped lines"" on some circumstances In Eclipse 4.5m6 formatting the code below leaves all the contents of the line in a single line even if the setting ""Never join already wrapped lines"" is turned on.Note that this does not happen if the '+' from the string concatenation is on the other side (i.e.: + ""b = 20\n"" instead of ""b = 20\n"" +)package org.python.pydev.core.docutils;public class Test { public static void main(String[] args) { String docContents = """" + ""a = 10\n"" + ""b = 20\n"" + ""c = 30\n""; }}"
463526,3/30/2015 19:30,sasikanth.bharadwaj,"Parenthesis are incorrectly allowed in lambda when LambdaBody is an expression statement Created attachment 252018Fails with javac 1.8.0._20; no errors with eclipse 4.4.2I found a case where javac won't compile a class but eclipse compiles without errors. The file is attached as Test.java. Compiling with javac 1.8.0_20 produces:Test.java:6: error: method accept in class Receiver cannot be applied to given types; r.accept((l) -> (doItOnTheClass(new Object()))); ^ required: Listener found: (l)->(doIt[...]t())) reason: argument mismatch; bad return type in lambda expression missing return value1 errorRemoving the parenthesis around 'doItOnTheClass(...)' allows the code to compile in eclipse and javac. ---I am not a JLS expert but my guess is that javac is correct based on:From JLS 15.27.3 Type of a Lambda Expression:* If the function type's result is void the lambda body is either a statement expression (??14.8) or a void-compatible block.Per JLS 14.8 Expression Statements it is not legal to parenthesize a method invocation expression in a statement context:* System.out.println(""Hello world""); // OK* (System.out.println(""Hello world"")); // illegalThanks!"
463559,3/31/2015 5:20,jarthana,"Contributed default formatter name needs to be externalized 4.5 M6.The contributed default formatter name needs to be externalized. Currently it is hard-coded: name=""Eclipse [built-in]"">"
464229,4/9/2015 2:42,sasikanth.bharadwaj,The type * cannot be resolved. It is indirectly referenced from required .class files Created attachment 252249Test setup to reproduce the problemWith the current Mars M6 milestone (as opposed to Eclipse 4.4) the compiler falsely detects an indirect reference to a type.Attached is a small demo setup (4 projects) that reproduce the problem. From my point of view it is a bug that the caller of MyInterface.callSomething(SomeClass) needs to be able to resolve the /interface/ that the SomeClass implements - that's purely SomeClass' business and the caller of the interface does not need to know.For us this is a blocker as we would need to create dependencies between bundles that are strictly forbidden!
464312,4/9/2015 11:56,markus.kell.r,"[formatter] for K_STATEMENTS inserts an unexpected line delimiter after initial comment Format this line with CodeFormatter.K_STATEMENTS:/**/int f;This inserts an unexpected line delimiter after the comment.I have a fix ready.Original steps from Dani:- have code:package p;public class A {	static_fin}- put caret after ""static_fin"" press Ctrl+Space and apply the template=> was:	public 	static final String NAME = """";=> expected:	public static final String NAME = """";"
464339,4/9/2015 17:36,manpalat,"When finding references Java Search fails with NullPointerException I receive the following error when trying to find references to anything:An internal error occurred during: ""Java Search"".java.lang.NullPointerExceptionI have deleted my workspace created a new one and still am receiving this issue.Here is the stack trace.java.lang.NullPointerException	at org.eclipse.core.runtime.Path.<init>(Path.java:183)	at org.eclipse.core.internal.resources.WorkspaceRoot.getProject(WorkspaceRoot.java:182)	at org.eclipse.jdt.internal.core.JavaModel.getJavaProject(JavaModel.java:169)	at org.eclipse.jdt.internal.core.search.IndexSelector.getJavaProject(IndexSelector.java:304)	at org.eclipse.jdt.internal.core.search.IndexSelector.initializeIndexLocations(IndexSelector.java:232)	at org.eclipse.jdt.internal.core.search.IndexSelector.getIndexLocations(IndexSelector.java:294)	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.selectIndexURLs(JavaSearchParticipant.java:148)	at org.eclipse.jdt.internal.core.search.PatternSearchJob.getIndexes(PatternSearchJob.java:84)	at org.eclipse.jdt.internal.core.search.PatternSearchJob.ensureReadyToRun(PatternSearchJob.java:52)	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:174)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:215)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516)	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584)	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144)	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)"
464369,4/10/2015 4:15,jarthana,[test][builder]BuildpathTests.testCorruptBuilder2 and IncrementalTests.testBug364450 failed BuildID N20150409-2000http://download.eclipse.org/eclipse/downloads/drops4/N20150409-2000/testresults/html/org.eclipse.jdt.core.tests.builder_win32.win32.x86_7.0.htmlstacktraceBuild path contains duplicate entry: 'C:Java/jdk1.7.0_51/jre/lib/resources.jar' for project 'P1'Java Model Exception: Java Model Status [Build path contains duplicate entry: 'C:Java/jdk1.7.0_51/jre/lib/resources.jar' for project 'P1']at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:785)at org.eclipse.jdt.internal.core.JavaProject.setRawClasspath(JavaProject.java:3097)at org.eclipse.jdt.internal.core.JavaProject.setRawClasspath(JavaProject.java:3059)at org.eclipse.jdt.internal.core.JavaProject.setRawClasspath(JavaProject.java:3112)at org.eclipse.jdt.core.tests.builder.TestingEnvironment.setClasspath(TestingEnvironment.java:1048)at org.eclipse.jdt.core.tests.builder.TestingEnvironment.addEntry(TestingEnvironment.java:285)at org.eclipse.jdt.core.tests.builder.TestingEnvironment.addExternalJars(TestingEnvironment.java:265)at org.eclipse.jdt.core.tests.builder.TestingEnvironment.addExternalJars(TestingEnvironment.java:253)at org.eclipse.jdt.core.tests.builder.BuildpathTests.testCorruptBuilder2(BuildpathTests.java:238)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:692)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:319)at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36)at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32)at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)at org.eclipse.equinox.launcher.Main.run(Main.java:1465)at org.eclipse.equinox.launcher.Main.main(Main.java:1438)at org.eclipse.core.launcher.Main.main(Main.java:34)
464408,4/10/2015 11:59,jarthana,"CCE: ArrayBinding cannot be cast to ReferenceBinding I'm using Eclipse Mars M6 (Build id: 20150326-0744)The problem can be reproduced easily using this program:------------------------------------------------import java.util.ArrayList;import java.util.List;public class Test { void x() { List<List<String>> list = new ArrayList<>(); list.stream().toArray(List<String>[]::new); }}------------------------------------------------Save the program in a file modify it and save it again. An exception should occur:------------------------------------------------!ENTRY org.eclipse.jdt.ui 4 10006 2015-04-10 17:51:58.660!MESSAGE The save participant 'org.eclipse.jdt.ui.postsavelistener.cleanup' caused an exception: java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.ArrayBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding!STACK 0java.lang.ClassCastException: org.eclipse.jdt.internal.compiler.lookup.ArrayBinding cannot be cast to org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding	at org.eclipse.jdt.internal.compiler.ast.ReferenceExpression.isPotentiallyCompatibleWith(ReferenceExpression.java:990)	at org.eclipse.jdt.internal.compiler.lookup.ConstraintExpressionFormula.reduce(ConstraintExpressionFormula.java:61)	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:844)	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.reduce(InferenceContext18.java:857)	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.solve(InferenceContext18.java:808)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod18(ParameterizedGenericMethodBinding.java:234)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:82)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:743)	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1634)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1535)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:672)	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1020)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:639)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:307)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:549)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1204)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:689)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)	at org.eclipse.jdt.internal.corext.fix.CleanUpPostSaveListener.createAst(CleanUpPostSaveListener.java:608)	at org.eclipse.jdt.internal.corext.fix.CleanUpPostSaveListener.saved(CleanUpPostSaveListener.java:385)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$5.run(CompilationUnitDocumentProvider.java:1598)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.notifyPostSaveListeners(CompilationUnitDocumentProvider.java:1593)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy(CompilationUnitDocumentProvider.java:1380)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$4.execute(CompilationUnitDocumentProvider.java:1458)	at org.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run(TextFileDocumentProvider.java:132)	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:70)	at org.eclipse.ui.actions.WorkspaceModifyOperation$1.run(WorkspaceModifyOperation.java:108)	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2241)	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:130)	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:75)	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:65)	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:456)	at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:772)	at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:5076)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1244)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1298)	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7209)	at org.eclipse.ui.Saveable.doSave(Saveable.java:216)	at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:355)	at org.eclipse.ui.internal.SaveableHelper$3.run(SaveableHelper.java:199)	at org.eclipse.ui.internal.SaveableHelper$5.run(SaveableHelper.java:283)	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:463)	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:371)	at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2137)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2133)	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:291)	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:269)	at org.eclipse.ui.internal.SaveableHelper.saveModels(SaveableHelper.java:211)	at org.eclipse.ui.internal.SaveableHelper.savePart(SaveableHelper.java:146)	at org.eclipse.ui.internal.WorkbenchPage.saveSaveable(WorkbenchPage.java:3802)	at org.eclipse.ui.internal.WorkbenchPage.saveEditor(WorkbenchPage.java:3816)	at org.eclipse.ui.internal.handlers.SaveHandler.execute(SaveHandler.java:54)	at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:295)	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)	at sun.reflect.GeneratedMethodAccessor218.invoke(Unknown Source)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)	at java.lang.reflect.Method.invoke(Unknown Source)	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55)	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247)	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229)	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499)	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1112)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108)	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1529)	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4764)	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:343)	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4645)	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5042)	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1112)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:993)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:654)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)	at java.lang.reflect.Method.invoke(Unknown Source)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603)	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)------------------------------------------------Here's relevant content from ""/.settings/org.eclipse.jdt.ui.prefs""------------------------------------------------cleanup.add_default_serial_version_id=falsecleanup.add_generated_serial_version_id=truecleanup.add_missing_annotations=truecleanup.add_missing_deprecated_annotations=truecleanup.add_missing_methods=falsecleanup.add_missing_nls_tags=falsecleanup.add_missing_override_annotations=truecleanup.add_missing_override_annotations_interface_methods=truecleanup.add_serial_version_id=truecleanup.always_use_blocks=truecleanup.always_use_parentheses_in_expressions=falsecleanup.always_use_this_for_non_static_field_access=truecleanup.always_use_this_for_non_static_method_access=falsecleanup.convert_to_enhanced_for_loop=falsecleanup.correct_indentation=truecleanup.format_source_code=falsecleanup.format_source_code_changes_only=falsecleanup.make_local_variable_final=truecleanup.make_parameters_final=falsecleanup.make_private_fields_final=truecleanup.make_type_abstract_if_missing_method=falsecleanup.make_variable_declarations_final=falsecleanup.never_use_blocks=falsecleanup.never_use_parentheses_in_expressions=truecleanup.organize_imports=truecleanup.qualify_static_field_accesses_with_declaring_class=falsecleanup.qualify_static_member_accesses_through_instances_with_declaring_class=truecleanup.qualify_static_member_accesses_through_subtypes_with_declaring_class=truecleanup.qualify_static_member_accesses_with_declaring_class=truecleanup.qualify_static_method_accesses_with_declaring_class=falsecleanup.remove_private_constructors=truecleanup.remove_trailing_whitespaces=truecleanup.remove_trailing_whitespaces_all=truecleanup.remove_trailing_whitespaces_ignore_empty=falsecleanup.remove_unnecessary_casts=truecleanup.remove_unnecessary_nls_tags=truecleanup.remove_unused_imports=truecleanup.remove_unused_local_variables=falsecleanup.remove_unused_private_fields=truecleanup.remove_unused_private_members=falsecleanup.remove_unused_private_methods=truecleanup.remove_unused_private_types=truecleanup.sort_members=falsecleanup.sort_members_all=falsecleanup.use_blocks=truecleanup.use_blocks_only_for_return_and_throw=falsecleanup.use_parentheses_in_expressions=falsecleanup.use_this_for_non_static_field_access=falsecleanup.use_this_for_non_static_field_access_only_if_necessary=falsecleanup.use_this_for_non_static_method_access=falsecleanup.use_this_for_non_static_method_access_only_if_necessary=truecleanup_profile=_jOOQcleanup_settings_version=2editor_save_participant_org.eclipse.jdt.ui.postsavelistener.cleanup=truesp_cleanup.add_default_serial_version_id=truesp_cleanup.add_generated_serial_version_id=falsesp_cleanup.add_missing_annotations=truesp_cleanup.add_missing_deprecated_annotations=truesp_cleanup.add_missing_methods=falsesp_cleanup.add_missing_nls_tags=falsesp_cleanup.add_missing_override_annotations=truesp_cleanup.add_missing_override_annotations_interface_methods=truesp_cleanup.add_serial_version_id=falsesp_cleanup.always_use_blocks=truesp_cleanup.always_use_parentheses_in_expressions=falsesp_cleanup.always_use_this_for_non_static_field_access=falsesp_cleanup.always_use_this_for_non_static_method_access=falsesp_cleanup.convert_to_enhanced_for_loop=falsesp_cleanup.correct_indentation=falsesp_cleanup.format_source_code=falsesp_cleanup.format_source_code_changes_only=falsesp_cleanup.make_local_variable_final=falsesp_cleanup.make_parameters_final=falsesp_cleanup.make_private_fields_final=truesp_cleanup.make_type_abstract_if_missing_method=falsesp_cleanup.make_variable_declarations_final=falsesp_cleanup.never_use_blocks=falsesp_cleanup.never_use_parentheses_in_expressions=truesp_cleanup.on_save_use_additional_actions=truesp_cleanup.organize_imports=truesp_cleanup.qualify_static_field_accesses_with_declaring_class=falsesp_cleanup.qualify_static_member_accesses_through_instances_with_declaring_class=truesp_cleanup.qualify_static_member_accesses_through_subtypes_with_declaring_class=truesp_cleanup.qualify_static_member_accesses_with_declaring_class=falsesp_cleanup.qualify_static_method_accesses_with_declaring_class=falsesp_cleanup.remove_private_constructors=truesp_cleanup.remove_trailing_whitespaces=truesp_cleanup.remove_trailing_whitespaces_all=truesp_cleanup.remove_trailing_whitespaces_ignore_empty=falsesp_cleanup.remove_unnecessary_casts=truesp_cleanup.remove_unnecessary_nls_tags=falsesp_cleanup.remove_unused_imports=truesp_cleanup.remove_unused_local_variables=falsesp_cleanup.remove_unused_private_fields=truesp_cleanup.remove_unused_private_members=falsesp_cleanup.remove_unused_private_methods=truesp_cleanup.remove_unused_private_types=truesp_cleanup.sort_members=falsesp_cleanup.sort_members_all=falsesp_cleanup.use_blocks=falsesp_cleanup.use_blocks_only_for_return_and_throw=falsesp_cleanup.use_parentheses_in_expressions=falsesp_cleanup.use_this_for_non_static_field_access=falsesp_cleanup.use_this_for_non_static_field_access_only_if_necessary=truesp_cleanup.use_this_for_non_static_method_access=falsesp_cleanup.use_this_for_non_static_method_access_only_if_necessary=true------------------------------------------------Removing editor_save_participant_org.eclipse.jdt.ui.postsavelistener.cleanup=true is a workaround for the problemThis incident was also auto-submitted by Eclipse:https://dev.eclipse.org/recommenders/community/confess/#/incidents/TJcYP17tuhMTaSlbNMxwxG6lYZM57ARjf83Zns4LdoIJp7E8KgH9ESesBnKu4NZR"
464426,4/10/2015 18:32,marcel.bruch,Make AnonymousTypeCompletionProposal more extensible I'd like to request changing the method visibility of org.eclipse.jdt.internal.ui.text.java.AnonymousTypeCompletionProposal.getImageForType(IType) from private to protected. This change would allow us to significantly improve the performance of several completion scenarios. I'd be happy if the JDT team would accept these changes.The patches will be contributed via Gerrit.
464552,4/13/2015 17:42,daniel_megert,[content assist] Consider computing AnonymousTypeCompletionProposal image lazily Created attachment 252359Profiling ScreenshotI'm trying to spot some performance bottlenecks in code completion. On my experiments I found an issue that may be worth evaluating for Eclipse Mars.I noticed that creating AnonymousTypeCompletionProposals is rather slow. It seems that computing the image of the proposal in the constructor is the culprit. See the attached screenshot for details.How do you feel about computing the image of such a proposal lazily?
464570,4/14/2015 3:41,sasikanth.bharadwaj,"[compiler][codegen] race condition on static field CodeStream.noVisibleLocals in method CodeStream.init() weblogic make use of JDT to compile the translated java source from jsp files to java bytecode with multi-threads ArrayIndexOutOfBoundsException occurs intermittently as following stack showing (weblogic repackaged the jdt jar for avoiding potential class conflict):java.lang.ArrayIndexOutOfBoundsException	at java.lang.System.arraycopy(Native Method)	at com.bea.core.repackaged.jdt.internal.compiler.codegen.CodeStream.init(CodeStream.java:4114)	at com.bea.core.repackaged.jdt.internal.compiler.codegen.StackMapFrameCodeStream.init(StackMapFrameCodeStream.java:426)	at com.bea.core.repackaged.jdt.internal.compiler.codegen.TypeAnnotationCodeStream.init(TypeAnnotationCodeStream.java:149)	at com.bea.core.repackaged.jdt.internal.compiler.codegen.CodeStream.reset(CodeStream.java:6665)	at com.bea.core.repackaged.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:330)	at com.bea.core.repackaged.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:281)	at com.bea.core.repackaged.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:567)	at com.bea.core.repackaged.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:636)	at com.bea.core.repackaged.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:368)	at com.bea.core.repackaged.jdt.internal.compiler.Compiler.process(Compiler.java:814)	at com.bea.core.repackaged.jdt.internal.compiler.Compiler.processCompiledUnits(Compiler.java:488)	at com.bea.core.repackaged.jdt.internal.compiler.Compiler.compile(Compiler.java:453)	at weblogic.jsp.internal.java.JDTJavaCompiler.generateByteCode(JDTJavaCompiler.java:137)	at weblogic.jsp.internal.java.JavaSourceFile._codeGen(JavaSourceFile.java:211)	at weblogic.jsp.internal.java.JavaSourceFile.codeGen(JavaSourceFile.java:201)	at weblogic.jsp.internal.ProxySourceFile.compileGeneratedFiles(ProxySourceFile.java:330)	at weblogic.jsp.internal.ProxySourceFile.codeGen(ProxySourceFile.java:258)	at weblogic.jsp.internal.SourceFile.codeGen(SourceFile.java:327)	at weblogic.jsp.internal.client.ClientUtilsImpl$CodeGenJob.run(ClientUtilsImpl.java:622)	at weblogic.jsp.internal.client.Job.performJob(Job.java:85)	at weblogic.jsp.internal.client.ThreadPool$WorkerThread.run(ThreadPool.java:219)This AIOOBE should be caused by race-condition on the shared static field org.eclipse.jdt.internal.compiler.codegen.CodeStream.noVisibleLocals it's easy to figure out a case which can reproduce such AIOOBE one of the possible fixes may be:index 8a1c987..58e40b7 100644--- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java+++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java@@ -410829 +410837 @@ public void init(ClassFile targetClassFile) { this.pcToSourceMapSize = 0; this.lastEntryPC = 0; int length = this.visibleLocals.length;+ LocalVariableBinding[] noVisibleLocals = this.noVisibleLocals; if (noVisibleLocals.length < length) { noVisibleLocals = new LocalVariableBinding[length];+ this.noVisibleLocals = noVisibleLocals; } System.arraycopy(noVisibleLocals 0 this.visibleLocals 0 length); this.visibleLocalsCount = 0; length = this.locals.length;+ LocalVariableBinding[] noLocals = this.noLocals; if (noLocals.length < length) { noLocals = new LocalVariableBinding[length];+ this.noLocals = noLocals; } System.arraycopy(noLocals 0 this.locals 0 length); this.allLocalsCounter = 0; length = this.exceptionLabels.length;+ ExceptionLabel[] noExceptionHandlers = this.noExceptionHandlers; if (noExceptionHandlers.length < length) { noExceptionHandlers = new ExceptionLabel[length];+ this.noExceptionHandlers = noExceptionHandlers; } System.arraycopy(noExceptionHandlers 0 this.exceptionLabels 0 length); this.exceptionLabelsCounter = 0; length = this.labels.length;+ BranchLabel[] noLabels = this.noLabels; if (noLabels.length < length) { noLabels = new BranchLabel[length];+ this.noLabels = noLabels; } System.arraycopy(noLabels 0 this.labels 0 length); this.countLabels = 0;"
464800,4/16/2015 9:53,markus.kell.r,ToolFactory#createCodeFormatter() refers Plugin#getDescriptor() without declaring dependency on compatibility bundle org.eclipse.jdt.core.ToolFactory#createCodeFormatter() refers to Plugin#getDescriptor() but doesn't declare a dependency on the org.eclipse.core.runtime.compatibility plug-in (as required by the Javadoc).I'll fix this right away.
464802,4/16/2015 10:18,sarika.sinha,Check org.eclipse.jdt.launching for further references to org.eclipse.core.runtime.compatibility* bundles While starting to run our tests for Gerrit changes we got two test failures which were caused by the missing 'org.eclipse.core.runtime.compatibility' bundle.I replaced the deprecated code that caused the failures but we have to investigate whether other stuff is used from the compatibility layer.
464974,4/20/2015 3:01,markus.kell.r,"GVT45:(Bidi) Wrong display of file path including bidi data on External Annotation Attachment Configuration panel Created attachment 252524Wrong display of file path including bidi data_Dynamic casesBuild ID: I20150320-0800Steps to reproduce: 1.Click Window -> Preferences 2.Expand Java -> Installed JREs 3.Select the installed JRE and Click Edit 4.Select the ""External annotations:(none)"" under rt.jar and Click External annotations button 5.Click Browse... 6.Select the folder including bidi data Problem Description:Wrong display of structured text (file path) including bidi data on External Annotation Attachment Configuration panel.Platform provides following level of support for structured text:1. Dynamic cases (editable controls like input fields combo box etc.) Use following API (from org.eclipse.jface.util.BidiUtils package) in the appropriate graphical context (label field):BidiUtils.applyBidiProcessing(sourceField StructuredTextTypeHandlerFactory.FILE); sourceField is the control in which file path appears.2. Static cases (not editable controls like labels)One need to work on the string level (rather than on graphical control level). You should use function leanToFullText defined in the class: org.eclipse.equinox.bidi.internal.StructuredTextImpl. Sample call : resultStr = STextExpertFactory.getExpert(STextTypeHandlerFactory.FILE).leanToFullText (inputStr)Please help investigate.Thanks."
464977,4/20/2015 3:32,jarthana,[compiler] Deprecated bit not set Created attachment 252526An example project@Deprecatedpublic class DeprecatedClass {}Compiling this class with the tycho-compiler-plugin I expect the deprecated bit to be set in the class file. But it isn't.
465521,4/27/2015 0:59,markus.kell.r,Many comparator errors in .class files in I20150426-2000 Full log at http://download.eclipse.org/eclipse/downloads/drops4/I20150426-2000/buildlogs/comparatorlogs/buildtimeComparatorUnanticipated.log.txtThe ones that concern me most are the .class files ones: . eclipse.jdt.debug/org.eclipse.jdt.debug.ui no-classifier: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different org/eclipse/jdt/debug/ui/launchConfigurations/AppletMainTab.class: different org/eclipse/jdt/debug/ui/launchConfigurations/JavaJRETab.class: different org/eclipse/jdt/debug/ui/launchConfigurations/JavaMainTab.class: different org/eclipse/jdt/internal/debug/ui/FilterLabelProvider.class: different org/eclipse/jdt/internal/debug/ui/JDIModelPresentation.class: different org/eclipse/jdt/internal/debug/ui/JavaSourceLocationWorkbenchAdapterFactory$SourceLocationPropertiesAdapter.class: different org/eclipse/jdt/internal/debug/ui/StorageEditorInput.class: different org/eclipse/jdt/internal/debug/ui/classpath/VariableClasspathEntryWorkbenchAdapter.class: different org/eclipse/jdt/internal/debug/ui/jres/ExecutionEnvironmentsLabelProvider.class: different org/eclipse/jdt/internal/debug/ui/jres/InstalledJREsBlock$VMLabelProvider.class: different org/eclipse/jdt/internal/debug/ui/jres/JREsLabelProvider.class: different org/eclipse/jdt/internal/debug/ui/jres/LibraryLabelProvider.class: different org/eclipse/jdt/internal/debug/ui/launcher/RuntimeClasspathEntryLabelProvider.class: different org/eclipse/jdt/internal/debug/ui/launcher/SourceElementLabelProvider.class: different org/eclipse/jdt/internal/debug/ui/launcher/SourceElementQualifierProvider.class: different org/eclipse/jdt/internal/debug/ui/snippeteditor/SelectImportsAction.class: different org/eclipse/jdt/internal/debug/ui/sourcelookup/WorkbenchAdapter.class: different snippetsupport.jar: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different classifier-sources: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different The main artifact has been replaced with the baseline version. The following attached artifacts have been replaced with the baseline version: [sources]4. eclipse.jdt.ui/org.eclipse.jdt.junit no-classifier: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different org/eclipse/jdt/internal/junit/buildpath/ClasspathVariableMarkerResolutionGenerator$1.class: different org/eclipse/jdt/internal/junit/ui/JUnitAddLibraryProposal.class: different org/eclipse/jdt/internal/junit/ui/JUnitClasspathFixProcessor$JUnitClasspathFixProposal.class: different org/eclipse/jdt/internal/junit/ui/JUnitPreferencePage.class: different org/eclipse/jdt/internal/junit/ui/JUnitQuickFixProcessor$AddAssertProposal.class: different classifier-sources: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different The main artifact has been replaced with the baseline version. The following attached artifacts have been replaced with the baseline version: [pack200 sources]7. eclipse.jdt.ui/org.eclipse.jdt.ui.tests no-classifier: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different org/eclipse/jdt/ui/examples/MyQuickAssistProcessor.class: different org/eclipse/jdt/ui/tests/search/TestLabelProvider.class: different classifier-sources: not present in baseline The main artifact has been replaced with the baseline version. The following attached artifacts have been replaced with the baseline version: [pack200] The following attached artifacts are not present in the baseline and have been removed: [sources]
465566,4/27/2015 8:15,eclipse,[organize imports] Organize imports does not remove duplicated imports Created attachment 252792Example project to reproduce the issueTo reproduce this bug please import the example and navigate to foo.MyClazz.When invoking organize imports you'll see that the unsed imports will stay.The referenced class bar.MyType is on classpath twice. Once in the project and once in a jar on the buildPath.
465630,4/27/2015 17:13,noopur_gupta,"[JUnit] ""Next/Previous Failed Test"" buttons enabled on ""Show Skipped Tests Only"" When Show Skipped Tests Only (bug 298603) is enabled in the JUnit view the ""Next/Previous Failed Test"" buttons don't work any more. They are enabled if the test run session had errors and they are disabled if all non-skipped tests are green.They at least need to be disabled when they don't work. A better solution would be to change them to ""Next/Previous Skipped Test"" in that case."
465657,4/28/2015 5:00,tmccrary,PNG icon for error_co_buildpath needs improvement Created attachment 252828Screenshot - error_co_buildpathSee attached screenshot. Left image is with gif and right image is with png.Looks like the red icon for error_co_buildpath no longer has a white background at the point where it intersects with the projects icon.
465669,4/28/2015 6:58,mateusz.matela,"NPE in WrapExecutor during Java text formatting Created attachment 252836Eclipse error log entryHiI've got a reproducible NPE when formatting the following code fragment (the real code obfuscated and reduced to the minimum that still causes an error):public class ffffffffffffffffff{ private static void test(String s) { dddd = (aaaaaaaaaaaaaaaaaaaaaaa.ffffffffffffffffff)new dddddddddddddddd() .ttt(null aaaaaaaaaaaaaaaaaaaaaaa.ffffffffffffffffff.class) .ttt(""bbbbbbb"" xxxxxxxxx.class) .ttt(""sssssssvvvvvvv"" new fffffffffff(""xxxx"") .add(""eeeeeeee"" aaaaaaaaaaaaaaaaaaaaaaa.ffffffffffffffffff.ssssssssssssss.class) .add(""cccccccccc"" aaaaaaaaaaaaaaaaaaaaaaa.ffffffffffffffffff.wwwwwwwwwwwwwwww.class) ) .bbbbbbbbbbb(s); } }If I change the code slightly for example change the 'dddd' to just 'd' the formatting completes normally.This problem occurs only if I use my own code formatter profile (see below). It does not happen with any of Eclipse built-in formatting profiles.The problems occurs regardless of am I doing the formatting in Eclipse IDE or programmatically with org.eclipse.jdt.core.formatter.CodeFormatter.My Eclipse formatting profile exported:<?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?><profiles version=""12""><profile kind=""CodeFormatterProfile"" name=""My"" version=""12""><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_ellipsis"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.blank_lines_after_imports"" value=""1""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.comment.format_javadoc_comments"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.indentation.size"" value=""2""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.disabling_tag"" value=""@formatter:off""/><setting id=""org.eclipse.jdt.core.formatter.continuation_indentation"" value=""2""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_enum_constants"" value=""0""/><setting id=""org.eclipse.jdt.core.formatter.blank_lines_before_imports"" value=""1""/><setting id=""org.eclipse.jdt.core.formatter.blank_lines_after_package"" value=""1""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_binary_operator"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.comment.indent_root_tags"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.enabling_tag"" value=""@formatter:on""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line"" value=""false""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations"" value=""1""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column"" value=""false""/><setting id=""org.eclipse.jdt.core.compiler.problem.enumIdentifier"" value=""error""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.indent_statements_compare_to_block"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration"" value=""end_of_line""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.comment.line_length"" value=""80""/><setting id=""org.eclipse.jdt.core.formatter.use_on_off_tags"" value=""false""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments"" value=""false""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.brace_position_for_method_declaration"" value=""end_of_line""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_union_type_in_multicatch"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body"" value=""0""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line"" value=""false""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_binary_expression"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.brace_position_for_block"" value=""end_of_line""/><setting id=""org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration"" value=""end_of_line""/><setting id=""org.eclipse.jdt.core.formatter.brace_position_for_lambda_body"" value=""end_of_line""/><setting id=""org.eclipse.jdt.core.formatter.compact_else_if"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration"" value=""16""/><setting id=""org.eclipse.jdt.core.compiler.problem.assertIdentifier"" value=""error""/><setting id=""org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment"" value=""false""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment"" value=""false""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_binary_operator"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_unary_operator"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve"" value=""1""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_ellipsis"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_try_resources"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.comment.format_line_comments"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.align_type_members_on_columns"" value=""false""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_assignment"" value=""0""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration"" value=""0""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_conditional_expression"" value=""80""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line"" value=""false""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration"" value=""end_of_line""/><setting id=""org.eclipse.jdt.core.formatter.brace_position_for_block_in_case"" value=""end_of_line""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.comment.format_header"" value=""false""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while"" value=""insert""/><setting id=""org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode"" value=""enabled""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_method_declaration"" value=""0""/><setting id=""org.eclipse.jdt.core.formatter.join_wrapped_lines"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration"" value=""end_of_line""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_resources_in_try"" value=""80""/><setting id=""org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations"" value=""false""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column"" value=""false""/><setting id=""org.eclipse.jdt.core.compiler.source"" value=""1.8""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.tabulation.size"" value=""2""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.comment.format_source_code"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_try"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_try_resources"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.blank_lines_before_field"" value=""0""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer"" value=""2""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.blank_lines_before_method"" value=""1""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.compiler.codegen.targetPlatform"" value=""1.8""/><setting id=""org.eclipse.jdt.core.formatter.brace_position_for_switch"" value=""end_of_line""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_after_type_annotation"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.comment.format_html"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_compact_if"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.indent_empty_lines"" value=""false""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_unary_operator"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation"" value=""0""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line"" value=""false""/><setting id=""org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch"" value=""false""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk"" value=""1""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_after_label"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.blank_lines_before_member_type"" value=""1""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_semicolon"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_try"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.comment.format_block_comments"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_lambda_arrow"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line"" value=""false""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.indent_statements_compare_to_body"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.alignment_for_multiple_fields"" value=""16""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.brace_position_for_array_initializer"" value=""end_of_line""/><setting id=""org.eclipse.jdt.core.formatter.wrap_before_binary_operator"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.compiler.compliance"" value=""1.8""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.brace_position_for_enum_constant"" value=""end_of_line""/><setting id=""org.eclipse.jdt.core.formatter.brace_position_for_type_declaration"" value=""end_of_line""/><setting id=""org.eclipse.jdt.core.formatter.blank_lines_before_package"" value=""0""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_lambda_arrow"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.join_lines_in_comments"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional"" value=""insert""/><setting id=""org.eclipse.jdt.core.formatter.comment.indent_parameter_description"" value=""true""/><setting id=""org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.tabulation.char"" value=""space""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.blank_lines_between_import_groups"" value=""1""/><setting id=""org.eclipse.jdt.core.formatter.lineSplit"" value=""80""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation"" value=""do not insert""/><setting id=""org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch"" value=""insert""/></profile></profiles>"
465788,4/29/2015 6:12,noopur_gupta,Update JDT Tips & Tricks for Mars (4.5) Update JDT T&T document with relevant items from Mars (4.5) N&N documents.
465900,4/30/2015 5:30,sasikanth.bharadwaj,"Internal compiler error: java.lang.IllegalArgumentException: info cannot be null at org.eclipse.jdt.internal.compiler.codegen.StackMapFrame.addStackItem(StackMapFrame.java:81) Created attachment 252943small showcase for the internal compiler errorWhen trying to compile the attached project (only 2 classes) with the latest 4.5 drop I get the following stacktrace in the compiler:java.lang.IllegalArgumentException: info cannot be null	at org.eclipse.jdt.internal.compiler.codegen.StackMapFrame.addStackItem(StackMapFrame.java:81)	at org.eclipse.jdt.internal.compiler.ClassFile.traverse(ClassFile.java:5573)	at org.eclipse.jdt.internal.compiler.ClassFile.generateStackMapTableAttribute(ClassFile.java:4332)	at org.eclipse.jdt.internal.compiler.ClassFile.completeCodeAttribute(ClassFile.java:1387)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:357)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:281)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:567)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:636)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:368)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1217)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:690)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:535)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:528)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:471)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:461)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:161)	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:273)	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367)	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349)	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:372)	at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:332)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)Information about my install:eclipse.buildId=4.5.0.I20150428-2000java.version=1.8.0_45java.vendor=Oracle CorporationBootLoader constants: OS=linux ARCH=x86_64 WS=gtk NL=en_USCommand-line arguments: -os linux -ws gtk -arch x86_64"
465910,4/30/2015 6:03,mateusz.matela,[formatter] add a 'wrap before operator' option for conditional expressions In the 'Line wrapping' tab 'Expressions' menu the 'Conditionals' settings do not allow to wrap the line after the '?' and ':' operators. There is a 'wrap before operator' setting for Binary expressions that can be unset and another one for multi-catch statements but it is not possible to unset this for conditional expressions: wrapping is always done before the operator never after.When people use a wrap after operator policy they often intend to use it for all kind of operators. The checkstyle tool Wrap Operator Policy does not distinguish between different uses. This means that is you set it to eol (operators are at the end of the line and wrapping occurs after them) then you set it also for conditionals expressions. With the current [formatter] setting you cannot do that for conditionals even if you did it for binary expressions and multi-catch statements.This is the same as bug #325631 but for conditionals. This is however a different bug than #459304.
465925,4/30/2015 7:57,jarthana,"[completion] Wrong toString() output in InternalCompletionProposal for METHOD_NAME_REFERENCE InternalCompletionProposal.toString:case CompletionProposal.METHOD_NAME_REFERENCE : buffer.append(""METHOD_IMPORT""); //$NON-NLS-1$break;should be:case CompletionProposal.METHOD_NAME_REFERENCE : buffer.append(""METHOD_NAME_REFERENCE""); //$NON-NLS-1$break;The codes are different and while debugging this takes you to the wrong track."
466252,5/4/2015 2:44,jarthana,"[templates] new 'finally' template does not appear when there's no catch block I20150503-2000.The new 'finally' template introduced via bug 184222 does not work when there's no catch block:	void foo() {		try {		} f<Ctrl+Space>	}"
466307,5/4/2015 8:51,markus.kell.r,"Icon missing for ""New JUnit Test Case"" action in main toolbar drop-down The ""New JUnit Test Case"" action in the drop-down menu of the main toolbar action ""New Java Class"" is missing an icon. Red placeholder is drawn."
466452,5/5/2015 11:06,Michael_Rennie,"JDT step filters don't work if a step filter is contributed 4.5 M7.JDT step filters don't work if there's a step filter is contributed.IMPORTANT NOTE: Close all Debug test projects as they also contribute step filters.4.5 M7.The stepFilters extension point does not seem to work.1. add this extension: <extension point=""org.eclipse.debug.core.stepFilters""> <stepFilter class=""tests.stepfilters.TestStepFilter"" modelIdentifier=""org.eclipse.jdt.debug""> </stepFilter> </extension> 2. create the 'TestStepFilter' that always returns 'true' and put a breakpoint there3. start to debug a new target workspace4. paste this into 'Package Explorer':	public static void main(String[] args) {		System.out.println();		C c= new C();		c.getS();		c.setS(""2"");		System.out.println();	}5. put a breakpoint on first line6. enable step filtering and enable to filter constructors simple getters and simple setters7. start debugging ==> stops at breakpoint on first line8. click Step Over9. click 'Step Into' ==> breakpoint in dev workspace is hit: 'true' is returned - resumeNow I would expect that it goes to line two but instead it steps into #C()And actually I would even expect this without enabling the filter for constructors because the contributed filter should always filter everything.And more fun: if one changes the contributed filter to return 'false' the JDT filters work again!"
466471,5/5/2015 12:31,markus.kell.r,"update dependency on JDT/Core o.e.jdt.ui still states:Require-Bundle: ... org.eclipse.jdt.core;bundle-version=""[3.10.04.0.0)""Shouldn't this be bumped up to 3.11.0 to avoid issues like bug 466380?The JDT feature only ensures compatible versions on fresh install but people seem to be able to replace JDT/Core with an older version without any complaints from p2.I don't know the exact installation steps from bug 466380 but a stricter requirement on jdt.ui would seem to avoid some issues in the field no?"
466512,5/6/2015 2:03,markus.kell.r,"Unexpected runtime error while computing a text hover (method reference with capture in type parameter bounds) The following code results in an unexpected runtime error when one hovers over ""testMethod"" in ""t.testMethod(null)"":--------------------------------public class HoverTest<T> {	static class TestClass<T>{		<S extends T> TestClass<S> testMethod(Class<S> c){			return null;		}	}	void test(TestClass<? super T> t){		t.testMethod(null);	}}--------------------------------Steps to reproduce:(1) Compile the above class(2) Try to hover over ""testMethod"" in ""t.testMethod(null)""Result:No method hover is shown.The following error is added to the error log:eclipse.buildId=4.4.2.M20150204-1700java.version=1.8.0_45java.vendor=Oracle CorporationBootLoader constants: OS=win32 ARCH=x86 WS=win32 NL=de_ATFramework arguments: -product org.eclipse.epp.package.rcp.productCommand-line arguments: -os win32 -ws win32 -arch x86 -product org.eclipse.epp.package.rcp.productorg.eclipse.jface.textErrorWed May 06 07:32:13 CEST 2015Unexpected runtime error while computing a text hoverjava.lang.IllegalArgumentException	at org.eclipse.jdt.core.Signature.getTypeParameters(Signature.java:2374)	at org.eclipse.jdt.internal.core.util.KeyToSignature.consumeParameterizedGenericMethod(KeyToSignature.java:118)	at org.eclipse.jdt.internal.core.util.BindingKeyParser.parseParameterizedMethod(BindingKeyParser.java:768)	at org.eclipse.jdt.internal.core.util.BindingKeyParser.parseMethod(BindingKeyParser.java:839)	at org.eclipse.jdt.internal.core.util.BindingKeyParser.parse(BindingKeyParser.java:670)	at org.eclipse.jdt.internal.core.util.BindingKeyParser.parse(BindingKeyParser.java:618)	at org.eclipse.jdt.internal.core.util.BindingKeyParser.parseTypeWithCapture(BindingKeyParser.java:1000)	at org.eclipse.jdt.internal.core.util.BindingKeyParser.parse(BindingKeyParser.java:688)	at org.eclipse.jdt.internal.core.util.BindingKeyParser.parse(BindingKeyParser.java:618)	at org.eclipse.jdt.core.BindingKey.toSignature(BindingKey.java:334)	at org.eclipse.jdt.internal.ui.viewsupport.JavaElementLabelComposer.appendMethodLabel(JavaElementLabelComposer.java:337)	at org.eclipse.jdt.internal.ui.viewsupport.JavaElementLabelComposer.appendElementLabel(JavaElementLabelComposer.java:272)	at org.eclipse.jdt.internal.ui.viewsupport.JavaElementLinks.getElementLabel(JavaElementLinks.java:704)	at org.eclipse.jdt.internal.ui.viewsupport.JavaElementLinks.getElementLabel(JavaElementLinks.java:686)	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:737)	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:683)	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:607)	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:599)	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:129)	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:85)	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:166)------------------------------------Additional information:- Replacing either ""<S extends T>"" with just ""<S>"" or ""TestClass<? super T>"" with just ""<T>"" causes the bug to disappear.- The argument ""Class<S> c"" is actually not necessary to reproduce the bug.- Perhaps somehow related to bug 384234? (but it has a different stack trace)"
466556,5/6/2015 6:51,register.eclipse,"[null][1.8] Incorrect null analysis for ""unconstrained"" type parameters This doc [1] says ""A type variable corresponding to an unconstrained type parameter requires pessimistic checking in order to guarantee safety with all legal substitutions: this type can neither be assumed to be nullable nor nonnull.""With this example: class C<T extends Number> { int consume(T t) { return t.intValue(); // NOT OK since T could be nullable } T provide() { return null; // NOT OK since T could require nonnull } }However the first method compiled perfectly fine in the current null analysis implementation.Tested under Luna 4.4.2 and Mars Milestone 6 (4.5.0M6) 20150326-0744. With Maven package 'org.eclipse.jdt:org.eclipse.jdt.annotation:2.0.0'.[1]: http://help.eclipse.org/luna/topic/org.eclipse.jdt.doc.user/tasks/task-using_null_type_annotations.htm?cp=25_3_9_1_0_1#typeVariables"
466578,5/6/2015 8:50,Lars.Vogel,"Menu icon missing in Quick outline Eclipse 4.5.I20150505-2000- Press Ctrl+O in a .java file to invoke Quick Outline.- Quick outline popup is missing the menu icon at the top-right which is shown as a red placeholder.Also the following warnings are logged in Error log view for ""images/popup_menu_disabled.png"" and ""images/popup_menu.png"":nullorg.eclipse.jfaceWarningWed May 06 18:12:25 IST 2015The image could not be loaded: FileImageDescriptor(location=class org.eclipse.jface.dialogs.PopupDialog name=images/popup_menu_disabled.png)org.eclipse.jface.resource.DeviceResourceException: Unable to create resource FileImageDescriptor(location=class org.eclipse.jface.dialogs.PopupDialog name=images/popup_menu_disabled.png)	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:166)	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:52)	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:86)	at org.eclipse.jface.resource.ResourceManager.createImageWithDefault(ResourceManager.java:192)	at org.eclipse.jface.resource.ImageRegistry.get(ImageRegistry.java:214)	at org.eclipse.jface.resource.JFaceResources.getImage(JFaceResources.java:387)	at org.eclipse.jface.dialogs.PopupDialog.createDialogMenu(PopupDialog.java:935)	at org.eclipse.jface.dialogs.PopupDialog.createTitleMenuArea(PopupDialog.java:814)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl.createTitleMenuArea(AbstractInformationControl.java:805)	at org.eclipse.jface.dialogs.PopupDialog.createContents(PopupDialog.java:686)	at org.eclipse.jface.window.Window.create(Window.java:430)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl.<init>(AbstractInformationControl.java:192)	at org.eclipse.jdt.internal.ui.text.JavaOutlineInformationControl.<init>(JavaOutlineInformationControl.java:540)	at org.eclipse.jdt.ui.text.JavaSourceViewerConfiguration$6.createInformationControl(JavaSourceViewerConfiguration.java:769)	at org.eclipse.jface.text.AbstractInformationControlManager.getInformationControl(AbstractInformationControlManager.java:819)	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1168)	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1150)	at org.eclipse.jface.text.AbstractInformationControlManager.setInformation(AbstractInformationControlManager.java:418)	at org.eclipse.jface.text.information.InformationPresenter.computeInformation(InformationPresenter.java:355)	at org.eclipse.jface.text.AbstractInformationControlManager.doShowInformation(AbstractInformationControlManager.java:1131)	at org.eclipse.jface.text.AbstractInformationControlManager.showInformation(AbstractInformationControlManager.java:1121)	at org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.doOperation(JavaSourceViewer.java:184)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:197)	at org.eclipse.ui.texteditor.TextOperationAction$1.run(TextOperationAction.java:128)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ui.texteditor.TextOperationAction.run(TextOperationAction.java:126)	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122)	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:601)	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56)	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:252)	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:234)	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:493)	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:486)	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1266)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1112)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108)	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1529)	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4773)	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:343)	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4654)	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5050)	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3767)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:654)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:601)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)	at org.eclipse.equinox.launcher.Main.run(Main.java:1499)"
466675,5/7/2015 3:04,markus.kell.r,"A number of ""class file"" comparator errors in I20150506-2000 Seehttp://download.eclipse.org/eclipse/downloads/drops4/I20150506-2000/buildlogs/comparatorlogs/buildtimeComparatorUnanticipated.log.txtI did update the compiler since last I-build ... but will try to attach some ""diffs"" to see if it a difference in string constants or similar again. = = = = = Comparator differences from current build	/shared/eclipse/builds/4I/siteDir/eclipse/downloads/drops4/I20150506-2000compared to reference repo at 	http://download.eclipse.org/eclipse/updates/4.5-I-builds1. eclipse.platform.ui/bundles/org.eclipse.e4.core.commands no-classifier: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different org/eclipse/e4/core/commands/CommandServiceAddon.class: different classifier-sources: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different The main artifact has been replaced with the baseline version. The following attached artifacts have been replaced with the baseline version: [pack200 sources]2. eclipse.platform.ua/org.eclipse.help.ui no-classifier: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different org/eclipse/help/ui/internal/DefaultHelpUI.class: different org/eclipse/help/ui/internal/ShowInTocAction$1.class: different org/eclipse/help/ui/internal/views/BrowserPart.class: different org/eclipse/help/ui/internal/views/HelpView.class: different org/eclipse/help/ui/internal/views/SearchResultsPart.class: different org/eclipse/help/ui/internal/views/SeeAlsoPart$2.class: different classifier-sources: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different The main artifact has been replaced with the baseline version. The following attached artifacts have been replaced with the baseline version: [pack200 sources]3. eclipse.platform.ua/org.eclipse.ui.cheatsheets no-classifier: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different org/eclipse/ui/cheatsheets/OpenCheatSheetAction.class: different org/eclipse/ui/internal/cheatsheets/views/CheatSheetViewer.class: different classifier-sources: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different The main artifact has been replaced with the baseline version. The following attached artifacts have been replaced with the baseline version: [pack200 sources]4. eclipse.jdt.debug/org.eclipse.jdt.debug.ui no-classifier: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different org/eclipse/jdt/debug/ui/launchConfigurations/AppletMainTab.class: different org/eclipse/jdt/debug/ui/launchConfigurations/JavaConnectTab.class: different org/eclipse/jdt/debug/ui/launchConfigurations/JavaMainTab.class: different snippetsupport.jar: different META-INF/ECLIPSE_.RSA: different classifier-sources: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different The main artifact has been replaced with the baseline version. The following attached artifacts have been replaced with the baseline version: [sources]5. eclipse.platform.team/bundles/org.eclipse.team.cvs.core no-classifier: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different org/eclipse/team/internal/ccvs/core/resources/RemoteModule.class: different classifier-sources: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different The main artifact has been replaced with the baseline version. The following attached artifacts have been replaced with the baseline version: [pack200 sources]6. eclipse.platform.team/bundles/org.eclipse.team.cvs.ui no-classifier: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different org/eclipse/team/internal/ccvs/ui/operations/DiffOperation.class: different classifier-sources: different META-INF/ECLIPSE_.RSA: different META-INF/ECLIPSE_.SF: different The main artifact has been replaced with the baseline version. The following attached artifacts have been replaced with the baseline version: [pack200 sources]"
466730,5/7/2015 9:22,sasikanth.bharadwaj,"Java 8: single method with generics is ambiguous when using import static ...* and inheritance DESCRIPTION:In Java 8 you get the error Message ""The method fails() is ambiguous for the type StaticImportBug?? for the following code:package bug;public class Base {	public static Object works() { throw new IllegalStateException();			} public static <T> T fails() { throw new IllegalStateException(); }}-??????????????????????????????package bug;public class Derived extends Base {}??????????????????????????????????????package bug;import static bug.Base.*;import static bug.Derived.*;public class StaticImportBug {	void m() {		java.util.Objects.requireNonNull(works());		java.util.Objects.requireNonNull(fails());	}}WORKAROUND: organize imports.(Real-Life example: Base= org.mockito.Matchers Derived=org.mockito.Mockito Method=any())"
466748,5/7/2015 11:15,Olivier_Thomann,"VerifyError when casting a MethodHandle#invoke() argument The following code results in a VerifyError:------------------------------import java.lang.invoke.MethodHandle;import java.lang.invoke.MethodHandles;import java.lang.reflect.Method;public class Test {	public static void test1(Integer i){		System.out.println(""test1:"" + i);	}	public static void test2(int i){		System.out.println(""test2:"" + i);	}	public static void main(String[] args) throws Throwable{		Method m1 = Test.class.getMethod(""test1"" Integer.class);		Method m2 = Test.class.getMethod(""test2"" int.class);		MethodHandle test1Handle = MethodHandles.lookup().unreflect(m1);		MethodHandle test2Handle = MethodHandles.lookup().unreflect(m2);				Integer arg_Integer = 1;		int arg_int = 1;				// results in a java.lang.VerifyError - but should work without error		test1Handle.invokeExact(Integer.class.cast(arg_int));				// The following line also results in a java.lang.VerifyError but should actually throw a ClassCastException		// test2Handle.invokeExact(int.class.cast(arg_Integer)); 			}}---------------------------------Steps to reproduce: compile and run the above codeResult: The JVM crashes:Exception in thread ""main"" java.lang.VerifyError: Bad type on operand stackException Details: Location: test/Test.main([Ljava/lang/String;)V @72: invokevirtual Reason: Type 'java/lang/Object' (current frame stack[1]) is not assignable to 'java/lang/Integer' Current Frame: bci: @72 flags: { } locals: { '[Ljava/lang/String;' 'java/lang/reflect/Method' 'java/lang/reflect/Method' 'java/lang/invoke/MethodHandle' 'java/lang/invoke/MethodHandle' 'java/lang/Integer' integer } stack: { 'java/lang/invoke/MethodHandle' 'java/lang/Object' } Bytecode: 0x0000000: 1201 1239 04bd 003a 5903 123c 53b6 003e 0x0000010: 4c12 0112 4204 bd00 3a59 03b2 0043 53b6 0x0000020: 003e 4db8 0047 2bb6 004d 4eb8 0047 2cb6 0x0000030: 004d 3a04 04b8 0053 3a05 0436 062d 123c 0x0000040: 1506 b800 53b6 0057 b600 5bb1 	at java.lang.Class.getDeclaredMethods0(Native Method)	at java.lang.Class.privateGetDeclaredMethods(Class.java:2699)	at java.lang.Class.privateGetMethodRecursive(Class.java:3046)	at java.lang.Class.getMethod0(Class.java:3016)	at java.lang.Class.getMethod(Class.java:1782)	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)-----------------------------Additional Information:- The code compiles and works fine with javac- The commented out invokation of ""test2"" also results in a VerifyError but should throw a ClassCastException instead (at least this is what javac does).- Same outcome when calling ""invoke"" instead of ""invokeExact"""
466944,5/11/2015 0:54,jarthana,[BETA_JAVA9] Make JDT Core tests run with JDK 9 JDT core's test framework needs changes to be able to run with JDK 9. The test frame work makes some assumptions about the JDK resources and quite a few tests are failing with JDK 9. The tests should be fixed to work with JDK 9 and below.
467229,5/13/2015 10:26,mateusz.matela,"[formatter] Indentation problems after changing tab size with 'Tabs only' policy Eclipse Mars M7.Changing Java formatter tab size from 3 to 4 and pressing ctrl-alt-f causes the tabs to no longer indent after the 4th column. Steps to reproduce:Used the ""Eclipse [build-in]"" profile as base and modified tab size from 4 to 3.baseline size = 4package abc;import java.util.Arrays;public class Test {	public static void main(String[] args) {		for (String a : Arrays.asList(""a"" ""b"")) {			if (a.equals(""c"")) {				System.out.println(""d"");				if (a.equalsIgnoreCase(""d"")) {					System.out.println(""f"");				}			}		}	}}changed size = 3 press ctrl-alt-fpackage abc;import java.util.Arrays;public class Test {	public static void main(String[] args) {		for (String a : Arrays.asList(""a"" ""b"")) {			if (a.equals(""c"")) {			System.out.println(""d"");			if (a.equalsIgnoreCase(""d"")) {				System.out.println(""f"");			}			}		}	}}expected resultspackage abc;import java.util.Arrays;public class Test {	public static void main(String[] args) {		for (String a : Arrays.asList(""a"" ""b"")) {			if (a.equals(""c"")) {				System.out.println(""d"");				if (a.equalsIgnoreCase(""d"")) {					System.out.println(""f"");				}			}		}	}}"
467243,5/13/2015 11:07,markus.kell.r,Remove unused icons callee_co.png & caller_co.png Remove unused icons callee_co.png & caller_co.pngThe have once been used in the Call Hierarchy view but they were removed quite some time ago.
467421,5/15/2015 12:49,noopur_gupta,"[1.8][mark occurrence] Mark Exception Occurrences doesn't highlight thrower inside lambda expression Created attachment 253512Screenshot demonstrating Highlight Exception Occurrences bugIf you click on the Exception inside a catch block it should highlight the expressions that throw the exception. This doesn't work inside lambda expressions. For example in the code below if you click on the first FileNotFoundException it highlights FileInputStream but if you click on the second FileNotFoundException it highlights the first FileNotFoundException. See the attached screen shot.Runnable inner = new Runnable() {	@Override	public void run() {		try {			new FileInputStream(""dummy"");		} catch (FileNotFoundException e) {		}	}};Runnable lambda = () -> {	try {		new FileInputStream(""dummy"");	} catch (FileNotFoundException e) {	}};"
467430,5/15/2015 15:59,register.eclipse,"[null][1.8] Confusing error message with known null value DESCRIPTION:with the following code:public class A {	@org.eclipse.jdt.annotation.NonNullByDefault	void m(java.util.@org.eclipse.jdt.annotation.Nullable Map<String Integer> map) {	}	void m2(A a) {		final java.util.Map<String Integer> v = null;		a.m(v);	}}you get the following confusing error message regarding the ""a.m(v)"" statement:""Null type mismatch: required '@Nullable Map<@NonNull String@NonNull Integer>' but the provided value is null""ANALYSIS:In org.eclipse.jdt.internal.compiler.problem.ProblemReporter.nullityMismatchingTypeAnnotation(Expression TypeBinding TypeBinding NullAnnotationMatching)the first ""if"" doesnt check if the required type is NonNull at all.I'll send a patch via gerrit."
467482,5/18/2015 4:27,register.eclipse,"[null][1.8] Incorrect ""Redundant null check""-warning DESCRIPTION:In the following code an incorrect ??Redundant null check??-warning appears for the ""if (winner == null)"".public abstract class Util {	public static <T> @org.eclipse.jdt.annotation.Nullable T f(T[] valuesArray java.util.Comparator<T> comparator) {		@org.eclipse.jdt.annotation.Nullable		T winner = null;		for (T value : valuesArray) {			if (winner == null) {				winner = value;			} else {				if (comparator.compare(winner value) < 0) {					winner = value;				}			}		}		return winner;	}}ANALYSIS:Because of the (necessary) @Nullable of winner the assignments of value to winner get marked as POTENTIALLY_NULL in org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.checkAssignment(BlockScope FlowContext VariableBinding FlowInfo int Expression TypeBinding).But in org.eclipse.jdt.internal.compiler.flow.UnconditionalFlowInfo.addPotentialNullInfoFrom(UnconditionalFlowInfo)def. null + pot. null =>??def. null(as documented and testable via see??org.eclipse.jdt.core.tests.compiler.regression.NullReferenceImplTransformations.addPotentialInitializationsFrom)SUGGESTED FIX:Change NullAnnotationMatching.checkAssignment so it marks this case as POTENTIALLY_NULL | POTENTIALLY_UNKNOWN which still makes sense and gets mapped by UnconditionalFlowInfo.addPotentialNullInfoFrom according to:def. null + pot. n & pot. un => pot. n & pot. unI??ll upload the patch via gerrit."
467618,5/19/2015 16:59,mateusz.matela,"[formater] Empty lines should not affect indentation of wrapped elements The old formatter's implementation didn't indent wrapped elements if they were preceded with an empty line (except for elements wrapped with ""force split"" wrapping policy).Attempts have been made to duplicate this behavior but it leads to some problems - more details in bug 458208 comment 34. With this and the fact that it's probably not a desired feature anyway let's change the formatter to always properly indent wrapped elements."
467718,5/20/2015 10:34,sarika.sinha,Remove method org.eclipse.jdt.internal.debug.core.model.JDIThread.StepHandler.locationIsFiltered(Method) New Method org.eclipse.jdt.internal.debug.core.model.JDIThread.StepHandler.locationIsFiltered(Method boolean) has been added and the old method can be removed.
467776,5/20/2015 19:03,sasikanth.bharadwaj,"[compiler][implementation] decouple method verification from bridge method generation The conflict between bug 438812 and bug 461529 tells me that we are interpreting too much different information into the field MethodVerifier.inheritedMethods:- for the original purpose (as represented by bug 461529) we want to use this data to analyse inheritance & overriding vs. abstractness covariance and such.- for the sake of bug 438812 et al we want use use this data to determine which bridge methods need to be created.It turns out we need to create bridge methods for methods which are not ""inherited"" by the current class because they are (covariantly) overridden somewhere along the path.IMHO we should stop coding between the lines but update our data structure to better reflect the underlying requirements. Maybe ""decouple"" in the bug title isn't an exact name for what we need but I can't really tell before having tried it."
467825,5/21/2015 5:20,sasikanth.bharadwaj,Missing code implementation in the compiler Compilation of this code fails in Eclipse:import java.util.function.Function;public class Main { public static Function<String String> f(int x) { class A { void g() { System.out.println(x); } } return s -> { A a = new A(); return s; }; }}
467845,5/21/2015 8:16,markus.kell.r,"Long sequence of ""Unable to install breakpoint"" dialogs Created attachment 253633ScreenshotI20150520-2000 maybe fallout from bug 462932In my main development workspace:- had ""Skip All Breakpoints"" enabled- launched a runtime workbench- disabled ""Skip All Breakpoints""=> Got a long sequence of ""Unable to install breakpoint"" dialogs. I've never seen that before and the user experience is pretty bad: I'm forced to check the ""Don't tell me again"" checkbox.I can reproduce when I enable the warning again on Preferences > Java > Debug. Here's the dialog:java.lang.Exception: Stack Trace at org.eclipse.swt.internal.win32.OS.PeekMessageW(Native Method) at org.eclipse.swt.internal.win32.OS.PeekMessage(OS.java:3141) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764) at org.eclipse.jface.window.Window.runEventLoop(Window.java:827) at org.eclipse.jface.window.Window.open(Window.java:803) at org.eclipse.jface.dialogs.ErrorDialog.open(ErrorDialog.java:347) at org.eclipse.jdt.internal.debug.ui.NoLineNumberAttributesStatusHandler$1.run(NoLineNumberAttributesStatusHandler.java:42) at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:162) at org.eclipse.ui.internal.UISynchronizer$3.run(UISynchronizer.java:154) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4155) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3772) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018)..."
468127,5/24/2015 8:04,manpalat,NullPointerException in JavaSearchScope.getPath (474) This problem seems to aggregate several paths to the same underlying issue a NPE in JavaSearchScope.getPath. Check the similar incidents page for similar traces.Two comments have been posted:Marcel Bruch < marcel.bruch@codetrails.com> wrote on incident 020d:15-05-06 17:21:48I triggered find referenced on a Java 8 Consumer#accept methodMarcel Bruch (RC1 Confess) < marcel.bruch@codetrails.com> wrote on incident d97c:15-05-24 14:00:15Searching for PrintStream.println(). Then I CallHierarchy switching search scope from workspace to projects. Then this exception occurred.The following incident was reported via the automated error reporting: code: 10001 plugin: org.eclipse.jdt.ui_3.10.100.v20150116-1347 message: Internal Error fingerprint: 2f050efd exception class: java.lang.reflect.InvocationTargetException exception message: - number of children: 0 java.lang.reflect.InvocationTargetException: null at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:420) at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2138) at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2134) at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:191) at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:151) at org.eclipse.jdt.ui.refactoring.RenameSupport.perform(RenameSupport.java:198) at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameLinkedMode.doRename(RenameLinkedMode.java:362) at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameLinkedMode$EditorSynchronizer.left(RenameLinkedMode.java:119) at org.eclipse.jface.text.link.LinkedModeModel.exit(LinkedModeModel.java:341) at org.eclipse.jface.text.link.LinkedModeUI$4.run(LinkedModeUI.java:1193) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:136) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4147) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3764) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:648) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:592) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) at sun.reflect.NativeMethodAccessorImpl.invoke0(null:-2) at sun.reflect.NativeMethodAccessorImpl.invoke(null:-1) at sun.reflect.DelegatingMethodAccessorImpl.invoke(null:-1) at java.lang.reflect.Method.invoke(null:-1) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1465)caused by: java.lang.NullPointerException: null at org.eclipse.jdt.internal.core.search.JavaSearchScope.getPath(JavaSearchScope.java:474) at org.eclipse.jdt.internal.core.search.JavaSearchScope.getPath(JavaSearchScope.java:490) at org.eclipse.jdt.internal.core.search.JavaSearchScope.getPath(JavaSearchScope.java:490) at org.eclipse.jdt.internal.core.search.JavaSearchScope.encloses(JavaSearchScope.java:463) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.encloses(MatchLocator.java:776) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2324) at org.eclipse.jdt.internal.core.search.matching.MemberDeclarationVisitor.visit(MemberDeclarationVisitor.java:214) at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.traverse(LambdaExpression.java:678) at org.eclipse.jdt.internal.compiler.ast.CastExpression.traverse(CastExpression.java:641) at org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse(MessageSend.java:1031) at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:355) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2398) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2952) at org.eclipse.jdt.internal.core.search.matching.MemberDeclarationVisitor.visit(MemberDeclarationVisitor.java:290) at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1374) at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse(QualifiedAllocationExpression.java:609) at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.traverse(FieldDeclaration.java:340) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2706) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2939) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2666) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1849) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1258) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1299) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1416) at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:122) at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232) at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516) at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584) at org.eclipse.jdt.internal.corext.refactoring.RefactoringSearchEngine.internalSearch(RefactoringSearchEngine.java:143) at org.eclipse.jdt.internal.corext.refactoring.RefactoringSearchEngine.search(RefactoringSearchEngine.java:130) at org.eclipse.jdt.internal.corext.refactoring.rename.RenameFieldProcessor.getReferences(RenameFieldProcessor.java:594) at org.eclipse.jdt.internal.corext.refactoring.rename.RenameFieldProcessor.doCheckFinalConditions(RenameFieldProcessor.java:448) at org.eclipse.jdt.internal.corext.refactoring.rename.JavaRenameProcessor.checkFinalConditions(JavaRenameProcessor.java:48) at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:224) at org.eclipse.ltk.core.refactoring.Refactoring.checkAllConditions(Refactoring.java:162) at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper$Operation.run(RefactoringExecutionHelper.java:80) at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39) at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2313) at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5409) at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106) at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:119) General Information: reported-by: anonymous-id: b0dd20ae-76a8-46eb-b969-65c59d8e1502 eclipse-build-id: 4.5.0.I20150203-1300 eclipse-product: org.eclipse.epp.package.java.product operating system: Windows8 6.2.0 (x86_64) - win32 jre-version: 1.8.0_45-b14The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.databinding.observable_1.4.1.v20140910-2107 2. org.eclipse.core.databinding_1.4.100.v20141002-1314 3. org.eclipse.core.resources_3.9.100.v20150114-1351 4. org.eclipse.core.runtime_3.10.0.v20150112-1422 5. org.eclipse.e4.ui.workbench_1.3.0.v20150113-2327 6. org.eclipse.e4.ui.workbench.swt_0.12.100.v20150114-0905 7. org.eclipse.equinox.app_1.3.200.v20130910-1609 8. org.eclipse.equinox.launcher_1.3.0.v20140415-2008 9. org.eclipse.jdt_3.11.0.v20150203-1300 10. org.eclipse.jdt.core_3.11.0.v20150126-2015 11. org.eclipse.jdt.ui_3.10.100.v20150116-1347 12. org.eclipse.jface_3.11.0.v20150121-1751 13. org.eclipse.jface.text_3.10.0.v20150112-1146 14. org.eclipse.ltk.core.refactoring_3.6.200.v20140826-0859 15. org.eclipse.swt_3.104.0.v20150203-2243 16. org.eclipse.ui_3.107.0.v20150107-0903 17. org.eclipse.ui.ide.application_1.0.600.v20150120-1542 18. org.eclipse.ui.ide_3.10.100.v20150126-1117Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.Other Resources:* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/553a60e7e4b026254ee06d72 * Manual: https://dev.eclipse.org/recommenders/community/confess/#/guideThank you for your assistance.Your friendly error-reports-inbox.
468252,5/26/2015 2:22,daniel_megert,"NullPointerException in JavaAppletLaunchConfigurationDelegate.buildHTMLFile (102) The following incident was reported via the automated error reporting: code: 2 plugin: org.eclipse.core.jobs_3.7.0.v20150316-1238 message: An internal error occurred during: ""Launching jiApplet"". fingerprint: 21971966 exception class: java.lang.NullPointerException exception message: - number of children: 0 java.lang.NullPointerException: null at java.io.FileOutputStream.<init>(FileOutputStream.java:203) at java.io.FileOutputStream.<init>(FileOutputStream.java:162) at org.eclipse.jdt.internal.launching.JavaAppletLaunchConfigurationDelegate.buildHTMLFile(JavaAppletLaunchConfigurationDelegate.java:102) at org.eclipse.jdt.internal.launching.JavaAppletLaunchConfigurationDelegate.getProgramArguments(JavaAppletLaunchConfigurationDelegate.java:326) at org.eclipse.jdt.launching.JavaLaunchDelegate.launch(JavaLaunchDelegate.java:64) at org.eclipse.jdt.internal.launching.JavaAppletLaunchConfigurationDelegate.launch(JavaAppletLaunchConfigurationDelegate.java:63) at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:885) at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:739) at org.eclipse.debug.internal.ui.DebugUIPlugin.buildAndLaunch(DebugUIPlugin.java:1039) at org.eclipse.debug.internal.ui.DebugUIPlugin$8.run(DebugUIPlugin.java:1256) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55) General Information: reported-by: Mat Jaggard anonymous-id: 23a63e0f-7cc7-4b62-b031-a77c94bb5b54 eclipse-build-id: 4.5.0.I20150320-0800 eclipse-product: org.eclipse.epp.package.jee.product operating system: Windows7 6.1.0 (x86_64) - win32 jre-version: 1.8.0_25-b18The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.jobs_3.7.0.v20150316-1238 2. org.eclipse.debug.core_3.10.0.v20150303-1130 3. org.eclipse.debug.ui_3.11.0.v20150303-1130 4. org.eclipse.jdt.launching_3.8.0.v20150316-0938 5. org.eclipse.jdt_3.11.0.v20150320-0800Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.Other Resources:* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/552e6583e4b026254ee046c3 * Manual: https://dev.eclipse.org/recommenders/community/confess/#/guideThank you for your assistance.Your friendly error-reports-inbox."
468260,5/26/2015 2:55,jarthana,[1.9] jrt visitor implementation should use package-module lookup Right now given a JDK 9 JDT has to look into every module (one by one) to find a type given its qualified name. Obviously this is not scalable but will change once the following enhancement is added in Oracle's JDK:https://bugs.openjdk.java.net/browse/JDK-8066492
468305,5/26/2015 8:56,daniel_megert,[common navigator] 'Non-Java projects' and 'Non-Java elements' filters hide Java projects in Project Explorer
468391,5/26/2015 15:37,Lars.Vogel,Remove outdated org.eclipse.jdt.ui/notes directory org.eclipse.jdt.ui/notes looks outdated and unused to me. Can this be removed?
468424,5/27/2015 2:07,Lars.Vogel,Add README.md (with content from the CONTRIBUTING.md file) Currently https://github.com/eclipse/eclipse.jdt.ui does not show text because Github renders README.md while JDT uses CONTRIBUTING.md. Maybe you can rename your file? I think the content of CONTRIBUTING.md is excellent already and would be benefical to be displayed in the main page of Github.
468457,5/27/2015 6:16,noopur_gupta,"[quick assist] Convert to Lambda Quick Assist missing for method parameters of type Object If a parameter is of type object it looks like the quickfix for convertion to lambda is missing.Example from the eclipse.platform.runtime repository:1.)Change plug-in: org.eclipse.e4.core.tests to be based on Java 8. 2.) Open ContextDynamicTest.java3.) Try to convert the following in testReplaceFunctionWithStaticValue via Quickfixcontext.set(""bar"" new IContextFunction() {			@Override			public Object compute(IEclipseContext context String contextKey) {				return ""baz1"";			}		});Manual convertion seem to workcontext.set(""bar"" (IContextFunction) (context1 contextKey) -> ""baz1"");"
468482,5/27/2015 10:21,Lars.Vogel,Add License to README.md similar to JDT core Stumbled upon Bug 370311 and I like that they have included the licence in their readme.
468698,5/28/2015 14:38,sarika.sinha,"Help on ""Re-launching a program"" doesn't reflect changes from bug 176841 On page org.eclipse.jdt.doc.user/tasks/task-running_and_debugging.htm it the paragraph starting with To relaunch the most recent launch do one of the following:does not reflect the changes introduced via bug 176841 notably: relaunching the previously launched application is no longer the default and needs to be configured explicitly in the general Run/Debug > Launching preferences.Also: While searching for this help content I was confused to find ""Launching Preferences"" in ""Java development user guide"" although the preference page is not a child of the ""Java"" top-level node. o.e.debug.* doesn't seem to have a section of its own in the help?Maybe it's just my insider knowledge that made me notice this. Not sure where regular users would search..."
468853,5/29/2015 14:57,eclipse.sprigogin,NPE in Compiler.restoreAptProblems This exception happens in 4.5RC2 but not in 4.4.2.java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.Compiler.restoreAptProblems(Compiler.java:514) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:457) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:452) at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:367) at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:179) at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:304) at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:61) at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:256) at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:175) at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:205) at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:329) at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:404) at org.eclipse.core.internal.resources.Project$1.run(Project.java:556) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2241) at org.eclipse.core.internal.resources.Project.internalBuild(Project.java:534) at org.eclipse.core.internal.resources.Project.build(Project.java:119)Unfortunately I don't have a self-contained example that triggers this problem.
468893,5/30/2015 23:04,jarthana,processor gets multiple processingOver=true calls in some cases Created attachment 253955small standalone project that demonstrates the problemAttached is a trivial test project that demonstrates the following scenarioTest annotation processor scans all types annotated with @Annotation and generates single TypeIndex interface that includes constants for all annotated types (think database IDs for all entity types). TypeIndex generates is expected to happen at the end of annotation processing when roundEnv.processingOver()==true.Test project includes Annotated class and TypeIndexClient class that extends TypeIndex interface generated by the annotation processor.There are two problems when I run Project->Clean on the test project.First and most importantly annotation processor is called twice with roundEnv.processingOver()==true. The second invocation fails in Filer#createSourceFile because the same type was already created.Second neither the exception thrown by the annotation processor nor Messager#printMessage call get an error marker in the workspace which makes it next to impossible for the user to realize there is a problem.
468902,5/31/2015 16:37,sarika.sinha,"SourceLookupFacility.dispose() is incomplete SourceLookupFacility.dispose() invokes	fLookupResults.clear();but fLookupResults is a Map with added value. Consequently LRU.fEntryStack is not cleared making a genuine cleanup in a JUnit task impractical.Suggest overload clear() to clear the fEntryStack or introduce a new dispose() that does both.It seems perverse that fLookupResults is a second static member. Surely it should be a normal member so that an additional fgDefault=null in shutdown would really clean up?"
469320,6/3/2015 14:27,manpalat,Cannot find references in workspace to javax.xml.validation.Validator.validate Created attachment 254092Test projectsUsing Eclipse 4.5-I20150602-2000.I have a plugin in my workspace that calls javax.xml.validation.Validator.validate. If I use Find references in workspace (Ctrl-shift-G) it does not find many of the references. The fact that it can't find them seems to be dependent on the presence of other code in other plugins. I have attached two projects to illustrate the problem.1. Extract the zip2. Import testPlugin project3. Import testReferences project4. Open Main.java class in testReferences project5. Click on the validate call6. Right-click References Workspace. Or Ctrl-shift-G. The workspace reference is not in the results.If you close the testPlugin project then it works. I also tested that this work in Eclipse 4.4.2 so this is a regression. I also set the severity to Major because I have the feeling that this might affect other methods.
469438,6/5/2015 2:40,mateusz.matela,ArrayIndexOutOfBoundsException in TokenManager.applyFormatOff (443) The following incident was reported via the automated error reporting: code: 2 plugin: org.eclipse.jdt.ui_3.11.0.v20150316-2042 message: HIDDEN fingerprint: 996c5631 exception class: java.lang.ArrayIndexOutOfBoundsException exception message: HIDDEN number of children: 0 java.lang.ArrayIndexOutOfBoundsException: HIDDEN at java.util.ArrayList.elementData(ArrayList.java:418) at java.util.ArrayList.set(ArrayList.java:446) at org.eclipse.jdt.internal.formatter.TokenManager.applyFormatOff(TokenManager.java:443) at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.prepareFormattedCode(DefaultCodeFormatter.java:197) at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:154) at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:138) at org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.reformat(CodeFormatterUtil.java:288) at org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.reformat(CodeFormatterUtil.java:351) at org.eclipse.jdt.internal.corext.fix.CodeFormatFix.createCleanUp(CodeFormatFix.java:69) at org.eclipse.jdt.internal.ui.fix.CodeFormatCleanUp.createFix(CodeFormatCleanUp.java:67) at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.calculateChange(CleanUpRefactoring.java:809) at org.eclipse.jdt.internal.corext.fix.CleanUpPostSaveListener.saved(CleanUpPostSaveListener.java:396) at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$5.run(CompilationUnitDocumentProvider.java:1598) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.notifyPostSaveListeners(CompilationUnitDocumentProvider.java:1593) at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy(CompilationUnitDocumentProvider.java:1380) at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$4.execute(CompilationUnitDocumentProvider.java:1458) at org.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run(TextFileDocumentProvider.java:132) at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:70) at org.eclipse.ui.actions.WorkspaceModifyOperation$1.run(WorkspaceModifyOperation.java:108) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2241) at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:130) at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:75) at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:65) at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:456) at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:772) at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:5076) at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1244) at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1298) at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7209) at org.eclipse.ui.Saveable.doSave(Saveable.java:216) at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:355) at org.eclipse.ui.internal.SaveableHelper$3.run(SaveableHelper.java:199) at org.eclipse.ui.internal.SaveableHelper$5.run(SaveableHelper.java:283) at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:463) at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:371) at org.eclipse.ui.internal.WorkbenchWindow$13.run(WorkbenchWindow.java:2137) at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2133) at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:291) at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:269) at org.eclipse.ui.internal.SaveableHelper.saveModels(SaveableHelper.java:211) at org.eclipse.ui.internal.SaveableHelper.savePart(SaveableHelper.java:146) at org.eclipse.ui.internal.WorkbenchPage.saveSaveable(WorkbenchPage.java:3802) at org.eclipse.ui.internal.WorkbenchPage.saveEditor(WorkbenchPage.java:3816) at org.eclipse.ui.internal.handlers.SaveHandler.execute(SaveHandler.java:54) at org.eclipse.ui.internal.handlers.HandlerProxy.execute(HandlerProxy.java:295) at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90) at sun.reflect.GeneratedMethodAccessor103.invoke(null:-1) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:55) at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:247) at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:229) at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132) at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152) at org.eclipse.core.commands.Command.executeWithChecks(Command.java:499) at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508) at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86) at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1262) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070) at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1112) at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108) at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1529) at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4764) at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:343) at org.eclipse.swt.widgets.Control.windowProc(Control.java:4645) at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:339) at org.eclipse.swt.widgets.Display.windowProc(Display.java:5042) at org.eclipse.swt.internal.win32.OS.DispatchMessageW(OS.java:-2) at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1112) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:993) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:654) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-2) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1465) General Information: reported-by: Daniel Mack anonymous-id: 1046e65a-1be2-4fec-8ac6-edb094ab5126 eclipse-build-id: 4.5.0.I20150320-0800 eclipse-product: org.eclipse.epp.package.jee.product operating system: Windows7 6.1.0 (x86_64) - win32 jre-version: 1.8.0_40-b25The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.commands_3.6.100.v20150311-0214 2. org.eclipse.core.databinding.observable_1.4.1.v20150311-0218 3. org.eclipse.core.databinding_1.4.100.v20150311-0216 4. org.eclipse.core.resources_3.9.100.v20150313-1707 5. org.eclipse.core.runtime_3.11.0.v20150316-1241 6. org.eclipse.e4.core.commands_0.10.2.v20150313-1340 7. org.eclipse.e4.core.contexts_1.3.100.v20150316-1240 8. org.eclipse.e4.core.di_1.4.0.v20150316-1236 9. org.eclipse.e4.ui.bindings_0.10.200.v20150313-1340 10. org.eclipse.e4.ui.workbench_1.3.0.v20150316-1403 11. org.eclipse.e4.ui.workbench.swt_0.12.100.v20150316-1403 12. org.eclipse.equinox.app_1.3.200.v20130910-1609 13. org.eclipse.equinox.launcher_1.3.0.v20140415-2008 14. org.eclipse.jdt_3.11.0.v20150320-0800 15. org.eclipse.jdt.ui_3.11.0.v20150316-2042 16. org.eclipse.jface_3.11.0.v20150313-1544 17. org.eclipse.swt_3.104.0.v20150319-1901 18. org.eclipse.ui_3.107.0.v20150315-0703 19. org.eclipse.ui.editors_3.9.0.v20150213-1939 20. org.eclipse.ui.ide.application_1.0.600.v20150315-1254 21. org.eclipse.ui.ide_3.11.0.v20150309-2044Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.Other Resources:* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/552e3b84e4b026254ee0461d * Manual: https://dev.eclipse.org/recommenders/community/confess/#/guideThank you for your assistance.Your friendly error-reports-inbox.
469454,6/5/2015 6:00,sasikanth.bharadwaj,"The compiler generates wrong code during inheritance Created attachment 254140A class that has the inner class ""B"" that gets compiled wrong.The innerclass ""B"" (of the attachment) gets compiled into:public class TestClass$B extends TestClass$A { public TestClass$B(); Code: 0: aload_0 1: invokespecial #8 // Method TestClass$A.""<init>"":()V 4: return public static TestClass$B method(); Code: 0: aconst_null 1: areturn public static TestClass$A method(); Code: 0: invokestatic #17 // Method method:()LTestClass$B; 3: areturn}when the code should be:public class TestClass$B extends TestClass$A { public TestClass$B(); Code: 0: aload_0 1: invokespecial #1 // Method TestClass$A.""<init>"":()V 4: return public static TestClass$B method(); Code: 0: aconst_null 1: areturn}This manifests in this class printing ""2"" instead of ""1"".This behaviour is wrong! There is no inheritance of static methods. None at all!"
469537,6/5/2015 18:09,sxenos,Eclipse throws LinkageError if an annotation processor uses a class that is also used by (or part of) Eclipse To reproduce:1. Create a workspace that includes the source for an Eclipse plugin that isn't the same as what you have installed (I used the source for org.eclipse.jface.text that shipped with Eclipse 4.4 while running Eclipse 4.5).2. Write an annotation processor that uses that code in some way (I used IRegion).3. Write a sample class that includes the annotation processed by said annotation processor.4. Try to build that sample class.Observed:Eclipse throws a LinkageError complaining about duplicate definition of the class.Expected:Eclipse compiles the class successfully.Analysis:Eclipse loads annotation processors in its own VM using the classloader from org.eclipse.jdt.apt.core. Running annotation processors in the same VM is itself a problem which can cause memory leaks and instability in the user's annotation code to cause Eclipse to become unstable.However using the org.eclipse.jdt.apt.core classloader is worse - it means that any class referenced by the annotation processor gets loaded into the plugin's namespace creating LinkageErrors if a class of the same name already exists.The best fix would be to launch annotation processors in a separate VM created for that purpose... but a lesser fix would be to parent the annotation processor's classloader under the system classloader so that duplicate classnames won't clobber one another.
469668,6/8/2015 20:30,jarthana,Implementation of TypeHierarchy.getAllSubtypes(IType) and TypeHierarchy. getAllSuperInterfaces(IType) needs improvement Create a sequence of interfaces in an Eclipse Java project:public interface I1 {}public interface I2 extends I1 {}public interface I3 extends I1 I2 {}public interface I4 extends I1 I2 I3 {}public interface I5 extends I1 I2 I3 I4 {}....public interface I31 extends I1 I2 I3 I4 ... I30 {}Create a test that will invoke a test that will invoke TypeHierarchy.getAllSuperInterfaces(IType) for type I31 and TypeHierarchy.getAllSubtypes(IType) for type I1.Test for all super interfaces will return correct result but only after very long computations.Private method getAllSuperInterfaces0(IType ArrayList) checks duplicates and does not add them to the result list but it does not avoid invoking recursively search for these duplicates.Test for all subtypes most probably will fail with out of memory when trying to add billion objects to the result list because private method getAllSubtypesForType0(IType type ArrayList subs) does not check duplicates and does not avoid recursive calls for duplicates. This use case is not what one gets 'in real life' but Java does not even provides a compilation warning about this style of programming. One more observation is about Type Hierarchy view (so maybe should be submitted to UI) when it is in the 'Show the Supertype Hierarchy' mode it automatically expands the entire tree. Even if the sample sequence has only 20 interfaces instead of 31 it is enough to hang Eclipse trying to open supertype hierarchy for I20. If the depth were limited and tree content loading were lazy it could survive.
469965,6/11/2015 11:21,manpalat,"[search] Declaration search matches for binary enum get method folded into one element 4.5 RC4.Declaration search matches for binary enum method get folded into one elementTest Case:- search for declarations of ""toNanos""==> matches in each anonymous enum class are folded into one entry saying (7 matches)We first have to check in UI whether we do this."
470199,6/15/2015 12:34,Lars.Vogel,Remove outdated _buildnotes_jdt-core.html _buildnotes_jdt-core.html seems outdated. I suggest to remove it similar to the change in Bug 468391.
470203,6/15/2015 13:19,noopur_gupta,[content assist] color/style matching characters in completion proposals Once Bug 350000 is fixed it would be nice if the LabelProvider used to display matches could highlight the matching parts. For example:Button b = new Button(..);b.selection -> Results in b.addSelectionListener would be great if Selection would be in bold.
470207,6/15/2015 13:33,markus.kell.r,IJavaProject#getOptions should return Map<String String> The Javadoc specifies already this type and as org.eclipse.jdt.core is based on Java 1.7 we could also return this type directly.
470232,6/16/2015 2:58,sasikanth.bharadwaj,"NPE at org.eclipse.jdt.internal.compiler.ast.WhileStatement.doesNotCompleteNormally After upgrade from 4.4.2 to 4.5.0RC3 compilation of some sources fails withInternal compiler error: java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.ast.WhileStatement.doesNotCompleteNormally(WhileStatement.java:294)Reduced test case:import java.util.function.Consumer;class While {	void m() {		t(Long.class value -> {			int x = 1;			while (--x >= 0)				;		});	}	<T> void t(Class<T> clazz Consumer<T> object) {	}}The same code with with for (; ...;) instead of while (...) compiles normally."
470312,6/16/2015 15:25,jdt-ui-inbox,Remove redundant null check in RefactoringSessionTransformer
470319,6/16/2015 19:11,noopur_gupta,[type hierarchy] Type Hierarchy view in 'Show the Supertype Hierarchy' mode automatically expands the entire tree The hierarchy may be constructed to have a huge number of nodes. Atomatical expanding the entire tree may hang Eclipse or crash it with out-of-memory.See test project TypeHierarchyTest attached to https://bugs.eclipse.org/bugs/show_bug.cgi?id=469668Load that project into workspace and try to show supertype hierarchy for interface hierarchy.I20. It will take cpu for a long time and most probably hang Eclipse.The project contains only 20 sources - interfaces extending each other.
470370,6/17/2015 8:54,sasikanth.bharadwaj,"[1.8] Wrong varargs behaviour causes ArrayStoreException Wrong varargs behaviour causes ArrayStoreException to unexpectedly be thrown by compiled code.Note that this happens only when compiling with Java 1.8 as source language.This happens both in the IDE and ECJ standalone compiler.For example:$ cat TestVarargs.java # example codeimport java.util.*;public class TestVarargs { public static void main(String[] args) { foo(new Class<?>[]{}); } public static void foo(Class<?>[] sig) { assert Arrays.asList(Arrays.copyOfRange(sig 0 sig.length)) != null; }}$ java -versionopenjdk version ""1.8.0_45""OpenJDK Runtime Environment (build 1.8.0_45-b14)OpenJDK 64-Bit Server VM (build 25.45-b02 mixed mode)$ java -jar ~/Downloads/ecj-4.5RC4.jar -versionEclipse Compiler for Java(TM) v20150602-1242 3.11.0 Copyright IBM Corp 2000 2015. All rights reserved.$ javac TestVarargs.java $ java -cp . -ea TestVarargs # As expected not throwing$ javap -c TestVarargsCompiled from ""TestVarargs.java""public class TestVarargs { static final boolean $assertionsDisabled; public TestVarargs(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.""<init>"":()V 4: return public static void main(java.lang.String[]); Code: 0: iconst_0 1: anewarray #2 // class java/lang/Class 4: invokestatic #3 // Method foo:([Ljava/lang/Class;)V 7: return public static void foo(java.lang.Class<?>[]); Code: 0: getstatic #4 // Field $assertionsDisabled:Z 3: ifne 27 6: aload_0 7: iconst_0 8: aload_0 9: arraylength 10: invokestatic #5 // Method java/util/Arrays.copyOfRange:([Ljava/lang/Object;II)[Ljava/lang/Object; 13: invokestatic #6 // Method java/util/Arrays.asList:([Ljava/lang/Object;)Ljava/util/List; 16: ifnonnull 27 19: new #7 // class java/lang/AssertionError 22: dup 23: invokespecial #8 // Method java/lang/AssertionError.""<init>"":()V 26: athrow 27: return static {}; Code: 0: ldc #9 // class TestVarargs 2: invokevirtual #10 // Method java/lang/Class.desiredAssertionStatus:()Z 5: ifne 12 8: iconst_1 9: goto 13 12: iconst_0 13: putstatic #4 // Field $assertionsDisabled:Z 16: return}$ rm TestVarargs.class $ java -jar ~/Downloads/ecj-4.5RC4.jar -source 8 TestVarargs.java $ java -cp . -ea TestVarargs # Unexpected throwing ArrayStoreExceptionException in thread ""main"" java.lang.ArrayStoreException: [Ljava.lang.Class; at TestVarargs.foo(TestVarargs.java:10) at TestVarargs.main(TestVarargs.java:6)$ javap -c TestVarargs # the wrong varargs handling can be seen: it tries to wrap the Class[] into a newly created Class[]Compiled from ""TestVarargs.java""public class TestVarargs { static final boolean $assertionsDisabled; static {}; Code: 0: ldc #1 // class TestVarargs 2: invokevirtual #10 // Method java/lang/Class.desiredAssertionStatus:()Z 5: ifne 12 8: iconst_1 9: goto 13 12: iconst_0 13: putstatic #16 // Field $assertionsDisabled:Z 16: return public TestVarargs(); Code: 0: aload_0 1: invokespecial #21 // Method java/lang/Object.""<init>"":()V 4: return public static void main(java.lang.String[]); Code: 0: iconst_0 1: anewarray #11 // class java/lang/Class 4: invokestatic #25 // Method foo:([Ljava/lang/Class;)V 7: return public static void foo(java.lang.Class<?>[]); Code: 0: getstatic #16 // Field $assertionsDisabled:Z 3: ifne 37 6: iconst_1 7: anewarray #11 // class java/lang/Class 10: dup 11: iconst_0 12: aload_0 13: iconst_0 14: aload_0 15: arraylength 16: invokestatic #31 // Method java/util/Arrays.copyOfRange:([Ljava/lang/Object;II)[Ljava/lang/Object; 19: checkcast #37 // class ""[Ljava/lang/Class;"" 22: aastore 23: invokestatic #39 // Method java/util/Arrays.asList:([Ljava/lang/Object;)Ljava/util/List; 26: ifnonnull 37 29: new #43 // class java/lang/AssertionError 32: dup 33: invokespecial #45 // Method java/lang/AssertionError.""<init>"":()V 36: athrow 37: return}$ java -jar ~/Downloads/ecj-4.5RC4.jar -source 7 TestVarargs.java $ java -cp . -ea TestVarargs # works as expected with source 7$ javap -c TestVarargs # code is generated as expectedCompiled from ""TestVarargs.java""public class TestVarargs { static final boolean $assertionsDisabled; static {}; Code: 0: ldc #1 // class TestVarargs 2: invokevirtual #10 // Method java/lang/Class.desiredAssertionStatus:()Z 5: ifne 12 8: iconst_1 9: goto 13 12: iconst_0 13: putstatic #16 // Field $assertionsDisabled:Z 16: return public TestVarargs(); Code: 0: aload_0 1: invokespecial #21 // Method java/lang/Object.""<init>"":()V 4: return public static void main(java.lang.String[]); Code: 0: iconst_0 1: anewarray #11 // class java/lang/Class 4: invokestatic #25 // Method foo:([Ljava/lang/Class;)V 7: return public static void foo(java.lang.Class<?>[]); Code: 0: getstatic #16 // Field $assertionsDisabled:Z 3: ifne 30 6: aload_0 7: iconst_0 8: aload_0 9: arraylength 10: invokestatic #31 // Method java/util/Arrays.copyOfRange:([Ljava/lang/Object;II)[Ljava/lang/Object; 13: checkcast #37 // class ""[Ljava/lang/Class;"" 16: invokestatic #39 // Method java/util/Arrays.asList:([Ljava/lang/Object;)Ljava/util/List; 19: ifnonnull 30 22: new #43 // class java/lang/AssertionError 25: dup 26: invokespecial #45 // Method java/lang/AssertionError.""<init>"":()V 29: athrow 30: return}"
470426,6/17/2015 15:32,markus.kell.r,[override method] JAX RS interface annotations are duplicated in the implementing class (3.8.2+/4.2.2+) +++ This bug was initially created as a clone of Bug #386410 +++Backport said fix to 4.2.2+.
470465,6/18/2015 6:20,noopur_gupta,Acquisition is spelt wrong Created attachment 254534Screenshot showing the problemIn the new lock acquisition quick fix acquisition is spelt wrong (missing the 'c').
470506,6/18/2015 11:44,mateusz.matela,"formatter option ""align field in columns"" changed in Mars working with Mars 4.5 RC3 formatting this class the result is:public class TestZ { public int a = 10; public int testAlignment = 10;}formatting this class for example with Eclipse 3.7.2 the result is:public class TestZ { public int a = 10; public int testAlignment = 10;}with Mars 4.5 RC3 the variables will be aligned only without spaces :public class TestZ { public int a = 10; public int testAlignment = 10;}"
470535,6/18/2015 22:18,alex.panchenko,"Bug in UserLibrary.hashCode() http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/tree/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/UserLibrary.java#n97calls hashCode() on the entries array each time should be:		for (int i= 0; i < this.entries.length; i++) {			hashCode= hashCode * 17 + this.entries[i].hashCode();		}"
470613,6/19/2015 11:53,markus.kell.r,[1.9] support 1.9 as compiler compliance level and add JCP disclaimer JDT UI should add support for 1.9 compiler compliance on the Java Compiler preference page. In 1.9 compliance the JCP disclaimer should be shown as a warning:> This is an implementation of an early-draft specification developed under the Java> Community Process (JCP) and is made available for testing and evaluation purposes> only. The code is not compatible with any specification of the JCP.Since 1.9 source and target levels are not supported yet we should not offer them in the UI. But if they are manually set in .settings/org.eclipse.jdt.core.prefs the UI should still show them and treat them correctly.
470614,6/19/2015 12:00,markus.kell.r,[1.9] support 1.9 as compiler compliance level For bug 470613 we need support for the 1.9 compiler compliance level. For now JavaCore#setComplianceOptions(String Map) should set source and target levels to 1.8 when the given compliance is 1.9.
470616,6/19/2015 12:15,markus.kell.r,[1.9] JavaSE-9 Execution Environment should set proper compiler compliance/source/target levels Since 1.9 source and target levels are not supported yet the JavaSE-1.9 Execution Environment should set compiler source and target level to 1.8 for now.The /org.eclipse.osgi/JavaSE-1.9.profile currently sets these properties to 1.9 but it's unclear if and when they should be set to 1.9.Since the jdt.launching bundle loads these profiles we can easily fix the values there. In the future we would better avoid declaring EEs in the OSGi bundle as long as they are not released yet. We could declare them in the jdt.launching bundle until they're ready for release.
470665,6/22/2015 2:22,sxenos,NullPointerException in AnnotationDiscoveryVisitor.visit (64) The following incident was reported via the automated error reporting: code: 75 plugin: org.eclipse.core.resources_3.9.100.v20150114-1351 message: Errors occurred during the build. fingerprint: aadc15f1 exception class: org.eclipse.recommenders.internal.stacktraces.rcp.StandInStacktraceProvider$StandInException exception message: Stand-In Stacktrace supplied by Eclipse Stacktraces & Error Reporting Tool number of children: 1 org.eclipse.recommenders.internal.stacktraces.rcp.StandInStacktraceProvider$StandInException: Stand-In Stacktrace supplied by Eclipse Stacktraces & Error Reporting Tool at org.eclipse.core.internal.jobs.JobManager.endJob(JobManager.java:712) at org.eclipse.core.internal.jobs.WorkerPool.endJob(WorkerPool.java:105) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:72) --- code: 75 plugin: org.eclipse.jdt.core_3.11.0.v20150126-2015 message: Errors running builder 'Java Builder' on project 'Ndetuneproadstyxhau'. fingerprint: 9dd49f3a exception class: java.lang.NullPointerException exception message: - number of children: 0 java.lang.NullPointerException: null at org.eclipse.jdt.internal.compiler.apt.dispatch.AnnotationDiscoveryVisitor.visit(AnnotationDiscoveryVisitor.java:64) at org.eclipse.jdt.internal.compiler.ast.Argument.traverse(Argument.java:228) at org.eclipse.jdt.internal.compiler.ast.TryStatement.traverse(TryStatement.java:1118) at org.eclipse.jdt.internal.compiler.ast.Block.traverse(Block.java:136) at org.eclipse.jdt.internal.compiler.ast.Initializer.traverse(Initializer.java:130) at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1353) at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:748) at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:709) at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundEnvImpl.<init>(RoundEnvImpl.java:59) at org.eclipse.jdt.internal.compiler.apt.dispatch.BaseAnnotationProcessorManager.processAnnotations(BaseAnnotationProcessorManager.java:148) at org.eclipse.jdt.internal.apt.pluggable.core.dispatch.IdeAnnotationProcessorManager.processAnnotations(IdeAnnotationProcessorManager.java:134) at org.eclipse.jdt.internal.compiler.Compiler.processAnnotations(Compiler.java:851) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:432) at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:367) at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:179) at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:304) at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:61) at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:256) at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:180) at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:730) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:205) at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:245) at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:298) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:301) at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:357) at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:380) at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:144) at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:239) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55) General Information: reported-by: Kenzie Togami anonymous-id: f637cb61-38bb-4b4a-b055-cd1b70a6e105 eclipse-build-id: 4.5.0.I20150203-1300 eclipse-product: org.eclipse.epp.package.dsl.product operating system: Windows7 6.1.0 (x86_64) - win32 jre-version: 1.8.0_45-b14The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.jobs_3.7.0.v20150115-2226 2. org.eclipse.core.runtime_3.10.0.v20150112-1422 3. org.eclipse.jdt.apt.pluggable.core_1.0.500.v20141128-1116 4. org.eclipse.jdt_3.11.0.v20150203-1300 5. org.eclipse.jdt.compiler.apt_1.1.100.v20141219-0603 6. org.eclipse.jdt.core_3.11.0.v20150126-2015Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.Other Resources:* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/5585c4c0e4b08735226aa4df * Manual: https://dev.eclipse.org/recommenders/community/confess/#/guideThank you for your assistance.Your friendly error-reports-inbox.
470667,6/22/2015 2:27,sasikanth.bharadwaj,"ArrayIndexOutOfBoundsException in InferenceContext18.addConstraintsToC (467) The following incident was reported via the automated error reporting: code: 2 plugin: org.eclipse.core.resources_3.10.0.v20150423-0755 message: Problems occurred when invoking code from plug-in: ""org.eclipse.core.resources"". fingerprint: 4f4839c9 exception class: java.lang.ArrayIndexOutOfBoundsException exception message: -1 number of children: 0 java.lang.ArrayIndexOutOfBoundsException: -1 at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.addConstraintsToC(InferenceContext18.java:467) at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.addConstraintsToC_OneExpr(InferenceContext18.java:542) at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.addConstraintsToC(InferenceContext18.java:470) at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:394) at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod18(ParameterizedGenericMethodBinding.java:256) at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:82) at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:743) at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:700) at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod0(Scope.java:1645) at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1546) at org.eclipse.jdt.internal.compiler.lookup.Scope.getImplicitMethod(Scope.java:2506) at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:674) at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve(ReturnStatement.java:341) at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:641) at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:309) at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:551) at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1188) at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1301) at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:590) at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:861) at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:141) at java.lang.Thread.run(Thread.java:745) General Information: reported-by: anonymous-id: ace698e4-9553-4ef0-ad1f-83b90a6893d6 eclipse-build-id: 4.5.0.I20150603-2000 eclipse-product: org.eclipse.platform.ide operating system: Windows7 6.1.0 (x86_64) - win32 jre-version: 1.8.0_45-b15The following plug-ins were present on the execution stack (*): 1. org.eclipse.jdt_3.11.0.v20150603-2000Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.Other Resources:* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/5580e4dbe4b07f2b167053f1 * Manual: https://dev.eclipse.org/recommenders/community/confess/#/guideThank you for your assistance.Your friendly error-reports-inbox."
470930,6/25/2015 0:29,manpalat,[Documentation] ecj man page addition for new compiler options follow up bug 462147 comment 15Reproducing bug 462147 comment 14 below:For the records this file should also have been updated for new options:/org.eclipse.jdt.core/scripts/ecj.1
470977,6/25/2015 6:35,mateusz.matela,"[formatter] Whitespace removed between assert and unary operator or primary expression Whitespace between the ""assert"" keyword and unary operators or primary expressions (where applicable) is removed with the eclipse-4.5 formatter. The eclipse-4.4 and eclipse-4.3 formatters keep resp. insert whitespace after the ""assert"" keyword.eclipse-4.5 [formatter = eclipse-builtin]:---public class TestFormat {	public static void main(String[] args) {		assert"""".length() == 0;		assert(!false);		assert!false;		assert+0 == 0;		assert-0 == 0;		int i = 0;		assert++i == 1;		assert--i == 0;	}}---eclipse-4.4.2 [formatter = eclipse-builtin]:---public class TestFormat {	public static void main(String[] args) {		assert """".length() == 0;		assert (!false);		assert !false;		assert +0 == 0;		assert -0 == 0;		int i = 0;		assert ++i == 1;		assert --i == 0;	}}---"
470986,6/25/2015 8:21,mateusz.matela,"Enable line formatting needs to be active for ""Preserve whitespace between code and line comments"" to work. As with Mars the option ""Enable line formatting"" of the Java formatter needs to be checked for ""Preserve whitespace between code and line comments"" to work. If ""Enable line formatting"" is not active whitespace between the code and line comments is removed completely even if ""Preserve whitespace between code and line comments"" is checked. If ""Preserve whitespace between code and line comments"" is deactivated the whitespace is collapsed to one space.Is this supposed to be that way?P.s.: I've seen #373625 and ""Align fields in columns"" is not checked."
471062,6/25/2015 21:40,mateusz.matela,Formatter inserts space before line comment Every time I edit a source file all my line comments have an extra space inserted between the semicolon and the double slash.This is causing havoc with my github repo.Checked items in the formatter:Enable line comment formattingFormat line comments on first columnPreserve white space between code and line commentsNever join linesThis only started to happen after I installed Mars.
471090,6/26/2015 3:22,register.eclipse,"Java Code Formatter breaks code if single line comments contains unicode escape The Java Code Formatter (with default settings) formats this:public class FormatterBug { public static void m() { // xxx \u00C4 yyy throw new RuntimeException();	}}to this:public class FormatterBug {	public static void m() {		// xxx \u00C4 yyy throw new RuntimeException();	}}then if you format it again to this;public class FormatterBug {	public static void m() {		// xxx \u00C4 yyy throw new RuntimeException(); }}then if you do it again it doesn't do anything because the code doesn't compile."
471145,6/26/2015 11:01,mateusz.matela,"[Formatter] doesn't remove space before ""{"" on the if line Created attachment 254757On formatter preference window we can see the bug.In Eclipse 4.5 the formatter doesn't remove the space before an opening brace on the if line."
471202,6/27/2015 8:37,mateusz.matela,"[formatter] Extra line break after annotation default expression The eclipse-4.5 formatter adds an extra line break after an annotation default expression which itself is an annotation.Expected: No line break added after ""default @Attributes()"".Actual: Line break added.eclipse-4.5 [formatter = eclipse-builtin]:---public class TestFormatLineBreakDefault {	public @interface MyAnnotation {		Attributes attributes() default @Attributes()		;	}	@Target({ ElementType.ANNOTATION_TYPE })	public static @interface Attributes {	}}---eclipse-4.4.2 [formatter = eclipse-builtin]:---public class TestFormatLineBreakDefault {	public @interface MyAnnotation {		Attributes attributes() default @Attributes();	}	@Target({ ElementType.ANNOTATION_TYPE })	public static @interface Attributes {	}}---I'm using the following patch to workaround this issue:---diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.javaindex 32640ec..122a78a 100644--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/LineBreaksPreparator.java@@ -4499 +44918 @@ public class LineBreaksPreparator extends ASTVisitor { breakAfter = this.options.insert_new_line_after_annotation_on_type; } else if (parentNode instanceof FieldDeclaration) { breakAfter = this.options.insert_new_line_after_annotation_on_field;- } else if (parentNode instanceof MethodDeclaration- || parentNode instanceof AnnotationTypeMemberDeclaration) {+ } else if (parentNode instanceof MethodDeclaration) { breakAfter = this.options.insert_new_line_after_annotation_on_method;+ } else if (parentNode instanceof AnnotationTypeMemberDeclaration) {+ if (((AnnotationTypeMemberDeclaration) parentNode).getDefault() != node) {+ breakAfter = this.options.insert_new_line_after_annotation_on_method;+ } } else if (parentNode instanceof VariableDeclarationStatement || parentNode instanceof VariableDeclarationExpression) { breakAfter = this.options.insert_new_line_after_annotation_on_local_variable;---"
471203,6/27/2015 8:37,mateusz.matela,"[formatter] Extra whitespace after annotation in member-value pair and annotation default The eclipse-4.5 formatter adds whitespace after an annotation in a MemberValuePair node and in an annotation default expression (only visible after applying the patch from bug 471202).Expected: No whitespace added after ""attributes = @Attributes()"" and ""Attributes attributes()"".Actual: Whitespace added.eclipse-4.5 [formatter = eclipse-builtin]:---public class TestFormat {	@Target({ ElementType.METHOD })	public @interface MyAnnotation {		Attributes attributes() ;	}	@Target({ ElementType.ANNOTATION_TYPE })	public static @interface Attributes {	}	@MyAnnotation(attributes = @Attributes() )	public void method() {	}}---eclipse-4.4.2 [formatter = eclipse-builtin]:---public class TestFormat {	@Target({ ElementType.METHOD })	public @interface MyAnnotation {		Attributes attributes() default @Attributes();	}	@Target({ ElementType.ANNOTATION_TYPE })	public static @interface Attributes {	}	@MyAnnotation(attributes = @Attributes())	public void method() {	}}---I'm using the following patch to workaround this issue:---diff --git a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/SpacePreparator.java b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/SpacePreparator.javaindex 63a49a4..34b75e0 100644--- a/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/SpacePreparator.java+++ b/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/SpacePreparator.java@@ -4618 +46310 @@ public class SpacePreparator extends ASTVisitor { } ASTNode parent = node.getParent();- if (!(parent instanceof Annotation) && !(parent instanceof ArrayInitializer))+ if (!(parent instanceof Annotation || parent instanceof ArrayInitializer || parent instanceof MemberValuePair+ || (parent instanceof AnnotationTypeMemberDeclaration && ((AnnotationTypeMemberDeclaration) parent).getDefault() == node))) { this.tm.lastTokenIn(node -1).spaceAfter();+ } } @Override---"
471364,6/29/2015 15:23,mateusz.matela,"[formatter] Method declarations in interfaces are sometimes indented incorrectly Created attachment 254817Example CodeMethod declarations in interfaces are indented too much if they follow a non-empty line and the formatter is configured to wrap method declarations where necessary.To reproduce this bug import the attached profile and then format the attached example source code.The attached profile is based on the ""Eclipse [built-in]"" profile (performing the same changes on the ""Java Conventions [built-in]"" profile also causes this bug). On the ""Line Wrapping"" tab under ""Method Declarations"" -> ""Declaration"" the Line Wrapping Policy has been set to ""Wrap Where Necessary"".This is sufficient to cause the bug on method declarations in interfaces directly following line block or javadoc comments. If a blank line is inserted between the comment and the method declaration it is indented correctly.If the formatter is configured to insert 0 blank lines before method declarations in the ""Blank Lines"" tab then method declarations immediately following other method declarations are also indented incorrectly. (If the formatter automatically inserts a blank line as configured in the built-in profile then the lines are indented correctly.)I could not reproduce this bug in an abstract class. Even using abstract method declarations which are very similar to method declarations in interfaces did not cause the bug in an abstract class."
471737,7/2/2015 14:58,noopur_gupta,Decorator for Default methods missing from documentation This page: http://help.eclipse.org/mars/index.jsp?topic=/org.eclipse.jdt.doc.user/reference/ref-icons.htmshould show the 'D' for default methods.Is the distinction between the two kinds of override/implement decorations still accurate? If you implement a default method is that 'implement' or 'override'?? (Didn't try).
471883,7/6/2015 2:36,mateusz.matela,[formatter] NullPointerException in TokenManager.firstIndexIn (188) The following incident was reported via the automated error reporting: code: 10.000 plugin: org.eclipse.ltk.ui.refactoring_3.7.200.v20140625-1835 message: HIDDEN fingerprint: 7cdfedcf exception class: java.lang.reflect.InvocationTargetException exception message: HIDDEN number of children: 0 java.lang.reflect.InvocationTargetException: HIDDEN at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:420) at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:331) at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:663) at org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:502) at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:74) at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:114) at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.nextOrPreviewPressed(RefactoringWizardDialog2.java:497) at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.access$2(RefactoringWizardDialog2.java:494) at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2$1.widgetSelected(RefactoringWizardDialog2.java:693) at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4362) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1113) at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4180) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3769) at org.eclipse.jface.window.Window.runEventLoop(Window.java:827) at org.eclipse.jface.window.Window.open(Window.java:803) at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:187) at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:202) at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:122) at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:38) at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startMoveRefactoring(RefactoringExecutionStarter.java:396) at org.eclipse.jdt.internal.ui.refactoring.reorg.ReorgMoveAction.run(ReorgMoveAction.java:113) at org.eclipse.jdt.ui.actions.MoveAction.tryReorgMove(MoveAction.java:257) at org.eclipse.jdt.ui.actions.MoveAction.run(MoveAction.java:168) at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:279) at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251) at org.eclipse.jface.action.Action.runWithEvent(Action.java:473) at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:595) at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:511) at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:420) at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4362) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1113) at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4180) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3769) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:654) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) at sun.reflect.NativeMethodAccessorImpl.invoke0(null:-2) at sun.reflect.NativeMethodAccessorImpl.invoke(null:-1) at sun.reflect.DelegatingMethodAccessorImpl.invoke(null:-1) at java.lang.reflect.Method.invoke(null:-1) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608) at org.eclipse.equinox.launcher.Main.run(Main.java:1515)caused by: java.lang.NullPointerException: HIDDEN at org.eclipse.jdt.internal.formatter.TokenManager.firstIndexIn(TokenManager.java:188) at org.eclipse.jdt.internal.formatter.LineBreaksPreparator.handleBracedCode(LineBreaksPreparator.java:542) at org.eclipse.jdt.internal.formatter.LineBreaksPreparator.visit(LineBreaksPreparator.java:243) at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:611) at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711) at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2782) at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:470) at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711) at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.prepareLineBreaks(DefaultCodeFormatter.java:356) at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.prepareFormattedCode(DefaultCodeFormatter.java:194) at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:155) at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:139) at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteFormatter.formatString(ASTRewriteFormatter.java:246) at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteFormatter.formatNode(ASTRewriteFormatter.java:376) at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteFormatter.getFormattedResult(ASTRewriteFormatter.java:187) at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer.doTextInsert(ASTRewriteAnalyzer.java:1357) at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer$ListRewriter.rewriteList(ASTRewriteAnalyzer.java:647) at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer$ListRewriter.rewriteList(ASTRewriteAnalyzer.java:802) at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer.rewriteParagraphList(ASTRewriteAnalyzer.java:1175) at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer.visit(ASTRewriteAnalyzer.java:1811) at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:453) at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711) at org.eclipse.jdt.core.dom.rewrite.ASTRewrite.internalRewriteAST(ASTRewrite.java:302) at org.eclipse.jdt.core.dom.rewrite.ASTRewrite.rewriteAST(ASTRewrite.java:291) at org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite.attachChange(CompilationUnitRewrite.java:278) at org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite.createChange(CompilationUnitRewrite.java:241) at org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite.createChange(CompilationUnitRewrite.java:225) at org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite.createChange(CompilationUnitRewrite.java:192) at org.eclipse.jdt.internal.corext.refactoring.reorg.ReorgPolicyFactory$SubCuElementReorgPolicy.createCompilationUnitChange(ReorgPolicyFactory.java:3630) at org.eclipse.jdt.internal.corext.refactoring.reorg.ReorgPolicyFactory$MoveSubCuElementsPolicy.createChange(ReorgPolicyFactory.java:2233) at org.eclipse.jdt.internal.corext.refactoring.reorg.JavaMoveProcessor.createChange(JavaMoveProcessor.java:169) at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.createChange(ProcessorBasedRefactoring.java:292) at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:124) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2241) at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87) at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:119) General Information: reported-by: anonymous-id: 08a7607c-3931-4a6e-bbea-55c117bba6d9 eclipse-build-id: 4.5.0.I20150528-0700 eclipse-product: org.eclipse.epp.package.jee.product operating system: Windows7 6.1.0 (x86) - win32 jre-version: 1.8.0_45-b14The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.databinding.observable_1.5.0.v20150422-0725 2. org.eclipse.core.databinding_1.5.0.v20150422-0725 3. org.eclipse.core.resources_3.10.0.v20150423-0755 4. org.eclipse.core.runtime_3.11.0.v20150405-1723 5. org.eclipse.e4.ui.workbench_1.3.0.v20150527-1447 6. org.eclipse.e4.ui.workbench.swt_0.13.0.v20150504-0621 7. org.eclipse.equinox.app_1.3.300.v20150423-1356 8. org.eclipse.equinox.launcher_1.3.100.v20150511-1540 9. org.eclipse.jdt.core_3.11.0.v20150526-1109 10. org.eclipse.jdt_3.11.0.v20150528-0700 11. org.eclipse.jdt.ui_3.11.0.v20150527-0925 12. org.eclipse.jface_3.11.0.v20150520-1503 13. org.eclipse.ltk.core.refactoring_3.6.200.v20140826-0859 14. org.eclipse.ltk.ui.refactoring_3.7.200.v20140625-1835 15. org.eclipse.swt_3.104.0.v20150528-0211 16. org.eclipse.ui_3.107.0.v20150507-1945 17. org.eclipse.ui.ide.application_1.1.0.v20150422-0725 18. org.eclipse.ui.ide_3.11.0.v20150510-1749Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.Other Resources:* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/5580b11be4b07f2b167053b9 * Manual: https://dev.eclipse.org/recommenders/community/confess/#/guideThank you for your assistance.Your friendly error-reports-inbox.
471918,7/6/2015 9:44,mateusz.matela,"Eclipse Mars/4.5 formatter forces multiple lines with Javadoc tags In Eclipse Luna/4.4 and Mars/4.5 I can have the following Javadoc comments and the formatter will leave it alone which is good:/** Returns a new foo instance. */public Foo createFoo() {...In Eclipse 4.4/Luna if I added a Javadoc tag it was still OK:/** @return a new foo instance. */public Foo createFoo() {...But in Eclipse 4.5/Mars the formatter forces the API comments to multiple lines just because I used a @return tag:/** * @return a new foo instance. */public String createFoo() {...This unnecessarily takes up space --- and is inconsistent with the behavior without the @return.There is a formatter option under ""Comments"" that says ""/** and */ on separate lines"" but that is not relevant. That option when turned off will place the /** on the same line as the comment _even when the comment is over multiple lines_. Furthermore as I have already mentioned this option does not prevent a single line when no Javadoc tag is present."
471934,7/6/2015 10:28,mat.booth,"[launching] Standardise on single version of maven-antrun-plugin As a continuation of bug #458043 and bug #463070 etcPlease don't define maven-antrun-plugin version but rely on the version defined in the parent pom's ""pluginManagement"" section.Please also drop the dependencies specified under maven-antrun-plugin -- this build does not actually need or use them."
472009,7/7/2015 3:19,mateusz.matela,"Formatter does not respect ""keep else if on one line"" The new formatter does not respect the option ""keep else if on one line"". Instead it always wraps after ""else""."
472066,7/7/2015 11:18,sxenos,"Deadlock in AnnotationProcessorFactoryLoader Deadlock discovered in AnnotationProcessorLoaderFactory""Worker-291"" prio=10 tid=0x00007ff39c1e0800 nid=0x6ccb waiting for monitor entry [0x00007ff440642000]org.eclipse.jdt.apt.core.internal.AnnotationProcessorFactoryLoader$ResourceListener.resourceChanged(AnnotationProcessorFactoryLoader.java:160)	- locked <0x00000007532fe738> (a org.eclipse.jdt.apt.core.internal.AnnotationProcessorFactoryLoader)	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:299)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:289)	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:152)	at org.eclipse.core.internal.resources.Workspace.broadcastBuildEvent(Workspace.java:359)	at org.eclipse.core.internal.resources.Workspace.aboutToBuild(Workspace.java:302)	at org.eclipse.core.internal.resources.Project$1.run(Project.java:546)	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2241)	at org.eclipse.core.internal.resources.Project.internalBuild(Project.java:534)	at org.eclipse.core.internal.resources.Project.build(Project.java:119)""org.eclipse.jdt.internal.ui.text.JavaReconciler"" daemon prio=10 tid=0x00007ff479669000 nid=0xe3f in Object.wait() [0x00007ff3eb016000] java.lang.Thread.State: TIMED_WAITING (on object monitor)	at java.lang.Object.wait(Native Method)	at org.eclipse.core.internal.jobs.Semaphore.acquire(Semaphore.java:39)	- locked <0x00000007f8693a78> (a org.eclipse.core.internal.jobs.Semaphore)	at org.eclipse.core.internal.jobs.OrderedLock.doAcquire(OrderedLock.java:170)	at org.eclipse.core.internal.jobs.OrderedLock.acquire(OrderedLock.java:106)	at org.eclipse.core.internal.jobs.OrderedLock.acquire(OrderedLock.java:82)	at org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:121)	at org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:2189)	at org.eclipse.core.internal.resources.Marker.delete(Marker.java:68)	at org.eclipse.jdt.apt.core.internal.AnnotationProcessorFactoryLoader.removeAptBuildProblemMarkers(AnnotationProcessorFactoryLoader.java:672)	at org.eclipse.jdt.apt.core.internal.AnnotationProcessorFactoryLoader.loadFactories(AnnotationProcessorFactoryLoader.java:496)	at org.eclipse.jdt.apt.core.internal.AnnotationProcessorFactoryLoader.getJava5FactoriesAndAttributesForProject(AnnotationProcessorFactoryLoader.java:391)	- locked <0x00000007532fe738> (a org.eclipse.jdt.apt.core.internal.AnnotationProcessorFactoryLoader)	at org.eclipse.jdt.apt.core.internal.AptCompilationParticipant.reconcile(AptCompilationParticipant.java:212)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation$1.run(ReconcileWorkingCopyOperation.java:258)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.notifyParticipants(ReconcileWorkingCopyOperation.java:245)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:95)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:126)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:108)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:89)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:151)	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:86)	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:77)	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:206)Note that this is very similar to bug 184923. That one was caused by a call to Marker.setAttributes and this one is caused by a call to Marker.delete. In order to prevent deadlocks we need to prevent calls to anything with any possibility of holding a workspace lock while inside the synchronized block."
472178,7/8/2015 10:09,sasikanth.bharadwaj,[1.8][Compiler] java.lang.ArrayIndexOutOfBoundsException: -1 on codegen.StackMapFrame.addStackItem(StackMapFrame.java:92) Hi allI'm using JDT Core org.eclipse.jdt.core_3.11.0.v20150602-1242 outside of IDE using AST.createASTs(String[] sourceFilePaths String[] encodings String[] bindingKeys FileASTRequestor requestor IProgressMonitor monitor) method.I'm getting java.lang.ArrayIndexOutOfBoundsException: -1Stack trace here : http://pastebin.com/08uA4KrQIt happens on file : http://pastebin.com/USDJsHEZError is in place in org.eclipse.jdt.internal.compiler.codegen.StackMapFrame.addStackItem(VerificationTypeInfo)in :final int length = this.stackItems.length;if (this.numberOfStackItems == length) { System.arraycopy(this.stackItems 0 this.stackItems = new VerificationTypeInfo[length + 1] 0 length);}this.stackItems[this.numberOfStackItems++] = info; <-- Index out of boundso it seems like race-issue (at least for me).I could give additional information if you have any ideas what could help to recreate this bug.RegardsGrzesiek
472205,7/8/2015 14:03,markus.kell.r,"[formatter] Class extends generic type and implements another type missing space after "">"" I have a problem with the formatter in the following case:class A extends B<ClientListener>implements CInstead of havingclass A extends B<ClientListener> implements C(class A extends B<ClientListener>[missing space here]implements C)Problem appears when class extends a typed type followed by an implements declaration.In other case there is no problem.I checked all options but I can't configure that case (it is possible to configure space after ""<"" and before "">"" but not after "">"" of the generic type).It is possible to avoid it by not formatting this kind of class but I as use the ""on save"" clean all option it is really annoying.Thanks for the help."
472224,7/8/2015 16:41,sxenos,NPE in AnnotationDiscoveryVisitor#resolveAnnotations Many users have reported NPEs like the following:java.lang.NullPointerException at org.eclipse.jdt.internal.compiler.apt.dispatch.AnnotationDiscoveryVisitor.resolveAnnotations(AnnotationDiscoveryVisitor.java:238) at org.eclipse.jdt.internal.compiler.apt.dispatch.AnnotationDiscoveryVisitor.visit(AnnotationDiscoveryVisitor.java:75) at org.eclipse.jdt.internal.compiler.ast.Argument.traverse(Argument.java:230) at org.eclipse.jdt.internal.compiler.apt.dispatch.AnnotationDiscoveryVisitor.visit(AnnotationDiscoveryVisitor.java:111) at org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.traverse(ConstructorDeclaration.java:605) at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1360) at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:748) at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:709) at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundEnvImpl.<init>(RoundEnvImpl.java:60) at org.eclipse.jdt.internal.compiler.apt.dispatch.BaseAnnotationProcessorManager.processAnnotations(BaseAnnotationProcessorManager.java:148) at org.eclipse.jdt.internal.apt.pluggable.core.dispatch.IdeAnnotationProcessorManager.processAnnotations(IdeAnnotationProcessorManager.java:134) at org.eclipse.jdt.internal.compiler.Compiler.processAnnotations(Compiler.java:909) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:434) at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:367) at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:179) at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:304) at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:61) at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:256) at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:180) at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:205) at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:245) at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:300) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:303) at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:359) at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:382) at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:144) at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:235) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)This appears similar to bug 471995 but in that case it appears to be a Scope attribute that was null. In this case it appears to be one of the bindings returned from getPackedAnnotationBindings() that was null.These bindings come from Factory.getPackedAnnotationBindings. Looking at the other callers of this method it seems that the result is intented to contain nulls and that nulls should be ignored and skipped.Will attach patches that add the missing null checks to all callers of Factory.getPackedAnnotationBindings.
472413,7/10/2015 23:58,mateusz.matela,"[formatter] Wrap all arguments on new lines and prefer outer expressions result is inconsistent This slightly expanded example from the formatter preview window doesn't wrap all function call arguments on new lines starting from the outermost expressions with this result:/*** Arguments*/class Example {	void foo() {		Other.bar(			100			nestedMethod2Arg(				nestedMethod1Arg(					nestedMethod2Arg(nestedMethod1Arg(nestedMethod2Arg(						nestedMethod1Arg(nestedMethod1Arg(nestedMethod1Arg(							nested(200 300 400 500 600 700 800 900))))						null)) null))				null)			100);	}}Tested with Eclipse IDE for Java DevelopersVersion: Mars Release (4.5.0)Build id: 20150621-1200"
472568,7/14/2015 2:10,sarika.sinha,ClassCastException in JavaApplicationLaunchShortcut.findTypes (134) The following incident was reported via the automated error reporting: code: 0 plugin: org.eclipse.ui_3.107.0.v20150315-0703 message: Unhandled event loop exception fingerprint: ff8774df exception class: java.lang.ClassCastException exception message: java.lang.ClassCastException cannot be cast to org.eclipse.core.runtime.CoreException number of children: 0 java.lang.ClassCastException: java.lang.ClassCastException cannot be cast to org.eclipse.core.runtime.CoreException at org.eclipse.jdt.debug.ui.launchConfigurations.JavaApplicationLaunchShortcut.findTypes(JavaApplicationLaunchShortcut.java:134) at org.eclipse.jdt.debug.ui.launchConfigurations.JavaLaunchShortcut.searchAndLaunch(JavaLaunchShortcut.java:112) at org.eclipse.jdt.debug.ui.launchConfigurations.JavaLaunchShortcut.launch(JavaLaunchShortcut.java:269) at org.eclipse.debug.internal.ui.launchConfigurations.LaunchShortcutExtension.launch(LaunchShortcutExtension.java:420) at org.eclipse.debug.internal.ui.actions.LaunchShortcutAction.run(LaunchShortcutAction.java:71) at org.eclipse.debug.internal.ui.actions.LaunchShortcutAction.runWithEvent(LaunchShortcutAction.java:123) at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:595) at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:511) at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:420) at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4354) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1070) at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:782) at org.eclipse.jface.action.ActionContributionItem$9.handleEvent(ActionContributionItem.java:1293) at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4354) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061) at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3761) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1112) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:993) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:654) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) at sun.reflect.NativeMethodAccessorImpl.invoke0(null:-2) at sun.reflect.NativeMethodAccessorImpl.invoke(null:-1) at sun.reflect.DelegatingMethodAccessorImpl.invoke(null:-1) at java.lang.reflect.Method.invoke(null:-1) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1465) General Information: reported-by: Lukas Eder anonymous-id: eb529e81-8dc8-4160-9814-3b51a0e4fdb0 eclipse-build-id: 4.5.0.I20150320-0800 eclipse-product: org.eclipse.epp.package.jee.product operating system: Windows8 6.2.0 (x86_64) - win32 jre-version: 1.8.0_40-b26The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.databinding.observable_1.4.1.v20150311-0218 2. org.eclipse.core.databinding_1.4.100.v20150311-0216 3. org.eclipse.core.runtime_3.11.0.v20150316-1241 4. org.eclipse.debug.ui_3.11.0.v20150303-1130 5. org.eclipse.e4.ui.workbench_1.3.0.v20150316-1403 6. org.eclipse.e4.ui.workbench.swt_0.12.100.v20150316-1403 7. org.eclipse.equinox.app_1.3.200.v20130910-1609 8. org.eclipse.equinox.launcher_1.3.0.v20140415-2008 9. org.eclipse.jdt.debug.ui_3.7.0.v20150316-0938 10. org.eclipse.jdt.debug_3.9.0.v20150314-0247 11. org.eclipse.jdt_3.11.0.v20150320-0800 12. org.eclipse.jface_3.11.0.v20150313-1544 13. org.eclipse.swt_3.104.0.v20150319-1901 14. org.eclipse.ui_3.107.0.v20150315-0703 15. org.eclipse.ui.ide.application_1.0.600.v20150315-1254 16. org.eclipse.ui.ide_3.11.0.v20150309-2044Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.Other Resources:* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/5527f344e4b026254ee0311a * Manual: https://dev.eclipse.org/recommenders/community/confess/#/guideThank you for your assistance.Your friendly error-reports-inbox.
472612,7/14/2015 8:14,sarika.sinha,NullPointerException in PopupInspectAction$2.close (64) The following incident was reported via the automated error reporting: code: 0 plugin: org.eclipse.ui_3.107.0.v20150507-1945 message: Unhandled event loop exception fingerprint: 1b522cf8 exception class: org.eclipse.swt.SWTException exception message: Failed to execute runnable (java.lang.NullPointerException) number of children: 0 org.eclipse.swt.SWTException: Failed to execute runnable (java.lang.NullPointerException) at org.eclipse.swt.SWT.error(SWT.java:4491) at org.eclipse.swt.SWT.error(SWT.java:4406) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:138) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4155) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3772) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:654) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) at sun.reflect.NativeMethodAccessorImpl.invoke0(null:-2) at sun.reflect.NativeMethodAccessorImpl.invoke(null:-1) at sun.reflect.DelegatingMethodAccessorImpl.invoke(null:-1) at java.lang.reflect.Method.invoke(null:-1) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608) at org.eclipse.equinox.launcher.Main.run(Main.java:1515) at org.eclipse.equinox.launcher.Main.main(Main.java:1488)caused by: java.lang.NullPointerException: null at org.eclipse.jdt.internal.debug.ui.actions.PopupInspectAction$2.close(PopupInspectAction.java:64) at org.eclipse.jface.dialogs.PopupDialog$5.run(PopupDialog.java:657) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4155) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3772) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:654) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) at sun.reflect.NativeMethodAccessorImpl.invoke0(null:-2) at sun.reflect.NativeMethodAccessorImpl.invoke(null:-1) at sun.reflect.DelegatingMethodAccessorImpl.invoke(null:-1) at java.lang.reflect.Method.invoke(null:-1) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608) at org.eclipse.equinox.launcher.Main.run(Main.java:1515) at org.eclipse.equinox.launcher.Main.main(Main.java:1488) General Information: reported-by: anonymous-id: f4c884c2-3540-4aaf-bb03-eaf5922bf22c eclipse-build-id: 4.5.0.I20150603-2000 eclipse-product: org.eclipse.epp.package.jee.product operating system: Windows7 6.1.0 (x86_64) - win32 jre-version: 1.7.0_75-b13The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.databinding.observable_1.5.0.v20150422-0725 2. org.eclipse.core.databinding_1.5.0.v20150422-0725 3. org.eclipse.core.runtime_3.11.0.v20150405-1723 4. org.eclipse.e4.ui.workbench_1.3.0.v20150531-1948 5. org.eclipse.e4.ui.workbench.swt_0.13.0.v20150504-0621 6. org.eclipse.equinox.app_1.3.300.v20150423-1356 7. org.eclipse.equinox.launcher_1.3.100.v20150511-1540 8. org.eclipse.jdt.debug.ui_3.7.0.v20150505-1916 9. org.eclipse.jdt.debug_3.9.0.v20150528-1838 10. org.eclipse.jdt_3.11.0.v20150603-2000 11. org.eclipse.jface_3.11.0.v20150602-1400 12. org.eclipse.swt_3.104.0.v20150528-0211 13. org.eclipse.ui_3.107.0.v20150507-1945 14. org.eclipse.ui.ide.application_1.1.0.v20150422-0725 15. org.eclipse.ui.ide_3.11.0.v20150510-1749Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.Other Resources:* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/55910d6de4b08735226b0cac * Manual: https://dev.eclipse.org/recommenders/community/confess/#/guideThank you for your assistance.Your friendly error-reports-inbox.
472635,7/14/2015 12:24,markus.kell.r,4.5 porting guide not visible in help The 4.5 porting guide is not visible in help because it has not been added to the TOC.
472648,7/14/2015 14:14,sasikanth.bharadwaj,"[compiler][1.8] Lambda expression referencing method with generic type has incorrect compile errors Using Mars 4.5.0 (Build id: 20150621-1200)Eclipse produces errors on the following code even though the code compiles and functions correctly in JDK 1.8.0_45. The same code compiles and runs in 4.4.2.The specific errors on the Lambda expression are: Incompatible type specified for lambda expression's parameter iThe method forEachValueOfType(List<?> Class<T> Consumer<T>) in the type BugDemonstrator is not applicable for the arguments (List<Number> Class<Integer> (Integer i) -> {})import java.util.ArrayList;import java.util.List;import java.util.function.Consumer;public class BugDemonstrator {	public static void main(String argv[]) {		new BugDemonstrator();	}		public BugDemonstrator() {		List<Number> numList = new ArrayList<>();		numList.add(1);		numList.add(1.5);		numList.add(2);		numList.add(2.5);				forEachValueOfType(numList Integer.class (Integer i) -> (System.out.println(Integer.toString(i))));	}	private <T> void forEachValueOfType(List<?> list Class<T> type Consumer<T> action) {		for (Object o : list) {			if (type.isAssignableFrom(o.getClass())) {				@SuppressWarnings(""unchecked"")				T convertedObject = (T) o;				action.accept(convertedObject);			}		}	}}"
472657,7/14/2015 15:59,sarika.sinha,"Set ""Redundant type arguments (1.7 or highter)"" to warning instead of ignore I personally was not aware of that warning / error in JDT and while I was trying to build an AST transformation to fix this in Platform UI I googled a bit and found this blogpost: http://blog.deepakazad.com/2011/07/java-7-support-in-eclipse-jdt-beta-part_22.htmlI think we you set it to warning more people will discover it."
472815,7/16/2015 6:54,mateusz.matela,[formatter] 'Indent Empty lines' option doesn't work inside empty blocks New in Mars:If I create a new class or interface the class body (consisting of one empty line so far) is not indented.
472962,7/17/2015 11:26,mateusz.matela,"[formatter] Missing whitespace after > ] in annotation type declaration Default settings (""Eclipse [built-in]"") before formatting:<pre>public @interface A {	String[] strings();	Class<String> stringClasses();}public static class B extends Stack<String> implements Serializable {	private static final long serialVersionUID = 1L;}public static void print(String s) {	// add '\u00A0' at the end	System.out.println(s + '\u00A0');}</pre>after formatting:<pre>public @interface A {	String[]strings();	Class<String>stringClasses();}public static class B extends Stack<String>implements Serializable {	private static final long serialVersionUID = 1L;}public static void print(String s) {	// add '\u00A0' at the end System.out.println(s + '\u00A0');}</pre>=> especially the last example is a severe bug! the other ones are just annoying especially when the team is working with different eclipse versions (Luna vs. Mars) and because the ""Mars version"" is wrong"
473008,7/18/2015 19:23,jarthana,"[content assist] method reference in field initialization prevents constructor autocomplete A lambda method reference in the field initialization of a class prevents the content-assist from auto-completing constructor parameters in the whole class. -----------code---------------public class Foo { private FooFunctional lambda = this::bar; public void bar() {}		}@FunctionalInterfaceprivate interface FooFunctional { void function();}-----------------------------When typing ""new String|"" in the method bar (or any other) and pressing CTRL+Space I would expect to get suggestions for all reachable constructors that start with ""String..."". But only types are suggested.The content assist works as expected when the field initialization is removed or moved into an constructor."
473101,7/20/2015 13:25,noopur_gupta,[content assist] Completion proposals fail to render the declaring type of array clone() methods See this SO question: http://stackoverflow.com/questions/31469457/eclipse-reporting-an-arrays-clone-method-is-from-its-corresponding-type-incThere's even an answer with detailed code analysis of were the information gets lost.
473178,7/21/2015 7:55,Lars.Vogel,Remove redundant type arguments (1.7 or highter) from Java 7 code in JDT core
473343,7/23/2015 2:45,jarthana,IllegalArgumentException in Util.scanTypeSignature (1237) The following incident was reported via the automated error reporting: code: 10.001 plugin: org.eclipse.jdt.ui_3.11.0.v20150527-0925 message: Internal Error fingerprint: a7c2ac4a exception class: java.lang.IllegalArgumentException exception message: - number of children: 0 java.lang.IllegalArgumentException: null at org.eclipse.jdt.internal.compiler.util.Util.scanTypeSignature(Util.java:1237) at org.eclipse.jdt.internal.compiler.util.Util.scanTypeArgumentSignature(Util.java:1566) at org.eclipse.jdt.core.Signature.getTypeArguments(Signature.java:2215) at org.eclipse.jdt.internal.core.util.Util.getAllTypeArguments(Util.java:2801) at org.eclipse.jdt.internal.core.search.matching.MethodPattern.<init>(MethodPattern.java:173) at org.eclipse.jdt.core.search.SearchPattern.createPattern(SearchPattern.java:2059) at org.eclipse.jdt.internal.corext.callhierarchy.CallerMethodWrapper.findChildren(CallerMethodWrapper.java:144) at org.eclipse.jdt.internal.corext.callhierarchy.MethodWrapper.performSearch(MethodWrapper.java:302) at org.eclipse.jdt.internal.corext.callhierarchy.MethodWrapper.doFindChildren(MethodWrapper.java:233) at org.eclipse.jdt.internal.corext.callhierarchy.MethodWrapper.getCalls(MethodWrapper.java:85) at org.eclipse.jdt.internal.ui.callhierarchy.DeferredMethodWrapper.getCalls(DeferredMethodWrapper.java:65) at org.eclipse.jdt.internal.ui.callhierarchy.DeferredMethodWrapper.fetchDeferredChildren(DeferredMethodWrapper.java:79) at org.eclipse.ui.progress.DeferredTreeContentManager$1.run(DeferredTreeContentManager.java:232) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55) General Information: reported-by: richard anonymous-id: 936b0120-9684-4bd2-8ac1-62e930de41ca eclipse-build-id: 4.5.0.I20150603-2000 eclipse-product: org.eclipse.epp.package.dsl.product operating system: Windows8 6.2.0 (x86_64) - win32 jre-version: 1.8.0_45-b15The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.jobs_3.7.0.v20150330-2103 2. org.eclipse.jdt_3.11.0.v20150603-2000 3. org.eclipse.jdt.core_3.11.0.v20150602-1242 4. org.eclipse.jdt.ui_3.11.0.v20150527-0925 5. org.eclipse.ui_3.107.0.v20150507-1945Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.Other Resources:* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/558eb81de4b08735226af3dd * Manual: https://dev.eclipse.org/recommenders/community/confess/#/guideThank you for your assistance.Your friendly error-reports-inbox.
473432,7/23/2015 15:24,sasikanth.bharadwaj,Incorrect unboxing of Boolean when part of a ternary operation Created attachment 255394Test class - execute to reproduce bugWhen using a ternary operation where one side is a boolean primitive and the other is a Boolean object the Boolean object is unboxed into a primitive. This potentially causes NullPointerExceptions that were not possible in previous versions of Eclipse.This worked correctly on Kepler (JDT version 3.9.2.v20140221-1700) but does not work in Mars (JDT version 3.11.0.v20150603-2000).This same code does not produce any errors when compiled and executed on Java 1.8.0_45-b14.See attached for a reproducible example.
473713,7/28/2015 2:36,register.eclipse,"[1.8][null] Type mismatch: cannot convert from @NonNull A1 to @NonNull A1 DESCRIPTION:With Java8 TYPE_USE Null-Annotations enabled create two Projects:In Project A create two classes:package a;@org.eclipse.jdt.annotation.NonNullByDefaultpublic class A1 {	public class NestedInA1 {	}}----package a;@org.eclipse.jdt.annotation.NonNullByDefaultpublic class A2 {	public static abstract class NestedInA2 {		public final A1 a1 = new A1();		protected abstract void handleApplicationSpecific(A1.NestedInA1 detail);	}}In Project B create one class:package b;@org.eclipse.jdt.annotation.NonNullByDefaultpublic class B {	public static a.A1 m(a.A2.NestedInA2 nestedInA2) {		return nestedInA2.a1;	}}At the return Statement an error is reported:""Type mismatch: cannot convert from @NonNull A1 to @NonNull A1""ANALYSIS:There are two types registered in TypeSystem for A1PATCH:I'll send the test case together with a possible patch via gerrit.(The bug occurs in 4.5 and the master)"
473863,7/29/2015 12:56,markus.kell.r,org.eclipse.ltk.core.refactoring.tests doesn't run all tests with tycho-surefire org.eclipse.ltk.core.refactoring.tests doesn't run all tests with tycho-surefire. Fix is ready.
473867,7/29/2015 14:02,markus.kell.r,"avoid calling BuilderTests#suite() twice (via jdt.apt.pluggable.tests) When trying to backport bug 461969 to make tests green on R4_4_maintenance when running with Java 8 I ran into another failing test:junit.framework.AssertionFailedError: Incorrect value expected:<0> but was:<2000>	at junit.framework.Assert.fail(Assert.java:57)	at junit.framework.Assert.failNotEquals(Assert.java:329)	at junit.framework.Assert.assertEquals(Assert.java:78)	at junit.framework.Assert.assertEquals(Assert.java:234)	at junit.framework.TestCase.assertEquals(TestCase.java:401)	at org.eclipse.jdt.core.tests.builder.BasicBuildTests.testbBug386901(BasicBuildTests.java:605)It turned out the actual problem was that the whole org.eclipse.jdt.core.tests.builder.BuilderTests suite was executed twice:1. as expected from /org.eclipse.jdt.core.tests.builder/pom.xml2. via org.eclipse.jdt.apt.pluggable.tests.TestBase which inherits BuilderTests but doesn't declare its own suite() method. That alone would not be a problem but the /org.eclipse.jdt.apt.pluggable.tests/pom.xml missed to declare the test to run and Tycho-Surefire behavior in that case is to use some pattern-guessing to find test classes -- that's not something to rely on."
473901,7/30/2015 5:28,jarthana,[1.9] Restructure Java Model for Jimage The current Java model is proving to be insufficient to represent the Jimage structure. As of now now (head of BETA_JAVA9) the entire Jimage is represented as a PackageFragmentRoot and packages are modeled as PackageFragment.But there is nothing really to hold the modules except for the package-module cache we maintain internally.It is also a problem for resources that don't have a package and hence no package-module mapping. I think we need to start thinking about changing models. I propose the following:A new kind of PackageFragmentRoot namely ModulePackageFragmentRootOptional - A new model Jimage to hold the modules. It will make sense when in future we will be required to load individual Jimage files and might also have a mixed set up of Jars and Jimages.We also need to discuss what happens when we also have modules as source.
473921,7/30/2015 8:52,markus.kell.r,"Inner enum cannot be resolved via Organize Imports but via Quickfix Eclipse defines org.eclipse.e4.ui.workbench.modeling.EPartService with an inner ENUM PartState (org.eclipse.e4.ui.workbench.modeling.EPartService.PartState).If I write the following statement ""Organize Imports"" is unable to resolve this import but CTRL+1 can. If Quickfix can solve that I think ""Organize Imports"" should also be able to.System.out.println(PartState.ACTIVATE);"
474011,7/31/2015 6:47,mateusz.matela,"[formatter] non-nls strings are duplicated by formatter If a long file contains an unnecessary non-nls tag which has a leading space in comment the formatter duplicates the comment in each format call.Reproduce:1. Use the default formatter2. add this line into a methodSystem.out.println(""dsadfsdfsdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd""); //$NON-NLS-1$ // $NON-NLS-2$3. Press Ctrl+f to format file.Got from the first call:		System.out.println([??]); //$NON-NLS-1$ //					[??]//$NON-NLS-1$ $NON-NLS-2$Expected:The line should not change or the parameter is moved to next line to shorten the line length."
474045,7/31/2015 10:36,markus.kell.r,"findSecondaryType blocked by sleeping Indexing Thread PDE's APIAnalysisBuilder uses JavaModelManager#secondaryTypes (see [PDE Builder Stack]). That is potentially blocked by a huge number of pending indexing jobs (IJob).I did a re-fresh after a branch switch and a canceled import and had around 15.000 of those little jobs to be processes. That wouldn't be so bad if the indexing thread would not wait 50ms between each job.See JobManager.java:412 if (this.awaitingClients == 0) Thread.sleep(50);I think the situation would be improved if at least the sleeping would be avoided in cases where a client waits.[PDE Builder Stack]Thread [Worker-11] (Suspended)		Thread.sleep(long) line: not available [native method]		JavaModelManager.secondaryTypes(IJavaProject boolean IProgressMonitor) line: 4573		NameLookup.findSecondaryType(String String IJavaProject boolean IProgressMonitor) line: 592		NameLookup.findType(String IPackageFragment boolean int boolean boolean) line: 773		NameLookup.findType(String String boolean int boolean boolean boolean IProgressMonitor) line: 663		NameLookup.findType(String boolean int boolean boolean boolean IProgressMonitor) line: 845		JavaProject.findType(String NameLookup boolean IProgressMonitor) line: 1277		JavaProject.findType(String WorkingCopyOwner IProgressMonitor) line: 1366		JavaProject.findType(String IProgressMonitor) line: 1270		LeakFieldProblemDetector(AbstractProblemDetector).createProblem(IReference IJavaProject) line: 183		LeakFieldProblemDetector(AbstractProblemDetector).createProblems() line: 526		ReferenceAnalyzer.analyze(IApiComponent IApiTypeContainer IProgressMonitor) line: 263		BaseApiAnalyzer.checkApiUsage(IBuildContext IApiComponent IProgressMonitor) line: 1206		BaseApiAnalyzer.analyzeComponent(BuildState IApiFilterStore Properties IApiBaseline IApiComponent IBuildContext IProgressMonitor) line: 271		ApiAnalysisBuilder.buildAll(IApiBaseline IApiBaseline IProgressMonitor) line: 754		ApiAnalysisBuilder.build(int Map<StringString> IProgressMonitor) line: 369"
474062,7/31/2015 14:22,sxenos,"[painting] Use 'maximum line width' formatter setting as print margin column Extracted from bug 306646Build Identifier: I20090611-1540In my company we have style rules that C++ files should be at most 80 columns while Java files should be at most 100 columns. The ""Help > Preferences > General > Editors > Text Editors > Print margin column"" is helpful to adhere to the style rule but it's the same for all file types which means it can be either 80 or 100 columns but not auto-adjustable according to the file type I'm currently editing.Reproducible: Always"
474073,7/31/2015 17:57,alex.blewitt,Replace new Boolean with Boolean.valueOf Using `new Boolean()` results in the creation of a new object on theheap when the flyweight `Boolean.TRUE` and `Boolean.FALSE` are available.Java 1.4 added a `Boolean.valueOf()` which can be used in place of`new Boolean()` but which will use the existing flyweight values instead. Globally change `new Boolean(...)` to `Boolean.valueOf(...)` and replace`new Boolean(...).booleanValue()` with the equivalent `Boolean.parseBoolean(...)`
474270,8/5/2015 0:24,manpalat,NullPointerException in ImportRewrite.annotateType (1250) The following incident was reported via the automated error reporting: code: 0 plugin: org.eclipse.ui_3.107.0.v20141112-1026 message: Unhandled event loop exception fingerprint: bdac70aa exception class: java.lang.NullPointerException exception message: - number of children: 0 java.lang.NullPointerException: null at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.annotateType(ImportRewrite.java:1250) at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.internalAddImport(ImportRewrite.java:1354) at org.eclipse.jdt.core.dom.rewrite.ImportRewrite.addImport(ImportRewrite.java:823) at org.eclipse.jdt.internal.ui.text.correction.proposals.ChangeMethodSignatureProposal.modifyParameters(ChangeMethodSignatureProposal.java:213) at org.eclipse.jdt.internal.ui.text.correction.proposals.ChangeMethodSignatureProposal.getRewrite(ChangeMethodSignatureProposal.java:131) at org.eclipse.jdt.ui.text.java.correction.ASTRewriteCorrectionProposal.addEdits(ASTRewriteCorrectionProposal.java:113) at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createTextChange(CUCorrectionProposal.java:234) at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createChange(CUCorrectionProposal.java:244) at org.eclipse.jdt.ui.text.java.correction.ChangeCorrectionProposal.getChange(ChangeCorrectionProposal.java:377) at org.eclipse.jdt.ui.text.java.correction.ChangeCorrectionProposal.performChange(ChangeCorrectionProposal.java:137) at org.eclipse.jdt.internal.ui.text.correction.proposals.LinkedCorrectionProposal.performChange(LinkedCorrectionProposal.java:150) at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.apply(CUCorrectionProposal.java:184) at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.apply(AbstractAnnotationHover.java:538) at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.access$2(AbstractAnnotationHover.java:515) at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl$5.widgetSelected(AbstractAnnotationHover.java:509) at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:248) at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4354) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1085) at org.eclipse.swt.widgets.Widget.sendSelectionEvent(Widget.java:1102) at org.eclipse.swt.widgets.Link.wmNotifyChild(Link.java:1086) at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5660) at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1935) at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5207) at org.eclipse.swt.widgets.Control.windowProc(Control.java:4683) at org.eclipse.swt.widgets.Display.windowProc(Display.java:5055) at org.eclipse.swt.internal.win32.OS.CallWindowProcW(OS.java:-2) at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:2443) at org.eclipse.swt.widgets.Link.callWindowProc(Link.java:172) at org.eclipse.swt.widgets.Widget.wmLButtonUp(Widget.java:2079) at org.eclipse.swt.widgets.Control.WM_LBUTTONUP(Control.java:5020) at org.eclipse.swt.widgets.Link.WM_LBUTTONUP(Link.java:922) at org.eclipse.swt.widgets.Control.windowProc(Control.java:4664) at org.eclipse.swt.widgets.Display.windowProc(Display.java:5042) at org.eclipse.swt.internal.win32.OS.DispatchMessageW(OS.java:-2) at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3759) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$9.run(PartRenderingEngine.java:1151) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1032) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:148) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:648) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:592) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) at sun.reflect.NativeMethodAccessorImpl.invoke0(null:-2) at sun.reflect.NativeMethodAccessorImpl.invoke(null:-1) at sun.reflect.DelegatingMethodAccessorImpl.invoke(null:-1) at java.lang.reflect.Method.invoke(null:-1) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:648) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:603) at org.eclipse.equinox.launcher.Main.run(Main.java:1465) General Information: reported-by: anonymous-id: f2a997f2-440a-3906-ba11-1be5b73ec988 eclipse-build-id: 4.5.0.I20141210-2000 eclipse-product: org.eclipse.epp.package.dsl.product operating system: Windows7 6.1.0 (x86_64) - win32 jre-version: 1.8.0_25-b18The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.databinding.observable_1.4.1.v20140910-2107 2. org.eclipse.core.databinding_1.4.100.v20141002-1314 3. org.eclipse.core.runtime_3.10.0.v20140724-1132 4. org.eclipse.e4.ui.workbench_1.3.0.v20141126-1637 5. org.eclipse.e4.ui.workbench.swt_0.12.100.v20141126-1500 6. org.eclipse.equinox.app_1.3.200.v20130910-1609 7. org.eclipse.equinox.launcher_1.3.0.v20140415-2008 8. org.eclipse.jdt.core_3.11.0.v20141209-1931 9. org.eclipse.jdt_3.11.0.v20141210-2000 10. org.eclipse.jdt.ui_3.10.100.v20141208-1433 11. org.eclipse.swt_3.104.0.v20141210-0658 12. org.eclipse.ui_3.107.0.v20141112-1026 13. org.eclipse.ui.ide.application_1.0.600.v20141107-1428 14. org.eclipse.ui.ide_3.10.100.v20141126-1713Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.Other Resources:* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/54c4f735bee810030da0d6c4 * Manual: https://dev.eclipse.org/recommenders/community/confess/#/guideThank you for your assistance.Your friendly error-reports-inbox.
474538,8/8/2015 3:48,noopur_gupta,Update JDT UI to Java 8 Now that the PMC decided that Eclipse Neon will require Java 8 I think it would be helpful if JDT UI updates to Java 8. This way the JDT developer can use their own Java 8 tooling on their code basis and modernize the code basis.
474629,8/10/2015 13:13,mateusz.matela,"[save actions][clean up] AIOOBE in TokenManager.get(TokenManager.java:68) Save action ""Use parentheses in expressions: Only when necessary"" always causes a crash of this feature (as long as the source file contains parentheses) and skips subsequent save actions. (the file is luckily still saved). The save participant 'Code Clean Up' caused an exception: java.lang.ArrayIndexOutOfBoundsException. See the error log for details.Example of what causes the crash: int i = (1 + 2);Error log: Problems occurred when invoking code from plug-in: ""org.eclipse.jdt.ui"". Exception stack trace: java.lang.ArrayIndexOutOfBoundsException(That's all there is no stack trace)"
474732,8/11/2015 13:16,markus.kell.r,"[reconciling] JavaReconciler should not run when non-shared working copy gets created/disposed The JavaReconciler should not run when a non-shared working copy gets created/disposed.* Steps:- have:package foo;public class Snippet {	void m() {		a	}}- put caret after the 'a'- Ctrl+1=> reconciler gets triggered several times* Analysis:SimilarElementsRequestor#getStaticImportFavorites(..) calls ICompilationUnit#getWorkingCopy(..). This triggers a reconcile operation on the active editor. This shouldn't happen because the non-shared working copy cannot influence the editor's input element.An effect of this is bug 474594: The reconciler triggers the OverrideIndicatorManager which accesses the editor AST and its bindings in parallel to other threads.	at org.eclipse.jdt.internal.ui.text.JavaReconciler$ElementChangedListener.canIgnore(JavaReconciler.java:181)	at org.eclipse.jdt.internal.ui.text.JavaReconciler$ElementChangedListener.canIgnore(JavaReconciler.java:192)	at org.eclipse.jdt.internal.ui.text.JavaReconciler$ElementChangedListener.canIgnore(JavaReconciler.java:192)	at org.eclipse.jdt.internal.ui.text.JavaReconciler$ElementChangedListener.canIgnore(JavaReconciler.java:192)	at org.eclipse.jdt.internal.ui.text.JavaReconciler$ElementChangedListener.elementChanged(JavaReconciler.java:164)	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1662)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1652)	at org.eclipse.jdt.internal.core.DeltaProcessor.firePostChangeDelta(DeltaProcessor.java:1486)	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1462)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:770)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.CompilationUnit.getWorkingCopy(CompilationUnit.java:988)	at org.eclipse.jdt.internal.core.CompilationUnit.getWorkingCopy(CompilationUnit.java:957)	at org.eclipse.jdt.internal.ui.text.correction.SimilarElementsRequestor.getStaticImportFavorites(SimilarElementsRequestor.java:230)	at org.eclipse.jdt.internal.ui.text.correction.UnresolvedElementsSubProcessor.addStaticImportFavoriteProposals(UnresolvedElementsSubProcessor.java:1080)	at org.eclipse.jdt.internal.ui.text.correction.UnresolvedElementsSubProcessor.getVariableProposals(UnresolvedElementsSubProcessor.java:293)	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.process(QuickFixProcessor.java:360)	at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.getCorrections(QuickFixProcessor.java:315)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:384)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:344)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:339)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:474)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectProposals(JavaCorrectionProcessor.java:284)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.computeQuickAssistProposals(JavaCorrectionProcessor.java:246)	at org.eclipse.jface.text.quickassist.QuickAssistAssistant$ContentAssistProcessor.computeCompletionProposals(QuickAssistAssistant.java:75)	at org.eclipse.jface.text.contentassist.ContentAssistant$5.run(ContentAssistant.java:1904)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1902)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:573)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$16(CompletionProposalPopup.java:570)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:505)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:499)	at org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1720)	at org.eclipse.jface.text.quickassist.QuickAssistAssistant.showPossibleQuickAssists(QuickAssistAssistant.java:128)	at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionAssistant.showPossibleQuickAssists(JavaCorrectionAssistant.java:198)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:192)	at org.eclipse.ui.texteditor.TextOperationAction$1.run(TextOperationAction.java:128)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ui.texteditor.TextOperationAction.run(TextOperationAction.java:126)	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122)	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)	at sun.reflect.GeneratedMethodAccessor50.invoke(Unknown Source)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:497)	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56)	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:252)	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:234)	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:493)	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:486)	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)..."
474762,8/12/2015 3:37,jarthana,LambdaExpressionsTest.test447119d - 1.8 fails I20150811-1400 and next N-build too.Fails since we switched to JRE 8 on the Mac OS X platform.LambdaExpressionsTest.test447119d - 1.8http://download.eclipse.org/eclipse/downloads/drops4/I20150811-1400/testresults/html/org.eclipse.jdt.core.tests.compiler_macosx.cocoa.x86_64_8.0.htmlUnexpected output running resulting class file for X.java: --[START]-- Lambda binds to: X.lambda$0 Methods (with generics): - java.util.List<java.lang.String> lambda$0(java.util.List<java.lang.String>) - java.util.List<java.lang.String> noop(java.util.List<java.lang.String>) ---[END]---junit.framework.AssertionFailedError: Unexpected output running resulting class file for X.java:--[START]--Lambda binds to: X.lambda$0Methods (with generics):- java.util.List<java.lang.String> lambda$0(java.util.List<java.lang.String>)- java.util.List<java.lang.String> noop(java.util.List<java.lang.String>)---[END]---at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2558)at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2298)at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runConformTest(AbstractRegressionTest.java:1365)at org.eclipse.jdt.core.tests.compiler.regression.LambdaExpressionsTest.test447119d(LambdaExpressionsTest.java:4988)at org.eclipse.jdt.core.tests.util.CompilerTestSetup.run(CompilerTestSetup.java:56)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:692)at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:319)at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36)at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32)at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)at org.eclipse.equinox.launcher.Main.run(Main.java:1515)at org.eclipse.equinox.launcher.Main.main(Main.java:1488)at org.eclipse.core.launcher.Main.main(Main.java:34)
474916,8/13/2015 11:45,markus.kell.r,"[formatter] Formatting GridBagLayout from Java 8 takes too long masterI tried to format the source of java.awt.GridBagLayout from Java 8 but I had to kill the process after it blocked for more than 5 minutes.The formatter hung while trying to apply the regex CommentsPreparator#HTML_TAG_PATTERN to the class' Javadoc.Abusing complex regular complex expressions as a parser is always problematic. To avoid excessive backtracking in nested expressions possessive quantifiers and atomic groups need to be used.Concrete problems:- the consecutive (pre)?(dl|hr)? etc. constructs would also allow concatenations of the tag names and can be inefficient since all combinations have to be tested- attribute value parsing didn't work for single-quoted values and was inefficient due to the [^\""]* which usually matched way too much and was- nesting quantifiers is very dangerous and should only be done when backtracking of the inner quantifiers is under control and cannot lead to an explosion of the problem spaceStack dump:...	at java.util.regex.Pattern$Ques.match(Pattern.java:4182)	at java.util.regex.Pattern$Loop.matchInit(Pattern.java:4806)	at java.util.regex.Pattern$Prolog.match(Pattern.java:4741)	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)	at java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3798)	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)	at java.util.regex.Pattern$Loop.matchInit(Pattern.java:4806)	at java.util.regex.Pattern$Prolog.match(Pattern.java:4741)	at java.util.regex.Pattern$Curly.match0(Pattern.java:4272)	at java.util.regex.Pattern$Curly.match(Pattern.java:4234)	at java.util.regex.Pattern$Loop.match(Pattern.java:4794)	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4568)	at java.util.regex.Pattern$Curly.match0(Pattern.java:4279)	at java.util.regex.Pattern$Curly.match(Pattern.java:4234)	at java.util.regex.Pattern$Branch.match(Pattern.java:4604)	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)	at java.util.regex.Pattern$Loop.matchInit(Pattern.java:4801)	at java.util.regex.Pattern$Prolog.match(Pattern.java:4741)	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)	at java.util.regex.Pattern$Loop.matchInit(Pattern.java:4804)	at java.util.regex.Pattern$Prolog.match(Pattern.java:4741)	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)	at java.util.regex.Pattern$Branch.match(Pattern.java:4602)	at java.util.regex.Pattern$Branch.match(Pattern.java:4602)	at java.util.regex.Pattern$Branch.match(Pattern.java:4602)	at java.util.regex.Pattern$Branch.match(Pattern.java:4602)	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4568)	at java.util.regex.Pattern$GroupTail.match(Pattern.java:4717)	at java.util.regex.Pattern$BranchConn.match(Pattern.java:4568)	at java.util.regex.Pattern$SliceI.match(Pattern.java:3997)	at java.util.regex.Pattern$Branch.match(Pattern.java:4604)	at java.util.regex.Pattern$GroupHead.match(Pattern.java:4658)	at java.util.regex.Pattern$Branch.match(Pattern.java:4604)	at java.util.regex.Pattern$Branch.match(Pattern.java:4602)	at java.util.regex.Pattern$Branch.match(Pattern.java:4602)	at java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3798)	at java.util.regex.Pattern$Start.match(Pattern.java:3461)	at java.util.regex.Matcher.search(Matcher.java:1248)	at java.util.regex.Matcher.find(Matcher.java:637)	at org.eclipse.jdt.internal.formatter.CommentsPreparator.handleHtml(CommentsPreparator.java:633)	at org.eclipse.jdt.internal.formatter.CommentsPreparator.endVisit(CommentsPreparator.java:623)	at org.eclipse.jdt.core.dom.TagElement.accept0(TagElement.java:282)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2782)	at org.eclipse.jdt.core.dom.Javadoc.accept0(Javadoc.java:205)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.prepareComments(DefaultCodeFormatter.java:367)	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.prepareFormattedCode(DefaultCodeFormatter.java:197)	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:157)	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:141)	at org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.reformat(CodeFormatterUtil.java:288)	at org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.reformat(CodeFormatterUtil.java:351)	at org.eclipse.jdt.internal.corext.fix.CodeFormatFix.createCleanUp(CodeFormatFix.java:69)	at org.eclipse.jdt.internal.ui.fix.CodeFormatCleanUp.createFix(CodeFormatCleanUp.java:61)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.calculateChange(CleanUpRefactoring.java:793)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.calculateSolutions(CleanUpRefactoring.java:303)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.acceptAST(CleanUpRefactoring.java:281)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.acceptSource(CleanUpRefactoring.java:292)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpFixpointIterator.next(CleanUpRefactoring.java:415)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.cleanUpProject(CleanUpRefactoring.java:704)	at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.checkFinalConditions(CleanUpRefactoring.java:660)	at org.eclipse.ltk.core.refactoring.Refactoring.checkAllConditions(Refactoring.java:162)	at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper$Operation.run(RefactoringExecutionHelper.java:81)	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2242)	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5409)	at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:105)	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:119)"
474918,8/13/2015 12:03,mateusz.matela,[formatter] doesn't align fields in declarations of annotations enums and anonymous classes See summary should be clear enough.
474922,8/13/2015 12:29,manpalat,"[dom ast] Bad AST node structure for nested ""t instanceof Comparable<?>"" 4.6.0.I20150805-2000Bad AST node structure:- parent [88 124] org.eclipse.jdt.core.dom.InfixExpression rightOperand [101 127] org.eclipse.jdt.core.dom.InstanceofExpression----------------------------------- SOURCE BEGIN -------------------------------------package xy;public class Try18 {	static <T> void comparableValueFrom(T t) {		if (t == null || t instanceof Comparable<?>)			return;	}}----------------------------------- SOURCE END -------------------------------------java.lang.IllegalStateException: Bad AST node structure	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1419)	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:270)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:207)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1250)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)..."
475155,8/17/2015 9:34,manpalat,Data race on org.eclipse.jdt.core.dom.MethodBinding.typeParameters A dynamic race detector outputs a few race reports on org.eclipse.jdt.core.dom.MethodBinding.typeParameters when testing against I-Build I20150811-1400. Here is one:Data race on field org.eclipse.jdt.core.dom.MethodBinding.typeParameters: {{{ Concurrent read in thread T63 (locks held: {}) ----> at org.eclipse.jdt.core.dom.MethodBinding.getTypeParameters(MethodBinding.java:364) at org.eclipse.jdt.internal.corext.dom.Bindings.isSubsignature(Bindings.java:753) at org.eclipse.jdt.internal.corext.dom.Bindings.findOverriddenMethodInType(Bindings.java:498) at org.eclipse.jdt.internal.corext.dom.Bindings.findOverriddenMethodInHierarchy(Bindings.java:513) at org.eclipse.jdt.internal.corext.dom.Bindings.findOverriddenMethods(Bindings.java:581) at org.eclipse.jdt.internal.corext.dom.Bindings.findOverriddenMethod(Bindings.java:540) at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.findInHierarchyWithAST(OverrideIndicatorLabelDecorator.java:184) at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:159) at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:132) at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:260) at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:260) at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:83) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.decorate(LightweightDecoratorManager.java:367) at org.eclipse.ui.internal.decorators.LightweightDecoratorManager.getDecorations(LightweightDecoratorManager.java:349) at org.eclipse.ui.internal.decorators.DecorationScheduler$1.ensureResultCached(DecorationScheduler.java:367) at org.eclipse.ui.internal.decorators.DecorationScheduler$1.run(DecorationScheduler.java:327) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55) T63 is created by T49 at org.eclipse.core.internal.jobs.WorkerPool.jobQueued(WorkerPool.java:148) Concurrent write in thread T68 (locks held: {Monitor@1feb6e9c}) ----> at org.eclipse.jdt.core.dom.MethodBinding.getTypeParameters(MethodBinding.java:370) at org.eclipse.jdt.internal.corext.dom.Bindings.isSubsignature(Bindings.java:753) at org.eclipse.jdt.internal.corext.dom.Bindings.findOverriddenMethodInType(Bindings.java:498) at org.eclipse.jdt.internal.corext.dom.Bindings.findOverriddenMethodInHierarchy(Bindings.java:513) at org.eclipse.jdt.internal.corext.dom.Bindings.findOverriddenMethods(Bindings.java:581) at org.eclipse.jdt.internal.corext.dom.Bindings.findOverriddenMethod(Bindings.java:540) at org.eclipse.jdt.internal.ui.javaeditor.OverrideIndicatorManager$1.visit(OverrideIndicatorManager.java:184) at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:611) at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711) at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2782) at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:470) at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711) at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2782) at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:212) at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711) at org.eclipse.jdt.internal.ui.javaeditor.OverrideIndicatorManager.updateAnnotations(OverrideIndicatorManager.java:176) at org.eclipse.jdt.internal.ui.javaeditor.OverrideIndicatorManager.reconciled(OverrideIndicatorManager.java:258) at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.reconciled(CompilationUnitEditor.java:1670) at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconciled(JavaReconcilingStrategy.java:219) at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconciled(JavaCompositeReconcilingStrategy.java:164) at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:144) at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:105) at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:414) - locked Monitor@1feb6e9c at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:413) at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:173) T68 is created by T1 at org.eclipse.jface.text.reconciler.AbstractReconciler.startReconciling(AbstractReconciler.java:577)}}}Looks like this field is lazily initialized. You may want to use the racey single-check pattern here to make it thread-safe.
475162,8/17/2015 9:58,daniel_megert,Data race on org.eclipse.jdt.text.tests.MarkOccurrenceTest.fOccurrences Here is the race report given by a dynamic race detector:Data race on field org.eclipse.jdt.text.tests.MarkOccurrenceTest.fOccurrences: {{{ Concurrent write in thread T64 (locks held: {Monitor@3def2050 Monitor@420c4aea}) ----> at org.eclipse.jdt.text.tests.MarkOccurrenceTest.access$2(MarkOccurrenceTest.java:79) at org.eclipse.jdt.text.tests.MarkOccurrenceTest$1.countOccurrences(MarkOccurrenceTest.java:137) - locked Monitor@420c4aea at org.eclipse.jdt.text.tests.MarkOccurrenceTest$1.countOccurrences(MarkOccurrenceTest.java:n/a) at org.eclipse.jdt.text.tests.MarkOccurrenceTest$1.selectionChanged(MarkOccurrenceTest.java:122) at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:180) at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:157) - locked Monitor@3def2050 at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:156) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55) T64 is created by T63 at org.eclipse.core.internal.jobs.WorkerPool.jobQueued(WorkerPool.java:148) Concurrent read in thread T1 (locks held: {Monitor@40866d39}) ----> at org.eclipse.jdt.text.tests.MarkOccurrenceTest.access$3(MarkOccurrenceTest.java:79) at org.eclipse.jdt.text.tests.MarkOccurrenceTest$2.condition(MarkOccurrenceTest.java:404) at org.eclipse.jdt.text.tests.performance.DisplayHelper.waitForCondition(DisplayHelper.java:76) at org.eclipse.jdt.text.tests.MarkOccurrenceTest.assertOccurrences(MarkOccurrenceTest.java:411) at org.eclipse.jdt.text.tests.MarkOccurrenceTest.testNoOccurrencesIfDisabled(MarkOccurrenceTest.java:358) at junit.framework.TestCase.runTest(TestCase.java:176) at junit.framework.TestCase.runBare(TestCase.java:141) at junit.framework.TestResult$1.protect(TestResult.java:122) at junit.framework.TestResult.runProtected(TestResult.java:142) at junit.framework.TestResult.run(TestResult.java:125) at junit.framework.TestCase.run(TestCase.java:129) at junit.framework.TestSuite.runTest(TestSuite.java:252) at junit.framework.TestSuite.run(TestSuite.java:247) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:23) at junit.extensions.TestSetup$1.protect(TestSetup.java:23) at junit.framework.TestResult.runProtected(TestResult.java:142) at junit.extensions.TestSetup.run(TestSetup.java:27) at junit.framework.TestSuite.runTest(TestSuite.java:252) at junit.framework.TestSuite.run(TestSuite.java:247) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:692) at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:319) at org.eclipse.test.UITestApplication$2.run(UITestApplication.java:197) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) - locked Monitor@40866d39 at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:131) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3794) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3433) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:157) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:654) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139) at org.eclipse.test.UITestApplication.runApplication(UITestApplication.java:140) at org.eclipse.test.UITestApplication.run(UITestApplication.java:62) at org.eclipse.test.UITestApplication.start(UITestApplication.java:212) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608) at org.eclipse.equinox.launcher.Main.run(Main.java:1515) at org.eclipse.equinox.launcher.Main.main(Main.java:1488) at org.eclipse.core.launcher.Main.main(Main.java:34) T1 is the main thread}}}It's basically saying that MarkOccurrenceTest.java#L137 and MarkOccurrenceTest.java#L404 are in a data race. According to the Java memory model it's possible for the read of fOccurrences at MarkOccurrenceTest.java#L405 to return -1 and fail the test.
475198,8/17/2015 15:18,markus.kell.r,"Unify 'Sort Members' messages in dialogs (actions preferences Clean Up) (In reply to Adrian Price from bug 474251 comment #5)> BTW I've just noticed that whereas the 'Sort members' label in the> 'Configure' dialog is ""Ignore fields and enum constants"" the corresponding> description in the parent preference page is ""Sort members excluding fields> enum constants and initializers"".Yes we should unify these messages."
475746,8/24/2015 17:17,mateusz.matela,"[formatter] insert-space rules sometimes ignored with anonymous subclass or when Annotations present Created attachment 256085screenshot of bugMy rule set should insert spaces before the final parentheses in the following. Look for the following: ""new Point( x y)"" and ""String s)"". Also the hashCode() method should not contain any spaces inbetween its parentheses.The bug is happening for me on stock Eclipse 4.5 as well as last night's nightly: Version: Neon (4.6) Build id: N20150823-2000.Here's my code sample:-----import java.awt.*;public class MyClass{	static int x = 1 y = 2;	static Point p = new Point( x y)	{ /* Notice: this is an anonymous subclass of Point. */		@Override		public int hashCode( )		{			return 42;		}	};	MyClass( @Annotation( ""annotationVal"" ) String s)	{	}}-----"
475791,8/25/2015 6:53,mateusz.matela,"[formatter] Additional blank line before static initializer When comparing the formatter between Luna and Mars the following issue is shown:https://github.com/OpenGamma/Strata/commit/32d7df3be5b6074268bfe92495c6e926e69cd0f7#diff-b26bcfe59b0e2af553f4654dafc60b1aR25In the Luna formatter the following code was accepted: private static final String FOO; static { FOO = null; }With Mars this is reformatted with an additional blank line: private static final String FOO; static { FOO = null; }The following settings are in use:https://github.com/OpenGamma/Strata/commit/32d7df3be5b6074268bfe92495c6e926e69cd0f7#diff-d30097771ce51124181036238439b176R1We use the Luna formatting style above for static initializers where the initializer refers to the variable to indicate that the two are related. As such the additional blank line is a real pain.I would be happy to accept a new preference option on the blank lines tab if necessary presumably ""before static initializers"".When considering this issue instance initializers should also be checked."
475793,8/25/2015 7:05,mateusz.matela,"[formatter] Incorrect whitespace after lambda block When comparing the formatter between Luna and Mars the following issue is shown:https://github.com/OpenGamma/Strata/commit/32d7df3be5b6074268bfe92495c6e926e69cd0f7#diff-664c9c6c3f81c57b76a90b484baf8317R171In the Luna formatter the following code was accepted: Foo.bar(() -> {} IllegalArgumentException.class);With Mars this is reformatted with an additional blank line: Foo.bar(() -> {} IllegalArgumentException.class);Note the additional incorrect space added after the lambda blockThe following preferences are in use:https://github.com/OpenGamma/Strata/commit/32d7df3be5b6074268bfe92495c6e926e69cd0f7#diff-d30097771ce51124181036238439b176R1Notably the preferences on the ""White space"" tab under ""Control Statements""/""Blocks"" has ""after closing brace"" set to true. When that is set to false the lambda block is formatted correctly. Unfortunately if/else blocks are then formatted incorrectly.As such I believe that this will require a new preference option. This would separate ""Blocks"" from ""Lambda blocks""."
475865,8/26/2015 3:39,mateusz.matela,JDT deletes code I have the following line of code:private Runnable disposeRunnable = () -> dispose();I change it to:private Runnable disposeRunnable = this::dispose(); // not syntactical correct and save. I know that I still need to remove the () at the end but CTRL+S is hardcode into my fingers.JDT changes the code to:dispose();To test this you can use org.eclipse.jface.resource.ImageRegistry and adjust line 57 to the starting point of:private Runnable disposeRunnable = () -> dispose();
476020,8/27/2015 6:16,markus.kell.r,"CCE in AbstractInformationControl when trying to filter Quick Type Hierarchy Example from bug 395202 comment #8:public class Foo {	Foo foo = new Foo() { }; // caret in ""Foo()"" Ctrl+O Ctrl+O T	void bar() {		new Foo() { }; // same problem	}}--------------------------------------------In the above example place caret at ""Foo()"" and press Ctrl+T.Type anything in quick type hierarchy say 'a'.We get the CCE in Error log.This happens in 4.5.1 RC2 and Neon I20150825-0800. But not reproducible with 4.5 and Neon I20150803-2000. So could be a result of fix for bug 395202.java.lang.ClassCastException: org.eclipse.jdt.internal.ui.typehierarchy.TraditionalHierarchyViewer$TraditionalHierarchyContentProvider cannot be cast to org.eclipse.jface.viewers.ITreePathContentProvider	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.hasUnfilteredChild(AbstractInformationControl.java:146)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.selectTreePath(AbstractInformationControl.java:140)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$NamePatternFilter.select(AbstractInformationControl.java:118)	at org.eclipse.jface.viewers.ViewerFilter.filter(ViewerFilter.java:56)	at org.eclipse.jface.viewers.StructuredViewer.getFilteredChildren(StructuredViewer.java:910)	at org.eclipse.jface.viewers.AbstractTreeViewer.getSortedChildren(AbstractTreeViewer.java:617)	at org.eclipse.jface.viewers.AbstractTreeViewer.updateChildren(AbstractTreeViewer.java:2647)	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefreshStruct(AbstractTreeViewer.java:1916)	at org.eclipse.jface.viewers.TreeViewer.internalRefreshStruct(TreeViewer.java:684)	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefreshStruct(AbstractTreeViewer.java:1923)	at org.eclipse.jface.viewers.TreeViewer.internalRefreshStruct(TreeViewer.java:684)	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java:1891)	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java:1848)	at org.eclipse.jface.viewers.AbstractTreeViewer.internalRefresh(AbstractTreeViewer.java:1834)	at org.eclipse.jface.viewers.StructuredViewer$7.run(StructuredViewer.java:1526)	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1462)	at org.eclipse.jface.viewers.TreeViewer.preservingSelection(TreeViewer.java:366)	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1423)	at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1523)	at org.eclipse.jface.viewers.ColumnViewer.refresh(ColumnViewer.java:522)	at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1482)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl.stringMatcherUpdated(AbstractInformationControl.java:427)	at org.eclipse.jdt.internal.ui.typehierarchy.HierarchyInformationControl.stringMatcherUpdated(HierarchyInformationControl.java:305)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl.setMatcherString(AbstractInformationControl.java:449)	at org.eclipse.jdt.internal.ui.text.AbstractInformationControl$6.modifyText(AbstractInformationControl.java:415)	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:179)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4362)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1113)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1137)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1118)	at org.eclipse.swt.widgets.Text.wmCommandChild(Text.java:3071)	at org.eclipse.swt.widgets.Control.WM_COMMAND(Control.java:4824)	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4679)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5063)	at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method)	at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:2443)	at org.eclipse.swt.widgets.Text.callWindowProc(Text.java:260)	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4774)	at org.eclipse.swt.widgets.Text.windowProc(Text.java:2671)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5050)	at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)	at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2549)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3767)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:157)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:654)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:601)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)	at org.eclipse.equinox.launcher.Main.run(Main.java:1515)"
476059,8/27/2015 11:14,loskutov,"ExternalFoldersManager.RefreshJob interrupts auto build job Similar to bug 474003: if the project is changed during auto build ExternalFoldersManager.RefreshJob is triggered and if the auto-build job is still running RefreshJob will interrupt the build via folder.refreshLocal() -> workspace.prepareOperation() -> buildManager.interrupt();In our case we saw endless auto-build series in our xtext based application because at the beginning of the build builder ""touched"" the project but failed to continue because it was interrupted by ExternalFoldersManager.RefreshJob.The fix is trivial and should not break ExternalFoldersManager.RefreshJob - it just need to be made a ""system"" job.I will try to provide a small reproducible example.Patch follows too."
476281,9/1/2015 5:13,sasikanth.bharadwaj,"[1.8] Using a local class inside a lambda inside an enum constant triggers a VerifyError This code compiles and throws a VerifyError at runtimepublic enum LambdaEnumLocalClassBug { A(() -> { class Foo { } new Foo(); }) ; private final Runnable runnable; private LambdaEnumLocalClassBug(Runnable runnable) { this.runnable = runnable; } public static void main(String[] args) { A.runnable.run(); }}If you take a look to the generated code there is obviously a bug because the constructor of Foo doesn't call the constructor of Object.Compiled from ""LambdaLocalClassBug.java""class LambdaLocalClassBug$1Foo { int x; LambdaLocalClassBug$1Foo(); Code: 0: return}the generated code should be:Compiled from ""LambdaLocalClassBug.java""class LambdaLocalClassBug$1Foo { int x; LambdaLocalClassBug$1Foo(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.""<init>"":()V 4: return} R??mi"
476304,9/1/2015 8:43,jarthana,"Eclipse can't ""Open Type"" with multilevel InnerClasses from TargetPlatform Created attachment 256283Workspace and TargetPlatform for ""Steps to reproduce""Found with:4.4.1 Eclipse LunaReproduced with:4.5.0 MarsCurrent result:Eclipse can't ""Open Type"" with InnerClasses from TargetPlatform that are on a level >1 in its defining class. The defining class will be loaded on line 1 instead.Steps to reproduce:- Open Eclipse with Workspace ""eclipse_bug/workspace""- Open Project ""Test2"" (so its types won't be resolved from the TargetPlatform)- Try to ""Open Type"" TestLevel1A ([CTRL] + [SHIFT] + [T]) or use [F3] on TestLevel1A in test.Main.main(...)-- Eclipse will open ""TestClassWithMultilevelInnerClasses"" and jump to L4 (""public class TestLevel1A {"") (Level = 1)- Try to ""Open Type"" TestLevel2A ([CTRL] + [SHIFT] + [T]) or use [F3] on TestLevel2A in test.Main.main(...)-- Eclipse will open ""TestClassWithMultilevelInnerClasses"" and jump to L46 (""public class TestLevel2A {"") (Level = 2)- Close Project ""Test2"" (so its types will be resolved from the TargetPlatform)- Try to ""Open Type"" TestLevel1A ([CTRL] + [SHIFT] + [T]) or use [F3] on TestLevel1A in test.Main.main(...)-- Eclipse will open ""TestClassWithMultilevelInnerClasses"" and jump to L4 (""public class TestLevel1A {"") (Level = 1)- Try to ""Open Type"" TestLevel2A ([CTRL] + [SHIFT] + [T]) or use [F3] on TestLevel2A in test.Main.main(...)-- Eclipse will open ""TestClassWithMultilevelInnerClasses"" and jump line 1 (Level = 2 / The same behavior will occur for all inner classes that are on a level >1 in its defining class)Excepted result:Eclipse can open InnerClasses and jump to the line of declaration on any level in its defining class and regardless of whether the type comes from the Workspace or TargetPlatform.Notes:This is bug is really uncomfortable if you??re working on a project that is based on Eclipse Scout (and suchlike) which relies heavily on InnerClasses for defining its model hierarchy."
476517,9/3/2015 4:38,noopur_gupta,"[1.8][quick fix] ""Add unimplemented methods"" creates stubs for methods with default implementation The problem is like this:let's say first there was an interface to be implemented by clients interface IHasInt { int getInt();}Later you want the implementors to be able to provide a BigInteger without breaking old implementors and without the need to implement the old method for new implementors (And the caller wants to be able to distinguish old and new implementations). So you defineinterface IHasIntAsBigInteger extends IHasInt {	default int getInt() {		return getIntAsBigInteger().intValue();	}		getIntAsBigInteger();}If a class implements IHasIntAsBigInteger and the dev applies ""add unimplemented methods"". Stubs for both methods are created which is bad. Propably due to the fact that both methods occur abstract somewhere in the interface hierarchy not eliminating those with a default occurance."
476528,9/3/2015 6:00,jarthana,"Wrong parameter name for user-defined Enum.valueOf If an enumeration has another method valueOf other than the compiler-generated the parameter name obtained through reflexion is wrong (it is always ""name"");public enum Foo { BAR; public static Foo valueOf(int intParameter) { throw new UnsupportedOperationException(); } public static Foo valueOf2(int intParameter) { throw new UnsupportedOperationException(); } public static void main(String[] args) throws NoSuchMethodException { for (java.lang.reflect.Parameter p : Foo.class.getMethod(""valueOf"" Integer.TYPE).getParameters()) { System.out.println(p.getName()); // outputs ""name"" instead of ""intParameter"" } for (java.lang.reflect.Parameter p : Foo.class.getMethod(""valueOf2"" Integer.TYPE).getParameters()) { System.out.println(p.getName()); // outputs ""intParameter"" (ok) } }}"
476693,9/5/2015 4:44,jarthana,"[1.8] Open declaration jumps to the wrong method when overloaded The following is the most minimal configuration that I have found to reproduce this issue:----------------------------------------------------------------import static java.util.stream.Collectors.toList;import java.util.List;import java.util.Spliterator;import java.util.stream.Stream;public class Test { <T1 T2> Seq<Tuple2<T1 T2>> m(Stream<T1> arg1 Stream<T2> arg2) { System.out.println(""m1""); return null; } <T1 T2> Seq<Tuple2<T1 T2>> m(Iterable<T1> arg1 Iterable<T2> arg2) { System.out.println(""m2""); return null; } <T1 T2> Seq<Tuple2<T1 T2>> m(Seq<T1> arg1 Seq<T2> arg2){ System.out.println(""m3""); return null; } <T1 T2 T3> void m(Seq<T1> c1 Seq<T2> c2 Seq<T3> c3) { // Click F3 on the m() call. This will jump to m3 correctly Seq<Tuple2<T1 T2>> s = m(c1 c2); try { // Click F3 on the m() call. This will jump to m1 erroneously List<Tuple2<T1 T2>> l = m(c1 c2).collect(toList()); } catch (NullPointerException ignore) {} } public static void main(String[] args) { new Test().m(null null null); }}interface Seq<T> extends Stream<T> Iterable<T> { @Override default Spliterator<T> spliterator() { return Iterable.super.spliterator(); }}interface Tuple2<T1 T2> {}interface Tuple3<T1 T2 T3> {}----------------------------------------------------------------The problem is only related to the ""open declaration"" functionality. The compiler links the correct method (m3 is output two times) and also when clicking on / highlighting ""m3"" both m() calls are highlighted as well.I have found that both the assignment to the ""List<Tuple2<T1 T2>>"" type as well as the ""collect"" call are relevant to reproduce this issue."
476738,9/7/2015 2:49,manpalat,ClassCastException in MatchLocator.getMostApplicableMethod (MatchLocator.java:1043) The following incident was reported via the automated error reporting: code: 10.001 plugin: org.eclipse.jdt.ui_3.11.0.v20150527-0925 message: HIDDEN fingerprint: b4dc998a exception class: java.lang.reflect.InvocationTargetException exception message: HIDDEN number of children: 0 java.lang.reflect.InvocationTargetException: HIDDEN at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:420) at org.eclipse.ui.internal.WorkbenchWindow$14.run(WorkbenchWindow.java:2156) at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2152) at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:191) at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper.perform(RefactoringExecutionHelper.java:151) at org.eclipse.jdt.ui.refactoring.RenameSupport.perform(RenameSupport.java:198) at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameLinkedMode.doRename(RenameLinkedMode.java:362) at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameLinkedMode$EditorSynchronizer.left(RenameLinkedMode.java:119) at org.eclipse.jface.text.link.LinkedModeModel.exit(LinkedModeModel.java:341) at org.eclipse.jface.text.link.LinkedModeUI$4.run(LinkedModeUI.java:1193) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4155) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3772) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:654) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) at sun.reflect.NativeMethodAccessorImpl.invoke0(null:-2) at sun.reflect.NativeMethodAccessorImpl.invoke(null:-1) at sun.reflect.DelegatingMethodAccessorImpl.invoke(null:-1) at java.lang.reflect.Method.invoke(null:-1) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608) at org.eclipse.equinox.launcher.Main.run(Main.java:1515) at org.eclipse.equinox.launcher.Main.main(Main.java:1488)caused by: java.lang.ClassCastException: HIDDEN at org.eclipse.jdt.internal.core.search.matching.MatchLocator.getMostApplicableMethod(MatchLocator.java:1043) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.getMethodBinding0(MatchLocator.java:1125) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.getMethodBinding(MatchLocator.java:925) at org.eclipse.jdt.internal.core.search.matching.MethodLocator.matchMethod(MethodLocator.java:361) at org.eclipse.jdt.internal.core.search.matching.MethodLocator.resolveLevel(MethodLocator.java:749) at org.eclipse.jdt.internal.core.search.matching.MethodLocator.resolveLevel(MethodLocator.java:679) at org.eclipse.jdt.internal.core.search.matching.OrLocator.resolveLevel(OrLocator.java:317) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2599) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1849) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1258) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1299) at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1416) at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:122) at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232) at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516) at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584) at org.eclipse.jdt.internal.corext.refactoring.rename.RenameMethodProcessor.searchForOuterTypesOfReferences(RenameMethodProcessor.java:423) at org.eclipse.jdt.internal.corext.refactoring.rename.RenameMethodProcessor.doCheckFinalConditions(RenameMethodProcessor.java:338) at org.eclipse.jdt.internal.corext.refactoring.rename.RenameVirtualMethodProcessor.doCheckFinalConditions(RenameVirtualMethodProcessor.java:146) at org.eclipse.jdt.internal.corext.refactoring.rename.JavaRenameProcessor.checkFinalConditions(JavaRenameProcessor.java:48) at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:224) at org.eclipse.ltk.core.refactoring.Refactoring.checkAllConditions(Refactoring.java:162) at org.eclipse.jdt.internal.ui.refactoring.RefactoringExecutionHelper$Operation.run(RefactoringExecutionHelper.java:80) at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39) at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729) at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2241) at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5409) at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:106) at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:119) General Information: reported-by: Paul Austin anonymous-id: ec0143c2-afd9-441c-bf40-a429bfc17683 eclipse-build-id: 4.5.0.I20150603-2000 eclipse-product: org.eclipse.epp.package.jee.product operating system: Windows8 6.3.0 (x86_64) - win32 jre-version: 1.8.0_45-b14The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.databinding.observable_1.5.0.v20150422-0725 2. org.eclipse.core.databinding_1.5.0.v20150422-0725 3. org.eclipse.core.resources_3.10.0.v20150423-0755 4. org.eclipse.core.runtime_3.11.0.v20150405-1723 5. org.eclipse.e4.ui.workbench_1.3.0.v20150531-1948 6. org.eclipse.e4.ui.workbench.swt_0.13.0.v20150504-0621 7. org.eclipse.equinox.app_1.3.300.v20150423-1356 8. org.eclipse.equinox.launcher_1.3.100.v20150511-1540 9. org.eclipse.jdt.core_3.11.0.v20150602-1242 10. org.eclipse.jdt_3.11.0.v20150603-2000 11. org.eclipse.jdt.ui_3.11.0.v20150527-0925 12. org.eclipse.jface_3.11.0.v20150602-1400 13. org.eclipse.jface.text_3.10.0.v20150603-1752 14. org.eclipse.ltk.core.refactoring_3.6.200.v20140826-0859 15. org.eclipse.swt_3.104.0.v20150528-0211 16. org.eclipse.ui_3.107.0.v20150507-1945 17. org.eclipse.ui.ide.application_1.1.0.v20150422-0725 18. org.eclipse.ui.ide_3.11.0.v20150510-1749Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.Other Resources:* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/55a6f043e4b0cf2e4bf602c1 * Manual: https://dev.eclipse.org/recommenders/community/confess/#/guideThank you for your assistance.Your friendly error-reports-inbox.
476859,9/8/2015 5:54,sasikanth.bharadwaj,enclosing method not found error when EJC compiled works fine with oracle jdk compiler Created attachment 256434class unit test failure tracesSee the attached class and the corresponding unit tests. All tests pass when run on command line with oracle jdk 1.8.0_60 . Running them inside eclipse there are 2 internal errors and 2 failures see attachment for code and error traces.
476861,9/8/2015 6:39,mat.booth,"[test] test failures when javafx is not available On my platform (openjdk on RHEL or Fedora) javafx is not available.This causes some tests in bundle o.e.jdt.core.tests.compiler to fail.I will submit a patch that skips the test in the case when javafx is not available on the platform running the tests. This follows the convention set out by the ""o.e.jdt.core.tests.builder"" bundle [1] where the test method simply returns without error if the javafx library does not exist.[1] http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/tree/org.eclipse.jdt.core.tests.builder/src/org/eclipse/jdt/core/tests/builder/IncrementalTests18.java#n311"
476930,9/8/2015 23:51,sarika.sinha,NullPointerException in AbstractJavaLaunchConfigurationDelegate.getDefaultWorkingDirectory (AbstractJavaLaunchConfigurationDelegate.java:995) The following incident was reported via the automated error reporting:The user(s) left the following comments:--- Pawel Puterla wrote: ---Trying to run a code from RSE project code: 2 plugin: org.eclipse.core.jobs_3.7.0.v20150330-2103 message: HIDDEN fingerprint: c41ebc8d exception class: java.lang.NullPointerException exception message: HIDDEN number of children: 0 java.lang.NullPointerException: HIDDEN at org.eclipse.jdt.launching.AbstractJavaLaunchConfigurationDelegate.getDefaultWorkingDirectory(AbstractJavaLaunchConfigurationDelegate.java:995) at org.eclipse.jdt.launching.AbstractJavaLaunchConfigurationDelegate.verifyWorkingDirectory(AbstractJavaLaunchConfigurationDelegate.java:683) at org.eclipse.jdt.launching.JavaLaunchDelegate.launch(JavaLaunchDelegate.java:54) at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:885) at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:739) at org.eclipse.debug.internal.ui.DebugUIPlugin.buildAndLaunch(DebugUIPlugin.java:1039) at org.eclipse.debug.internal.ui.DebugUIPlugin$8.run(DebugUIPlugin.java:1256) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55) General Information: reported-by: Pawel Puterla anonymous-id: 0dc51669-b051-483d-870a-17f4b6fa2608 eclipse-build-id: 4.5.0.I20150603-2000 eclipse-product: org.eclipse.epp.package.java.product operating system: Windows7 6.1.0 (x86_64) - win32 jre-version: 1.8.0_40-b26The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.jobs_3.7.0.v20150330-2103 2. org.eclipse.debug.core_3.10.0.v20150303-1130 3. org.eclipse.debug.ui_3.11.0.v20150514-0917 4. org.eclipse.jdt.launching_3.8.0.v20150527-0946 5. org.eclipse.jdt_3.11.0.v20150603-2000Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.Other Resources:* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/55e6e849e4b0f02971da3eac * Manual: https://dev.eclipse.org/recommenders/community/confess/#/guideThank you for your assistance.Your friendly error-reports-inbox.This bug was created on behalf of sarika.sinha@xxxxxxxxxxxx.
477005,9/9/2015 16:43,mateusz.matela,"[formatter] NullPointerException when first line is empty and indented With ""Indent empty lines"" turned on and one or more empty lines before package declaration the formatter throws an exception:java.lang.NullPointerException	at org.eclipse.jdt.internal.formatter.TextEditsBuilder.bufferWhitespaceBefore(TextEditsBuilder.java:156)	at org.eclipse.jdt.internal.formatter.TextEditsBuilder.token(TextEditsBuilder.java:119)	at org.eclipse.jdt.internal.formatter.TokenTraverser.traverse(TokenTraverser.java:103)	at org.eclipse.jdt.internal.formatter.TokenManager.traverse(TokenManager.java:378)	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:161)	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:139)	at org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.format2(CodeFormatterUtil.java:227)	at org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.format2(CodeFormatterUtil.java:254)	at org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.format(CodeFormatterUtil.java:182)"
477263,9/12/2015 10:12,sasikanth.bharadwaj,"[1.8][compiler] No enclosing instance of the type Outer is accessible in scope for method reference The following code compiles with javac 1.8.0_60 but not with Eclipse. It looks as though the call of ""function.apply(null)"" causes issues with the subsequent constructor reference ""Inner::new""--------------------------------------------------------import java.util.function.Function;interface Test<T> { static <K> void test(Function<? ? extends K> function) { class Outer { class Inner { public Inner(K k) { } private void method(K k) { function.apply(null); Function<K Inner> f = Inner::new; } } } }}--------------------------------------------------------The following equivalent program compiles--------------------------------------------------------import java.util.function.Function;interface Test<T> { static <K> void test(Function<? ? extends K> function) { class Outer { class Inner { public Inner(K k) { } private void method(K k) { function.apply(null); Function<K Inner> f = x -> new Inner(x); } } } }}--------------------------------------------------------"
477324,9/14/2015 3:09,noopur_gupta,"[quick fix] NullPointerException in ModifierCorrectionSubProcessor.addAbstractMethodProposals (ModifierCorrectionSubProcessor.java:588) The following incident was reported via the automated error reporting: code: 2 plugin: org.eclipse.jdt.ui_3.11.0.v20150527-0925 message: Problems occurred when invoking code from plug-in: ""org.eclipse.jdt.ui"". fingerprint: 56fa7ca8 exception class: java.lang.NullPointerException exception message: - number of children: 0 java.lang.NullPointerException: null at org.eclipse.jdt.internal.ui.text.correction.ModifierCorrectionSubProcessor.addAbstractMethodProposals(ModifierCorrectionSubProcessor.java:588) at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.process(QuickFixProcessor.java:491) at org.eclipse.jdt.internal.ui.text.correction.QuickFixProcessor.getCorrections(QuickFixProcessor.java:316) at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionCollector.safeRun(JavaCorrectionProcessor.java:378) at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.run(JavaCorrectionProcessor.java:339) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor$SafeCorrectionProcessorAccess.process(JavaCorrectionProcessor.java:335) at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectCorrections(JavaCorrectionProcessor.java:468) at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.collectProposals(JavaCorrectionProcessor.java:280) at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionProcessor.computeQuickAssistProposals(JavaCorrectionProcessor.java:242) at org.eclipse.jface.text.quickassist.QuickAssistAssistant$ContentAssistProcessor.computeCompletionProposals(QuickAssistAssistant.java:75) at org.eclipse.jface.text.contentassist.ContentAssistant$5.run(ContentAssistant.java:1904) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.jface.text.contentassist.ContentAssistant.computeCompletionProposals(ContentAssistant.java:1902) at org.eclipse.jface.text.contentassist.CompletionProposalPopup.computeProposals(CompletionProposalPopup.java:573) at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$16(CompletionProposalPopup.java:570) at org.eclipse.jface.text.contentassist.CompletionProposalPopup$2.run(CompletionProposalPopup.java:505) at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) at org.eclipse.jface.text.contentassist.CompletionProposalPopup.showProposals(CompletionProposalPopup.java:499) at org.eclipse.jface.text.contentassist.ContentAssistant.showPossibleCompletions(ContentAssistant.java:1720) at org.eclipse.jface.text.quickassist.QuickAssistAssistant.showPossibleQuickAssists(QuickAssistAssistant.java:128) at org.eclipse.jdt.internal.ui.text.correction.JavaCorrectionAssistant.showPossibleQuickAssists(JavaCorrectionAssistant.java:200) at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:192) at org.eclipse.ui.texteditor.TextOperationAction$1.run(TextOperationAction.java:128) at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70) at org.eclipse.ui.texteditor.TextOperationAction.run(TextOperationAction.java:126) at org.eclipse.jface.action.Action.runWithEvent(Action.java:473) at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122) at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90) at sun.reflect.GeneratedMethodAccessor57.invoke(null:-1) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56) at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:252) at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:234) at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132) at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152) at org.eclipse.core.commands.Command.executeWithChecks(Command.java:493) at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:486) at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324) at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86) at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84) at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1550) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1326) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1351) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1336) at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1363) at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:763) at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:3317) at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:785) at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:1965) at org.eclipse.swt.widgets.Control.windowProc(Control.java:5590) at org.eclipse.swt.widgets.Display.windowProc(Display.java:4717) at org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(OS.java:-2) at org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:9272) at org.eclipse.swt.widgets.Display.eventProc(Display.java:1225) at org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(OS.java:-2) at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:2422) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3428) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018) at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:654) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) at sun.reflect.NativeMethodAccessorImpl.invoke0(NativeMethodAccessorImpl.java:-2) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608) at org.eclipse.equinox.launcher.Main.run(Main.java:1515) at org.eclipse.equinox.launcher.Main.main(Main.java:1488) General Information: reported-by: Marcello Nuccio anonymous-id: 7228e5a2-6df2-4975-8f28-9c20866a1027 eclipse-build-id: 4.5.0.I20150603-2000 eclipse-product: org.eclipse.epp.package.java.product operating system: Linux 3.13.0 (x86_64) - gtk jre-version: 1.8.0_45-b14The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.commands_3.7.0.v20150422-0725 2. org.eclipse.core.databinding.observable_1.5.0.v20150422-0725 3. org.eclipse.core.databinding_1.5.0.v20150422-0725 4. org.eclipse.core.runtime_3.11.0.v20150405-1723 5. org.eclipse.e4.core.commands_0.11.0.v20150422-0725 6. org.eclipse.e4.core.contexts_1.4.0.v20150421-2214 7. org.eclipse.e4.core.di_1.5.0.v20150421-2214 8. org.eclipse.e4.ui.bindings_0.11.0.v20150422-0725 9. org.eclipse.e4.ui.workbench_1.3.0.v20150531-1948 10. org.eclipse.e4.ui.workbench.swt_0.13.0.v20150504-0621 11. org.eclipse.equinox.app_1.3.300.v20150423-1356 12. org.eclipse.equinox.launcher_1.3.100.v20150511-1540 13. org.eclipse.jdt.ui_3.11.0.v20150527-0925 14. org.eclipse.jdt_3.11.0.v20150603-2000 15. org.eclipse.jface_3.11.0.v20150602-1400 16. org.eclipse.jface.text_3.10.0.v20150603-1752 17. org.eclipse.swt_3.104.0.v20150528-0211 18. org.eclipse.ui_3.107.0.v20150507-1945 19. org.eclipse.ui.ide.application_1.1.0.v20150422-0725 20. org.eclipse.ui.ide_3.11.0.v20150510-1749Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.Other Resources:* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/55a61b68e4b0cf2e4bf5ecd9 * Manual: https://dev.eclipse.org/recommenders/community/confess/#/guideThank you for your assistance.Your friendly error-reports-inbox."
477387,9/14/2015 13:23,jarthana,[1.9] JDT tests are incredibly slow with JRE 9 I clocked few samples like NullTypeAnnotationTest org.eclipse.jdt.apt.tests.TestAll and I clearly see the test take about four times more with JRE 9. Here are the reasons why it is so:1. First and foremost JDT has no clue how to load only the bootmodules.jimage and we end up reading everything known to the JVM.2. Several sub components assume that JavaModelManager caches the zip files and don't bother caching information themselves. This caching is not available to Jimages though.The latter needs to be looked at case by case and fixed.But we also need to take a look at (1). We simply can't afford to load every available class in the JVM. Even if we can't read specific jimage files as of today we should at least be able to load only specific modules. Ideally we should leave it to the user to choose what modules he/she wants to be loaded. But for that JDT should provide a configurable method. And this should be provisioned in a way that all JDT components (Java Model compiler batch compiler JSR 199 etc.) could leverage.
477430,9/15/2015 4:34,mateusz.matela,"[formatter] wrong indentation when nesting anonymous classes Since the change of the code formatter in Mars the indentation of anonymous inner classes is incorrect when used as method parameter. Might be related to additional formatter settings like 'Never join already wrapped lines"" and 'Function Calls -> Arguments -> Line wrapping policy = Wrap where necessary""The indentation policy was never touched and is set to 'Default indentation'As you can see in the following snippet the anonymous inner class is indented dependent to the method call not dependent to the definition of the anonymous inner class. configRegistry.registerConfigAttribute( ExportConfigAttributes.EXPORT_FORMATTER new IExportFormatter() { @Override public Object formatForExport(ILayerCell cell IConfigRegistry configRegistry) { // simply return the data value which is an // integer for the row header // doing this avoids the default conversion to // string for export return cell.getDataValue(); } } DisplayMode.NORMAL GridRegion.ROW_HEADER);"
477476,9/15/2015 12:08,mateusz.matela,"Auto-formatter gets indentation wrong when used as post-save action To reproduce:Load the /platform/eclipse.platform.ui git repositoryImport the project org.eclipse.ui.ideEdit the file CopyFilesAndFoldersOperation.javaLine 1815 looks like this:						copyResources);Change it to this: copyResources.clone());Save.Observed:The post-save action runs the formatter and the formatter removes all indentation from line 1815 moving the text ""copyResources.clone()"" to the beginning of the line.Expected:Either no change in indentation or correct indentation."
477487,9/15/2015 13:07,markus.kell.r,"Declaration view background color should use same default as Source hover The Declaration view background color defaults to COLOR_INFO_BACKGROUND. On systems with bright-on-dark tooltips this makes the Declaration view unreadable.From /org.eclipse.jdt.ui/plugin.xml: <colorDefinition label=""%DeclarationViewBackgroundColor.label"" categoryId=""org.eclipse.jdt.ui.presentation"" value=""COLOR_INFO_BACKGROUND"" id=""org.eclipse.jdt.ui.DeclarationView.backgroundColor"">The Java source hover once had the same problem but that was fixed using org.eclipse.jdt.internal.ui.text.java.hover.SourceViewerInformationControl#getVisibleBackgroundColor(Display).We should move that method into org.eclipse.jdt.internal.ui.JavaUIPreferenceInitializer and then use it to initialize the DeclarationView.backgroundColor with a better color."
477790,9/18/2015 6:01,sxenos,Change usage of SubProgressMonitor to SubMonitor in org.eclipse.jdt.core SubProgressMonitor has bad performance characteristics and SubMonitorwas offered 2007 as replacement for it. Platform recently deprecatedSubProgressMonitor and continues to improve performance of SubMonitorSee Bug 475767 Bug 475785 and Bug 475747 for details.
477888,9/20/2015 3:22,sasikanth.bharadwaj,"[1.8][compiler] Compiler silently produces garbage but editor shows no errors I tried print annotated lines with new lambdas and produced the naive code below which seem to be ""accepted"" by Eclipse but produces bytecode with ""Unresolved compilation problem"".The Java editor in Eclipse doesn't show any sign of a problem but the javac produces this:###import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.function.Consumer;public class Test {	public static void main(String[] args) throws IOException {		Files.lines(Paths.get(args[0])).filter(x -> !x.startsWith(""."")).forEach(printMe());	}	private static Consumer<String> printMe() {		return x -> x.isEmpty() ? System.out.println() : System.out.println(getIndex() + "" "" + x); // error must be reported here!	}	static int idx;	private static int getIndex() {		return ++idx;	}}###javac *.javaTest.java:13: error: incompatible types: bad return type in lambda expression return x -> x.isEmpty() ? System.out.println() : System.out.println(getIndex() + "" "" + x); ^ target-type for conditional expression cannot be void 1 error"
477891,9/20/2015 8:26,sasikanth.bharadwaj,"[1.8] regression caused by the fix for bug 438812: order dependencies in analysis of default method inheritance As discussed in http://stackoverflow.com/questions/32663581/why-does-order-of-implementing-interfaces-with-default-methods-matter-in-javaTurns out that our fix for bug 438812 introduced a bogus order dependence: //---interface A { public default void display() { System.out.println(""Display from A""); }}interface B extends A { public default void display() { System.out.println(""Display from B""); }}interface C extends A { public void display();}public interface D extends B C {}//---Prior to bug 438812 we correctly reported:The default method display() inherited from B conflicts with another method inherited from CAfter the fix we remain silent.The error *is* consistently reported however if we change D to //---public interface D extends C B { }//---"
478019,9/22/2015 1:42,sarika.sinha,StringIndexOutOfBoundsException in BinaryBasedSourceGenerator.getReturnStatement (BinaryBasedSourceGenerator.java:531) The following incident was reported via the automated error reporting: code: 120 plugin: org.eclipse.jdt.debug_3.8.100.v20140522-1618 message: Exception processing async thread queue fingerprint: 47d6498a exception class: org.eclipse.recommenders.internal.stacktraces.rcp.StandInStacktraceProvider$StandInException exception message: Stand-In Stacktrace supplied by Eclipse Stacktraces & Error Reporting Tool number of children: 1 org.eclipse.recommenders.internal.stacktraces.rcp.StandInStacktraceProvider$StandInException: Stand-In Stacktrace supplied by Eclipse Stacktraces & Error Reporting Tool at org.eclipse.core.internal.jobs.JobManager.endJob(JobManager.java:661) at org.eclipse.core.internal.jobs.WorkerPool.endJob(WorkerPool.java:105) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:71) --- code: 120 plugin: org.eclipse.jdt.debug_3.8.100.v20140522-1618 message: Exception processing async thread queue fingerprint: b96756d5 exception class: java.lang.StringIndexOutOfBoundsException exception message: String index out of range: 1 number of children: 0 java.lang.StringIndexOutOfBoundsException: String index out of range: 1 at java.lang.String.charAt(null:-1) at org.eclipse.jdt.internal.debug.eval.ast.engine.BinaryBasedSourceGenerator.getReturnStatement(BinaryBasedSourceGenerator.java:531) at org.eclipse.jdt.internal.debug.eval.ast.engine.BinaryBasedSourceGenerator.buildMethodDeclaration(BinaryBasedSourceGenerator.java:515) at org.eclipse.jdt.internal.debug.eval.ast.engine.BinaryBasedSourceGenerator.buildTypeDeclaration(BinaryBasedSourceGenerator.java:331) at org.eclipse.jdt.internal.debug.eval.ast.engine.BinaryBasedSourceGenerator.buildTypeDeclaration(BinaryBasedSourceGenerator.java:149) at org.eclipse.jdt.internal.debug.eval.ast.engine.BinaryBasedSourceGenerator.buildSource(BinaryBasedSourceGenerator.java:75) at org.eclipse.jdt.internal.debug.eval.ast.engine.EvaluationSourceGenerator.getInstanceSourceMapper(EvaluationSourceGenerator.java:217) at org.eclipse.jdt.internal.debug.eval.ast.engine.EvaluationSourceGenerator.getSource(EvaluationSourceGenerator.java:238) at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.getCompiledExpression(ASTEvaluationEngine.java:319) at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.evaluate(ASTEvaluationEngine.java:131) at org.eclipse.jdt.internal.debug.ui.JavaWatchExpressionDelegate$EvaluationRunnable.run(JavaWatchExpressionDelegate.java:142) at org.eclipse.jdt.internal.debug.core.model.JDIThread$ThreadJob.run(JDIThread.java:3158) at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54) General Information: reported-by: David Seide anonymous-id: a648ccd8-dc5d-41ef-8480-42ef10c15824 eclipse-build-id: 4.4.0.I20140606-1215 eclipse-product: org.eclipse.sdk.ide operating system: Windows8 6.3.0 (x86_64) - win32 jre-version: 1.8.0_25-b18The following plug-ins were present on the execution stack (*): 1. org.eclipse.core.jobs_3.6.0.v20140424-0053 2. org.eclipse.jdt.debug_3.8.100.v20140522-1618 3. org.eclipse.jdt_3.10.0.v20140606-1215 4. org.eclipse.jdt.debug.ui_3.6.300.v20140512-1926Please note that:* Messages stacktraces and nested status objects may be shortened.* Bug fields like status resolution and whiteboard are sent back to reporters.* The list of present bundles and their respective versions was calculated by package naming heuristics. This may or may not reflect reality.Other Resources:* Report: https://dev.eclipse.org/recommenders/committers/confess/#/problems/54c8b274e4b095b6c75549fa * Manual: https://dev.eclipse.org/recommenders/community/confess/#/guideThank you for your assistance.Your friendly error-reports-inbox.This bug was created on behalf of sarika.sinha@xxxxxxxxxxxx.
478042,9/22/2015 6:12,manpalat,[search] Support for Open Method using a single api Ref bug 470763 - This bug investigates the possibility of a single API for achieving the same.
478077,9/22/2015 11:20,markus.kell.r,[1.9] Render IPackageFragmentRoot#getElementName() if different from last path segment After bug 473901 comment 10 module names are not rendered in JDT UI because we assume the name of an IPFR is the name of its JAR file.
478136,9/23/2015 4:20,noopur_gupta,[1.8][clean up] Lambda rewriter removes annotations from method public class Class { public void method() { Runnable r = new Runnable() { @Override @Deprecated public void run() { } }; r.run(); }}When I process this code snippet with the lambda replacer the result is:public class Class { public void method() { Runnable r = () -> { }; r.run(); }}The @Deprecated annotation has been removed. Since this also happens with other annotations it has an effect especially in code that uses annotations for AspectJ weaving.The lambda cleanup should only remove @Override annotations.
478143,9/23/2015 5:16,manpalat,[1.9][search] type in non java.base module in bootmodules.jimage are not found in open type dialogue This is a follow-up of bug 473901 comment 9
478225,9/23/2015 14:39,jarthana,"JDT APT doesn't deal gracefully with 'broken' annotation processors When a broken annotation processor (one that throws exceptions) is activated on the factory path it can cause a 'bombardement' of error popups which make the IDE unusable.See for example here: https://jira.spring.io/browse/IDE-1381Broken processors while not the 'norm' can occur for a number of reasons and they should be handled gracefully.A number of things could be done: - detect broken processor and stop trying to execute it - use project error marker to indicate the problem instead of popup dialogs - write error to error log instead of popup in the UI.Really... the most import thing is... don't bombard the user with endless popups. So at the very least these errors should be dumped in error log instead of a UI popup.From the link above this stacktrace may help pinpoint where 'exceptions' might be escaping from the build-process and turning into a bombardment of popups:!ENTRY org.eclipse.core.resources 4 2 2015-09-23 09:22:05.893!MESSAGE Problems occurred when invoking code from plug-in: ""org.eclipse.core.resources"".!STACK 0java.lang.NoClassDefFoundError: org/springframework/boot/configurationprocessor/TypeExcludeFilter	at org.springframework.boot.configurationprocessor.ConfigurationMetadataAnnotationProcessor.<init>(ConfigurationMetadataAnnotationProcessor.java:89)	at sun.reflect.GeneratedConstructorAccessor262.newInstance(Unknown Source)	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)	at java.lang.reflect.Constructor.newInstance(Constructor.java:422)	at java.lang.Class.newInstance(Class.java:442)	at org.eclipse.jdt.apt.core.internal.ClassServiceFactory.newInstance(ClassServiceFactory.java:26)	at org.eclipse.jdt.internal.apt.pluggable.core.dispatch.IdeAnnotationProcessorManager.discoverNextProcessor(IdeAnnotationProcessorManager.java:92)	at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundDispatcher.round(RoundDispatcher.java:116)	at org.eclipse.jdt.internal.compiler.apt.dispatch.BaseAnnotationProcessorManager.processAnnotations(BaseAnnotationProcessorManager.java:159)	at org.eclipse.jdt.internal.apt.pluggable.core.dispatch.IdeAnnotationProcessorManager.processAnnotations(IdeAnnotationProcessorManager.java:134)	at org.eclipse.jdt.internal.compiler.Compiler.processAnnotations(Compiler.java:967)	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:489)	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:395)	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:183)	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:332)	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:62)	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:256)	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:180)	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:734)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:205)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:245)	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:300)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:303)	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:359)	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:382)	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:144)	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:235)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55) Attach one or more files to this issue"
478356,9/24/2015 17:14,jarthana,Update JDT web site
478360,9/24/2015 19:07,manpalat,"[1.9][search] AIOOBE while searching for java.base methods With the latest change in modules using build b82 and the patch of bug 473901 the search of java.base methods (for eg println) results in the following ArrayIndexOutofBoundException with the following stacktracejava.lang.ArrayIndexOutOfBoundsException	at java.lang.System.arraycopy(Native Method)	at org.eclipse.jdt.internal.compiler.util.ObjectVector.copyInto(ObjectVector.java:87)	at org.eclipse.jdt.internal.core.search.matching.PossibleMatchSet.getPossibleMatches(PossibleMatchSet.java:51)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1301)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1443)	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:122)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516)	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584)	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:148)	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)follow up of Ref bug 473901 comment 13 and bug 473901 comment 9Root cause is the addition of new Module structures in addition to PFR - search PossibleMatches need to factor in these structure while allocation."
478365,9/24/2015 19:23,manpalat,[1.9][search] Add Initial Unit Testing Support for search for Java 9 Or to put it simply create the first JavaSearchBugs9Tests.java unit test file with all usual required setup infra structure and util functions.
478427,9/25/2015 11:29,jarthana,"org.eclipse.jdt.internal.compiler.batch.Main.initializeAnnotationProcessorManager() consumes ClassNotFoundException In org.eclipse.jdt.internal.compiler.batch.Main.initializeAnnotationProcessorManager() the following code is present:protected void initializeAnnotationProcessorManager() {	try {		Class c = Class.forName(""org.eclipse.jdt.internal.compiler.apt.dispatch.BatchAnnotationProcessorManager""); //$NON-NLS-1$		AbstractAnnotationProcessorManager annotationManager = (AbstractAnnotationProcessorManager) c.newInstance();		annotationManager.configure(this this.expandedCommandLine);		annotationManager.setErr(this.err);		annotationManager.setOut(this.out);		this.batchCompiler.annotationProcessorManager = annotationManager;	} catch (ClassNotFoundException e) {		// ignore	} catch (InstantiationException e) {		// should not happen		throw new org.eclipse.jdt.internal.compiler.problem.AbortCompilation();	} catch (IllegalAccessException e) {		// should not happen		throw new org.eclipse.jdt.internal.compiler.problem.AbortCompilation();	} catch(UnsupportedClassVersionError e) {		// report a warning		this.logger.logIncorrectVMVersionForAnnotationProcessing();	}}If someone calls the eclipse compiler programmatically or from command line and does not have the org.eclipse.jdt.compiler.apt on the classpath the compiler simply ignores annotation processors without a single output or error message. This happens even if the user defines the ""-processors"" argument.What I would expect:If there is any annotation processor on the classpath and/or ""-processors"" is given and the org.eclipse.jdt.compiler.apt jar is missing the compilation should fail."
478714,9/30/2015 9:34,noopur_gupta,[1.7][quick fix] Multi-Catch QuickFix creates compiler error Created attachment 256939A video showing the errorSame as bug no. 388724. For administrative purposes I created a new bug report as it was requested from me.See the attached video for details. Quick fix generates broken code.
478780,10/1/2015 1:01,jarthana,add API IProblem#isInfo() Add API IProblem#isInfo() and fix the Javadoc of isError() and isWarning().
478807,10/1/2015 9:03,noopur_gupta,Update T&T document for bug 478136 See bug 478136 comment #10.
479094,10/5/2015 19:47,Lars.Vogel,Remove unused internal class TemplateContentProvider
479104,10/6/2015 0:11,jarthana,"[api] Provide API to compare two versions of Java Platform The requirement comes from Ant (bug 464845). The new API is more of utility and should provide comparison results and should support versions mentioned in JavaCore#COMPILER_CODEGEN_TARGET_PLATFORM.I have this in mind:	/**	 * Compares two given versions of the Java platform. The versions being	 * compared are <code>String</code> and one of the supported values mentioned in	 * {@link #COMPILER_CODEGEN_TARGET_PLATFORM COMPILER_CODEGEN_TARGET_PLATFORM}	 *	 * @param first version to be compared	 * @param second version to be compared	 * @return the value {@code 0} if both versions are same; * a value less than {@code 0} if <code>second</code> is higher than <code>first</code>; and * a value greater than {@code 0} if <code>first</code> is higher than <code>second</code>	 * @since 3.12	 */	public static int compareJavaVersions(String first String second) {}"
479105,10/6/2015 2:11,noopur_gupta,Adjust your Gerrit build trigger to store more than the 5 last runs Created attachment 257062ScreenshotCan you adjust your Gerrit build trigger to store more than the last 5 runs? Otherwise it is really hard to analyse build failure of changes as the build results are removed to quickly.https://hudson.eclipse.org/platform/job/eclipse.jdt.ui-Gerrit/I think 20 as we use in platform.ui is a good value.
479109,10/6/2015 3:37,mateusz.matela,[formatter] Add option to group aligned fields with blank lines With Mars.1 the formatter now does NOT restart the alignment after whitespace.So now ALL fields in the file are aligned.This is quite annoying to me since my files are divided in 'functional blocks'.Please fix this so that the alignment is restarted after whitespaceSee also https://bugs.eclipse.org/bugs/show_bug.cgi?id=474918#c12
479119,10/6/2015 4:37,sasikanth.bharadwaj,[1.8][compiler][codegen] Improve code generated for Serializable method/constructor references We turn a method/constructor reference into a lambda expression when the Functional Interface involved is Serializable.This needs to be avoided because it adds overhead and is inefficient.See Bug 430157 for more details
479130,10/6/2015 6:41,Lars.Vogel,Rename org.eclipse.jdt.core.tests.model/workspace/TypeResolve from org.eclipse.jdt.core to TypeResolve I imported org.eclipse.jdt.core from org.eclipse.jdt.core.tests.model/workspace/TypeResolve unintentially. I took me a while to find out that this is actually a test project incorrectly named. I suggest to rename it to TypeResolve.
479134,10/6/2015 7:31,manpalat,"Unable to build ECJ compiler binary from source I am unable to build the ECJ compiler binary using the ""ecjsrc"" download available on the release build download page here http://download.eclipse.org/eclipse/downloads/drops4/R-4.5.1-201509040015/Here is what I had to do in order build it:$ wget 'http://eclipse.mirror.garr.it/mirrors/eclipse//eclipse/downloads/drops4/R-4.5.1-201509040015/ecjsrc-4.5.1.jar'$ unzip -d ecj-4.5.1 ecjsrc-4.5.1.jar$ cd ecj-4.5.1$ antBuild failure due to usage of java 1.7 language features which is fine let's just bump the compile source/target to 1.7:$ sed -i -e 's/1.6/1.7/' build.xml$ antBuild failure due to unknown symbol ""class JavaCore"" in package ""org.eclipse.jdt.core"" -- this is more dubious since we can't include JavaCore due to it's own dependencies but the compiler still functions without it so let's patch it out for now. Maybe this should be used by reflection instead?$ sed -i -e '/import org.eclipse.jdt.core.JavaCore;/d' \ -e 's|JavaCore.getOptions()||g' \ org/eclipse/jdt/internal/compiler/batch/ClasspathDirectory.java$ antBuild failure due to could not find ""scripts/binary/META-INF/MANIFEST.MF"" file. This just seems to be missing from the source archive let's get it from the repo:$ mkdir -p scripts/binary/META-INF/$ wget 'http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/plain/org.eclipse.jdt.core/scripts/binary/META-INF/MANIFEST.MF' \ -O scripts/binary/META-INF/MANIFEST.MF$ antBuild successful at last!!!So the question is... Is this way of building even supported these days? Is there a better way or should effort be expended making this better?"
479193,10/7/2015 1:30,jarthana,"[test][compiler] AnnotationTest.testBug470665 - 1.8 failed Platform: AllBuild: I20151006-0800details: Unexpected failure. ----------- Expected ------------ ------------ but was ------------ ----------\n 1. ERROR in A.java (at line 10)\n };\n ^\n Syntax error on token ""}"" delete this token\n ----------\n ----------\n 1. WARNING in B.java (at line 12)\n X x = new X();\n ^^^^^^^\n Access to enclosing constructor B.X() is emulated by a synthetic accessor method\n ----------\n --------- Difference is ---------- expected:<[]> but was:<[----------\n 1. ERROR in A.java (at line 10)\n };\n ^\n Syntax error on token ""}"" delete this token\n ----------\n ----------\n 1. WARNING in B.java (at line 12)\n X x = new X();\n ^^^^^^^\n Access to enclosing constructor B.X() is emulated by a synthetic accessor method\n ----------\n ]>stacktrace: junit.framework.ComparisonFailure: Unexpected failure.----------- Expected ------------------------ but was ----------------------\n1. ERROR in A.java (at line 10)\n	};\n	^\nSyntax error on token ""}"" delete this token\n----------\n----------\n1. WARNING in B.java (at line 12)\n	X x = new X();\n	 ^^^^^^^\nAccess to enclosing constructor B.X() is emulated by a synthetic accessor method\n----------\n--------- Difference is ---------- expected:<[]> but was:<[----------\n1. ERROR in A.java (at line 10)\n	};\n	^\nSyntax error on token ""}"" delete this token\n----------\n----------\n1. WARNING in B.java (at line 12)\n	X x = new X();\n	 ^^^^^^^\nAccess to enclosing constructor B.X() is emulated by a synthetic accessor method\n----------\n]>	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:259)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:235)	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2509)	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runTest(AbstractRegressionTest.java:2294)	at org.eclipse.jdt.core.tests.compiler.regression.AbstractRegressionTest.runConformTest(AbstractRegressionTest.java:1213)	at org.eclipse.jdt.core.tests.compiler.regression.AnnotationTest.testBug470665(AnnotationTest.java:11636)	at org.eclipse.jdt.core.tests.util.CompilerTestSetup.run(CompilerTestSetup.java:56)	at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:692)	at org.eclipse.test.EclipseTestRunner.run(EclipseTestRunner.java:319)	at org.eclipse.test.CoreTestApplication.runTests(CoreTestApplication.java:36)	at org.eclipse.test.CoreTestApplication.run(CoreTestApplication.java:32)	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)	at org.eclipse.equinox.launcher.Main.run(Main.java:1515)	at org.eclipse.equinox.launcher.Main.main(Main.java:1488)	at org.eclipse.core.launcher.Main.main(Main.java:34)"
479284,10/7/2015 16:40,sasikanth.bharadwaj,[1.8][inference] fail to resolve matching types for lambda and method reference + NPE at build Created attachment 257130code sampletype inference doesn't work forCollectors.toMap(Function.identity() t -> Arrays.asList(t) Util::sum)where sum has signaturestatic <T> List<T> sum(List<T> l1 List<T> l2);It works only after adding an explicit cast:(BinaryOperator<List<X>>) Util::sumor after type parameterization:t -> Arrays.<X> asList(t)Additionally malicious type parameterization of method reference like Util<X>::sum leads to NPE from build process.affected version:Version: Mars.1 Release (4.5.1)Build id: 20150924-1200This code compiles and runs on openjdk and works well in intellij idea.In fact I report this problem only because my dev team uses both IDEs and ones with idea occasionally commit things like this.
479286,10/7/2015 16:52,sxenos,"NullPointerException in JavaElementLabelComposer We're seeing a NPE when using ctrl-shift-g to search for all references to a symbol. The exception seems to be thrown by the label provider (possibly the search or problems view). Exception shown here:Thread [main] (Suspended (exception NullPointerException))		owns: RunnableLock (id=2197)		Signature.getTypeErasure(String) line: 2290		JavaElementLabelComposer.getSimpleTypeName(IJavaElement String) line: 882		JavaElementLabelComposer.appendTypeLabel(IType long) line: 1016		JavaElementLabelComposer.appendElementLabel(IJavaElement long) line: 287		JavaElementLabels.getElementLabel(IJavaElement long StyledString) line: 531		JavaElementLabels.getStyledElementLabel(IJavaElement long) line: 506		JavaElementLabels.getStyledTextLabel(Object long) line: 434		PostfixLabelProvider(JavaUILabelProvider).getStyledText(Object) line: 178		PostfixLabelProvider.internalGetStyledText(Object) line: 79		PostfixLabelProvider.getStyledText(Object) line: 104		DecoratingJavaLabelProvider(DelegatingStyledCellLabelProvider).getStyledText(Object) line: 206		DecoratingJavaLabelProvider(DecoratingStyledCellLabelProvider).getStyledText(Object) line: 199		DecoratingJavaLabelProvider(DelegatingStyledCellLabelProvider).update(ViewerCell) line: 106		DecoratingJavaLabelProvider(DecoratingStyledCellLabelProvider).update(ViewerCell) line: 136		ColumnViewer$3(ViewerColumn).refresh(ViewerCell) line: 154		ProblemTreeViewer(AbstractTreeViewer).doUpdateItem(Item Object) line: 949		AbstractTreeViewer$UpdateItemSafeRunnable.run() line: 114		SafeRunner.run(ISafeRunnable) line: 42		JFaceUtil$1.run(ISafeRunnable) line: 50		SafeRunnable.run(ISafeRunnable) line: 173		ProblemTreeViewer(AbstractTreeViewer).doUpdateItem(Widget Object boolean) line: 1029		StructuredViewer$UpdateItemSafeRunnable.run() line: 473		SafeRunner.run(ISafeRunnable) line: 42		JFaceUtil$1.run(ISafeRunnable) line: 50		SafeRunnable.run(ISafeRunnable) line: 173		ProblemTreeViewer(StructuredViewer).updateItem(Widget Object) line: 2176		ProblemTreeViewer(AbstractTreeViewer).createTreeItem(Widget Object int) line: 843		AbstractTreeViewer$1.run() line: 818		BusyIndicator.showWhile(Display Runnable) line: 70		ProblemTreeViewer(AbstractTreeViewer).createChildren(Widget boolean) line: 791		ProblemTreeViewer(TreeViewer).createChildren(Widget boolean) line: 611		ProblemTreeViewer(AbstractTreeViewer).createChildren(Widget) line: 762		ProblemTreeViewer(AbstractTreeViewer).setExpandedState(Object boolean) line: 2500		TreeViewerNavigator.getChildren(TreeItem) line: 136		TreeViewerNavigator.getFirstChildWithMatches(TreeItem) line: 125		TreeViewerNavigator.getNextItemForward(TreeItem) line: 102		TreeViewerNavigator.navigateNext(boolean) line: 37		JavaSearchResultPage(AbstractTextSearchViewPage).navigateNext(boolean) line: 1000		AbstractTextSearchViewPage.access$10(AbstractTextSearchViewPage boolean) line: 993		AbstractTextSearchViewPage$UpdateUIJob.runInUIThread(IProgressMonitor) line: 157		UIJob$1.run() line: 97		RunnableLock.run() line: 35		UISynchronizer(Synchronizer).runAsyncMessages(boolean) line: 135		Display.runAsyncMessages(boolean) line: 3794		Display.readAndDispatch() line: 3433		PartRenderingEngine$4.run() line: 1127		Realm.runWithDefault(Realm Runnable) line: 336		PartRenderingEngine.run(MApplicationElement IEclipseContext) line: 1018		E4Workbench.createAndRunUI(MApplicationElement) line: 156		Workbench$5.run() line: 654		Realm.runWithDefault(Realm Runnable) line: 336		Workbench.createAndRunWorkbench(Display WorkbenchAdvisor) line: 598		PlatformUI.createAndRunWorkbench(Display WorkbenchAdvisor) line: 150		IDEApplication.start(IApplicationContext) line: 139		EclipseAppHandle.run(Object) line: 196		EclipseAppLauncher.runApplication(Object) line: 134		EclipseAppLauncher.start(Object) line: 104		EclipseStarter.run(Object) line: 380		EclipseStarter.run(String[] Runnable) line: 235		NativeMethodAccessorImpl.invoke0(Method Object Object[]) line: not available [native method]		NativeMethodAccessorImpl.invoke(Object Object[]) line: 62		DelegatingMethodAccessorImpl.invoke(Object Object[]) line: 43		Method.invoke(Object Object...) line: 483		Main.invokeFramework(String[] URL[]) line: 669		Main.basicRun(String[]) line: 608		Main.run(String[]) line: 1515		Main.main(String[]) line: 1488	It looks to me like the problem may be in JavaElementLabelComposer.appendTypeLabel.Line 1016 says this:supertypeName= getSimpleTypeName(type type.getSuperclassTypeSignature());However type.getSuperclassTypeSignature() returns a Nullable and getSimpleTypeName() requires a non-null argument."
479287,10/7/2015 16:57,sasikanth.bharadwaj,"erroneous compile error using static imports and generics Problem with erroneous compile error using static imports and generics. With a static method:public static <T> void takesAnything(T thing)And a method that returns a wildcard:private <T> Collection<? extends T> returnThingsWildcard(T toReturn)The following gets a compile error: ""The method takesAnything(Collection<Object>) in the type GenericsIssueCollaborator is not applicable for the arguments (Collection<capture#4-of ? extends String>)	GenericsIssue.java	/joetest/src/main/java/joetest	line 17	Java Problem""takesAnything(returnThingsWildcard(""doesn't work with static import""))This does not occur unless I use a static import to access takesAnything(T). This also does not occur using javac.The two classes are below:package joetest;import static joetest.GenericsIssueCollaborator.takesAnything;import java.util.Collection;import java.util.Collections;public class GenericsIssue {	private void oddCompileError() {		takesAnything(returnThings(""works without wildcard in return value""));		GenericsIssueCollaborator.takesAnything(returnThingsWildcard(""works without static import""));		takesAnything(returnThingsWildcard(""doesn't work with static import""));	}		private <T> Collection<T> returnThings(T thing) {		return Collections.singleton(thing);	}			private <T> Collection<? extends T> returnThingsWildcard(T toReturn) {		return Collections.singleton(toReturn);	}}package joetest;public class GenericsIssueCollaborator {	public static <T> void takesAnything(T thing) {		System.out.println(""TOOK IT: "" + thing);	}}-- Configuration Details --Product: Eclipse 4.5.1.20150917-1200 (org.eclipse.epp.package.java.product)Installed Features: org.eclipse.jdt 3.11.1.v20150904-0015"
479292,10/7/2015 20:04,mateusz.matela,"[formatter] Header comment formatting for package-info.java occurs even when ""Format header comment"" is unchecked Header comments of `package-info.java` files always appear to get formatted regardless of the ""Enable header comment formatting"" setting.Possibly related to #184263"
479408,10/9/2015 6:22,jarthana,[1.9] Support JDK 9 when run with JRE 8 It is now possible to load JRE 9 images from within JRE 8. The page [1] talks about it a bit. Even though Oracle has said JRE 7 is not in the picture it will be nice to get this update to JDT.The idea seems to be loading the JRE 9 image through the class loader of the jrt-fs.jar that is present in JAVA 9 home.[1] http://permalink.gmane.org/gmane.comp.java.openjdk.jigsaw/820
479440,10/9/2015 11:18,noopur_gupta,"[rename] Show rename options as links in hover Inline renaming of a field should propose to also rename corresponding getter setter and constructor parameter. Currently when triggering rename there is a small popup saying ""Enter new name then press Enter"". This popup could also show a couple of settings as checkbox ""propagate to getter and setter name"" and ""propagate to constructor parameter name"".This is inspired from IntelliJ renaming feature."
479469,10/9/2015 17:44,mateusz.matela,[formatter] Line wrap for long @see references Give the following code and a line wrap of 90:> //>> /**> * @see org.springframework.boot.context.embedded.jetty.JettyEmbeddedServletContainerFactory> */> package com.example;The formatter will wrap the reference to something that Javadoc cannot process:> * @see org.springframework.boot.context.embedded.jetty.> * JettyEmbeddedServletContainerFactory
479474,10/9/2015 20:24,mateusz.matela,[formatter] Problems when doc.comment.support=disabled The formatter assumes that javadoc nodes are always attached to their corresponding body declaration nodes. It is not true with preference org.eclipse.jdt.core.compiler.doc.comment.support=disabled.This leads to problems like one reported in bug 471364 comment 17.After reading bug 52264 and bug 51529 I'm still not sure how important this setting is.I think the formatter can just override this setting when it initializes its parser but I'd like someone to confirm if this is a good idea and would not cause any unexpected problems.
479553,10/12/2015 6:17,markus.kell.r,[JUnit] assertions are not enabled by default Analouge to a bug in Netbeans (https://netbeans.org/bugzilla/show_bug.cgi?id=175517) asserations should be activated by default.So intellij idea enables asserations in junit tests netbeans does maven does and many many more. Only eclipse does not.Step 11. Create empty junit test.2. Insert `assert false;`3. Execute test.Expected: Test failure.
479656,10/13/2015 10:28,jarthana,"Code completion does not work when a binary type refers to a member source type this bug is also the same on windows 7/8 version of eclipse and previous osx version.this bug appears on installations where a previous version of eclipse was also installed and on new installations as well.this bug makes java development with eclipse a pain.we have 2 pure java projects. but randomly some java files offer no code completion any more.in preferences -> java / editor / content assist / advancedthere is NONE of the following checked: ""java non-type proposals"" ""java proposals"" ""java proposals (task focused)"" ""java type proposals"". checking them pressing ""apply"" and then ""ok"" normally does NOT store these settings.sometimes it works but mostly not.today i tried preferences -> code recommenders -> completionsto uncheck ""enable code recommenders code completion"" and apply / ok. and then check it again and apply / ok. then add the java proposals (as noted above) and then it worked on one machine. but this ""trick"" does not work on others.switching back to 4.4 version also does not help.on one machine we use an old ggts (groovy/grails tool suite) ... all works here.in the past we all used ggts (which is now outdated) and never experienced such problems.it seems preferences are not stored. any help welcome. thanks!"
479838,10/15/2015 5:14,markus.kell.r,Outline view not available for Java file Outline view is not available for java files in the latest I build.Eclipse SDKVersion: Neon (4.6)Build id: I20151014-1100Not sure if it is related but only for 1 file in my workspace Ctrl+o is also not working.
479898,10/15/2015 17:59,mateusz.matela,"[formatter] removes whitespace between final and first exception in multi-line multi-catch When formatting the code:{code}try{	throwsException();} catch ( final InstantiationException | IllegalAccessException | IllegalArgumentException | NoSuchMethodException		| SecurityException | InvocationTargetException e ){	throw new RuntimeException( e );}{code}(Which wraps the line after 'NoSuchMethodException')leads to:{code}catch ( finalInstantiationException | IllegalAccessException | IllegalArgumentException | NoSuchMethodException		| SecurityException | InvocationTargetException e ){code}Where 'finalInstantiationException' is clearly wrong.Does not happen with single-line multi-catch."
479959,10/16/2015 8:17,mateusz.matela,[formatter] indented empty lines after ifs and loops without braces Created attachment 257299My code formatter settingsThe Java formatter doesn't work correctly in two cases.###############################public int foo( Integer a ){ if ( a == null ) throw new SomeException(); return ( a.intValue() );}###############################Mars will indent the empty line by two levels (eight spaces here). But it should only apply one level (four spaces).I have attached my formatter rules.###############################private List< String > l = new ArrayList< >();###############################Mars will add an unwanted space between the generic brackets (diamond) for ArrayList. There seems to be a setting missing to avoid this.
479963,10/16/2015 8:27,jarthana,[1.8] Open Declared Type for lambda parameter SCENARIO:new ArrayList<String>().forEach( item -> System.out.println( item ) );Ctrl+Click 'item' before ->Click Open Declared typeEXPECTED:String class is opened(class of method parameter of the corresponding method in functional interface is expected to be opened)ACTUALLY:Nothing happens
480029,10/17/2015 10:46,mateusz.matela,[formatter] Comments indentation error in javadoc @return statements Created attachment 257331Class file and formatter to reproduce this issueHelloTo demand I separate my previous bug submit into individual substitutions original ticket:https://bugs.eclipse.org/bugs/show_bug.cgi?id=479958In the javadoc formatting when a @return statement start with a tag indentation is wrong in this case.In the ZIP file there is the class file to reproduce the bug with formatter settings.My configuration: * Windows 10 * Eclipse 4.5.1 64-bit * JDK 1.8 update 60Tested with these builds same result for all these builds (fresh install no plug-in): * Eclipse 4.5.1 64-bit * Eclipse 4.6 M2 64-bit * eclipse-SDK-M20151014-1000-win32-x86_64.zip * eclipse-SDK-I20151014-1100-win32-x86_64.zipBest regards
480030,10/17/2015 10:49,mateusz.matela,[formatter] Comments indentation error in switch statements Created attachment 257332Class file and formatter to reproduce this issueHelloTo demand I separate my previous bug submit into individual substitutions original ticket:https://bugs.eclipse.org/bugs/show_bug.cgi?id=479958In switch statements when a line comment is set before a case and when the previous case uses a block statement the comment indentation is wrong.In the ZIP file there is the class file to reproduce the bug with formatter settings.My configuration: * Windows 10 * Eclipse 4.5.1 64-bit * JDK 1.8 update 60Tested with these builds same result for all these builds (fresh install no plug-in): * Eclipse 4.5.1 64-bit * Eclipse 4.6 M2 64-bit * eclipse-SDK-M20151014-1000-win32-x86_64.zip * eclipse-SDK-I20151014-1100-win32-x86_64.zipBest regards
480086,10/19/2015 3:21,mateusz.matela,[formatter] unwanted spaces in generic diamond operator Created attachment 257342INFOLOG Java code formatterList< String > l = new ArrayList< >();Our code formatter adds spaces after the opening brace and before the closing brace. For other types of braces you can set an option to not add spaces when the braces are empty. This option is missing for the diamond.Mars will add an unwanted space between the generic brackets (diamond) for ArrayList.
480682,10/26/2015 12:41,noopur_gupta,[override method] Do not offer to override / implement a final method Consider the following code:---------------------------------------------public class Test extends Base {}abstract class Base implements I { @Override public final void method1() {}}interface I { void method1(); void method2();}---------------------------------------------Let's click Alt-Shift-S V (Override / Implement Methods) inside of the Test class. The popup offers to implement both method1() and method2() via the interface I even if method1() cannot be further overridden in the context of Test.Notice how the class Base doesn't appear in the results which is correct as it doesn't contain any methods that can be overridden.Eclipse should not offer overriding inherited methods from interfaces which are made final somewhere in the super class chain.
480735,10/27/2015 4:57,mateusz.matela,"[formatter] whitespace after comma in enum declaration is removed The ""whitespace after comma"" setting for classes is not respected in enum declarations. If an enum implements multiple interfaces the whitespace after the comma between the declarations is removed.`public enum Something implements Serializable Cloneable { NONE }`becomes `public enum Something implements SerializableCloneable { NONE }`This happens even if I activate ALL ""After Comma"" settings in the formatter options."
480835,10/28/2015 3:59,jarthana,Failures in build due to changes not being picked up by tests The failures in build I20151027-2000 are all due to a recent change in JDT Core not being picked up by tests. I am investigating this with the help of David at the moment and the fix might simply a 'touch'. More details to follow.
481000,10/29/2015 10:17,Olivier_Thomann,[1.9] Support Unicode 7.0 in ECJ Unicode 7.0 support is slated to be one of the features for Java 9 (JEP 227). When it is confirmed we should upgrade the compiler to support Unicode 7.0.See bug 426214 for how it was done in 1.8.
481143,10/30/2015 15:07,mateusz.matela,"[formatter][parser] Parser missing some line comments As of 4.5.1 using any of the built-in formatter profiles the formatter is capable of joining two lines even if the first line ends in a single-line comment.ExampleBefore auto-formattingpublic class AutoFormatTest {	public AutoFormatTest subtest = new AutoFormatTest(""Test1"" // comment			""Test2""){			};	public AutoFormatTest(String foo String bar) {	}}After auto-formattingpublic class AutoFormatTest {public class AutoFormatTest {	public AutoFormatTest subtest = new AutoFormatTest(""Test1"" // comment""Test2"") {	};	public AutoFormatTest(String foo String bar) {	}}This only seems to occur when the second line contains the opening brace to an anonymous class."
481157,10/30/2015 18:06,david_williams,Java 1.9 patch apparently deleted from build.eclipse.org Back in September I started bug 476610 where I was given a link to allow eclipse to work with java 1.9 (https://bugs.eclipse.org/bugs/show_bug.cgi?id=476610) (http://build.eclipse.org/eclipse/builds/4P/siteDir/updates/4.6-P-builds/P20150901-1406/). Since then however the P20150901-1406 subdirectory has been deleted and there are only two jar files at the 4.6-P-builds subdirectory. I am unable to make eclipse install those jar files or the directories containing them. Has the method for java 1.9 patch installation changed or am I doing something wrong with eclipse?
481215,11/2/2015 4:06,jarthana,"Code completion does not work under certain circumstances when using generics and java8 lambdas Created attachment 257676Example showing where code assist does not workCode completion/assist says ""No default Proposals"" under certain circumstances when working with java8 lambdas and generics.I only experience this when I have a method that takes in two lambdas for example:MyGeneric<String> mystring = new MyGeneric<>("""");		complete((String result) -> {	mystring.get(result); //<-- autocompletion does not work for return value} (Throwable t) -> {	t.printStackTrace();});where the complet method is defined as:static void complete(Consumer<String> success Consumer<Throwable> failure)and MyGeneric as:public static class MyGeneric<T> {	public T get(String value);}It must have something to do with that the get method takes the lambda parameter as a parameter to get the generic value. If I don't use java8 lambda it works and if the method only accepts one lambda it works.See attachment for fully reproducable example. I just tested this with a fresh install of eclipse Mars 4.5.1 for Java EE developers."
481221,11/2/2015 4:38,mateusz.matela,"[formatter] New formatter incorrectly formats "" ;"" in enum declaration * Steps to reproduceHave enum written so that adding new (last) option results in precisely 1 line changed from VCS point of view:---------------------public enum Foo { OPTION1 OPTION2 ; public bar() { }}---------------------Configure (new) formatter in Eclipse Mars to ""never join already wrapped lines"".Optionally set wrapping policy for ""'enum' declaration > constants"" to ""wrap all elements every element on a new line"" (the expected and the observed do not depend on this).Reformat the code above.* ExpectedCode does not change* ObservedThe ; is put with last option (it doesn't even look right...) like this:---------------------public enum Foo { OPTION1 OPTION2; public bar() { }}---------------------"
481223,11/2/2015 5:32,manpalat,"[performance] Regression below SearchableEnvironment.findConstructorDeclarations Dear JDT teamwhen switching from the platform's Neon M2 milestones to its M3 milestone one of Code Recommenders' integration tests started to fail [1]: SubwordsCompletionProposalComputerIntegrationTest. In this test the (simulated) user triggers content assist at InputStream in = new Ziut<ctrl+space>Under the hood Code Recommenders subword completion triggers again at InputStream in = new Z<ctrl+space>Obviously this can result in a large number of results (in a production scenario subwords would hence by default use a two character prefix).Now our test simulates that the user triggers content assist twice (calls warmup and exercise in [2]). In previous versions of JDT (we test against Kepler SR2 Luna SR2 Mars SR1 and Neon M2 ATM) this warmup reliably prevented the timeout in exercise.As of Neon M3 this is no longer the case however. The following occurs both on warmup (to be expected) and exercise call:org.eclipse.core.runtime.OperationCanceledException	at org.eclipse.jdt.internal.core.SearchableEnvironment.findConstructorDeclarations(SearchableEnvironment.java:599)	at org.eclipse.jdt.internal.codeassist.CompletionEngine.findTypesAndPackages(CompletionEngine.java:10674)	at org.eclipse.jdt.internal.codeassist.CompletionEngine.completionOnSingleTypeReference(CompletionEngine.java:3360)	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1715)	at org.eclipse.jdt.internal.codeassist.CompletionEngine.complete(CompletionEngine.java:1939)	at org.eclipse.jdt.internal.core.Openable.codeComplete(Openable.java:131)	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:357)	at org.eclipse.jdt.internal.core.CompilationUnit.codeComplete(CompilationUnit.java:345)	at org.eclipse.recommenders.internal.subwords.rcp.SubwordsSessionProcessor.computeProposals(SubwordsSessionProcessor.java:313)	at org.eclipse.recommenders.internal.subwords.rcp.SubwordsSessionProcessor.getNewProposals(SubwordsSessionProcessor.java:202)	at org.eclipse.recommenders.internal.subwords.rcp.SubwordsSessionProcessor.initializeContext(SubwordsSessionProcessor.java:142)	at org.eclipse.recommenders.completion.rcp.processable.IntelligentCompletionProposalComputer.fireInitializeContext(IntelligentCompletionProposalComputer.java:292)	at org.eclipse.recommenders.completion.rcp.processable.IntelligentCompletionProposalComputer.computeCompletionProposals(IntelligentCompletionProposalComputer.java:169)	at org.eclipse.recommenders.subwords.rcp.it.SubwordsCompletionProposalComputerIntegrationTest.exercise(SubwordsCompletionProposalComputerIntegrationTest.java:224)	at org.eclipse.recommenders.subwords.rcp.it.SubwordsCompletionProposalComputerIntegrationTest.warmup(SubwordsCompletionProposalComputerIntegrationTest.java:191)	at org.eclipse.recommenders.subwords.rcp.it.SubwordsCompletionProposalComputerIntegrationTest.test(SubwordsCompletionProposalComputerIntegrationTest.java:152)I know that our integration test is far from a minimal test case but if I can be of any help or assistance just ask.Best wishesAndreas[1] <https://hudson.eclipse.org/recommenders/job/org.eclipse.recommenders-gerrit/1334/>[2] <https://git.eclipse.org/c/recommenders/org.eclipse.recommenders.git/tree/tests/org.eclipse.recommenders.completion.rcp.tests/src/org/eclipse/recommenders/subwords/rcp/it/SubwordsCompletionProposalComputerIntegrationTest.java?h=v2.2.4#n144>"
481564,11/6/2015 3:55,jarthana,"content assist fails in lambda when class contains another method a method reference See the example class below. Depending on the presence of the ""poisonMethod"" content assist does or does not work inside the lambda. It always works in the anonymous class.---import java.util.ArrayList;public class TestCompletion { public void foo() { new Thread(new Runnable() { public void run() { // som completes to someMethod } }); new Thread(() -> { // som gives no proposal // but if you delete poisonMethod then it completes to someMethod }); } public void poisonMethod() { ArrayList<String> views = new ArrayList<>(); views.stream().filter(String::isEmpty).forEach(s -> s.length()); } public void someMethod() {}}"
481729,11/9/2015 10:38,jarthana,[model] clarify use of '.' vs. '/' separators in Java model API Created attachment 257831sample JUnit projectFor the EASE project I am trying to retrieve java help content programmatically. While I know that there exists no public API for this usecase I would love to get a prototype working to propose a public API.I am able to retrieve help for packages classes and some methods. However retrieval fails for static methods and overridden ones.To simplify the process I implemented a sample project with testcases:As users might not have a Java project in their workspace I am dynamically creating one with a dynamic project. Its sole purpose is to provide content of a dynamic .classpath file. Eventually you need to update VirtualClasspathFile.getContents() to your environment.Now test getHelpCanExecute() should work the other 2 tests will fail as help cannot be retrieved.Please let me know if the sample code provided is not working for you.
481752,11/9/2015 12:38,jarthana,"[content assist] Substring completion proposals have bad relevance I20151103-0800In org.eclipse.swt.widgets.TabFolder#_getChildren() I added this code:		Control [] directChildren = super._getChildren ();		int count = diContent assist at the end (after ""= di"") gives me an unusable proposals list. The first few entries are all constants from class Widget.Expected: Same order as when the second line is just ""di""."
482005,11/12/2015 6:27,noopur_gupta,"[content assist] Substring completion matches token with type's qualifier package p1;public class Test {	p}Press Ctrl+space after ""p"" and filter the proposed list by completing the token to ""pri"". The filtered list also contains proposals like ""PageFormat - java.awt.print"" as the token ""pri"" matches the type's qualifier."
482087,11/13/2015 4:20,jarthana,Enable concurrent builds in Gerrit Similar to bug 481421 but this is for eclipse.jdt.core jobs.
482119,11/13/2015 9:55,manpalat,[search] New SearchPattern.R_SUBSTRING_MATCH In order to style tokens in substring proposals (bug 470203) a new search pattern R_SUBSTRING_MATCH is required along with the corresponding support in SearchPattern.getMatchingRegions(String pattern String name int matchRule).
482257,11/16/2015 5:19,jarthana,"[1.9] Cannot open module-info.class file With jdk-9-pwa6490-20151112_01 I can see module-info.class file of a module in Package explorer. Double-clicking on the file to open it gives the following exception:java.lang.ClassCastException: org.eclipse.core.runtime.Status (in module: Unnamed Module) cannot be cast to org.eclipse.jdt.core.IJavaModelStatus (in module: Unnamed Module)	at org.eclipse.jdt.internal.core.ClassFile.getBuffer(ClassFile.java:467)	at org.eclipse.jdt.internal.core.ClassFile.getSourceRange(ClassFile.java:619)	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.getEditorID(EditorUtility.java:421)	at org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.openInEditor(EditorUtility.java:179)	at org.eclipse.jdt.ui.actions.OpenAction.run(OpenAction.java:256)	at org.eclipse.jdt.ui.actions.OpenAction.run(OpenAction.java:221)	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:271)	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:249)	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerActionGroup.handleOpen(PackageExplorerActionGroup.java:379)	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerPart$4.open(PackageExplorerPart.java:540)..."
482268,11/16/2015 6:11,jarthana,"[1.9] Problems while using multiple versions of JRE 9 Created attachment 257962Screenshot of Open Type error dialogSteps:- Launch Eclipse BETA_JAVA9 workspace as runtime using the Jigsaw build jdk-9-pwa6490-20151112_01.- In runtime workspace add two different versions of JDK9 in Installed JREs.- Create two Java projects using these two different 1.9 JREs.- Invoke Open Type dialog and type ""String"".=> We see two results for type String.java in the dialog one for each of the JRE 9 versions.Issues:- The package name of the entry is shown as ""java.base|java.lang"" => the module name somehow makes it to the package name.- Click on one entry in the dialog and see the JRE path changes for the other entry as well.- Double-click on any entry to open the type String we get an error dialog (see attached screenshot) and after that the Open Type dialog gets closed and the type is not opened."
482309,11/16/2015 10:55,markus.kell.r,"Organize Imports does not work for accessible binary types Created attachment 257980Example projectIn the attached example SamplePart is missing the import for ""org.eclipse.e4.ui.di.Persist"".Ctrl+1 is able to add it but not ""Organize Imports""."
482752,11/21/2015 9:07,register.eclipse,"[1.8][null] @NonNullByDefault does not apply to lambda parameter across classes It seems @NonNullByDefault on a functional interface is not considered when ""implemented"" using lambda expressions or method references in another class:======== Foo.java ========import org.eclipse.jdt.annotation.NonNull;public final class Foo {	// Same method as in StringProcessor but does not compile	public static StringProcessor createProcessorLambdaExpression() {		// ""Illegal redefinition of parameter value inherited method from		// StringProcessor does not constrain this parameter""		return (@NonNull String value) -> Foo.test(value);	}	// Same method as in StringProcessor but emits warning	public static StringProcessor createProcessorMethodReference() {		// ""Null type safety: parameter 1 provided via method descriptor		// StringProcessor.process(String) needs unchecked conversion to		// conform to '@NonNull String'""		return Foo::test;	}	public static void test(@NonNull String value) {		System.out.println(value);	}}============================ StringProcessor.java ==import org.eclipse.jdt.annotation.NonNull;import org.eclipse.jdt.annotation.NonNullByDefault;@NonNullByDefaultpublic interface StringProcessor {	void process(String value);	// Same method as in Foo but compiles without warning	public static StringProcessor createProcessorLambdaExpression() {		return (@NonNull String value) -> Foo.test(value);	}	// Same method as in Foo but compiles without warning	public static StringProcessor createProcessorMethodReference() {		return Foo::test;	}}==========================Steps to reproduce:1. Enable annotation-based null analysis2. Add the two Java files above to the project3. Copy library with default null annotations to build path (e.g. using quick fix)4. Modify (e.g. whitespace) in Foo.java and save to recompile itNotes:* Adding an explicit @NonNull to the parameter of process(??) fixes the problem but results in the expected warning ""The nullness annotation is redundant with a default that applies to this location"".* It does not matter if the classes are in the default package together in another package or in different packages.* It does not matter where the @NonNullByDefault annotation is applied (at method level class level or package level).* The problem appears only after an incremental build of Foo.java. After cleaning the project or disabling ""Build Automatically"" and running ""Build All"" the error and warning disappears until Foo.java is again built incrementally.* The @NonNullByDefault is respected when using a StringProcessor in class Foo: createProcessor??().process(null) fails (as expected) with ""Null type mismatch: required '@NonNull String' but the provided value is null"".* The @NonNullByDefault is also respected when implementing the interface using an anonymous inner class.Tested using ""Eclipse Java Development Tools"" 3.11.1.v20150904-0015 and 3.11.1.v20151118-1100 on Eclipse Mars 4.5.1 (20150924-1200).I hope this problem is not reported already I did not find a matching bug report??"
482775,11/22/2015 1:09,jarthana,[javadoc] Autocomplete does not propose proceeding enum constants I am using Mars/4.5.1. Autocomplete does not propose constants that are defined after the cursor. This happens in the absence of any compiler error.Example:public enum MyEnum { /** * @see #B| */ ALPHA /** * @see #A| */ BETA1 BETA2}If you press Ctrl+Space at | in BETA's javadoc you will be recommended ALPHA. If you do this in ALPHA's javadoc you will not be recommended anything.
483019,11/25/2015 11:42,sasikanth.bharadwaj,"Cast with intersection type causes method call to trigger IllegalAccessError at runtime Created attachment 258275This attachment contains an eclipse project to reproduce the issue.HOW TO REPRODUCE:Import attached sample eclipse project and run it. The program raises the following exception:Exception in thread ""main"" java.lang.IllegalAccessError: tried to access class sub.A from class Test009 at Test009.test(Test009.java:23) at Test009.main(Test009.java:27)Works fine with javac outputs ""1"".Tested with nightly build ecj-N20151124-2000.jar and latest release ecj-4.5.1.jar."
483191,11/27/2015 11:52,mateusz.matela,"[formatter] HTML in javadoc: <em> tag is never split I am using the default Eclipse formatter. Comment width set to 80. If the Javadoc width is exceeded inside the body of an HTML tag the entire body is wrapped. This is too aggressive. I am not sure why having the tag present changes behavior but it is not desired.Before formatting:public class Z { /** * This is a test. These words that shall follow <em>are being emphasized</em> and are wrapping too early. */}After formatting:public class Z { /** * This is a test. These words that shall follow * <em>are being emphasized</em> and are wrapping too early. */}But it shouldn't break after ""follow"" (column 53); there is enough room for more words. It should be like this:public class Z { /** * This is a test. These words that shall follow <em>are being * emphasized</em> and are wrapping too early. */}"
483239,11/29/2015 23:58,manpalat,"Unusual errors in N20151129-2200 build The N20151129-2200 build failed in the same way as the N20151129-2000 build. The first ""ERROR"" is that Tycho/Maven can not find the artifacts to put into the repository. But before that of course there should have been some other ERROR indicating ""what went wrong"". Oh finally found it ... not sure why so ""buried""? (It was easy to find when I used --fail-fast on my local build. [ERROR] Failed to execute goal org.eclipse.tycho:tycho-compiler-plugin:0.23.1:compile (default-compile) on project org.eclipse.osgi: Execution default-compile of goal org.eclipse.tycho:tycho-compiler-plugin:0.23.1:compile failed: An API incompatibility was encountered while executing org.eclipse.tycho:tycho-compiler-plugin:0.23.1:compile: java.lang.NoSuchMethodError: org.eclipse.jdt.internal.compiler.batch.FileSystem.getClasspath(Ljava/lang/String;Ljava/lang/String;Lorg/eclipse/jdt/internal/compiler/env/AccessRuleSet;)Lorg/eclipse/jdt/internal/compiler/batch/FileSystem$Classpath;I am not sure if this is due to a recent change in JDT OR my guess there may be an error in the JDT-combined-with-APT upgrade that I did this afternoon. That is not an error in *my* upgrade :) I double checked and the versions from M3 seem right but an error in them ""working together with Tycho"". I will also attach the ""whole end of the log"" ... it seemed that some bundles were compiled but most not. I'm wondering if it has to do with some assumption about the level of Java used or similar?"
483303,11/30/2015 7:56,manpalat,"[search] searchAllMethodNames API gives invalid result for method with parameter Place the following in a new workspace:package com.test;public class C1 {	void m1(int i) {	}}To test the API you can use the WIP jdt.ui patch: https://git.eclipse.org/r/#/c/50687/Or just invoke the #searchAllMethodNames API with the arguments:null 1 null 1 null 1 ""m1"".toCharArray() SearchPattern.R_PREFIX_MATCH /*an instance of MethodNameMatchRequestor*/ IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH nullThe SourceMethod in MethodNameMatch of requestor's #acceptMethodNameMatch comes as:m1(*** invalid signature: int) (not open) [in C1 [in [Working copy] C1.java [in com.test [in src [in P1]]]]]If the parameter ""int i"" is removed from #m1 the result is correct:void m1() [in C1 [in [Working copy] C1.java [in com.test [in src [in P1]]]]]"
483509,12/2/2015 14:07,noopur_gupta,"[search] New API SearchEngine.createMethodNameMatch(IMethod int) New API ""SearchEngine.createMethodNameMatch(IMethod int)"" (similar to SearchEngine#createTypeNameMatch) is required to maintain the history of Open Method dialog."
483511,12/2/2015 14:11,noopur_gupta,"[content assist] Substring completion breaks proposal sorting I20151201-1100Invoke Content Assist after ""s."" then type ""st"": String s = """"; s.When substring matches are enabled the most relevant completions (""startWith"") are not on top of the list any more. When you complete after ""s.st"" the proposals are sorted as expected.=> Substring completions require Content Assist to re-compute the relevance of all proposals when the user continues typing. This is especially important when the proposal popup has been opened automatically by the auto-activation trigger on "".""."
483512,12/2/2015 14:16,noopur_gupta,"[content assist] Substring completion breaks ""Insert common prefixes automatically"" I20151201-1100When substring matches are enabled the ""Insert common prefixes automatically"" feature is often broken.Example (JDK 8): String s = """"; s.indWithout substring matching content assist after ""ind"" completes to ""indexOf"". This doesn't work any more because the ""lastIndexOf"" proposals use an uppercase ""I"". I would expect the common prefix of the prefix matches to be inserted (i.e. ""indexOf"").The feature still works here: s.suIt completes to ""sub"" and proposes ""subSequence"" and ""substring"". This example should keep working as is. I.e. it should not auto-complete to ""subS"" or ""subs"".I find it very confusing that ""Insert common prefixes"" auto-inserts ""startsWith"" here: (completing to ""tartsWith"" would be fine) s.tarBut it doesn't complete ""Point"" here: s.PoAnd here it even steals the last character the user entered: (produces ""s.sub""!) s.ubsSuggested fix:- ""Insert common prefixes"" should never add or remove any character in front of the caret. (Changing the case is fine e.g. for ""s.Sub"".) => Keeps the user's text stable- If there is any prefix match it should not consider the casing of the substring matches to compute the common prefix to insert. => Avoids the ""ind"" problem- If there are only substring matches it should insert the completion that is common to all substring matches => Completes common prefix of substrings if applicable"
483534,12/3/2015 3:00,manpalat,"[search]Open Method error on parameterized methods interface FI {	void foo(ArrayList<IOException> x);}IMethod exists() returns false cause: IOException not stored (intentional as multiple parameterized methods of the same erasure type not allowed) - but this causes the failure of type.getMethod()."
483605,12/3/2015 13:02,loskutov,"Breakpoint in nested type not hit any more Breakpoint in nested types are not hit any more. Got broken by bug 5188.Example:package snippet;import java.util.*;public class Snippet {	public static void main(String[] args) {		List<String> list = Arrays.asList(""1"" ""two"" ""drei"");		System.out.println(list);	}}A breakpoint in java.util.Arrays.ArrayList#size() is never hit when I debug this snippet. Note that this is about Arrays.ArrayList not java.util.ArrayList."
483650,12/4/2015 5:41,manpalat,"[search]open Method - new api with unified qualifier For the ease of use with jdt.ui a new api where qualifier is a combination of package name enclosing type name and type name for searchAllMethodNames. The proposed api is given below:	/**	 * Searches for all method declarations in the given scope. 	 * <p>	 * Provided {@link MethodNameMatchRequestor} requestor will collect the {@link MethodNameMatch}	 * matches found during the search.	 * </p>	 * 	 * @param qualifier qualifier including package name and qualified type name	 *	May be <code>null</code> then any qualifier name is accepted.	 * @param qualifierMatchRule match rule for package.	 * @param methodName the method name searched for.	 * @param methodMatchRule match rule for the method name.	 * @param scope the scope to search in	 * @param nameRequestor the {@link MethodNameMatchRequestor}	 * @param waitingPolicy one of	 * <ul>	 *		<li>{@link IJavaSearchConstants#FORCE_IMMEDIATE_SEARCH} if the search should start immediately</li>	 *		<li>{@link IJavaSearchConstants#CANCEL_IF_NOT_READY_TO_SEARCH} if the search should be cancelled if the	 *			underlying indexer has not finished indexing the workspace</li>	 *		<li>{@link IJavaSearchConstants#WAIT_UNTIL_READY_TO_SEARCH} if the search should wait for the	 *			underlying indexer to finish indexing the workspace</li>	 * </ul>	 * @param progressMonitor the progress monitor to report progress to or <code>null</code> if no progress	 *							monitor is provided	 * @exception JavaModelException if the search failed.	 * 	 * @since 3.12	 */	public void searchAllMethodNames(			final char[] qualifier			final int qualifierMatchRule			final char[] methodName			final int methodMatchRule			IJavaSearchScope scope			final MethodNameMatchRequestor nameRequestor			int waitingPolicy			IProgressMonitor progressMonitor) throws JavaModelException"
483690,12/4/2015 11:53,jarthana,"IdeJavaSourceOutputStream always uses default charset IdeJavaSourceOutputStream always uses default charset via the inherited ByteArrayOutputStream#toString() call in line 68: ""this.toString()"".That discards all character encoding used via the IdeOutputJavaFileObject#openOutputStream() method like: new OutputStreamWriter(openOutputStream() encoding);Possible solution: write the collected bytes ""as is"" to the file?"
483895,12/8/2015 6:24,noopur_gupta,[content assist] Disable and remove substring completion from Preferences Disable and remove substring code completion from Preferences until dependent bugs like bug 470203 bug 483511 bug 483512 and bug 483888 are fixed.
483902,12/8/2015 8:32,ma.becker,library icon appears unsharp Created attachment 258504Library/Classpath Icon used in Eclipse 4.4.2Comparing the icon used for the libraries (classpath.gif|png) in Java tools (e.g. JRE System library) used in the Java Tools coming with 4.5.1 with one used in 4.4.2 the newer one seems to be unsharp (you can find both versions in the attachements).Can you please replace the icon with a sharper one?Regards Felix
483922,12/8/2015 10:57,mateusz.matela,"[formatter] Wrong indentation base for wrapped ""throws"" elements in method declaration Formatting options checked:Method declaration: do not wrapParameters: wrap where necessary indent on columnThrows clause: wrap where necessary default indentationHere is what formatter does:public ReturnType longlonglonglongmethodname(A param 1 B param2 | C param 3) throws Exception E {Here is what I think formatter should do:public ReturnType longlonglonglongmethodname(A param1 B param2 | C param3) throws ExceptionE {The reasoning being that the throws clause is not a subpart of the parameters but is a subpart of the method declaration itself."
483948,12/8/2015 15:26,markus.kell.r,"[organize imports] ImportReferencesCollector#possibleStaticImportFound(Name) called too often ImportReferencesCollector#possibleStaticImportFound(Name) is called too often. ImportReferencesCollector doesn't account for labels and MethodRefParameters. Since those cases are not filtered out this assumption is not valid and hence too many nodes are processed:	public boolean visit(SimpleName node) {		// if the call gets here it can only be a variable reference		possibleStaticImportFound(node);		return false;	}After bug 357795 these calls may incur some cost and should be avoided."
483952,12/8/2015 16:58,register.eclipse,"NPE in situation with null type annotations and raw type used with genericc DESCRIPTION:With Java 1.8 and null type annotations enabled:package test;import java.util.function.Function;import org.eclipse.jdt.annotation.Nullable;public class Test {	void test1() {		Function function = x -> x;		String @Nullable [] z = test2(function """");	}	<T> T @Nullable [] test2(Function<T T> function T t) {		return null;	}}An exception is thrown:java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:205)	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(NullAnnotationMatching.java:146)	at org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.checkAssignment(NullAnnotationMatching.java:120)	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.analyseCode(LocalDeclaration.java:106)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.analyseCode(MethodDeclaration.java:128)ANALYSIS:Because of the raw usage in a generics context the type inference fails and a ProblemMethodBinding is created. As consequence this.initialization.resolvedType is null in LocalDeclaration.analyseCode.SUGGESTED PATCH:adds a null check(I'll upload it via gerrit)"
484026,12/9/2015 10:11,jens.schiebel,If no perfect match is available for an EE the workspace default VM is used even when that is incompatible with passed EE. Created attachment 258545Patch suggestion for the fix of this issue.When for a certain Execution Environment no perfect match is availablethe workspace default VM is used even when incompatible with passed Exe Env.Code location of bug:org.eclipse.jdt.internal.launching.JREContainerInitializer.resolveVM(IExecutionEnvironment) // line 193Added patch file with possible fix.
484055,12/9/2015 17:16,register.eclipse,"incorrect warning for nullable array parameter in overriding method DESCRIPTION:For the following code with nullable type annotations:interface A {	public void f(String[] x);	public void f2(String x);}public class B implements A {	public void f(String @org.eclipse.jdt.annotation.Nullable [] x) {	}	public void f2(@org.eclipse.jdt.annotation.Nullable String x) {	}}An incorrect error is generated:Illegal redefinition of parameter x inherited method from A declares this parameter as 'String[]' (mismatching null constraints)\nANALYSIS:This error didn't exist in 4.5. It might be a consequence of the fix for 481332.In org.eclipse.jdt.internal.compiler.ast.NullAnnotationMatching.analyse(TypeBinding TypeBinding TypeBinding Substitution int CheckMode) for non-arrays the check is only executed with a condition ""requiredBits != TagBits.AnnotationNullable || nullStatus == -1"" but no such condition is present for the array case.PATCH (via gerrit):adds an equivalent check for arrays"
484114,12/10/2015 8:48,jarthana,"[content assist] Flow sensitive typing doesn't work in autocompletion when in else if condition Consider the following piece of code:--------------------------------------------import java.util.function.Predicate;public class Test { void x() { Object a = null; if (a instanceof Predicate && a.) }}--------------------------------------------I can now use auto-completion on ""a."" to automatically cast a to Predicate (we know this from the instanceof check) and then call Predicate methods such as test():--------------------------------------------import java.util.function.Predicate;public class Test { void x() { Object a = null; if (a instanceof Predicate && ((Predicate) a).test(null)) }}--------------------------------------------This doesn't seem to work in a condition of an else if statement:--------------------------------------------import java.util.function.Predicate;public class Test { void x() { Object a = null; if (true) ; else if (a instanceof Predicate && a.) }}--------------------------------------------Now I no longer have the choice of auto-completing the test() method. Only Object methods (the declared type of a) are available."
484220,12/11/2015 9:57,manpalat,"[dom][ast][compiler] Invalid AST structure Reproducible on latest Eclipse Luna versionSteps to reproduce:-create following classimport java.util.Collection;public class InvalidTree {	public void foo(Collection collection) {		/** javadoc */		for (final Object obj : collection) {		}	}}-use AST View to inspect AST tree-EnhancedForStatement has correct position 123+42-PARAMETER represented by SingleVariableDeclaration node which is a child of EnhancedForStatement is corrupted and has following invalid position: 105+39 It looks like removing javadoc or final modifier fixes the problem with invalid SingleVariableDeclaration but of course it is not acceptable workaround."
484361,12/14/2015 16:08,novanic,Huge performance slowdown between 4.6 M3 and M4 I notice a huge performance slowdown on trying to upgrade my project from 4.6 M3 to M4. My integrative tests run about 6x slower than with 4.6 M3. I noticed a comparable slowdown already between Luna (JDT 3.10) and Mars (JDT 3.11) which was away/solved with Neon M3 (JDT 3.12 M3).The integrative test suite runs about 550 tests and every test calls ASTParser#createASTs(...) and an implementation of FileASTRequestor triggers 6 ASTVisitor implementations. Normally (with JDT 3.10 and JDT 3.12 M3) the test suite runs about 1 minute now with JDT 3.12 M4 it runs more than 6 minutes.I hope this slowdown will be solved with the final release of Neon until then I have to stay on M3. :-)
484367,12/14/2015 23:56,manpalat,"call hierarchy does not finds calls via method references on interface implementations Here is an example to reproduce the probleminterface Bar {		public void print();}@FunctionalInterfacepublic interface Foo {		void process(Bar bar);}public class BarImpl implements Bar{	@Override//call hierarchy on print does not finds invocation in the below TestMethod class 	public void print() {			}}public class TestMethod {		public void test(){		//Foo foo = (bar)->bar.print();		Foo foo = Bar::print;	}		}Invocation of call hierarchy fails on BarImpl#print however it works on Bar#print. If the method reference expression is replaced with the lambda expression then it works. Marked this as major as I use this functionality everyday on interface implementations and it is very annoying that such a basic thing does not works."
484425,12/15/2015 14:21,sasikanth.bharadwaj,"[bytecode] Bad type on operand stack - compiler omitted instructions for unboxing null Boolean Compiling in Eclipse Neon (and Mars) this simple code:public class Main {	public static void main(String[] args) {		if (false ? true : null) ;	}}I get the next sequence of JVM instructions in produced .class file:0: aconst_null1: ifeq 44: returnRunning it I get this:Error: A JNI error has occurred please check your installation and try againException in thread ""main"" java.lang.VerifyError: Bad type on operand stackException Details: Location: Main.main([Ljava/lang/String;)V @1: ifeq Reason: Type null (current frame stack[0]) is not assignable to integer...and other stuff...Compiling the same code with javac 1.8.0_60 I get this: 0: aconst_null 1: checkcast #2 // class java/lang/Boolean 4: invokevirtual #3 // Method java/lang/Boolean.booleanValue:()Z 7: ifeq 1010: returnRunning it I get what I expected:Exception in thread ""main"" java.lang.NullPointerException at Main.main(Main.java:6)"
484448,12/15/2015 17:44,register.eclipse,"compilation problem in method is caused by javadoc reference with raw type DESCRIPTION:for the following code (note the javadoc refers to g() with the raw type Class)package test;public final class Test {	/**	 * @see #g(T Class)	 */	public static <T> T f(T t Class<T> c1) {		return g(t c1);	}	public static <U> U g(U u Class<U> c2) {		return u;	}}the following error is reported for the return statement in f():??Type mismatch: cannot convert from U to T??ANALYSIS:this used to work in 4.5. the bug has has been introduced by commit 4e6bb96b0e120539a45cc4860f508bf12e097d37 (for bug 473657)PATCH: (sent via gerrit)store inferredWithUncheckedConversion in ParameterizedGenericMethodBinding and check during cache lookup in LookupEnvironment"
484474,12/16/2015 6:31,noopur_gupta,"[content assist] Substring completion matches token with method qualifier in method reference expression - Press Ctrl+space after ""String::|"".- Type ""e"" to filter the proposals.=> The filtered list also contains the proposal ""chars() : IntStream - CharSequence"" since the prefix ""e"" matches the method qualifier."
484479,12/16/2015 6:52,jarthana,"[content assist] Cannot insert a proposal after method reference :: Reproducible with Eclipse 4.5.------------------------------------------package snippet;import java.util.function.Supplier;public interface Bar {	static public Bar print() {		return null;	}}class A {	Supplier<Bar> c = Bar::|}------------------------------------------In the given example press Ctrl+space after :: and select a proposal to enter.=> Nothing is inserted after ::"
484546,12/17/2015 3:37,sasikanth.bharadwaj,"IncompatibleClassChangeError: Expected static method[...] with inner classes Created attachment 258748Sample eclipse projectTested with ecj4.6M4 and eclipse 4.5.2.I've attached a sample eclipse project with a JUnit test to execute in order to reproduce the bug.Executed on command line with ecj4.6M4 produces:JUnit version 4.10-SNAPSHOT.ETime: 0.007There was 1 failure:1) test(inner.test.Tests)java.lang.IncompatibleClassChangeError: Expected static method inner.test.InnerTest.getValue()I	at inner.test.InnerTest$Inner$Inner2.test(InnerTest.java:48)	at inner.test.InnerTest.<init>(InnerTest.java:38)	at inner.test.Tests.test(Tests.java:28)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:497)	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)	at org.junit.runners.ParentRunner.run(ParentRunner.java:300)	at org.junit.runners.Suite.runChild(Suite.java:128)	at org.junit.runners.Suite.runChild(Suite.java:24)	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)	at org.junit.runners.ParentRunner.run(ParentRunner.java:300)	at org.junit.runner.JUnitCore.run(JUnitCore.java:157)	at org.junit.runner.JUnitCore.run(JUnitCore.java:136)	at org.junit.runner.JUnitCore.run(JUnitCore.java:117)	at org.junit.runner.JUnitCore.runMain(JUnitCore.java:98)	at org.junit.runner.JUnitCore.runMainAndExit(JUnitCore.java:53)	at org.junit.runner.JUnitCore.main(JUnitCore.java:45)FAILURES!!!Tests run: 1 Failures: 1From eclipse:java.lang.IncompatibleClassChangeError: Expected static method inner.test.InnerTest.getValue()I	at inner.test.InnerTest$Inner$Inner2.test(InnerTest.java:48)	at inner.test.InnerTest.<init>(InnerTest.java:38)	at inner.test.Tests.test(Tests.java:28)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:497)	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)	at org.junit.runners.ParentRunner.run(ParentRunner.java:300)	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)"
484686,12/18/2015 8:50,sarika.sinha,"ArrayIndexOutOfBoundsException in org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.visit JDT Version: 3.11.1.v20150904-0015When I hover over certain variables in the Variables view during debugging I get the following exception.* Curiously there is no enhanced for statement nearby.* The failing variable has type com.google.common.collect.AbstractMapBasedMultimap.WrappedSet (a private inner class).* The working variables have some public types.java.lang.ArrayIndexOutOfBoundsException: 0	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTInstructionCompiler.visit(ASTInstructionCompiler.java:2242)	at org.eclipse.jdt.core.dom.EnhancedForStatement.accept0(EnhancedForStatement.java:185)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2782)	at org.eclipse.jdt.core.dom.Block.accept0(Block.java:137)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2759)	at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:635)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2782)	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:470)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2782)	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:470)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2782)	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:212)	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2711)	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.createExpressionFromAST(ASTEvaluationEngine.java:579)	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.getCompiledExpression(ASTEvaluationEngine.java:517)	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine.getCompiledExpression(ASTEvaluationEngine.java:477)	at org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.getCompiledExpression(JavaDetailFormattersManager.java:390)	at org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.resolveFormatter(JavaDetailFormattersManager.java:155)	at org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.access$1(JavaDetailFormattersManager.java:140)	at org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager$1.run(JavaDetailFormattersManager.java:135)	at org.eclipse.jdt.internal.debug.core.model.JDIThread$ThreadJob.run(JDIThread.java:3244)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)"
484741,12/20/2015 18:26,register.eclipse,"[1.8][null] wrong warnings with interdependent type variables DESCRIPTION:With null type annotations enabled the following code compiles with errors even tough no null annotations appear at all:package test;public class Test {	static <T E extends T> void f(java.util.ArrayList<T> list E element) {	}	static <A> void g(A a) {		f(new java.util.ArrayList<A>() a);	}	static <T1 E1 extends T1> void h(E1 element1 java.util.ArrayList<T1> list1) {		f(list1 element1);	}}Null constraint mismatch: The type 'A' is not a valid substitute for the type parameter 'E extends T'Null constraint mismatch: The type 'E1 extends T1' is not a valid substitute for the type parameter 'E extends T'ANALYSIS:This bug happens since the changes for bug 481332. In NullAnnotationMatching: For mode BOUND_CHECK there is no NonNull requirement for type variables in requiredNullTagBits. But in analyse mode BOUND_CHECK switches to COMPATIBLE for parent checks and EXACT for detail checks and in the recursive invocation of analyse requiredNullTagBits is invoked with these modes and NonNull requirements appear for the parent type variables.PATCH:Introduces new CheckMode cases instead of COMPATIBLE/EXACT in these situations."
484957,12/28/2015 20:26,mateusz.matela,[formatter] Extra blank lines between consecutive javadoc comments Based on forum thread https://www.eclipse.org/forums/index.php/t/1070825/Some users put multiple javadoc comments on a single element to create some king of decoration for example:/*********************//** Something... ***//*********************/public class Test {}Now when formatter needs to insert some blank lines before such an element they go between those comments:/*********************//** Something... ***//*********************/public class Test {}
484981,12/29/2015 13:41,register.eclipse,"[null][1.8] type variables that have upper bounds This bug addresses two topics regarding bounds on type variables:(1) different behavior between accessing a class with type variables with bounds as source (if no other type annotations are present) or binary(2) implementation doesn't match documentationDESCRIPTION(2) According to http://help.eclipse.org/mars/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Ftasks%2Ftask-using_null_type_annotations.htm&cp=1_3_9_1 using an upper bound of @Nullable for a type variable imposes no constraint. This is not what is currently implemented. It looks that a different behavior was originally planned and is still implemented (and tested in NullTypeAnnotationTest as part of testBinary06 testBinary06b and testBinary07) namely that ""<T extends @Nullable SomeType>"" on the type bound means the same as ""<@Nullable T extends SomeType>"".All of this is currently partially hidden by the fact (1) that null annotations of upper bounds are currently ignored when accessed as source and no other type annotation is present on the type variable.Examples:The following class that conforms to the documentation compiles fine but only because of (1):package test1;import org.eclipse.jdt.annotation.NonNull;import org.eclipse.jdt.annotation.NonNullByDefault;import org.eclipse.jdt.annotation.Nullable;@NonNullByDefaultpublic class GenericWithNullableBound<T extends @Nullable Number> {	static void f1() {		new GenericWithNullableBound<@NonNull Number>();	}}The following code should compile without errors but doesn't:package test1;import static java.lang.annotation.ElementType.TYPE_USE;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.eclipse.jdt.annotation.NonNull;import org.eclipse.jdt.annotation.NonNullByDefault;import org.eclipse.jdt.annotation.Nullable;@Retention(RetentionPolicy.CLASS)@Target({ TYPE_USE })@interface SomeAnnotation {}@NonNullByDefaultpublic class GenericWithNullableBound2<@SomeAnnotation T extends @Nullable Number> {	static void f2() {		new GenericWithNullableBound2<@NonNull Number>(); // unexpected error	}}Similar when GenericWithNullableBound is accessed as binary an error appears.In a different project the following compiles with error:package test2;import org.eclipse.jdt.annotation.NonNull;import org.eclipse.jdt.annotation.Nullable;import test1.GenericWithNullableBound;public class ClassInOtherProject {	static void g1() {		new GenericWithNullableBound<@NonNull Number>(); // unexpected error	}}ANALYSIS:(1) TypeVariableBinding.evaluateNullAnnotations is only executed if type annotations are present on the type variable.(2) In TypeVariableBinding.resolve() and TypeVariableBinding.evaluateNullAnnotations() the superNullTagBits are always copied from the super type/interface but only TagBits.AnnotationNonNull should be. PATCH: (1) make sure that TypeVariableBinding.evaluateNullAnnotations is always invoked if isAnnotationBasedNullAnalysisEnabled is true (possible minor optimization: pass this flag to org.eclipse.jdt.internal.compiler.ast.TypeParameter.resolveAnnotations(Scope)).(2) only copy TagBits.AnnotationNonNull valuesAlso I removed a bogus looking line ""interfaces[i] = resolveType;"" after the if statement in interfaces loop in evaluateNullAnnotations().I adjusted the behavior of testBinary06 testBinary06b and testBinary07 in NullAnnotationMatching and also added variants of these tests which don't go via BinaryTypeBindings.(will be uploaded via gerrit)"
485027,12/30/2015 13:17,register.eclipse,"[1.8][null] Problem with array of typevariable with NonNull upper bound accessed via BinaryTypeBinding DESCRIPTION: With the patch for 484981 applied i stumbled over the following problem (here with @SomeAnnotation so it can be reproduced on the master without the fix for 484981) :- first project -import static java.lang.annotation.ElementType.TYPE_USE;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.CLASS)@Target({ TYPE_USE })@interface SomeAnnotation {}import java.io.Serializable;import org.eclipse.jdt.annotation.NonNullByDefault;import org.eclipse.jdt.annotation.Nullable;@NonNullByDefaultpublic class Base {	public <@SomeAnnotation Q extends Serializable> void setValuesArray(Q @Nullable [] value) {	}}- second project -import java.io.Serializable;import org.eclipse.jdt.annotation.NonNullByDefault;import org.eclipse.jdt.annotation.Nullable;@NonNullByDefaultpublic class Derived extends Base {	@Override	public final <@SomeAnnotation Q1 extends Serializable> void setValuesArray(Q1 @Nullable [] value) {	}}an error is reported for Derived.java:	public final <@SomeAnnotation Q1 extends Serializable> void setValuesArray(Q1 @Nullable [] value) {\n	 ^^^^^^^^^^^^^^^\nIllegal redefinition of parameter value inherited method from Base declares this parameter as 'Q extends @NonNull Serializable @Nullable[]' (mismatching null constraints)\nANALYSIS:When compiling Derived.java when the ArrayBinding for Q[] is constructed the method TypeVariableBinding.resolve() has not been invoked for the type variable Q (which has been read from the class file) so the null bits have not been copied from the type bounds to Q and as consequence the wrong null bits get copied for the leaf type in nullTagBitsPerDimension of the ArrayBindingPATCH:Makes sure that resolve() is invoked before creating an array with TypeVariable as leaf type if null annotations are enabled. (I??m not sure whether the solution in the patch is at the best place or has the optimal if-condition)(will be uploaded via gerrit)"
485030,12/30/2015 18:37,register.eclipse,"[1.8][null] ""contradictory null specification"" on generic array DESCRIPTION: Like bug 485027 the following problem became apparent with the patch for 484981 applied (here with @SomeAnnotation so it can be reproduced on the master without the fix for 484981)Compilation of:import static java.lang.annotation.ElementType.TYPE_USE;import java.lang.annotation.Target;@Target({ TYPE_USE })@interface SomeAnnotation {}import java.io.Serializable;import org.eclipse.jdt.annotation.NonNullByDefault;import org.eclipse.jdt.annotation.Nullable;@NonNullByDefaultpublic class TestContradictoryOnGenericArray {	public <@SomeAnnotation Q extends Serializable> void f() {		final @Nullable Q[] array = null;	}}leads to error:	final @Nullable Q[] array = null;	 ^^^^^^^^^Contradictory null specification; only one of @NonNull and @Nullable can be specified at any locationANALYSIS:ASTNode.mergeAnnotationsIntoType checks ??existingType instanceof TypeVariableBinding?? but it should check oldLeafType to handle the array case.PATCH (via gerrit):changes the check accordingly"
485056,12/31/2015 9:46,register.eclipse,"[1.8][null] capture binding is not compatible with super interface DESCRIPTION:The following code compiles with an error:import java.io.Serializable;import org.eclipse.jdt.annotation.NonNull;import org.eclipse.jdt.annotation.Nullable;class ExplainedValue<T extends Serializable> {	public @Nullable T featureValue;}public class TestExplainedValue {	static @Nullable Serializable g(ExplainedValue<? extends @NonNull Serializable> explainedValue) {		return explainedValue.featureValue;	}}	return explainedValue.featureValue;	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^Type mismatch: cannot convert from capture#1-of ? extends Serializable to SerializableANALYSIS: This bug is a consequence of the fix for bug 484108. In the clone-constructor of TypeVariableBinding this.superInterfaces is initialized to empty array Binding.NO_SUPERINTERFACES (rather than the null value of the prototype) which is the case for the CaptureBinding in this situation. Then when TypeVariableBinding.setSuperInterfaces is invoked (for the annotated CaptureBinding) this clone is not updated because of the (annotatedType.superInterfaces == null) check.PATCH (via gerrit):Also update the super interfaces if annotatedType.superInterfaces == Binding.NO_SUPERINTERFACES"
485058,12/31/2015 11:44,register.eclipse,"[1.8][null] problem with wildcards and null-annotated type bounds DESCRIPTION:The following code compiles with an error:package test;import org.eclipse.jdt.annotation.NonNullByDefault;@NonNullByDefaultclass Feature4<Q extends java.io.Serializable> {}@NonNullByDefaultpublic class Test4 {	public static <Q1 extends java.io.Serializable F extends Feature4<Q1>> Q1[] getValues(F feature) {		throw new RuntimeException();	}	public static void f(Feature4<?> feature) {		getValues(feature);	}}	getValues(feature);	^^^^^^^^^^^^^^^^^^Null constraint mismatch: The type \'@NonNull Feature4<capture#of ?>\' is not a valid substitute for the type parameter \'F extends @NonNull Feature4<Q1 extends @NonNull Serializable>\'ANALYSIS:In CaptureBinding.initializeBounds the null-related tagbits are not updated after invoking setSuperClass and setSuperinterfacesPATCH (via gerrit).Invokes TVB.evaluateNullAnnotations (with null as TypeParameter which now means that now conflicts should be reported which should be ok as they should have been already reported on the actual type that was captured)"
485092,1/3/2016 9:46,register.eclipse,"[null] Cannot initialize an @Nullable array to null I20151229-0800: The following gives the error:Null type mismatch: required '@NonNull IScopeContext @Nullable[]' but the provided value is null	private @NonNull IScopeContext @Nullable [] scopeContexts = null;I think it is valid."
485102,1/3/2016 21:49,mateusz.matela,"[formatter][javadoc] quoted sentence does not word-wrap This bug is always reproducible. Please update the summary to correctly reflect the root cause when you figure it out. I tried and could not. It is something peculiar to the following sentence. After formatting the comment wraps after ""To quote Spring"" (but why?) and will not word-wrap anything else with this particular quote (but why?):/** * To quote Spring ""A hypermedia-driven site provides information to navigate the site's REST interfaces dynamically by including hypermedia links with the responses."" */public class My {}After formatting:/** * To quote Spring * ""A hypermedia-driven site provides information to navigate the site's REST interfaces dynamically by including hypermedia links with the responses."" */public class My {}"
485163,1/4/2016 11:56,mateusz.matela,"[formatter] Incorrect empty line indentation after line wrap When the formatter wraps lines a following blank line is incorrectly indented. It is indented to the position of the previously wrapped line.The easiest way to see this happen is to edit the Eclipse [built-in] formatter profile. Under the Indentation tab check ""Empty lines"". Under Line Wrapping tab change Expressions -> Assignments to ""Wrap where necessary"".In the preview box you can see the incorrect formatting in the blank line after the String assignment. The indentation should line up with ""private"" and ""void"" (1 tab) but rather lines up with the indentation of the wrapped ""TextTextText"" (3 tabs)."
485276,1/6/2016 10:52,mateusz.matela,"[formatter] another ArrayIndexOutOfBoundsException while formatting code Happens with custom formatting settings (tested on Eclipse Mars.1).More details and the exact settings how to reproduce this can be found here:https://issuetracker.springsource.com/browse/STS-4222org.eclipse.e4.core.di.InjectionException: org.eclipse.core.commands.ExecutionException: While executing the action an exception occurred	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:252)	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:234)	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:493)	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:486)	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1105)	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4225)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1491)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1514)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1499)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1528)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1524)	at org.eclipse.swt.widgets.Canvas.sendKeyEvent(Canvas.java:496)	at org.eclipse.swt.widgets.Control.doCommandBySelector(Control.java:1060)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5784)	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method)	at org.eclipse.swt.internal.cocoa.NSResponder.interpretKeyEvents(NSResponder.java:68)	at org.eclipse.swt.widgets.Composite.keyDown(Composite.java:594)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5694)	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)	at org.eclipse.swt.widgets.Widget.callSuper(Widget.java:227)	at org.eclipse.swt.widgets.Widget.windowSendEvent(Widget.java:2130)	at org.eclipse.swt.widgets.Shell.windowSendEvent(Shell.java:2337)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5756)	at org.eclipse.swt.internal.cocoa.OS.objc_msgSendSuper(Native Method)	at org.eclipse.swt.widgets.Display.applicationSendEvent(Display.java:5193)	at org.eclipse.swt.widgets.Display.applicationProc(Display.java:5342)	at org.eclipse.swt.internal.cocoa.OS.objc_msgSend(Native Method)	at org.eclipse.swt.internal.cocoa.NSApplication.sendEvent(NSApplication.java:128)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3695)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1127)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1018)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:156)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:654)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:520)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608)	at org.eclipse.equinox.launcher.Main.run(Main.java:1515)Caused by: org.eclipse.core.commands.ExecutionException: While executing the action an exception occurred	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:127)	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:520)	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:56)	... 60 moreCaused by: java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 4	at java.util.Arrays.rangeCheck(Arrays.java:122)	at java.util.Arrays.fill(Arrays.java:3444)	at org.eclipse.jdt.internal.formatter.TextEditsBuilder.appendIndentationString(TextEditsBuilder.java:269)	at org.eclipse.jdt.internal.formatter.TextEditsBuilder.bufferIndent(TextEditsBuilder.java:238)	at org.eclipse.jdt.internal.formatter.TextEditsBuilder.bufferWhitespaceBefore(TextEditsBuilder.java:165)	at org.eclipse.jdt.internal.formatter.TextEditsBuilder.token(TextEditsBuilder.java:119)	at org.eclipse.jdt.internal.formatter.TokenTraverser.traverse(TokenTraverser.java:103)	at org.eclipse.jdt.internal.formatter.TokenManager.traverse(TokenManager.java:378)	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:161)	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:139)	at org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.reformat(CodeFormatterUtil.java:288)	at org.eclipse.jdt.internal.ui.text.java.JavaFormattingStrategy.format(JavaFormattingStrategy.java:67)	at org.eclipse.jface.text.formatter.MultiPassContentFormatter.formatMaster(MultiPassContentFormatter.java:199)	at org.eclipse.jface.text.formatter.MultiPassContentFormatter.format(MultiPassContentFormatter.java:143)	at org.eclipse.jface.text.source.SourceViewer.doOperation(SourceViewer.java:1014)	at org.eclipse.jface.text.source.projection.ProjectionViewer.doOperation(ProjectionViewer.java:1501)	at org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer.doOperation(JavaSourceViewer.java:196)	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor$AdaptedSourceViewer.doOperation(CompilationUnitEditor.java:197)	at org.eclipse.ui.texteditor.TextOperationAction$1.run(TextOperationAction.java:128)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ui.texteditor.TextOperationAction.run(TextOperationAction.java:126)	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:122)	... 66 more"
485302,1/6/2016 18:20,register.eclipse,[1.8][null]Missing warnings when using Wildcards with null annotations
485333,1/7/2016 6:13,sasikanth.bharadwaj,"[1.8][compiler][codegen] Serializable lambda does not work for method references in some cases I have the following code that compiles that when compiled with normal javac passes but fails with EJC I tryed 4.4.2 and 4.5.1 failed with both.I have on class file Test.java and the content is:import junit.framework.Assert;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;interface Func<T> extends Serializable { T get();}class Impl implements Serializable { int val = 0; public int next() { val += 1; return val; }}public class Test { final Impl impl = new Impl(); final Func<Integer> func = (Func<Integer> & Cloneable)impl::next; public void test() throws Throwable { byte[] bytes = write(func);//25 Func<Integer> func = read(bytes); Assert.assertEquals(2 (int)func.get()); } @SuppressWarnings(""unchecked"") private static Func<Integer> read(byte[] bytes) throws Exception { ByteArrayInputStream bis = new ByteArrayInputStream(bytes); try (ObjectInputStream ois = new ObjectInputStream(bis)) { return (Func<Integer>) ois.readObject(); } } private static byte[] write(Func<Integer> func) throws Exception { ByteArrayOutputStream bos = new ByteArrayOutputStream(); System.out.println(func.get()); try (ObjectOutputStream oos = new ObjectOutputStream(bos)) { oos.writeObject(func);//42 } return bos.toByteArray(); }}This test fails with:java.io.NotSerializableException: Test at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184) at java.io.ObjectOutputStream.writeArray(ObjectOutputStream.java:1378) at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1174) at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1548) at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1509) at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432) at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178) at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348) at Test.write(Test.java:42) at Test.test(Test.java:25)I used Java(TM) SE Runtime Environment (build 1.8.0_25-b18)Also I want to use the latest ECJ from maven I found this reference:http://mvnrepository.com/artifact/org.eclipse.jdt.core.compiler/ecjThe latest version there is 4.4.2 but on eclipse page there is also 4.5.1. Are those updates not pushed automatically?"
485374,1/7/2016 15:31,register.eclipse,[1.8][null] IllegalStateException in TypeSystem.cacheDerivedType DESCRIPTION:An IllegalStateException is thrown in TypeSystem.cacheDerivedType for the following code.Project A - - - package test;public interface I<W> { public class Nested { }}package test;import org.eclipse.jdt.annotation.NonNull;public class D implements I<I.@NonNull Nested> {}Project B - - - package test2;import test.D;class Import {}ANALYSIS:This happens since the patch for bug 473713.In TypeSystem.getUnannotatedType when a resolvedType is found for an URB and already has an id set the URB.id is not updated.PATCH (via gerrit:)updates the id of the urb if necessary
485465,1/8/2016 15:59,register.eclipse,"[1.8][null] null annotations completely broken for classes that are resolved in lambda DESCRIPTION:The following problem is very dependent of the compilation order. I noted it when the reconciler ran while editing code.Luckily I was able to narrow it down to a reproducible test case.project 1 - - - package test2;import java.rmi.registry.Registry;import org.eclipse.jdt.annotation.Nullable;public class ClassWithRegistry { @Nullable public Registry registry;}project 2 - - - package test1;import test2.ClassWithRegistry;// must be compiled before ZClassWithBug (but in the same project)public class ClassWithLambda {	interface Lambda {		void f();	}	public static void invoke(Lambda lambda) {		lambda.f();	}	public void f() {		new ClassWithRegistry(); // must be accessed as class file		invoke(() -> java.rmi.registry.Registry.class.hashCode());	}}package test1;import java.rmi.registry.Registry;import org.eclipse.jdt.annotation.NonNullByDefault;import org.eclipse.jdt.annotation.Nullable;@NonNullByDefaultpublic abstract class ZClassWithBug {	@Nullable	public Registry rmiregistry;}1. ERROR in test1\ZClassWithBug.java (at line 12)	public Registry rmiregistry;	 ^^^^^^^^^^^\nThe @NonNull field rmiregistry may not have been initializedANALYSIS:In LambdaExpression isAnnotationBasedNullAnalysisEnabled is temporarily set to false. If during that time URBs are resolvedthe null bits are not correctly set when UnresolvedReferenceBinding.swapUnresolved calls TypeBinding.setTypeAnnotations. Because the annotated types are cached this may lead to all kinds of problems in the null analysis (outside the lambda expression)In the given example a NonNull annotation is added to ""@Nullable Registry"" in FieldBinding.fillInDefaultNonNullness because of the incorrect tag bits when compiling ZClassWithBug.java.PATCH (via gerrit): It is unclear why ""isAnnotationBasedNullAnalysisEnabled"" is set to false. There is no comment and the tests (testBug429430*) that came with the commit that added this code don??t seem to need it. (I ran them as variation with Null Type Annotations on). Maybe it was some leftover from debugging or maybe some later changes have made this unnecessary? The Patch simply removes that code."
485495,1/10/2016 13:23,mateusz.matela,[Formatter] does not insert space before semicolon at the end of the statement Please activate the checkbox at below path.Window/Preferences/Java/Code Style/Formatter/Edit/White Space/Sort Options By Syntax Element/Before Semicolon/StatementsThe code sample on the right would be like this:int a = 4;foo( );bar( x y );But it should be like this:int a = 4 ;foo( ) ;bar( x y ) ;(Please notice the space before the semicolons at the end of each line)This is a big issue because it causes a change at the end of every line whenever I auto-format a file.
485501,1/10/2016 22:45,jarthana,CompletionTests#testBug421469a() fails I found this test to be failing but wasn't noticed because this was never added to the suite in first place. In CompletionTests we add each test explicitly to the suite but this one was overlooked. Anyway now I have made this particular suite to include tests automatically based on bytecode declaration order but for now disabled the failing test. We need to investigate this failure.
485527,1/11/2016 4:58,Lars.Vogel,"Remove ""What??s Happening?"" from JDT UI website What??s Happening? is clearly outdated and its better to have ""time neutral content""."
485528,1/11/2016 5:01,Lars.Vogel,Remove https://www.eclipse.org/jdt/ui/JDT_UI_Jobs.html Not sure what the purpose of this page is but AFAIK Benno Tobias and Martin do not work in JDT UI anymore.
485529,1/11/2016 5:02,sasikanth.bharadwaj,"[1.8][compiler] Verify error with constructor reference to nested class constructor The following code results in Verify Error when compiled with eclipse but runs fine when compiled with javacinterface I {	X makeX(int x);}public class X {		class Y extends X {			class Z extends X {				private Z(int z) {				}				private Z() {}			}			private Y(int y) {			}			 Y() {			}		}		I i = Y :: new;	private X(int x) {	}	X() {	}	public static void main(String[] args) {		new X();	}}This is the exception seenException in thread ""main"" java.lang.VerifyError: Bad type on operand stackException Details: Location: X.lambda$1(LX;LX;I)LX$Y; @7: invokespecial Reason: Type integer (current frame stack[4]) is not assignable to 'X$Y' Current Frame: bci: @7 flags: { } locals: { 'X' 'X' integer } stack: { uninitialized 0 uninitialized 0 'X' 'X' integer } Bytecode: 0x0000000: bb00 2159 2a2b 1cb7 0023 b0 	at java.lang.Class.getDeclaredMethods0(Native Method)	at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)	at java.lang.Class.privateGetMethodRecursive(Class.java:3048)	at java.lang.Class.getMethod0(Class.java:3018)	at java.lang.Class.getMethod(Class.java:1784)	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)"
485531,1/11/2016 5:04,Lars.Vogel,"Remove outdated ""What??s Happening?"" from JDT core website What??s Happening? is clearly outdated. IMHO its better to have ""time neutral content""."
485576,1/11/2016 14:47,noopur_gupta,[content assist] Duplicate method computeRelevance() in CompletionProposalCollector and LazyJavaCompletionProposal The method #computeRelevance was copied into the LazyJavaCompletionProposal to improve performance (only do it when needed). However the way this was done is problematic since clients are allowed to override CompletionProposalCollector.computeRelevance(CompletionProposal). We could put a reference to the collector into the LazyJavaCompletionProposal and then call the method on the collector. That also eliminates the code duplication.
485581,1/11/2016 16:34,register.eclipse,"[1.8][null] NonNullByDefault applies to type variables when used as field type and accessed via class file DESCRIPTION: An error is reported for the following codeproject 1 - - - package test;import org.eclipse.jdt.annotation.NonNullByDefault;@NonNullByDefaultpublic class MatchResult<V> implements Comparable<MatchResult<?>> {	public final int score;	public final V value;	public MatchResult(int score V value) {		this.score = score;		this.value = value;	}	@Override	public int compareTo(MatchResult<?> o) {		return score - o.score;	}}project 2 - - - package test;import org.eclipse.jdt.annotation.NonNullByDefault;@NonNullByDefaultpublic class FVEHandler {	public static void process(MatchResult<?> matchResult) {		if (matchResult.value != null) {		}	}}----------1. ERROR in test\FVEHandler.java (at line 8)	if (matchResult.value != null) {	 ^^^^^Redundant null check: comparing '@NonNull capture#of ?' against null----------ANALYSIS:In BinaryTypeBinding.scanFieldForNullAnnotation the check fieldType.acceptsNonNullDefault() is missing (that is done in the corresponding to FieldBinding.fillInDefaultNonNullness)PATCH (via gerrit):Adds the check."
485660,1/12/2016 9:20,jarthana,"[1.9][model] Align ModulePackageFragmentRoot#hashCode() with #equals(..) BETA_JAVA9http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=e2511e103fee396c9ab7514f46c3914a90ea3708 added ""this.jarPath"" to ModulePackageFragmentRoot#equals(..) but not to #hashCode().For performance reasons #hashCode() should use the same fields as #equals(..).And I don't think it's OK to refer to ""this.parent.hashCode()"" in #hashCode() but not in #equals(..)."
485738,1/13/2016 6:02,noopur_gupta,[content assist] Support substring matching for templates Bug 350000 introduced substring matching for methods. Currently this does not work for template selection e.g. SWT templates. Would be great to have this here also.
485741,1/13/2016 7:00,sarika.sinha,"[Breakpoints] Can't remove method breakpoint in second anonymous inner class M20160106-1000On the commented line press Ctrl+Shift+B or double-click the left ruler to create a method entry breakpoint. Then do the same again.Expected: Breakpoint should be removed.Was: Breakpoint stays and a duplicate breakpoint is created.package xy;public class Try18 {	void foo() {		new Object() {			public int hashCode() {				return 0;			}		};		new Object() {			public int hashCode() { // can't remove method breakpoint				return 0;			}		};	}}Note that these breakpoints don't even work see bug 182650. Until this bug and bug 182650 can be fixed completely method breakpoints on anonymous classes should be disabled. Running the Toggle Breakpoint action on the method declaration can just toggle a line breakpoint on the first line of the method body."
485748,1/13/2016 8:14,sxenos,Progress bar stays even after completion Created attachment 259155Screenshot4.6 I20160112-1800- In a new workspace open the editor for java.lang.String using Open Type dialog.- Press Ctrl+O to open the Quick Outline popup.- Press Ctrl+O again which shows the progress bar on the status bar.=> The progress bar stays on the status bar even after completion. See attached screenshot.
485762,1/13/2016 9:57,noopur_gupta,[content assist] Use bold blue for template substring matches +++ This bug was initially created as a clone of Bug #470203 +++See https://bugs.eclipse.org/bugs/show_bug.cgi?id=470203#c15Substring matches for templates are blue by default therefore the match should be highlighted with bold blue.
485805,1/13/2016 18:37,manpalat,"[1.8][search] Search engine throws UnsupportedOperationException when searching for subclass implementors I am executing the following code snippet for a given IType superType and a given IJavaProject projectconfigured with Compiler Compliance Level 1.8IPackageFragment packageFragment = superType.getPackageFragment();final LinkedHashSet<IType> subTypes = new LinkedHashSet<IType>();SearchPattern searchPattern = SearchPattern.createPattern(superType IJavaSearchConstants.IMPLEMENTORS);SearchEngine searchEngine = new SearchEngine();IJavaSearchScope scope = null;scope = SearchEngine.createJavaSearchScope(new IJavaElement[] {packageFragment} false);//orscope = SearchEngine.createStrictHierarchyScope(project superType true false null);SearchRequestor requestor = new TypeSearchRequestor(subTypes);searchEngine.search(searchPattern new SearchParticipant[] {SearchEngine.getDefaultSearchParticipant()} scope requestor null);The implementation for class TypeSearchRequestor ispublic class TypeSearchRequestor extends SearchRequestor {		private Set<IType> subTypes;		public TypeSearchRequestor(Set<IType> subTypes) {		this.subTypes = subTypes;	}	public void acceptSearchMatch(SearchMatch match) throws CoreException {		Object element = match.getElement();		if (match.getElement() instanceof IType) {			subTypes.add((IType)element);		}	}}In particular when the superType is one of the following classes:java.util.AbstractCollectionjava.util.AbstractMapjava.util.SortedMapjava.util.Iteratorjava.util.AbstractSetjava.util.NavigableSetthe following exception is always thrown.Caused by: java.lang.UnsupportedOperationException	at org.eclipse.jdt.internal.compiler.lookup.IntersectionTypeBinding18.getPackage(IntersectionTypeBinding18.java:120)	at org.eclipse.jdt.internal.compiler.lookup.TypeBinding.qualifiedPackageName(TypeBinding.java:1499)	at org.eclipse.jdt.internal.core.search.matching.PatternLocator.resolveLevelForType(PatternLocator.java:795)	at org.eclipse.jdt.internal.core.search.matching.PatternLocator.resolveLevelForType(PatternLocator.java:735)	at org.eclipse.jdt.internal.core.search.matching.SuperTypeReferenceLocator.resolveLevel(SuperTypeReferenceLocator.java:101)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2600)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1850)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1259)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1300)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1417)	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:122)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516)	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584)The above code snippet used to work perfectly in Eclipse Kepler."
485814,1/14/2016 2:36,register.eclipse,"[1.8][null] wrong warning when overriding method with type variables DESCRIPTION:A problem is reported for withValue():package test;import org.eclipse.jdt.annotation.NonNullByDefault;@NonNullByDefaultpublic class ExplainedResult<V2> extends Result<V2> {	public ExplainedResult(int score V2 extractedValue2) {		super(score extractedValue2);	}	@Override	public <OtherV2> ExplainedResult<OtherV2> withValue(OtherV2 otherValue2) {		return new ExplainedResult<OtherV2>(this.score otherValue2);	}}package test;import org.eclipse.jdt.annotation.NonNullByDefault;@NonNullByDefaultpublic class Result<V1> {	public final int score;	public final V1 extractedValue;	public Result(int score V1 extractedValue1) {		this.score = score;		this.extractedValue = extractedValue1;	}	public <OtherV1> Result<OtherV1> withValue(OtherV1 otherValue1) {		return new Result<OtherV1>(score otherValue1);	}}1. ERROR in test\ExplainedResult.java (at line 13)\n	public <OtherV2> ExplainedResult<OtherV2> withValue(OtherV2 otherValue2) {\n	 ^^^^^^^^^^^^^^^\nThe return type is incompatible with '@NonNull Result<OtherV1>' returned from Result<V2>.withValue(OtherV1) (mismatching null constraints)\nANALYSIS:In NullAnnotationMatching.analyse the CheckMode is switched from OVERRIDE_RETURN to OVERRIDE and in NullAnnotationMatching.requiredNullTagBits an implimicit @NonNull requirement is added for the type variables.PATCH (via gerrit):For CheckMode.OVERRIDE the type variables are defined by subclass and not free therefore no implicit @NonNull requirement in NullAnnotationMatching.requiredNullTagBits is necessary."
485854,1/14/2016 10:00,noopur_gupta,"[content assist] Emphasize match for Javadoc link type proposals public class C {	/**	 * CCE	 * @param args	 */	public static void main(String[] args) {}}- In the above example press Ctrl+space after ""CCE"".=> The link type proposals (example: {@link ClassCastException} - java.lang) are not emphasized."
485860,1/14/2016 10:47,Lars.Vogel,Remove unnecessary @See Javadoc from spelling engine to prepare for Bug 185695 org.eclipse.jdt.internal.ui.text.spelling.engine contains lots of redundant Javadoc references. If we move the engine code to text (see Bug 185695) we would have to delete them as the package name and plug-in version would change.I suggest to do this before the move.
485988,1/16/2016 9:42,register.eclipse,"[1.8][null] cannot override method with wildcard in return types DESCRIPTION: An error is reported for the following code:package test;public class Result<V> implements Comparable<Result<?>> {	public final int score;	public final V value;	protected Result(int score V value) {		this.score = score;		this.value = value;	}	@Override	public int compareTo(Result<?> o) {		return score - o.score;	}}package test;import org.eclipse.jdt.annotation.NonNullByDefault;@NonNullByDefaultpublic abstract class Base {	public abstract Result<?> matches();}package test;import java.math.BigDecimal;import org.eclipse.jdt.annotation.NonNullByDefault;@NonNullByDefaultpublic class Derived extends Base {	@Override	public Result<BigDecimal> matches() {		return new Result<BigDecimal>(0 new BigDecimal(""1""));	}----------1. ERROR in test\Derived.java (at line 10)	public Result<BigDecimal> matches() {	 ^^^^^^The return type is incompatible with '@NonNull Result<?>' returned from Base.matches() (mismatching null constraints)----------ANALYSIS:In NullAnnotationMatching.requiredNullTagBits and NullAnnotationMatching.providedNullTagBits the null bits for unannotated wildcards are set 0 treating them like an unannotated normal type. But wildcards are like free type variables i.e. when not annotated they should accept both NonNull or Nullable without warning (and NonNullByDefault doesn??t apply to them).As longer example the following code should compile without warnings (there are currently errors for the return types of g2() g3() h2() h3():package neutral;import org.eclipse.jdt.annotation.NonNull;import org.eclipse.jdt.annotation.NonNullByDefault;import org.eclipse.jdt.annotation.Nullable;@NonNullByDefaultclass A<T> {}abstract class X {	abstract A<?> g1();	abstract A<?> g2();	abstract A<?> g3();	abstract A<?> h1();	abstract A<?> h2();	abstract A<?> h3();}class Y extends X {	@Override	A<?> g1() {		return new A<@NonNull String>();	}	@Override	A<@NonNull ?> g2() {		return new A<@NonNull String>();	}	@Override	A<@NonNull String> g3() {		return new A<@NonNull String>();	}	@Override	A<?> h1() {		return new A<@Nullable String>();	}	@Override	A<@Nullable ?> h2() {		return new A<@Nullable String>();	}	@Override	A<@Nullable String> h3() {		return new A<@Nullable String>();	}}@NonNullByDefaultpublic class WildcardTest {	void f(A<?> a) {	}	<T1> void g(A<T1> a) {	}	<T2> void invoke(T2 t) {		f(new A<T2>());		g(new A<T2>());		f(new A<@NonNull T2>());		g(new A<@NonNull T2>());		f(new A<@Nullable T2>());		g(new A<@Nullable T2>());	}}PATCH (via gerrit):Modifies NAM such that the null bits of wildcards are set to AnnotationNullMASK meaning they can accept/provide Nullable or NonNull types. The tests also contain variations of the second example from above which shows the proper error messages."
486012,1/18/2016 2:19,sasikanth.bharadwaj,[1.9][compiler] Grammar Changes Grammar changes for compiling a single module pushed by Sasi via:http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&id=1cc7d27c43e9d6f266edd7944e7969b3b5f0e4f4
486026,1/18/2016 5:09,noopur_gupta,"[content assist] Substring completion for Javadoc tags and Javadoc inline tags public class C {	/**	 * @	 * {@	 */	public static void main(String[] args) {}}With substring completion enabled press Ctrl+space after '@' or '{@' and type 'd' to filter the list.=> Proposals like '@serialData' (Javadoc tag) or '{@inheritDoc}' (Javadoc inline tag) are not shown in the filtered list."
486156,1/20/2016 4:47,sarika.sinha,Adapt to ListenerList changes bug 483340 has generified ListenerList. Need to adapt to the changes.
486305,1/21/2016 15:36,noopur_gupta,"[quick fix] Configure problem severity with multiple markers Created attachment 259314Screenshotpackage p;class C {	private void foo() {		int i;	}}-----------------------------------Set these compiler options to 'Error':- Unused private member- Method can be staticThis will result in two markers at line having 'foo()'.Press Ctrl+1 on 'foo()' - We get two quick fixes 'Configure problem severity' one for each problem marker. But these cannot be distinguished with the proposal text and look like duplicate quick fixes (See attached screenshot).This problem does not happen with quick fix hover as there we consider only one problem annotation."
486350,1/22/2016 8:13,noopur_gupta,[quick fix] Remove 'Configure problem severity' button from hover toolbar Remove 'Configure problem severity' button from hover toolbar.
486359,1/22/2016 9:21,noopur_gupta,[content assist] substring completion for keywords Substring completion should also work for keywords.
486719,1/28/2016 7:42,mateusz.matela,"[formatter] Formatter removes space in //$IDENTITY-COMPARISON$ resulting in compiler errors Open LookupEnvironment from JDT Core code base. Do a format (Ctrl+Shit+F). The resulting code produces two compiler errors. The reason being formatting adds a space after ""//"" in //$IDENTITY-COMPARISON$.This doesn't happen with //$NON-NLS-1$ though."
486899,1/30/2016 19:04,Lars.Vogel,"[templates] Using a variable name for word_selection or line_selection makes the template not being proposed anymore If I use a variable for word_selection in a template this template ""vanishes"" if I select a text in the editor.For example:${button}.setText(${w:word_selection});Or in a full template (modified Button template):---------${buttonType:newType(org.eclipse.swt.widgets.Button)} ${button:newName(org.eclipse.swt.widgets.Button)}= new ${buttonType}(${parent:var(org.eclipse.swt.widgets.Composite)} ${style:link(SWT.PUSH SWT.TOGGLE SWT.RADIO SWT.CHECK SWT.FLAT)});${button}.setLayoutData(new ${type:newType(org.eclipse.swt.layout.GridData)}(SWT.${horizontal:link(BEGINNING CENTER END FILL)} SWT.${vertical:link(CENTER TOP BOTTOM FILL)} ${hex:link(false true)} ${vex:link(false true)}));${button}.setText(${w:word_selection});${button}.addSelectionListener(new SelectionAdapter() {			@Override			public void widgetSelected(SelectionEvent e) {				${listener:link('')}			}		});${imp:import(org.eclipse.swt.SWT org.eclipse.swt.events.SelectionAdapter org.eclipse.swt.events.SelectionEvent)}${cursor}----------"
486912,1/31/2016 14:44,register.eclipse,"[null]??potential null pointer access not reported in do{...}while(false) or while(...){...; break;} In the following code there are no problems reported for lines marked with // ERROR(noted during experiments for bug 466556)public class PotNullInLoop {	boolean b;	public void testDoWhile1() {		Object o1 = null;		Object o2 = new Object();		Object potNonNull = b ? o2 : o2;		Object potNull = b ? o1 : o1;		Object ponNullOrNonNull = b ? potNull : potNonNull;		do {			potNonNull.hashCode(); // OK			potNull.hashCode(); // ERROR 1: pot null but nothing reported			ponNullOrNonNull.hashCode(); // ERROR 2: pot null but nothing reported		} while (false); // <- false is important	}	public void testWhileWithBreak() {		Object o1 = null;		Object o2 = new Object();		Object potNonNull = b ? o2 : o2;		Object potNull = b ? o1 : o1;		Object ponNullOrNonNull = b ? potNull : potNonNull;		while (b) {			potNonNull.hashCode(); // OK			potNull.hashCode(); // ERROR 3 : pot null but nothing reported			ponNullOrNonNull.hashCode(); // ERROR 4: pot null but nothing reported			break; // <- unconditional break is important		}	}}"
487174,2/3/2016 17:07,markus.kell.r,"[navigation] Quick Outline colors nested binary type as inherited member The Quick Outline renders nested binary types with the ""Inherited members"" color.Steps:- open java.util.Map from a JDK (with source attachment)- press Ctrl+O Ctrl+O=> Entry<K V> and all its children are rendered in blue"
487180,2/4/2016 1:40,akurtakov,Adapt to platform text tests moving to JUnit 4 Adjustment for tests extending platform.text ones.
487204,2/4/2016 5:06,manpalat,"[1.9][compiler] NPE while compiling module-info.java file Created attachment 259560Project to reproduce the issuefollow up of bug 482882The issue here is that the compilationUnit.moduleDeclaration does not get filled in when there is an error (recovery?) and there is no check at acceptModuleInfo()The relevant part of st given below:java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.lookup.ModuleEnvironment.createModule(ModuleEnvironment.java:240)	at org.eclipse.jdt.internal.core.builder.ClasspathMultiDirectory.acceptModuleInfo(ClasspathMultiDirectory.java:85)	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder$1.visit(AbstractImageBuilder.java:240)	at org.eclipse.core.internal.resources.Resource$1.visitElement(Resource.java:84)if you put a semicolon after nothing then it passes (consumeInternalCompilationUnitWithModuleDeclaration fills in the module information)."
487333,2/5/2016 6:54,Lars.Vogel,Update JDT user guide with adjustments of $word_selection and $line_selection template variable See https://bugs.eclipse.org/bugs/show_bug.cgi?id=486903#c2
487375,2/5/2016 14:55,mateusz.matela,"[formatter] block comment in front of method signature effects too much indentation 4.6 M6The code formatter wrongly indents a method declaration (including Javadoc) by two tabs when the method signature starts with a block comment.* Example with default profile:package xy;public class FormatterBug {	/**	 * Effects an affect: surprise!	 */	/*public*/ void effect() {	}}* Expected: Formatting should be a no-op.* Was:public class FormatterBug {			/**			 * Effects an affect: surprise!			 */			/* public */ void effect() {	}}"
487429,2/8/2016 4:12,noopur_gupta,Save action or cleanup action creates syntax error Example: Run the convert to Enhance for loops clean-up action on org.eclipse.jdt.internal.ui.text.template.contentassist.TemplateEngine or active the corresponding save action.https://git.eclipse.org/r/#/c/66014/4/org.eclipse.jdt.ui/ui/org/eclipse/jdt/internal/ui/text/template/contentassist/TemplateEngine.java
487569,2/10/2016 5:21,jarthana,"JDT Debug test testTranslateContainers failing in Beta_Java_9 IPackageFragmentRoot.getElementName() is returning """" for PackageFragmentRoot.Works fine on master with Java8. Looks like getElementName from JarPackageFragmentRoot has been removed."
487593,2/10/2016 9:53,daniel_megert,GTK: Remove Ctrl+Shift+V as keybinding for the Display command Remove Ctrl+Shift+V as keybinding for the Display command on GTK.The keybinding got introduced in 2004 as a workaround for Ctrl+Shift+D not working on GTK (bug 59524) but AFAIK GTK no longer takes away Ctrl+Shift+D.
487666,2/11/2016 9:10,sarika.sinha,[content assist] color/style matching characters in completion proposals in JDT Debug Code completions in JDT Debug should emphasize matching characters in completion proposals like in Java editors (bug 470203).
487668,2/11/2016 9:32,noopur_gupta,[content assist] Substring completion still breaks proposal sorting Created attachment 259710ScreenshotI20160209-0800Even after bug 483511 I see still cases where substring completions are shown before prefix completions. See attachment for examples.Probably a issue with proposals from different providers. In the examples affected proposals are from type history and template proposals.
487716,2/12/2016 5:27,jarthana,"Type use annotations should not be attached to constructor elements Here's a test code that annotates TYPE_USE annotations on a constructor declaration:@Target(ElementType.TYPE_USE)@interface Type {}public class X { @Type public X(){} X _x_ = new X();}ExecutableElement constr = ...; // Represents the constructor element.annotationMirrors = constr.getAnnotationMirrors();The result contains all the type use annotations which is wrong. The specification says:""A type annotation is permitted in front of a constructor declaration where declaration annotations are already permitted. In that location a type annotation is treated as applying to the constructed object (which is different than the receiver if any of the constructor). ""Looking at the code I don't see any effort is being made to move the SE8 annotations to the type of the node (ASTNode#copySE8AnnotationsToType())."
487779,2/13/2016 0:11,noopur_gupta,[1.9][content assist] jdt.ui support for code completion in module-info This is the jdt ui part of bug 480612
487781,2/13/2016 4:20,register.eclipse,"[1.8][null] bogus error only in editor when referenced type has type annotations only on type parameter DESCRIPTION:Given the following code two errors are shown in the class Usage but only in the editor not in the problems view:============== Util.javapackage test;import org.eclipse.jdt.annotation.NonNullByDefault;import org.eclipse.jdt.annotation.Nullable;class A<T> {}interface I {}@NonNullByDefaultclass Util2<T extends @Nullable I> {}@NonNullByDefaultpublic class Util {	public static <T extends @Nullable I> void uniqueMapOfUniqueable(A<T> set) {	}}============== Usage.javapackage test;import org.eclipse.jdt.annotation.Nullable;public class Usage {	public void f() {		Util.uniqueMapOfUniqueable(new A<@Nullable I>());		new Util2<@Nullable I>();	}}----------\n1. ERROR in /BugXXX/src/test/Usage.java (at line 5)\n	Util.uniqueMapOfUniqueable(new A<@Nullable I>());\n	 ^^^^^^^^^^^^^^^^^^^^\nNull type mismatch (type annotations): required '@NonNull A<@NonNull I>' but this expression has type 'A<@Nullable I>'\n----------\n2. ERROR in /BugXXX/src/test/Usage.java (at line 6)\n	new Util2<@Nullable I>();\n	 ^^^^^^^^^^^\nNull constraint mismatch: The type '@Nullable I' is not a valid substitute for the type parameter 'T extends @NonNull I'\n----------\nANALYSIS:The type annotations in Util.java are not returned by SourceTypeConverter because they only appear on type parameters. Therefore the @NonNullByDefault is applied to the type bounds and the errors are reported.PATCH(via gerrit:)Extends the changes for Bug??405843 to type parameters"
487841,2/15/2016 16:25,register.eclipse,"All Java elements that are not open in an editor and have no problem are decorated with ""info""-icon DESCRIPTION:All Java element below compilation units i.e. classes fields methods that are visible in the package explorer search result hierarchy view but NOT open in an editor and that don't have an error warning or info are decorated with an ""info""-iANALYSIS:If a file is NOT open in an editor the method ProblemsLabelDecorator.getErrorTicksFromMarkers is used where severity is initialized to ""0"" but this is the value for IMarker.SEVERITY_INFO so ERRORTICK_INFO is returned instead of 0.(If a file IS open in an editor ProblemsLabelDecorator.getErrorTicksFromAnnotationModel is used instead which works correctly)PATCH (via gerrit):Initializes severity = -1 in ProblemsLabelDecorator.getErrorTicksFromMarkers"
488249,2/22/2016 14:07,markus.kell.r,"[1.8][nls tooling][quick fix] ""Add missing //$NON-NLS-1$ tag"" not shown in default method The ""Add missing //$NON-NLS-1$ tag"" Quick Fix is not shown in an default method's body e.g. here:public interface Intf {	default void foo() {		System.out.println(""Hello"");	}}Furthermore such string literals are also missing in the Externalize Strings wizard."
488266,2/23/2016 1:10,manpalat,"[1.9][compiler] NPE in isModuleInfo() Due to a change in commit http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA9&id=d8e876759bbccfa88c266183ef2c12348f6c6feb (Fix several NPEs occurring because of module name not being set in CUD) there is another NPE that happens with st:java.lang.NullPointerException: null	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.getMainTypeName(CompilationUnitDeclaration.java:412)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.isModuleInfo(CompilationUnitDeclaration.java:438)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.<init>(CompilationUnitDeclaration.java:105)	at org.eclipse.jdt.core.dom.DefaultBindingResolver.<init>(DefaultBindingResolver.java:181)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1074)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:639)	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:993)	at org.eclipse.jdt.core.tests.dom.StandAloneASTParserTest.test2(StandAloneASTParserTest.java:136)"
488273,2/23/2016 4:19,manpalat,Move JDT Project compliance to 1.8 An early move to 1.8 would help to use the java 8 constructs during implementation. Let us discuss on this bug if there are issues for moving to 1.8.
488274,2/23/2016 4:20,noopur_gupta,Update decorator icon and problems view icon for information severity level See bug 485352 comment #16.
488363,2/24/2016 4:05,manpalat,"[code completion] SIOOBE while completing for package Consider the case:package p1.<complete Here>and let there be package p1 p1.p2 available in the project there is an exception.The ST is given below:java.lang.StringIndexOutOfBoundsException: String index out of range: 3	at java.lang.String.substring(String.java:1980)	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getPatternMatchRule(AbstractJavaCompletionProposal.java:910)	at org.eclipse.jdt.internal.ui.text.java.LazyJavaCompletionProposal.emphasizeMatch(LazyJavaCompletionProposal.java:507)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.handleSetData(CompletionProposalPopup.java:869)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.access$24(CompletionProposalPopup.java:849)	at org.eclipse.jface.text.contentassist.CompletionProposalPopup$3.handleEvent(CompletionProposalPopup.java:599)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4373)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1105)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)Although the ST is shows jdt.ui the root cause is the parameter passed from jdt.core and hence component is ""Core"""
488420,2/24/2016 16:21,register.eclipse,"[1.8][extract interface] EmptyStackException caused by return statement in lambda outside of method DESCRIPTION:For the following two files:===== test/X.javapackage test;class X {	public void m1() {	}	public void m2() {	}}====== test/Util.javapackage test;import java.util.function.Supplier;/** {@link X} */class Util {	static Supplier<Object> lambda1 = () -> {		return null;	};}On X do ""refactor > extract interface"" fill in name select m1 click preview. An error is reported caused by EmptyStackException triggered by fCurrentMethods.peek() called from SuperTypeConstraintsCreator.endVisit(ReturnStatement).ANALYSIS:Handling for return statements in LambdaExpressions that have a block as body is simply missing. Because there is no surrounding MethodDeclaration the stack is completely empty. (If it was not empty no Exception would be thrown but some (probably wrong) constraints involving the method that contains the Lambda created.)PATCH(via gerrit):Changes fCurrentMethods so LambdaExpressions are tracked too and also adds contraints in the context of LambdaExpressions."
488432,2/25/2016 2:43,Lars.Vogel,[templates] adjust word_selection and line_selection variable in JDT Text to consider a default value similar to platform.text See Bug 487901 which created a new base class.
488441,2/25/2016 4:56,jarthana,"[content assist] Substring proposals have incorrect relevance public class Try18 {	public static void main(String[] args) {		n|	}}- Press ctrl+space after 'n'.=> Proposal for 'main(..)' (substring proposal) has a higher relevance than some other Types starting with 'n'.----------------------------public class Try18 {	public static void main(String[] args) {		y|	}}- Press ctrl+space after 'y'.=> Proposal for 'Try18' (substring proposal) has a higher relevance than other Types starting with 'y'.----------------------------See screenshot in bug 487668 comment #0.Substring proposals should always be less relevant than applicable prefix proposals."
488461,2/25/2016 8:01,markus.kell.r,Javadoc for CompilationParticipant.isAnnotationProcessor() is not accurate Javadoc for CompilationParticipant#isAnnotationProcessor() is not accurate.It says:Returns whether this participant is interested in only Annotations.but that's not what it does. It only tells whether annotations are processed by calling CompilationParticipant#processAnnotations(BuildContext[]). Other APIs of the CompilationParticipant are not affected.
488495,2/25/2016 15:14,register.eclipse,[null] Wrong warning about unchecked conversion. Constraints lost after using streams. Created attachment 259931Sample projectUsing Eclipse 4.6-I20160223-0800After using a few stream methods it seems that the null constraints get lost. For example in this code:@NonNullByDefaultpublic class Main { public static void main(String[] args Set<String> set) { Optional<@Nullable String> kam = set.stream() .map(trace -> getString(String.class)) .findFirst(); // Null type safety (type annotations): The expression of type 'Optional<String>' needs unchecked conversion to conform to 'Optional<@Nullable String>' System.out.println(kam); } public @Nullable static <T extends CharSequence> T getString(Class<T> moduleClass) { return null; }}After the map it should be a stream of @Nullable String but instead it's just String (can be verified with hover). Because of that findFirst returns an Optional<String> instead of Optional<@Nullable String>I attached a sample project for convenience.
488542,2/26/2016 5:26,daniel_megert,[templates] Surround With does not show templates that specify a default for the selection variable Surround With does not show templates that specify a default for the selection variable.
488552,2/26/2016 7:34,mateusz.matela,"[formatter] Misleading exception for invalid preferences value Under yet unclear circumstances Eclipse doesn't allow further typing after a quotation mark. In affected classes eg after typing throw new AssertionError( ""no further characters can be entered. Input like """"; ""also causes the effect.In the workspace log following exception occurs:!ENTRY org.eclipse.ui 4 0 2016-02-26 13:26:16.270!MESSAGE Unhandled event loop exception!STACK 0java.lang.IllegalArgumentException at org.eclipse.jdt.core.formatter.DefaultCodeFormatterConstants.<clinit>(DefaultCodeFormatterConstants.java:3989) at org.eclipse.jdt.internal.core.JavaCorePreferenceInitializer.initializeDefaultPreferences(JavaCorePreferenceInitializer.java:70) at org.eclipse.core.internal.preferences.PreferenceServiceRegistryHelper$1.run(PreferenceServiceRegistryHelper.java:300) at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42) at org.eclipse.core.internal.preferences.PreferenceServiceRegistryHelper.runInitializer(PreferenceServiceRegistryHelper.java:303) at org.eclipse.core.internal.preferences.PreferenceServiceRegistryHelper.applyRuntimeDefaults(PreferenceServiceRegistryHelper.java:131) at org.eclipse.core.internal.preferences.PreferencesService.applyRuntimeDefaults(PreferencesService.java:368) at org.eclipse.core.internal.preferences.DefaultPreferences.applyRuntimeDefaults(DefaultPreferences.java:221) at org.eclipse.core.internal.preferences.DefaultPreferences.load(DefaultPreferences.java:274) at org.eclipse.core.internal.preferences.EclipsePreferences.create(EclipsePreferences.java:409) at org.eclipse.core.internal.preferences.EclipsePreferences.internalNode(EclipsePreferences.java:670) at org.eclipse.core.internal.preferences.EclipsePreferences.node(EclipsePreferences.java:812) at org.eclipse.core.internal.preferences.AbstractScope.getNode(AbstractScope.java:38) at org.eclipse.core.runtime.preferences.DefaultScope.getNode(DefaultScope.java:76) at org.eclipse.jdt.internal.core.JavaModelManager.initializePreferences(JavaModelManager.java:3011) at org.eclipse.jdt.internal.core.JavaModelManager.startup(JavaModelManager.java:5025) at org.eclipse.jdt.core.JavaCore.start(JavaCore.java:5704) at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:771) at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1) at java.security.AccessController.doPrivileged(Native Method) at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:764) at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:721) at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:941) at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:318) at org.eclipse.osgi.container.Module.doStart(Module.java:571) at org.eclipse.osgi.container.Module.start(Module.java:439) at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:454) at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107) at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:531) at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:324) at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:327) at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:402) at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:352) at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:344) at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:160) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at org.eclipse.pde.internal.core.PDECore.start(PDECore.java:275) at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:771) at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1) at java.security.AccessController.doPrivileged(Native Method) at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:764) at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:721) at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:941) at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:318) at org.eclipse.osgi.container.Module.doStart(Module.java:571) at org.eclipse.osgi.container.Module.start(Module.java:439) at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:454) at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107) at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:531) at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:324) at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:327) at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:36) at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:398) at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:352) at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:344) at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:160) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at org.eclipse.pde.internal.ui.PDEPlugin.getPreferenceManager(PDEPlugin.java:66) at org.eclipse.pde.internal.ui.shared.target.TargetStatus.initializeTargetStatus(TargetStatus.java:188) at org.eclipse.pde.internal.ui.PDEPlugin.start(PDEPlugin.java:200) at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:771) at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1) at java.security.AccessController.doPrivileged(Native Method) at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:764) at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:721) at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:941) at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:318) at org.eclipse.osgi.container.Module.doStart(Module.java:571) at org.eclipse.osgi.container.Module.start(Module.java:439) at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:454) at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:107) at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:531) at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:324) at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:327) at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:402) at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:352) at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:344) at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:160) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:573) at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:174) at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:905) at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:243) at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:55) at org.eclipse.ui.internal.services.WorkbenchServiceRegistry.getSourceProviders(WorkbenchServiceRegistry.java:177) at org.eclipse.ui.internal.services.SourceProviderService.readRegistry(SourceProviderService.java:108) at org.eclipse.ui.internal.Workbench$47.runWithException(Workbench.java:2376) at org.eclipse.ui.internal.StartupThreading$StartupRunnable.run(StartupThreading.java:32) at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35) at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:135) at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3794) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3433) at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2949) at org.eclipse.ui.internal.Workbench.access$8(Workbench.java:2854) at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:651) at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:337) at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:598) at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150) at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:139) at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134) at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:380) at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:235) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:669) at org.eclipse.equinox.launcher.Main.basicRun(Main.java:608) at org.eclipse.equinox.launcher.Main.run(Main.java:1515) at org.eclipse.equinox.launcher.Main.main(Main.java:1488)"
488658,2/28/2016 23:17,manpalat,[1.9] Allow @SafeVarargs on private instance methods Coin project (JEP 213) states that private instance methods can also accommodate @SafeVarargs from 1.9 level. We currently reject this.
488659,2/28/2016 23:31,manpalat,[1.9] Allow effectively-final variables to be used as resources in the try-with-resources Refer to the coin project (JEP 213) and JSR 334 an effectively final variable can be allowed in try with resources. Thus the try with resources statement can manage the resource without having to declare a new variable.
488662,2/29/2016 0:00,manpalat,[1.9] Allow private methods in interfaces Refer coin project (JEP 213) - To enable non abstract methods in an interface to share code among them it is proposed to allow private methods in interfaces.
488737,3/1/2016 2:24,manpalat,[1.9] SIOOBE while completing for exports similar to bug 488363 but in the context of exports
488898,3/2/2016 16:10,mateusz.matela,"[formatter] Disabled options still have effect From bug 118264 comment 5:> - Set the policy to ""Wrap where necessary"".> - Check ""Force split..."".> - Change policy back to ""Do not wrap"" which disables ""Force split..."" and> should give the same result as the default profile.> Issue => A newline is still added after the opening parenthesis.It's worth checking if similar problems occur for other settings that are sometimes disabled."
488933,3/3/2016 6:04,noopur_gupta,"[quick assist] ""Join if statement with outer..."" removes preceding comment Sample code:void foo(int a) {	// comment1	if (a > 0) {		if (a < 6) {			return;		}	}}- put the cursor before the second if- Ctrl+1 choose Join 'if' statement with outer 'if' statementResult: //comment1 is removed"
488951,3/3/2016 10:21,register.eclipse,[preferences][null] UI for compiler preference to pessimistically analyze free type variables Bug 466556 has introduced a new compiler option JavaCore.COMPILER_PB_PESSIMISTIC_NULL_ANALYSIS_FOR_FREE_TYPE_VARIABLES which needs a new combo in the compiler preferences.
489081,3/5/2016 15:12,register.eclipse,"[quick fix][null] Quickfix to add @NonNull to local variable Developed in the context of Bug 466556 for problem 452 ""PotentialNullLocalVariableReference"""
489170,3/7/2016 16:36,register.eclipse,[1.8][extract interface] Handle method references There are 5 cases:1. static method referenced via the type. This case is a bit special as there is TypeMethodReference but ExpressionMethodReference is used for this case too.2. instance method referenced via the type. This case is a bit special as the first parameter of the sam corresponds to the method receiver.3. constructor reference. Like in the previous two cases the type must not changed in this case.4. super method reference5. instance method referenced via an expression
489202,3/8/2016 6:15,markus.kell.r,"[save actions] Format edited lines on Save formats lines with non-ASCII characters The ""Format edited lines"" Save Action formats lines with non-ASCII characters even the lines were not touched.Steps:- have a project with Cp1252 encoding- save this snippet in a *.java file with UTF-8 encoding:package tests.saveaction;public class LongLines{ 	void foo() { 		System.out.println(""C:\\temp\\????????\\????.txt""); // file is 2 chars folder is 4 chars 		System.out.println(""Here's a Java method: Does it need line breaks? "" + ""p."" + ""abc"" + ""("" + ""abcdef f"" + "" "" + ""abcdef2 f2"" + "");""); 		System.out.println(""Here's a Java method: Does it need line breaks? "" + ""??."" + ""??????"" + ""("" + ""?? ????????????"" + "" "" + ""2?? 2????????????"" + "");"");	}}- add a space at the end of the first line- Save=> expected: space gets removed=> was: space gets removed and the two lines that contain Hebrew characters get formattedThe bug is in org.eclipse.jdt.internal.ui.javaeditor.EditorUtility.calculateChangedLineRegions(...).new ISafeRunnable() {...}.run():IFileBufferManager#connectFileStore(..) specifies that it should not be used with a file store for a file from the workspace. Here it doesn't fail for the reason specified in the Javadoc but because connectFileStore creates a buffer with a wrong encoding (see FileStoreTextFileBuffer#cacheEncodingState() which uses the global default and not the resource's encoding in the workspace)."
489207,3/8/2016 7:30,sarika.sinha,[1.9] Latest Jigsaw JRE is no longer recognized The problem is two fold:1. The boot.class.path environment variable has been removed. This results in JREContainer not being created at all. Apparently a container can not be created with zero library entries.2. JDT Core also assumes that the bootmodules.jimage will be the path representing the JDK. This needs to change too.While we work on a longer term solution I propose this short term fix:While trying to look up the VM install let's look for jrt-fs.jar in java.home and add that to the container. And in JDT Core accommodate the new reality that presence of a jrt-fs.jar means we are dealing with a Jigsaw.JDT Core anyway relies on jrt-fs to get to the modules. So this is not an additional restriction.
489245,3/8/2016 15:34,register.eclipse,"[1.8][null][lambda] bogus problem report in lambda block when severity is set to ""info"" DESCRIPTION:While testing with the new setting ??Problems detected by pessimistic analysis for free type variables?? from bug 488951 set to ??info?? I noted that some bogus problems are reported at info level that don??t appear if the level is set to error or warning:package test;import java.util.function.Supplier;import org.eclipse.jdt.annotation.NonNull;import org.eclipse.jdt.annotation.NonNullByDefault;@NonNullByDefaultpublic class TestBogusProblemReportOnlyAsInfo {	static <U> void get(Supplier<U> supplier @NonNull U defaultValue) {	}	static void f() {		get(() -> {			return null; // bogus problem report only as info		} """");	}	static <T> void h(@NonNull T t) {		get(() -> {			return null; // correctly reported (but twice with the bug)		} t);	}}ANALYSIS:In LambdaExpresion#cachedResolvedCopy silentErrorHandlingPolicy is activated for which ignoreAllErrors() returns true.But this doesn??t prevent ??info??-level messages from being reported in ProblemHandler#handle:	 if (severity < ProblemSeverities.InternalError && this.policy.ignoreAllErrors()) { because the ProblemSeverity for INFO is higher than InternalError:	final int InternalError = 512; // always exposed even when silent error handling policy is in effect.	final int Info = 1024; // When bit is set the unit or project is not flagged.PATCH(via gerrit):- Changes the condition to:	 if ((severity & ProblemSeverities.InternalError) == 0 && this.policy.ignoreAllErrors()) {- Even when set to ??INFO?? the problems where reported as ??WARNING?? in tests.To fix this the patch contains changes for org.eclipse.jdt.core.tests.util.Util"
489277,3/9/2016 7:05,noopur_gupta,"[content assist] SIOOBE on typing '(' while overriding method public class Bug extends ASTVisitor {	visit|}class ASTVisitor {	public boolean visit(Bug node) {	 return false;	}	public boolean visit(Boolean node) {		return false;	}}Press Ctrl+space in place of '|' and type '('. We get the exception:java.lang.StringIndexOutOfBoundsException: String index out of range: 6	at java.lang.String.substring(String.java:1963)	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getPatternMatchRule(AbstractJavaCompletionProposal.java:910)	at org.eclipse.jdt.internal.ui.text.java.AbstractJavaCompletionProposal.getStyledDisplayString(AbstractJavaCompletionProposal.java:1252)...At the exception location in code [string.substring(0 pattern.length())] pattern is ""visit("" and string is ""visit"".The original string ""visit(Boolean node) : boolean - Override method in 'ASTVisitor'"" is truncated at '(' and becomes ""visit"" after the discussion in bug 482119 comment #4."
489404,3/11/2016 2:33,register.eclipse,"[search]??NPE while searching references caused by missing types DESCRIPTION:- create a new java project. add http://search.maven.org/remotecontent?filepath=com/google/gwt/gwt-user/2.7.0/gwt-user-2.7.0.jar as java library.- create a new java file:package test;public class Test {	String lang;}- select ??lang?? and do Search>References>Workspace. A NullPointerException is thrownANALYSIS:(For a reduced testcase see the patch in Gerrit):A Class is cached as missing (PackageBinding.addNotFoundType) and (invisibly) reported in context of a SourceTypeBinding (note: the gwt-user-2.7.0.jar contains .java files for some of the .class files and the search uses them)A BinaryTypeBinding for a class C1 is created that is needed by another BinaryTypeBinding:In org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(IBinaryType PackageBinding boolean AccessRestriction) it is added to the cache with	packageBinding.addType(binaryBinding)and then	binaryBinding.cachePartsFrom(binaryType needFieldsAndMethods);is invoked but an AbortCompilation exception is thrown during BTB.createFields/createMethods because of the missing type that was already (invisibly) reported.Now the cached BinaryTypeBinding??s fields or methods array is set but contains some null values (BUG!).When C1 is processed for search the cached copy is found and BinaryTypeBinding.availableFields or availableMethods is invoked which crashesPATCH(via Gerrit):Modifies BTB createFields and createMethods such that this.fields/this.methods is only set once the array has been filled."
489486,3/12/2016 12:28,register.eclipse,Type mismatch error with annotations and generics Regression of 386356 (https://bugs.eclipse.org/bugs/show_bug.cgi?id=386356)This appeared for me in 4.5.1 so I upgraded to 4.5.2 in hopes that it would be resolved but it still exists.
489604,3/14/2016 19:27,david_williams,should not override <timestampProvider> This issue came to light during bug 489594. The org.eclipse.jdt.core.tests.model bundle overrides the parent's timestampProvider by specifying <timestampProvider>defuault</timestampProvider>. Can you explain why the parent's value does not work?
489618,3/15/2016 1:14,daniel_megert,"jdt features needs to adjust ranges for jdt.annotation 2.x While doing a local test build I get an error that jdt.feature can not resolve dependency on jdt.annotations [2.0.1002.1.101]. That is because jdt.annotations has changed to be version 2.1.0! Perhaps I simply tried the test build ""in the middle of things"" but marking as blocker since the 8 AM will fail quickly if this isn't fixed by then."
489631,3/15/2016 6:13,sasikanth.bharadwaj,"[1.8] ""java.lang.VerifyError: Bad type on operand stack"" with lamba and type defined in method Created attachment 260301Sample projectWorks fine with javac.Tested with latest Integration and Nightly builds: ecj-I20160314-2000.jar ecj-N20160312-1500.jar.I've attached a sample project to reproduce.Run and the result should be:0But is instead:Error: A JNI error has occurred please check your installation and try againException in thread ""main"" java.lang.VerifyError: Bad type on operand stackException Details: Location: com/test/Test.lambda$0(Ljava/util/List;)I @6: invokespecial Reason: Type 'java/util/List' (current frame stack[2]) is not assignable to 'com/test/Test' Current Frame: bci: @6 flags: { } locals: { 'java/util/List' } stack: { uninitialized 0 uninitialized 0 'java/util/List' 'java/util/List' } Bytecode: 0x0000000: bb00 3659 2a2a b700 38b4 003b b900 3e01 0x0000010: 00ac 	at java.lang.Class.getDeclaredMethods0(Native Method)	at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)	at java.lang.Class.privateGetMethodRecursive(Class.java:3048)	at java.lang.Class.getMethod0(Class.java:3018)	at java.lang.Class.getMethod(Class.java:1784)	at sun.launcher.LauncherHelper.validateMainClass(LauncherHelper.java:544)	at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:526)"
489636,3/15/2016 6:53,sasikanth.bharadwaj,"[1.8] ""Bound mismatch"" for a generic method parameter Created attachment 260305sample projectTested with latest Integration and Nightly builds: ecj-I20160314-2000.jar ecj-N20160312-1500.jar.I've attached a sample project with the following sources:interface I<T> { I<T> get();}public class Test { @SuppressWarnings(""unused"") private static <T S extends I<T>> void test(S p) { I<T> i = p.get(); test(i); // Bound mismatch }}It compiles fine with javac if source is set to 1.7 and 1.8.It compiles fine with ecj if source is set 1.7 but it fails if source is set to 1.8 with:----------1. ERROR in /ssd/workspace/Sample/src/com/test/Test.java (at line 12)	test(i); // Bound mismatch	^^^^Bound mismatch: The generic method test(S) of type Test is not applicable for the arguments (I<T>). The inferred type I<T> is not a valid substitute for the bounded parameter <S extends I<T>>----------1 problem (1 error)"
489674,3/15/2016 13:32,register.eclipse,"[1.8][null] mixed annotations not recognized by warning ""Unsafe @Nonnull interpretation..."" test case moved here from bug 461268"
489702,3/15/2016 19:26,alex.blewitt,Replace calls from new Integer to Integer.valueOf Creating wrappers around Integers especially for small numbers results in a wasteful object creation on the heap. Using Integer.valueOf() allows the internal flyweight cache to be used instead; similarly for other primitive wrapper types. Some optimisations can be replaced; for example new Integer().intValue() can be replaced with Integer.parseInt().
489797,3/16/2016 17:39,mateusz.matela,"[formatter] 'Indent empty lines' sometimes doesn't work with 'format edited lines' save action Enable 'Indent emtpy lines' in the formatter profile and the save actioin 'Format source code' -> 'Format edited lines'. Create a class like this:public class Example {	public void foo() {		if (true)			return;				return;	}}Save.Result: indentation is removed from the empty line.Using Ctrl+Shift+F the indentation is correct."
489869,3/17/2016 12:49,mistria,"Contribute Java project detection to importer framework JDT could contribute the mechanism to automatically detect and configure Java projects if those aren't already handled by more ""structuring"" import (Eclipse Maven Gradle...)"
489901,3/18/2016 1:58,noopur_gupta,[content assist] AbstractJavaCompletionProposal#getPatternMatchRule may cause SIOOBE The following statement in AbstractJavaCompletionProposal#getPatternMatchRule may cause SIOOBE when pattern's length is greater than string's length:string.substring(0 pattern.length());For example see bug 488363 bug 488737 bug 489833 bug 489277.To prevent the error message being shown in proposal text and to be still aware of the issues that cause SIOOBE we can catch the exception and log an error message.
489934,3/18/2016 9:17,noopur_gupta,[1.8][override method] Problems with overriding default interface methods 4.6 M6- In the org.eclipse.jface project create class:public class MyArrayContentProvider extends ArrayContentProvider {}Problems:1. Content Assist in the class body doesn't offer to override the default methods dispose() and inputChanged(..) from interface IContentProvider.2. Source > Override/Implement Methods... allows to override inputChanged(..) but the generated stub is wrong: @Override public void inputChanged(Viewer viewer Object oldInput Object newInput) { // TODO Auto-generated method stub ArrayContentProvider.super.inputChanged(viewer oldInput newInput); }When the overriding method is in a class the body needs to call super.inputChanged(..) without the qualifying class.
489962,3/18/2016 14:15,jarthana,"[content assist] default interface method not proposed for overriding package pp;public class CC extends S1 {	}class S1 implements I1 {}interface I1 extends I2 {}interface I2 {	default void dispose() {	}}In this example invoke content assist in CC.=> #dispose is not returned by ICodeAssist#codeComplete to CompletionProposalCollector.accept(CompletionProposal proposal).If I2 is a direct super interface of CC then #dispose is returned."
489963,3/18/2016 14:43,sxenos,Improve the performance of the Region class While profiling the code for the new index I discovered a hotspot in the Region class. It appears that creating large Regions is quite expensive and degenerates to O(n^2) time to to all the linear-time insertions.I've implemented an alternative version that uses a tree representation instead of a flat list which massively improves runtime performance (it drops from being a top hotspot to being too fast to measure with my sampling profiler). This makes sense because all the operations drop from O(n) time to O(d) where d is the path length n is the number of elements and d << n.Please see the attached patch.Note that this has a memory cost. The memory usage for small regions will increase by about a factor of 5 (estimated) but its growth rate for large regions should remain about the same. I don't believe the memory cost to be an issue since I don't generally see a lot of Region instances in memory at once. If we believe this to be a problem I know of a fix... but it would be complicated so we shouldn't go there unless we actually need it.
489978,3/18/2016 18:25,register.eclipse,"[1.8][null] NonNullByDefault doesn??t apply to type arguments of field via BinaryTypeBinding DESCRIPTION:############# project 1package test;import java.util.ArrayList;import org.eclipse.jdt.annotation.NonNullByDefault;@NonNullByDefaultpublic class BinaryClass {	public ArrayList<Object> list;	public BinaryClass(ArrayList<Object> list) {		this.list = list;	}}############# project 2 package test;import java.util.ArrayList;import org.eclipse.jdt.annotation.NonNullByDefault;@NonNullByDefaultpublic class Usage {	ArrayList<Object> f(BinaryClass b) {		return b.list;	}}An incorrect warning is reported:----------1. WARNING in test\Usage.java (at line 10)	return b.list;	 ^^^^^^Null type safety (type annotations): The expression of type '@NonNull ArrayList<Object>' needs unchecked conversion to conform to '@NonNull ArrayList<@NonNull Object>'----------ANALYSIS:Field handling is missing in NonNullDefaultAwareTypeAnnotationWalker because it wasn??t needed pre java 8 (for the field itself it is done in BTB.scanFieldForNullAnnotation)PATCH:Adds it."
490010,3/19/2016 15:57,sxenos,Move the code for external annotation processing out of ClassFileReader Currently some of the code for applying external annotations lives inside ClassFileReader.However this is causing problems on the branch where I'm working on the new indexer since the indexer has its own implementation of IBinaryType and external annotations also need to be applied to it.The consequence is some code replication and the fact that every bugfix for external annotations creates a nasty merge on my branch.I'd like to extract this code out of ClassFileReader and move it to a separate location that will work on any implementation of IBinaryType. I'd suggest the decorator pattern for this.
490022,3/20/2016 4:26,jdt-ui-inbox,"Killed eclipse.jdt.ui-Gerrit after 37 hours By chance I noticed that the subject job (#652) had been running for ""1 day 13 hr""Looking at the history I could see the job normally takes around 45 minutes. There were three other jobs (of the same name) waiting in the queue -- all triggered by Gerrit changes apparently. So I killed the very long-running job. And then I re-configured the job so it would be forcefully cancelled if it runs over 2 hours. I did not try to look at log or otherwise investigate why it was taking so long. I will leave this open for JDT UI team to do with it what they want (such as ""investigate"" ""change 'abort job' value to longer/shorter"" or whatever. If no action needed just close as 'fixed'. Thanks P.S. All Hudson jobs should have the ""about if stuck"" checked with some value that is 2 or 4 times ""the usual time"" since something is always going wrong with Hudson (or the jobs themselves. or the infrastructure etc.)."
490070,3/21/2016 6:56,daniel_megert,[content assist][templates] content assist inside Javadoc contains templates from Java context 4.6 M6 but also in older versions.1. select some text in inside Javadoc2. Ctrl+Space==> templates like 'Button' appear
490102,3/21/2016 11:38,jarthana,[1.9] Test Failures after merge on BETA_JAVA9 branch
490337,3/23/2016 16:41,noopur_gupta,"Technically incorrect language in quick fix for inheriting multiple interface methods The language for the quick fix is technically incorrect in the following situation. Suppose we have the following:interface I {	void m();}interface J {	default void m() {	}}class A implements I J {}Here A must choose to either implement I.m() or override J.m(). However the two quick fix options state to override I.m() or override J.m(). Technically the first option should be to *implement* I.m() (the language for the J.m() option is correct)."
490343,3/23/2016 18:23,register.eclipse,"[1.8][null][external] AIOOBE with external annotations for Map.Entry.comparingByKey DESCRIPTION:- put an external @NonNull-annotation on the return type of java.util.Map.Entry.comparingByKey- reference the Map.Entry class somewhere. An ArrayIndexOutOfBoundsException is reported stack trace is:	at org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationProvider$TypeParametersAnnotationWalker.toTypeParameterBounds(ExternalAnnotationProvider.java:477)	at org.eclipse.jdt.internal.compiler.classfmt.ExternalAnnotationProvider$MethodAnnotationWalker.toTypeParameterBounds(ExternalAnnotationProvider.java:600)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createTypeVariables(BinaryTypeBinding.java:972)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createMethod(BinaryTypeBinding.java:776)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createMethods(BinaryTypeBinding.java:912)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.cachePartsFrom(BinaryTypeBinding.java:524)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:722)	??ANALYSIS:In ExternalAnnotationProvider.TypeParametersAnnotationWalker.TypeParametersAnnotationWalker(??) while scanning <K::Llibs/Comparable<-TK;>;V:Ljava/lang/Object;>()L1libs/Comparator<Llibs/Map$Entry<TK;TV;>;>;the case of nested < ;> is not handled while looking for the ; that terminates the bound.PATCH (via gerrit):Counts nested pairs < > so nested ; are ignored"
490532,3/28/2016 13:22,noopur_gupta,"Order of ""Source"" menu items inconsitent (main menu editor context menu) Testing Eclipse for Java Developers (Neon M6):In the Java Editor context menu > Source ""Generate hashCode() and equals()..."" is listed before ""Generate toString()"" while in the Eclipse main menu > Source it is the other way around. This is inconsistent. (FWIW either order is sensible.)"
490534,3/28/2016 13:38,noopur_gupta,"Order of ""Refactor"" menu items inconsitent (main menu editor context menu) - In the main menu ""Extract superclass"" comes before ""Extract interface"". In the context menu it is the other way around. (IMHO ""interface"" should IMHO come first; not only alphabetically but also because it is always applicable)- In the main menu ""Push Down"" comes before ""Pull Up"". In the context menu it is the other way around.FYI there may be other inconsistencies but these were the ones I spotted doing a quick test."
490988,4/4/2016 4:34,sasikanth.bharadwaj,"[compiler] Able to compile Interface.super construct in 1.7 project while using classes defined in 1.8 project IStructuredContentProvider.super.dispose(); compiles without any error in 1.7 project where as IStructuredContentProvider is defined in jfaces at 1.8 level.private class AvailableOrganizersProvider implements IStructuredContentProvider {		protected List<IBreakpointOrganizer> availableOrganziers = new ArrayList<IBreakpointOrganizer>();				public void addAvailable(IBreakpointOrganizer organizer) { availableOrganziers.add(organizer);			fSelectedOrganizersProvider.selectedOrganizers.remove(organizer);		}				@Override		public Object[] getElements(Object inputElement) {			return availableOrganziers.toArray();		}				@Override		public void dispose() {			IStructuredContentProvider.super.dispose();		}		@Override		public void inputChanged(Viewer viewer Object oldInput Object newInput) {		}	}"
491139,4/6/2016 5:26,sasikanth.bharadwaj,"Lambda that redefines a default method with generics Created attachment 260745sample projectHiIn the following example a lambda redefines default method of Foo in testLambdaRedefiningADefault().interface Foo<T> { default String bar(String s) { return (""default : "" + s); } String bar(T t);} public String testLambdaRedefiningADefault() { Foo<String> foo = (t) -> { return ""lambda : "" + t; }; return (((Foo) foo).bar(""String"")); } public static void main(String[] args) { System.out.println(new Test().testLambdaRedefiningADefault()); }The output with ecj-N20160405-2000.jar is:default : StringWhereas with javac it is:lambda : StringNot sure what the right behavior is.I've attached a sample project to reproduce this case.In this project I've added 2 other cases where the lambda is replaced by anonymous classes.Foo<String> foo = new Foo<String>() { @Override public String bar(String t) { return ""lambda : "" + t; }};Foo<String> foo = new Foo() { @Override public String bar(Object t) { return ""lambda : "" + t; }};For 1 and 2 the behavior between javac and ecj is the same they output ""lambda : String"" and ""default : String"" respectively."
491151,4/6/2016 8:53,manpalat,"NPE when searching for references in project Eclipse I20160329-0800jdk-8u66-fcs-bin-b08-windows-x64-03_aug_2015package p;import java.util.ArrayList;public class C {	ArrayList<String> a;}Select 'ArrayList' right-click > References > Project results in NPE:java.lang.NullPointerException	at org.eclipse.jdt.internal.core.search.JavaSearchScope.getPath(JavaSearchScope.java:474)	at org.eclipse.jdt.internal.core.search.JavaSearchScope.getPath(JavaSearchScope.java:490)	at org.eclipse.jdt.internal.core.search.JavaSearchScope.getPath(JavaSearchScope.java:490)	at org.eclipse.jdt.internal.core.search.JavaSearchScope.encloses(JavaSearchScope.java:463)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.encloses(MatchLocator.java:779)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2327)	at org.eclipse.jdt.internal.core.search.matching.MemberDeclarationVisitor.visit(MemberDeclarationVisitor.java:218)	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.traverse(LambdaExpression.java:698)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse(MessageSend.java:1056)	at org.eclipse.jdt.internal.compiler.ast.Block.traverse(Block.java:139)	at org.eclipse.jdt.internal.compiler.ast.TryStatement.traverse(TryStatement.java:1117)	at org.eclipse.jdt.internal.compiler.ast.Block.traverse(Block.java:139)	at org.eclipse.jdt.internal.compiler.ast.IfStatement.traverse(IfStatement.java:285)	at org.eclipse.jdt.internal.compiler.ast.Block.traverse(Block.java:139)	at org.eclipse.jdt.internal.compiler.ast.TryStatement.traverse(TryStatement.java:1117)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:354)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2401)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2973)	at org.eclipse.jdt.internal.core.search.matching.MemberDeclarationVisitor.visit(MemberDeclarationVisitor.java:311)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1374)	at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse(QualifiedAllocationExpression.java:625)	at org.eclipse.jdt.internal.compiler.ast.FieldDeclaration.traverse(FieldDeclaration.java:341)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2710)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2960)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2670)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1852)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1261)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1302)	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1434)	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:122)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:236)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:583)	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:596)	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:148)	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:92)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)"
491299,4/8/2016 2:32,akurtakov,Classpath tab for Java application has wrong colors Non editable entries are white text on black background on Linux with Gtk default theme Adwaita (due to usage of COLOR_INFO_* constants which are ment for popups) which is way too intrusive in the UI.Additionally when using Eclipse dark theme having same colors makes it undistinguishable from the rest of the UI using dark pallette.As the bug is really similar to bug 488825 I'm taking the same approach and will make the respective class not implement IColorProvider.
491301,4/8/2016 4:22,akurtakov,Java/Build Path/Classpath Variable pref page has wrong colors Non editable entries are white text on black background on Linux with Gtk default theme Adwaita (due to usage of COLOR_INFO_* constants which are ment for popups) which is way too intrusive in the UI.Additionally when using Eclipse dark theme having same colors makes it undistinguishable from the rest of the UI using dark pallette.As the bug is really similar to bug 488825 I'm taking the same approach and will make the respective class not implement IColorProvider.
491302,4/8/2016 4:50,akurtakov,Java/Debug/Logical Structure pref page has wrong colors Non editable entries are white text on black background on Linux with Gtk default theme Adwaita (due to usage of COLOR_INFO_* constants which are ment for popups) which is way too intrusive in the UI.Additionally when using Eclipse dark theme having same colors makes it undistinguishable from the rest of the UI using dark pallette.As the bug is really similar to bug 488825 I'm taking the same approach and will make the respective class not implement IColorProvider.
491311,4/8/2016 5:23,loskutov,"NPE in JDIDebugTarget.supportsBreakpoint eclipse-SDK-N20160407-2000-win32-x86_64NPE in JDIDebugTarget.supportsBreakpoint.Sorry no steps.!ENTRY org.eclipse.debug.ui 4 2 2016-04-08 11:02:14.794!MESSAGE Problems occurred when invoking code from plug-in: ""org.eclipse.debug.ui"".!STACK 0java.lang.NullPointerException	at org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.supportsBreakpoint(JDIDebugTarget.java:1403)	at org.eclipse.debug.internal.ui.model.elements.BreakpointManagerContentProvider.supportsBreakpoint(BreakpointManagerContentProvider.java:810)	at org.eclipse.debug.internal.ui.model.elements.BreakpointManagerContentProvider.supportsBreakpoint(BreakpointManagerContentProvider.java:796)	at org.eclipse.debug.internal.ui.model.elements.BreakpointManagerContentProvider$InputData.setFilterSelection(BreakpointManagerContentProvider.java:345)	at org.eclipse.debug.internal.ui.model.elements.BreakpointManagerContentProvider$InputData.debugContextChanged(BreakpointManagerContentProvider.java:328)	at org.eclipse.debug.internal.ui.model.elements.BreakpointManagerContentProvider$InputData.access$1(BreakpointManagerContentProvider.java:315)	at org.eclipse.debug.internal.ui.model.elements.BreakpointManagerContentProvider$InputData$3.debugContextChanged(BreakpointManagerContentProvider.java:130)	at org.eclipse.debug.internal.ui.contexts.DebugWindowContextService$2.run(DebugWindowContextService.java:231)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.debug.internal.ui.contexts.DebugWindowContextService.notify(DebugWindowContextService.java:228)	at org.eclipse.debug.internal.ui.contexts.DebugWindowContextService.notify(DebugWindowContextService.java:204)	at org.eclipse.debug.internal.ui.contexts.DebugWindowContextService.debugContextChanged(DebugWindowContextService.java:439)	at org.eclipse.debug.ui.contexts.AbstractDebugContextProvider$1.run(AbstractDebugContextProvider.java:82)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.debug.ui.contexts.AbstractDebugContextProvider.fire(AbstractDebugContextProvider.java:79)	at org.eclipse.debug.internal.ui.views.launch.LaunchView$ContextProviderProxy.debugContextChanged(LaunchView.java:519)	at org.eclipse.debug.ui.contexts.AbstractDebugContextProvider$1.run(AbstractDebugContextProvider.java:82)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.debug.ui.contexts.AbstractDebugContextProvider.fire(AbstractDebugContextProvider.java:79)	at org.eclipse.debug.internal.ui.views.launch.LaunchView$TreeViewerContextProvider.possibleChange(LaunchView.java:405)	at org.eclipse.debug.internal.ui.views.launch.LaunchView$TreeViewerContextProvider$Visitor.visit(LaunchView.java:327)	at org.eclipse.debug.internal.ui.viewers.model.provisional.ModelDelta.doAccept(ModelDelta.java:401)	at org.eclipse.debug.internal.ui.viewers.model.provisional.ModelDelta.doAccept(ModelDelta.java:404)	at org.eclipse.debug.internal.ui.viewers.model.provisional.ModelDelta.accept(ModelDelta.java:397)	at org.eclipse.debug.internal.ui.views.launch.LaunchView$TreeViewerContextProvider.modelChanged(LaunchView.java:435)	at org.eclipse.debug.internal.ui.viewers.model.TreeModelContentProvider.doModelChanged(TreeModelContentProvider.java:431)	at org.eclipse.debug.internal.ui.viewers.model.TreeModelContentProvider.access$0(TreeModelContentProvider.java:418)	at org.eclipse.debug.internal.ui.viewers.model.TreeModelContentProvider$2.run(TreeModelContentProvider.java:406)	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:182)	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4208)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3824)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1119)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1020)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:687)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:497)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)"
491354,4/8/2016 15:51,markus.kell.r,"[compiler] Wrong ""indirectly referenced"" error for member type of raw binary type This fix for bug 490724 caused a new compile error in org.eclipse.equinox.http.registry.internal.HttpServiceTracker:""The type org.osgi.util.tracker.ServiceTracker.Tracked cannot be resolved. It is indirectly referenced from required .class files"".Relevant structure of class ServiceTracker:public class ServiceTracker<S T> .. {	private Tracked tracked() { .. }	private class Tracked extends AbstractTracked<ServiceReference<S> T ServiceEvent> { .. }}When I set a breakpoint in BinaryTypeBinding#resolveTypesFor(MethodBinding) with condition: ""tracked"".equals(new String(method.selector)) then the returnType of the method used to be a RawTypeBinding ""ServiceTracker#RAW"". This was wrong since the return type of the method is ""Tracked"" not ""ServiceTracker"". But this apparently obscured the present bug.After the fix for bug 490724 the return type is the UnresolvedReferenceBinding ""org.osgi.util.tracker.ServiceTracker.Tracked"". That looks better but this type cannot be resolved.If you dive into the resolveType(..) method you can see that LookupEnvironment#askForType(char[][]) eventually calls NameLookup#seekTypes(..) which contains matchName= matchName.replace('.' '$');Because of that the NameEnvironmentAnswer#binaryType actually contains a correctly resolved type but at the end of #askForType(char[][]) return getCachedType(compoundName);only finds the variant with the '.'.The data structures are quite convoluted but I think the right point to fix this is in UnresolvedReferenceBinding#resolve(LookupEnvironment boolean) where the lookup should be repeated with the '$' variant.Original stacktrace for reference:org.eclipse.jdt.internal.compiler.problem.ProblemReporter.isClassPathCorrect(ProblemReporter.java:4713)	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:105)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:212)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveTypesFor(BinaryTypeBinding.java:1499)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.methods(BinaryTypeBinding.java:1453)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.methods(ParameterizedTypeBinding.java:968)	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.unResolvedMethods(ReferenceBinding.java:1857)	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.computeInheritedMethods(MethodVerifier.java:512)	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.computeInheritedMethods(MethodVerifier.java:485)	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.verify(MethodVerifier.java:970)	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier15.verify(MethodVerifier15.java:1008)	at org.eclipse.jdt.internal.compiler.lookup.MethodVerifier.verify(MethodVerifier.java:980)	at org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.verifyMethods(SourceTypeBinding.java:2592)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.verifyMethods(CompilationUnitScope.java:824)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1020)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:197)	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:194)	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:259)	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:579)	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1085)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:171)..."
491461,4/11/2016 13:39,sxenos,Merge the latest JDT core into the newindex branch
491504,4/12/2016 8:37,manpalat,ASTParser.createASTs() throws IllegalArgumentException Created attachment 260890CrashStacktrace:org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:604)org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:334)org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2514)org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1693)org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2754)org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:635)org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:195)org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2961)org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1370)org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1033)org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:639)org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:993)ru.scanner.Main.main(Main.java:119)Source which occur crash is attached
491551,4/12/2016 18:21,noopur_gupta,"[1.8] Convert to lambda expression as multi-fix Created attachment 260905Sample projectUsing Eclipse 4.6-I20160412-0800When trying to convert an anonymous class to a lambda expression a quick assist is offered. The UI also offers to press ""Ctrl+Enter"" to fix all problems in the same category. If this is pressed it doesn't do anything.I attached a sample project to show this behavior:public class Main { static void runRunnable(Runnable runable) { } public static void main(String[] args Set<String> set) { runRunnable(new Runnable() { @Override public void run() { } }); runRunnable(new Runnable() { @Override public void run() { } }); }}1. Import the project2. Place the cursor on the first 'new Runnable'3. Press Ctrl+1 to invoke quick assist4. Press the down arrow key to select ""Convert to lambda expression""5. Press Ctrl+Enter. Nothing happens.I would expect both anonymous classes to be converted to lambda expression."
491558,4/13/2016 0:07,sxenos,Merge results between the new and old indices The new index from bug 481796 isn't yet indexing source files.To ensure we still get the full result sets from uncompiled files we need to merge the results from the new and old indices.
491576,4/13/2016 5:27,noopur_gupta,Info severity not shown for 'No strictly compatible JRE...' option eclipse-SDK-N20160412-2000-win32-x86_64Info severity not shown for 'No strictly compatible JRE...' option.
491656,4/14/2016 4:25,manpalat,[search] doesn't find reference to binary method with parameterized argument type in nested class Broken since 4.5 worked in 4.4.2In a 1.7 project configured with a 1.7 JDK open methodjava.util.LinkedHashMap.Entry#addBefore(Entry<K V>) and try to search for references.=> No matches found although there is a reference in recordAccess a few lines down.Search still works fine for java.util.LinkedHashMap.Entry#remove()In 1.8 LinkedHashMap has been restructured but there a similar examples:- references to java.util.LinkedHashMap.LinkedEntrySet#spliterator() are found- references to java.util.LinkedHashMap.LinkedEntrySet#forEach(Consumer<? super Entry<K V>>) are not found=> Looks like the problem only happens for binary methods that have a parameterized argument type and that are declared in a nested class.
491731,4/14/2016 15:31,mateusz.matela,[Formatter] New settings for parentheses positions - UI Add a formatter configuration page for new features added in bug 370540.
491756,4/15/2016 2:32,jan.rosczak,[Project Explorer] ExtensionState is not always applied - Open Project explorer in Java perspective having a project with referenced libraries.- Click on view menu > Customize view > Content tab > Uncheck Java Elements > OK.- Now go back and check Java Elements.=> The referenced libraries are listed again but are not groupedApplies also to the package presentation.
491988,4/19/2016 7:31,eclipse,Add F1 help documentation for bug 339292 Add documentation for the new options in:/org.eclipse.jdt.doc.user/reference/ref-wizard-annotation.htm present in the platform.common repo:http://git.eclipse.org/c/platform/eclipse.platform.common.git/Add a link to the online Javadocs to the help page instead of the tooltips.
492106,4/20/2016 11:38,markus.kell.r,[1.8][compiler] ClassFormatException in Disassembler for invokespecial/invokestatic referring to interface method Compile this valid 1.8 class:import java.util.Comparator;import java.util.Iterator;public abstract class Thing implements Iterator<Object> { void breaking() { Iterator.super.remove(); Comparator.naturalOrder(); }}The disassembler produces:... void breaking(); 0 aload_0 [this] Class Format Exception Line numbers:...Expected:... void breaking(); 0 aload_0 [this] 1 invokespecial java.util.Iterator.remove() : void [2] 4 invokestatic java.util.Comparator.naturalOrder() : java.util.Comparator [3] 7 pop 8 return Line numbers:...Fix is ready.
492207,4/21/2016 15:55,sxenos,"Incorrect progress monitor usage in PatternSearchJob.execute The progress reporting error detection tool from bug 482062 picked up the following problem:!MESSAGE beginTask was called on this instance more than once!STACK 0java.lang.Throwable	at org.eclipse.core.runtime.SubMonitor.logProblem(SubMonitor.java:1000)	at org.eclipse.core.runtime.SubMonitor.beginTask(SubMonitor.java:623)	at org.eclipse.jdt.internal.core.search.PatternSearchJob.execute(PatternSearchJob.java:63)	at org.eclipse.jdt.internal.core.search.processing.JobManager.performConcurrentJob(JobManager.java:265)	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchAllTypeNames(BasicSearchEngine.java:1816)	at org.eclipse.jdt.core.search.SearchEngine.searchAllTypeNames(SearchEngine.java:1030)	at org.eclipse.jdt.core.JavaCore.initializeAfterLoad(JavaCore.java:4270)	at org.eclipse.jdt.internal.ui.InitializeAfterLoadJob$RealJob.run(InitializeAfterLoadJob.java:36)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)"
492322,4/24/2016 8:15,register.eclipse,@Nullable method parameter gives erroneous 'Null type mismatch' error for null argument This situation arises where a @NonNullByDefault Base class declares a method with an @Nullable parameter of a generic inner type.If the subclass legally passes null to
492327,4/24/2016 14:55,register.eclipse,[1.8][compiler] regression: bogus name clash again on class implementing java.nio.file.Path From https://www.eclipse.org/forums/index.php?t=rview&goto=1730008 :----------------public class Test1 implements Path { @Override public WatchKey register(WatchService watcher Kind<?>... events) throws IOException { return null; } public WatchKey register(WatchService watcher java.nio.file.WatchEvent.Kind<?>[] events java.nio.file.WatchEvent.Modifier[] modifiers) throws IOException { }}-----------------This looks exactly like bug 423849. The JUnit from that bug still passes whereas batch-compiling the exact example from bug 423849 comment 2 triggers the bogus name clash error. What?The bogus error is triggered since the fix for bug 473713.
492439,4/26/2016 8:23,sarika.sinha,??Display?? view can not execute code if your current stack-element is inside a JSP Eclipse Mars 4.5.2To reproduce:1. Debug a project with a breakpoint set in a JSP on Tomcat.2. When the breakpoint is hit open the Display view from Window > Show View.3. Type some java code (e.g. System.out.println(??test??))4. Select the java code and click the ??Execute the selected text??-button in the upper right corner of the Display viewThe error-message is:Evaluation failed. Reason(s):Unable to evaluate the selected expression:To perform an evaluation an expression must be compiled in the context of a Java project??s build path. The current execution context is not associated with a Java project in the workspace.Same behavior in Eclipse Neon. In Eclipse Luna the code is executed and works as expected.
492450,4/26/2016 9:19,markus.kell.r,"AIOOBE in CodeStream.generateSyntheticBodyForMethodAccess for PDE's DocumentObject.java 4.6.0.I20160425-1300Compile error in /org.eclipse.pde.core/text/org/eclipse/pde/internal/core/text/DocumentObject.java see exception below.The problem was introduced with http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=65386f283034d2adbed1c5efa5bf0164d0891bf0 for bug 467776.Standalone snippet:-----------------------package p;import java.util.ArrayList;interface IDocumentElementNode {	public ArrayList<?> getChildNodesList();}abstract class DocumentElementNode implements IDocumentElementNode {	@Override	public ArrayList<IDocumentElementNode> getChildNodesList() {		return null;	}}interface IDocumentObject extends IDocumentElementNode {	public ArrayList<?> getChildNodesList(Class<?>[] classes boolean match);}public abstract class DocumentObject extends DocumentElementNode implements IDocumentObject {	@Override	public ArrayList<IDocumentElementNode> getChildNodesList(Class<?>[] classes boolean match) {		return null;	}}------------------------------------------Error in JDT Core during AST creation:java.lang.ArrayIndexOutOfBoundsException: 0	at org.eclipse.jdt.internal.compiler.codegen.CodeStream.generateSyntheticBodyForMethodAccess(CodeStream.java:2934)	at org.eclipse.jdt.internal.compiler.ClassFile.addSyntheticMethodAccessMethod(ClassFile.java:1253)	at org.eclipse.jdt.internal.compiler.ClassFile.addSpecialMethods(ClassFile.java:920)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:572)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:637)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:371)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1224)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1190)	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:551)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:543)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:486)	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:476)	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:128)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:173)	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:158)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)"
492488,4/26/2016 16:07,sxenos,[newindex] Add change notifications to the new index We need to do the following:1. Add a listener interface to Nd that can be used to notify the model when indexing is finished.2. Propagate those change events through the java model.3. Suppress events that are fired from the java model directly in response to resource change events if those same events would end up being fired later after indexing occurs.The purpose to delaying the events is to encourage clients of the Java model to refresh after indexing (when they'll get an efficient cached version of the data) rather than before indexing (when they'll read a slower version directly from the .jar or .class file).
492503,4/26/2016 20:53,sxenos,Fix progress monitoring in IndexBasedHierarchyBuilder A number of methods in IndexBasedHierarchyBuilder are incorrectly reusing their progress monitor.
492735,4/29/2016 12:05,mateusz.matela,"[formatter] Excessive wrapping in a complex expression There seems to be a bug in the computation of whether an outer expression needs to be wrapped.Steps to reproduce:1. Select the ""Eclipse [built-in]"" formatter settings2. Edit these settings and a) change the line wrapping policy for ""Assignments"" to ""Wrap where necessary"" b) change the ""Maximum line width"" to 60 and c) ""Use spaces to indent wrapped lines""[Points b and c are only needed so that Bugzilla doesn't break the examples below.]3. Create a class with the following content:public class FormatterIssue { String[] S = new String[] { foo(""first line xxxxxxxxxx"" ""y"" ""z"") foo(""second line xxxxxxxxxxxxxxxxxxx"" ""b"" ""c"") }; static String foo(String a String b String c) { return null; }}4. Invoke the formatter. There should be no changes.5. Add another X in the first line and invoke the formatter again. As expected there are no changes so the (relevant part) of the code looks like this: String[] S = new String[] { foo(""first line xxxxxxxxxxX"" ""y"" ""z"") foo(""second line xxxxxxxxxxxxxxxxxxx"" ""b"" ""c"")6A. Remove the blank line before ""first line"" and invoke the formatter again. There should be no formatting change. However the formatting is broken and looks like this: String[] S = new String[] { foo(""first line xxxxxxxxxxX"" ""y"" ""z"") foo(""second line xxxxxxxxxxxxxxxxxxx"" ""b"" ""c"")6B. Alternatively add a new line with a line comment directly above ""first line"" and invoke the formatter. Again there should be no change but the formatting is broken in the same way. (Note: 6B only occurs on Windows it doesn't occur on Mac.) String[] S = new String[] { // comment foo(""first line xxxxxxxxxxX"" ""y"" ""z"") foo(""second line xxxxxxxxxxxxxxxxxxx"" ""b"" ""c"")Further observations:* The formatting would be correct in 6A and 6B if the ""first line"" was one character shorter. So this problem only seems to occur with first lines which have a lenght >= max length - 8* If the first line is long enough i.e. so long that it is wrapped like the second line removing the blank line (6A) or adding the comment (6B) also doesn't cause any issues. So there is only a narrow window of cases that reproduce this issue.Nevertheless this is quite annoying - in particular the difference between PC and Mac - so please fix this issue."
492752,4/29/2016 18:05,noopur_gupta,"[introduce parameter] Introduce parameter does not work with enum constants The Introduce Parameter refactoring does not work when the object to be replaced is an enum constant. I can't see any reason why that should not be allowed.Steps to reproduce:1. Select a piece of code which is suitable to refactor to use parameters e.g.: public static Alert createAlert() { Alert alert = new Alert(AlertType.INFORMATION ""Message"" ButtonType.OK); alert.getDialogPane().getStylesheets().add(DefaultTheme.DEFAULT_CSS); alert.setTitle(""Title""); alert.setHeaderText(null); return alert; }2. Highlight the string ""Message"" and select Refactor -> Introduce Parameter. Result: string is refactored into a parameter as expected: public static Alert createAlert(String message) { Alert alert = new Alert(AlertType.INFORMATION message ButtonType.OK); alert.getDialogPane().getStylesheets().add(DefaultTheme.DEFAULT_CSS); alert.setTitle(""Title""); alert.setHeaderText(null); return alert; }3. Highlight AlertType.INFORMATION and select Refactor -> Introduce Parameter. Result: error message saying ""Cannot extract this name - try selecting the whole instance creation expression"". The error message does not make sense - there should be no reason why an enum constant should not be able to be refactored into a parameter e.g.: public static Alert createAlert(String message AlertType type) { Alert alert = new Alert(type message ButtonType.OK); alert.getDialogPane().getStylesheets().add(DefaultTheme.DEFAULT_CSS); alert.setTitle(""Title""); alert.setHeaderText(null); return alert; }"
492858,5/2/2016 19:25,manpalat,"[4.6M7] ant javac adapter fails with NoClassDefFoundError: org/eclipse/jdt/internal/core/INameEnvironmentWithProgress Created attachment 261417Repro for ant ecj regressionSummary: Using ecj-4.6M7.jar the ant javac adapter appears to be broken.This only reproduces in 4.6M7; 4.6M6 seems to be OK. So I think it's a regression in M7.Steps to Reproduce:1) unzip ecj-ant-bug.zip2) cd ecj-ant-bug3) antExpected Result:ant build completes successfullyActual Result:ant build fails with the following error:java.lang.NoClassDefFoundError: org/eclipse/jdt/internal/core/INameEnvironmentWithProgress=== ERROR BEGIN ===ecj-ant-bug/build.xml:6: java.lang.reflect.InvocationTargetException	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:497)	at org.eclipse.jdt.core.JDTCompilerAdapter.execute(JDTCompilerAdapter.java:80)	at org.apache.tools.ant.taskdefs.Javac.compile(Javac.java:1160)	at org.apache.tools.ant.taskdefs.Javac.execute(Javac.java:936)	at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:293)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:497)	at org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)	at org.apache.tools.ant.Task.perform(Task.java:348)	at org.apache.tools.ant.Target.execute(Target.java:435)	at org.apache.tools.ant.Target.performTasks(Target.java:456)	at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1405)	at org.apache.tools.ant.Project.executeTarget(Project.java:1376)	at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)	at org.apache.tools.ant.Project.executeTargets(Project.java:1260)	at org.apache.tools.ant.Main.runBuild(Main.java:853)	at org.apache.tools.ant.Main.startAnt(Main.java:235)	at org.apache.tools.ant.launch.Launcher.run(Launcher.java:285)	at org.apache.tools.ant.launch.Launcher.main(Launcher.java:112)Caused by: java.lang.NoClassDefFoundError: org/eclipse/jdt/internal/core/INameEnvironmentWithProgress	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createPackage(LookupEnvironment.java:783)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.buildTypeBindings(CompilationUnitScope.java:110)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.buildTypeBindings(LookupEnvironment.java:212)	at org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:820)	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:385)	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:435)	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:417)	at org.eclipse.jdt.internal.compiler.batch.Main.performCompilation(Main.java:4180)	at org.eclipse.jdt.internal.compiler.batch.Main.compile(Main.java:1712)	... 24 moreCaused by: java.lang.ClassNotFoundException: org.eclipse.jdt.internal.core.INameEnvironmentWithProgress	at org.apache.tools.ant.AntClassLoader.findClassInComponents(AntClassLoader.java:1388)	at org.apache.tools.ant.AntClassLoader.findClass(AntClassLoader.java:1337)	at org.apache.tools.ant.AntClassLoader.loadClass(AntClassLoader.java:1089)	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)	... 33 more=== ERROR END ===Note: I included a separate `ant good` target you can use to confirm 4.6M6 is OK. (The underlying AOSP code does have some warnings you can ignore them.)"
492941,5/3/2016 23:11,sxenos,Add error detection to new index Error detection was always a planned feature for the new index. The index should contain CRCs which are capable of detecting disk corruption and aborted writes.
493040,5/4/2016 23:03,sarika.sinha,Multi Select search in Hierarchy behaves inconsistently for References and Declarations Forking out the details from Bug 477340 comment#32Multi select search in Hierarchy is enabled for Declarations and disabled for References.
493054,5/5/2016 5:09,manpalat,ASTParser.createASTs() performance slowdown in 4.5.2 Created attachment 261480Sample project showcasing a performance regression in createASTsSince Eclipse Mars 4.5.2 we see a performance regression when calling ASTParser.createASTs().I used a k9mail as a sample app which has 264 compilation units (android application compiled with java 7).If I use the JDT released with Eclipse Luna 4.4.2 createASTs() runs in 2 seconds. With the JDT released with Eclipse Mars 4.5.2 the same code runs in 100 seconds.All that the project does is to build the AST compilation units nothing else.The sample project that I have does something odd it provides the compiled classes for the source files to the AST parser. This is due to the nature of android projects configured through gradle where some classes are generated by the android toolchain and by laziness I opted for including the classes in to the classpath. This means that the project has both the sources and compiled code for the compilation units.While building a small sample project that demonstrates the bug I noticed that if the compiled classes (the ones that match the sources) are stored in a jar vs a folder. There's no longer a regression in performance.Can it be that loading classes from a folder is somehow way slower than loading from a jar?
493062,5/5/2016 7:11,noopur_gupta,Update JDT Tips & Tricks for Neon (4.6) Update T&T document with relevant items from Neon (4.6) N&N documents.
493129,5/6/2016 6:15,noopur_gupta,Update JDT F1 help docs for Neon (4.6) Update JDT F1 help docs for Neon (4.6).
493222,5/9/2016 6:21,manpalat,Help is broken: HTTP 500 internal server error It fails to load the index.jsp file withProblem accessing /help/index.jsp. Reason: java.lang.AbstractMethodError: org.apache.jasper.compiler.JDTJavaCompiler$1.findType([C[[CZ)Lorg/eclipse/jdt/internal/compiler/env/NameEnvironmentAnswer;
493336,5/10/2016 9:49,manpalat,"ASTParser.createASTs() throws IllegalArgumentException Created attachment 261598Sourcejava.lang.IllegalArgumentException	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:2845)	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3218)	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:438)	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2733)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1259)	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:423)	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:188)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1374)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1033)	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:639)	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:993)	at ru.scanner.Main.main(Main.java:118)JDT Core is just downloaded from masterAlso I cannot reproduce this issue from Eclipse exception occurs only when running jar from console (java -jar myprog.jar)"
494487,5/24/2016 16:25,sasikanth.bharadwaj,Another ArrayIndexOutOfBoundsException in ClassFile.generateBootstrapMethods (In reply to Janusz Chorko from bug 465330 comment #5)> Created attachment 261987 [details]> File reproducing bug> > I can still reproduce this bug using ecj 4.5.1 and 4.5.2 (and aspectj> 1.8.7-1.8.9 compilers):> > java -jar ecj-4.5.2.jar -1.8 -encoding UTF-8 -source 1.8 -target 1.8> Bug465330.java> > ----------> 1. ERROR in (...)\Bug465330.java (at line 0)> package com.example;> ^> Internal compiler error: java.lang.ArrayIndexOutOfBoundsException: 3000 at> org.eclipse.jdt.internal.compiler.ClassFile.generateBootstrapMethods(ClassFile.java:3034)> > ----------> > It seems that in generateBootstrapMethods resizeContents is called before> the loop making sure contents will fit 10 bytes per bootstrap. Then inside> the loop for serializable lambdas more memory is used (and while it fits> content is not resized) leaving less than required 10 bytes memory for> non-serializable lambda in some cases.Still happens in HEAD as of Neon release candidates.
494681,5/26/2016 14:25,daniel_megert,Add Packages dialog context help cannot be found Created attachment 262039Package selection dialog with help pane expandedOn the Java > Appearance > Type Filters preference page click Add Packages and then the '?' icon. This opens the help pane with an error message (see screenshot): The context help for this user interface element could not be found.This happens with the Neon RC2 contribution.
494682,5/26/2016 14:30,noopur_gupta,"Misleading context help for Type Filter dialog Created attachment 262040Type Filter dialog with context helpThe attached screenshot explains this best:While the ""Type Filter"" dialog was opened through the Java > Appearance > Type Filters preference page it's context help is written as if it applies only to the Organize Imports preference page."
494734,5/27/2016 6:25,sarika.sinha,[Documentation] Update Debug F1 Documentation Update Documentation for new Preference entries created via Bug 5188 and Bug 487554
494831,5/28/2016 15:48,mateusz.matela,"Formatter ignores whitespace rules for diamond operator As of 4.5.2 formatter no longer respects ""before opening angle bracket"" whitespace setting for generic type parameter references.For example in 4.5.1 the formatter would produce: List <String> list = new ArrayList <>();with this setting enabled as expected. As of 4.5.2 this happens: List <String> list = new ArrayList<>();while this still works as expected: List <String> list = new ArrayList <String>();I have verified that this bug was introduced in 4.5.1 -> 4.5.2 by checking vanilla Eclipse installations of 4.5.1 and 4.5.2.Should be easy to repro: just download latest Mars version (4.5.2) set the formatter to add whitespace before opening type parameter bracket and try running it on code using the diamond operator."
495138,6/1/2016 7:34,manpalat,"[1.9] NPE while creating a module-info.java file Created attachment 262156Steps to reproduce the issuejava.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.buildTypeBindings(CompilationUnitScope.java:134)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.buildTypeBindings(LookupEnvironment.java:251)	at org.eclipse.jdt.internal.compiler.Compiler.internalBeginToCompile(Compiler.java:820)	at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:385)	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:431)	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:417).."
495179,6/1/2016 11:00,manpalat,"[1.9] [compiler] error - the declared package does not match the expected package Created attachment 262165Project attached to reproduce the errorFor the module-info file the error The declared package """" does not match the expected package crops up. This error is not applicable here since this is a module-info.java file"
495424,6/3/2016 13:21,noopur_gupta,"Organize imports no longer fixes problems caused by 'moved' types Created attachment 262232project.zip with sample codeA common use of the 'Organize Imports' action (at least for me) is to update imports against a newer version of some library if that library has moved some types to different packages.To reproduced this bug. I'll attach a sample project. In that project there's a class: 'MyApp'. Open it and press CTRL-SHIFT-O to invoke organize imports.In Eclipse 4.5 doing this would have fixed the broken import.In Eclipse 4.6 RC it does nothing.In 4.6 to make the organize import work in this example. I have to manually delete the broken import(s) before invoking it. This is rather annoying as it means I have to do a lot more manual steps to fix a problem that I could fix with just a a single keyboard shortcut in Eclipse 4.5.For easy reference to whoever reads this bug-report. I'll paste the sample code below as well--- MyApp.java ----package my.fancy.app;import my.fancy.lib.FancyUtils;public class MyApp {	public static void main(String[] args) {		new FancyUtils().hello();	}	}--- FancyUtils.javapackage my.fancy.lib.utils;public class FancyUtils {	public void hello() {	}}---PS: This bug sounds similar to https://bugs.eclipse.org/bugs/show_bug.cgi?id=409142So it could be a duplicate except... this one involves regular imports (i.e non-static). So I'm not sure its a duplicate so decided to raise a new bug-report with an specific example."
495500,6/5/2016 19:11,jarthana,[9][compiler][batch][options] ecj batch compiler doesn't support -source 9 and -target 9 The ecj batch compiler doesn't support -source 9 and -target 9.Support for -1.9 and -9 (and the strange -9.0) has been added with http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=71b0d0b351555ce3f978ec9a79e82f3287df53fb but the -source and -target flags were not updated.
495501,6/5/2016 20:07,markus.kell.r,[BETA_JAVA9] fix default compiler compliance and Javadoc location Bug 463689 missed half of the changes that were correctly made when support for JavaSE-1.8 was added ( http://git.eclipse.org/c/jdt/eclipse.jdt.debug.git/commit/?id=b6a6f65aac73b1facba9081b3fbf4a158fce7954 ).
495557,6/6/2016 14:38,sxenos,[newindex] Record stats about index usage The new JDT index (bug 481796) makes use of a lot of disk space. In some tests of larger workspaces the database can grow to almost a gigabyte. In order to optimize disk usage we first need to collect data about where that disk usage is going.I propose we add a new section to the database header which records allocation stats. All calls to malloc/free will take an extra argument indicating what malloc pool they will be allocating from. The malloc pools will be integer identifiers used to classify memory allocations. Each node type will be given a unique malloc pool ID and each caller of malloc within the framework will also be given a unique pool ID. The header will record total number of allocations for each pool and the total amount of memory used for those allocations.A new tracing option will print out statistics about these allocations.
495565,6/6/2016 17:03,jdt-ui-inbox,"Java editor clips bottom of letters In the attached screenshot the letters ""g"" has its bottom cut off.See the selected line and the line below it for examples.Version: Neon Milestone 7 (4.6.0M7) plus current updates."
495635,6/7/2016 17:31,register.eclipse,"[null] NPE in TypeVariableBinding.evaluateNullAnnotations What steps will reproduce the problem?1. Press F3 on something to navigate to it's declaration.2. 3. -- Error Details --Date: Tue Jun 07 15:22:49 MDT 2016Message: Internal ErrorSeverity: ErrorProduct: Eclipse 4.6.0.20160601-1520 (org.eclipse.epp.package.java.product)Plugin: org.eclipse.jdt.uiSession Data:eclipse.buildId=4.6.0.I20160525-2000java.version=1.8.0_91java.vendor=Oracle CorporationBootLoader constants: OS=linux ARCH=x86_64 WS=gtk NL=en_CAFramework arguments: -product org.eclipse.epp.package.java.productCommand-line arguments: -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.productThis is a continuation of log file /run/media/hubick/chwork/eclipse_workspace/.metadata/.bak_0.logCreated Time: 2016-06-07 15:16:15.771Exception Stack Trace:java.lang.reflect.InvocationTargetException	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:398)	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:481)	at org.eclipse.ui.internal.progress.ProgressMonitorJobsDialog.run(ProgressMonitorJobsDialog.java:242)	at org.eclipse.ui.internal.progress.ProgressManager$3.run(ProgressManager.java:895)	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)	at org.eclipse.ui.internal.progress.ProgressManager.busyCursorWhile(ProgressManager.java:930)	at org.eclipse.ui.internal.progress.ProgressManager.busyCursorWhile(ProgressManager.java:905)	at org.eclipse.jdt.internal.ui.actions.SelectionConverter.performForkedCodeResolve(SelectionConverter.java:265)	at org.eclipse.jdt.internal.ui.actions.SelectionConverter.codeResolveForked(SelectionConverter.java:170)	at org.eclipse.jdt.ui.actions.OpenAction.run(OpenAction.java:152)	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:275)	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:249)	at org.eclipse.jface.action.Action.runWithEvent(Action.java:473)	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:118)	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:90)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:54)	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:282)	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:264)	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:132)	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:152)	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:494)	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:488)	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:210)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:286)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:507)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:558)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:378)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$0(KeyBindingDispatcher.java:324)	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:86)	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1594)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1339)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1366)	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1349)	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1378)	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:764)	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:3458)	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:801)	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2000)	at org.eclipse.swt.widgets.Control.windowProc(Control.java:5820)	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5479)	at org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(Native Method)	at org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:9545)	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1275)	at org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method)	at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:2495)	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4130)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:1121)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1022)	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:150)	at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:687)	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:336)	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:604)	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:148)	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:138)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)Caused by: java.lang.NullPointerException	at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.evaluateNullAnnotations(TypeVariableBinding.java:932)	at org.eclipse.jdt.internal.compiler.lookup.CaptureBinding.initializeBounds(CaptureBinding.java:252)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.capture(ParameterizedTypeBinding.java:174)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.capture(ParameterizedTypeBinding.java:1)	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isCompatibleWith0(ReferenceBinding.java:1356)	at org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding.isCompatibleWith(ReferenceBinding.java:1282)	at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.internalBoundCheck(TypeVariableBinding.java:256)	at org.eclipse.jdt.internal.compiler.lookup.TypeVariableBinding.boundCheck(TypeVariableBinding.java:119)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.boundCheck(ParameterizedTypeBinding.java:117)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.checkBounds(ParameterizedSingleTypeReference.java:66)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.checkParameterizedTypeBounds(ClassScope.java:903)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.checkParameterizedTypes(CompilationUnitScope.java:240)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:313)	at org.eclipse.jdt.internal.codeassist.impl.Engine.accept(Engine.java:132)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:192)	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:214)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3228)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2940)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveLeafType(ParameterizedSingleTypeReference.java:187)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:165)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveType(ParameterizedSingleTypeReference.java:382)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:590)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType(TypeReference.java:564)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype(ClassScope.java:1320)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperInterfaces(ClassScope.java:1052)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:1114)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:324)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:312)	at org.eclipse.jdt.internal.codeassist.impl.Engine.accept(Engine.java:132)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:192)	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:214)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3228)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2940)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveLeafType(ParameterizedSingleTypeReference.java:187)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:165)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveType(ParameterizedSingleTypeReference.java:382)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:590)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType(TypeReference.java:564)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype(ClassScope.java:1320)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperInterfaces(ClassScope.java:1052)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:1114)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:324)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:312)	at org.eclipse.jdt.internal.codeassist.impl.Engine.accept(Engine.java:132)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:192)	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(PackageBinding.java:214)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3228)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:2940)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveLeafType(ParameterizedSingleTypeReference.java:187)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:165)	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveType(ParameterizedSingleTypeReference.java:382)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:590)	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveSuperType(TypeReference.java:564)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.findSupertype(ClassScope.java:1320)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectSuperInterfaces(ClassScope.java:1052)	at org.eclipse.jdt.internal.compiler.lookup.ClassScope.connectTypeHierarchy(ClassScope.java:1114)	at org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope.connectTypeHierarchy(CompilationUnitScope.java:324)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.completeTypeBindings(LookupEnvironment.java:312)	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:973)	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:163)	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:377)	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:371)	at org.eclipse.jdt.internal.ui.actions.SelectionConverter.codeResolve(SelectionConverter.java:274)	at org.eclipse.jdt.internal.ui.actions.SelectionConverter$1CodeResolveRunnable.run(SelectionConverter.java:258)	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:119)"
495641,6/8/2016 0:46,sarika.sinha,Use pngs available in jdt.ui and jdt.doc plugins JDT Debug is using gifs for which corresponding png images are available in jdt.ui or jdt.doc plugins.Copy the png images to jdt.debug and use them instead of gif images.
495680,6/8/2016 8:02,noopur_gupta,"Improve ""Type name must not be qualified"" message in new Java class dialog In my training sessions with people new to the Eclipse IDE I frequently see people typing the .java extension. The error message ""Type name must not be qualified"" seems not to help them. I suggest to improve this for them via one of the following alternatives:1.) Allow that .java is specified and at a warning ""Specifying the .java file extension is not necessary""2.) Or change the ""Type name must not be qualified"" message to ""The file extension %1 in the Name field must not be specified"" and to repalce %1 with the specified file extension."
495818,6/9/2016 12:51,noopur_gupta,[1.9][content assist] module references The jdt.ui part of bug 495801
495967,6/13/2016 4:36,sasikanth.bharadwaj,"[1.9][codegen] AIOOBE when generating code for module-info.java For large module-info files AIOOBE occurs while generating code. Reason is that the contents array is not resized when needed. Here's the stack trace.java.lang.ArrayIndexOutOfBoundsException: 400	at org.eclipse.jdt.internal.compiler.ClassFile.generateModuleAttribute(ClassFile.java:2683)	at org.eclipse.jdt.internal.compiler.ClassFile.addAttributes(ClassFile.java:361)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:580)	at org.eclipse.jdt.internal.compiler.ast.ModuleDeclaration.generateCode(ModuleDeclaration.java:67)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:638)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:398)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1036)	at org.eclipse.jdt.internal.compiler.Compiler.resolve(Compiler.java:1075)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:205)	at org.eclipse.jdt.internal.core.CompilationUnitProblemFinder.process(CompilationUnitProblemFinder.java:271)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:191)	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:90)	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:724)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:790)	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1254)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:128)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:110)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:90)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:87)	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:154)	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:89)	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:104)	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:73)	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)"
496044,6/13/2016 21:45,sxenos,[newindex] The type hierarchy is missing certain subclasses when using the new index When the new index is enabled subclasses of generic types often seem to be omitted.
496237,6/16/2016 2:27,sarika.sinha,JavaStackTraceConsoleFactory as API org.eclipse.jdt.internal.debug.ui.console.JavaStackTraceConsoleFactory is required as an API. It is already used in org.eclipse.pde.internal.ui.ShowErrorInStackTraceConsoleAction with discouraged access.It will also be required in jdt.ui for fixing bug 72847.
496591,6/22/2016 16:45,register.eclipse,"Incorrectly marking return types as incompatible Created attachment 262604Class to reproduce issue withSeeing the following messages when compiling a source file generated by the protoc-jar-maven-plugin maven plugin. The generated source file does compile fine when running maven from command line.Description	Resource	Path	Location	TypeThe return types are incompatible for the inherited methods MessageOrBuilder.getAllFields() GeneratedMessage.getAllFields()	EventInfo.java	/utils/target-ide/generated-sources/protbuf/com/mylaps/taguse/proto	line 85	Java ProblemDescription	Resource	Path	Location	TypeThe return types are incompatible for the inherited methods MessageOrBuilder.getAllFields() GeneratedMessage.Builder<EventInfo.EventInfoStorage.Builder>.getAllFields()	EventInfo.java	/utils/target-ide/generated-sources/protbuf/com/mylaps/taguse/proto	line 507	Java ProblemWe didn't see this issue when running a previous release candidate only when upgrading to the final Neon release. We can reproduce on OSX and Windows both with Java 8.A generated protocol buffer file is attached that can reproduce the issue steps to reproduce are:1. Create a new Java 1.8 project and place the file in the com.mylaps.taguse.proto package2. Add the protobuf 2.6.1 jar to the project ( http://search.maven.org/remotecontent?filepath=com/google/protobuf/protobuf-java/2.6.1/protobuf-java-2.6.1.jar )3. Compile the two errors are shown."
497044,6/29/2016 21:12,sxenos,"[newindex] Test failures in the new index branch The newindex branch currently has some test failures with stack traces resembling the following:RunAllTestsorg.eclipse.jdt.core.tests.nd.RunAllTestsorg.eclipse.jdt.core.tests.nd.BTreeTeststestBySortedSetMirrorLite(org.eclipse.jdt.core.tests.nd.BTreeTests)org.eclipse.jdt.internal.core.nd.db.IndexException: Attempted to free more memory from pool 1 than was ever allocated	at org.eclipse.jdt.internal.core.nd.db.MemoryStats.recordFree(MemoryStats.java:215)	at org.eclipse.jdt.internal.core.nd.db.Database.free(Database.java:527)	at org.eclipse.jdt.internal.core.nd.db.BTree.mergeNodes(BTree.java:514)	at org.eclipse.jdt.internal.core.nd.db.BTree.deleteImp(BTree.java:470)	at org.eclipse.jdt.internal.core.nd.db.BTree.delete(BTree.java:303)	at org.eclipse.jdt.core.tests.nd.BTreeTests.trialImp(BTreeTests.java:168)	at org.eclipse.jdt.core.tests.nd.BTreeTests.trial(BTreeTests.java:135)	at org.eclipse.jdt.core.tests.nd.BTreeTests.sortedMirrorTest(BTreeTests.java:85)	at org.eclipse.jdt.core.tests.nd.BTreeTests.testBySortedSetMirrorLite(BTreeTests.java:70)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at junit.framework.TestCase.runTest(TestCase.java:176)	at junit.framework.TestCase.runBare(TestCase.java:141)	at org.eclipse.jdt.core.tests.nd.util.BaseTestCase.runBare(BaseTestCase.java:181)	at junit.framework.TestResult$1.protect(TestResult.java:122)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at junit.framework.TestResult.run(TestResult.java:125)	at junit.framework.TestCase.run(TestCase.java:129)	at org.eclipse.jdt.core.tests.nd.util.BaseTestCase.run(BaseTestCase.java:227)	at junit.framework.TestSuite.runTest(TestSuite.java:252)	at junit.framework.TestSuite.run(TestSuite.java:247)	at junit.framework.TestSuite.runTest(TestSuite.java:252)	at junit.framework.TestSuite.run(TestSuite.java:247)	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)	at org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:66)	at org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run(CoreTestApplication.java:24)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)"
497168,7/1/2016 19:51,sxenos,[newindex] Fix test failures in the new index branch There are a number of test failures on the newindex branch now that the index is enabled by default.
497355,7/5/2016 17:34,sxenos,[newindex] Fix compiler warnings in the newindex branch As mentioned in bug 481796 there are a number of compiler warnings in the newindex branch. They all need to be fixed.
497368,7/6/2016 4:45,noopur_gupta,"[pull up] Pull Up refactoring to interface generates broken code Create an interface IFoo and implementing classes Foo FooImpl1 FooImpl2. In Foo define a method as follows:	public void log(Level level String message String... parameters) {		String formattedMessage = MessageFormat.format(message (Object[])parameters);		System.out.println(""Logging ""+message+"" with ""+Arrays.asList(parameters));		LogManager.getLogManager().getLogger(Foo.class.getName()).log(level formattedMessage);	}Use the Pull Up refactoring to pull the method up into interface IFoo. In the wizard select ""Create necessary method stubs ...""Expected outcome:1. The result is compile-error free2. The method is added to IFoo along with imports needed for the method signature3. The method is added to all non-abstract implementors along with imports needed for the method signature4. The method in implementors looks the same as when using the ""Add unimplemented methods"" hotfix to create it including- task marker //TODO auto-generated method stub- @Override annotationThe method stub should look something like this:	//import for java.util.logging.Level		@Override	public void log(Level level String message String... parameters) {		// TODO Auto-generated method stub			}Actual outcome:1. All implementors (except Foo) have compile errors2. IFoo gets additional unnecessary imports for classes used in the method body of the original implementation in Foo3. Imports needed for the method signature are not added to implementors4. The method in implementors lacks both the //TODO marker and the @Override annotationThe method stub actually looks like this:	//no import for java.util.logging.Level	public void log(Level level String message String... parameters) {	}"
497419,7/6/2016 15:13,register.eclipse,Fix CRLF line endings in jdt.core sources While working on bug 496591 it was noted that some java files have CRLF line endings:NullTypeAnnotationTest.javaASTConverter18Test.javaFormatterBugsTests.java
497698,7/11/2016 11:51,register.eclipse,"java.lang.IllegalStateException at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getParameterizedType(AnnotatableTypeSystem.java:114) I'm getting this error almost every second mostly on save actions.Surely something is in a mess must Eclipse must be able to cope with this problem or fix it itself.Working became totally impractical.java.lang.IllegalStateException	at org.eclipse.jdt.internal.compiler.lookup.AnnotatableTypeSystem.getParameterizedType(AnnotatableTypeSystem.java:114)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createParameterizedType(LookupEnvironment.java:998)	at org.eclipse.jdt.internal.compiler.lookup.Scope$Substitutor.substitute(Scope.java:597)	at org.eclipse.jdt.internal.compiler.lookup.Scope.substitute(Scope.java:432)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedMethodBinding.<init>(ParameterizedMethodBinding.java:123)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.createParameterizedMethod(ParameterizedTypeBinding.java:389)	at org.eclipse.jdt.internal.compiler.lookup.RawTypeBinding.createParameterizedMethod(RawTypeBinding.java:98)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.getMethods(ParameterizedTypeBinding.java:695)	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.getExactMethod(ParameterizedTypeBinding.java:605)	at org.eclipse.jdt.internal.compiler.lookup.Scope.findExactMethod(Scope.java:1231)	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2830)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:915)	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:729)	at org.eclipse.jdt.internal.compiler.ast.Assignment.resolveType(Assignment.java:206)	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1026)	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)	at org.eclipse.jdt.internal.compiler.ast.IfStatement.resolve(IfStatement.java:276)	at org.eclipse.jdt.internal.compiler.ast.Block.resolve(Block.java:117)	at org.eclipse.jdt.internal.compiler.ast.ForeachStatement.resolve(ForeachStatement.java:576)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:634)	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:306)	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:544)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1195)	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1308)	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:593)	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:867)	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:141)	at java.lang.Thread.run(Thread.java:745)session data:eclipse.buildId=4.6.0.I20160606-1100java.version=1.8.0_92java.vendor=Oracle CorporationBootLoader constants: OS=macosx ARCH=x86_64 WS=cocoa NL=de_DEFramework arguments: -product org.eclipse.epp.package.jee.productCommand-line arguments: -os macosx -ws cocoa -arch x86_64 -product org.eclipse.epp.package.jee.product -cleanThis is a continuation of log file /Users/bojanantonovic/workspace-smood/.metadata/.bak_2.logCreated Time: 2016-07-11 17:33:50.297"
497879,7/14/2016 2:28,sasikanth.bharadwaj,[1.8][compiler][codegen] Serializable lambda does not work for constructor references Picked up from bug 485333 comment 9The following code results in IAE with invalid lambda deserialization when compiled with eclipse but works fine when compiled with javacpublic class LambdaSerializationTest { interface SerializableSupplier<T> extends Supplier<T> Serializable {} @Test public void constructorReferenceSerialization() throws IOException ClassNotFoundException { SerializableSupplier<List<?>> function = ArrayList::new; //Collections::emptyList; Object result = serializeDeserialize(function); Assert.assertTrue(result instanceof SerializableSupplier<?>); } private static Object serializeDeserialize(Object obj) throws IOException ClassNotFoundException { try ( ByteArrayOutputStream buffer = new ByteArrayOutputStream(); // ObjectOutputStream output = new ObjectOutputStream(buffer)) { output.writeObject(obj); try (ObjectInputStream input = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()))) { return input.readObject(); } } }}
497996,7/15/2016 21:04,sxenos,[newindex] Implement David Cheung's suggestions from the newindex code review David's comments can be found here:https://git.eclipse.org/r/#/c/76660
498409,7/25/2016 3:26,ma.becker,"HighDPI: Wizard banner icons blurry Created attachment 263282Comparison of old ( low res / left ) and new ( high res / right )All the wizard banner icons are not as crisp as they could be if you have high resolution display (eg. MacBook with Retina display). The cause of this is that JDT does not provide @2x-versions of these images. The eclipse.platform.images git repo (does also not contain SVG-versions of these images.I could provide some re-drawn SVG-versions as well as rendered PNG-versions in the ""normal"" PNG-version and the @2x-PNG-version to the eclipse.platform.images repo. After that we could copy the PNGs to the eclipse.jdt-ui repo. Attached you find a comparison of the first one (for the new class wizard). On the left hand side you find the current situation and on the right hand side the new version (redrawn by me) in high resolution.What do you think? Is this one okay? Should I proceed?"
498423,7/25/2016 6:53,markus.kell.r,Build warnings in o.e.jdt.ui http://download.eclipse.org/eclipse/downloads/drops4/N20160724-2000/compilelogs/plugins/org.eclipse.jdt.ui_3.12.100.N20160724-2000/@dot.html
498658,7/27/2016 15:47,sxenos,"[newindex] Fix test failures in TypeHierarchyTests In the newindex branch there are currently two test failures in the TypeHierarchyTests:TypeHierarchyTestsorg.eclipse.jdt.core.tests.model.TypeHierarchyTeststestAnonymousType07(org.eclipse.jdt.core.tests.model.TypeHierarchyTests)junit.framework.ComparisonFailure: Unexpected key.----------- Expected ------------Lmy/pkg/Y$1;------------ but was ------------null--------- Difference is ---------- expected:<Lmy/pkg/Y$1;> but was:<null>	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:259)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:235)	at org.eclipse.jdt.core.tests.model.TypeHierarchyTests.testAnonymousType07(TypeHierarchyTests.java:300)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at junit.framework.TestCase.runTest(TestCase.java:176)	at junit.framework.TestCase.runBare(TestCase.java:141)	at junit.framework.TestResult$1.protect(TestResult.java:122)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at junit.framework.TestResult.run(TestResult.java:125)	at junit.framework.TestCase.run(TestCase.java:129)	at junit.framework.TestSuite.runTest(TestSuite.java:252)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:105)	at junit.framework.TestSuite.run(TestSuite.java:247)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:89)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite$1.protect(SuiteOfTestCases.java:77)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:86)	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)	at org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:66)	at org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run(CoreTestApplication.java:24)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)testGeneric06(org.eclipse.jdt.core.tests.model.TypeHierarchyTests)junit.framework.ComparisonFailure: Unexpected key.----------- Expected ------------Lutil/Map<TK;TV;>;------------ but was ------------null--------- Difference is ---------- expected:<Lutil/Map<TK;TV;>;> but was:<null>	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:259)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:235)	at org.eclipse.jdt.core.tests.model.TypeHierarchyTests.testGeneric06(TypeHierarchyTests.java:913)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at junit.framework.TestCase.runTest(TestCase.java:176)	at junit.framework.TestCase.runBare(TestCase.java:141)	at junit.framework.TestResult$1.protect(TestResult.java:122)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at junit.framework.TestResult.run(TestResult.java:125)	at junit.framework.TestCase.run(TestCase.java:129)	at junit.framework.TestSuite.runTest(TestSuite.java:252)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:105)	at junit.framework.TestSuite.run(TestSuite.java:247)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:89)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite$1.protect(SuiteOfTestCases.java:77)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:86)	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)	at org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:66)	at org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run(CoreTestApplication.java:24)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)"
498769,7/28/2016 9:41,noopur_gupta,[type wizards] Pasting qualified type name with extension splits incorrectly In a new type wizard pasting the following in Name field should correctly identify the package name and the type name with extension:- com.test.util.C1.java- C1.javaOther tests:- com.test.util.C1<T>.java- C1<T>.java
499078,8/2/2016 22:27,sxenos,"[newindex] Fix test failures in AttachSourceTests.testGetNameRange03 The following test failures are occurring in AttachSourceTests in the newindex branch.AttachSourceTestsorg.eclipse.jdt.core.tests.model.AttachSourceTeststestInnerClass10(org.eclipse.jdt.core.tests.model.AttachSourceTests)junit.framework.ComparisonFailure: Unexpected source.----------- Expected ------------class WW {\n WW() {}\n class WWW {\n WWW() {}\n }\n }------------ but was ------------null--------- Difference is ---------- expected:<class WW {\n WW() {}\n class WWW {\n WWW() {}\n }\n }> but was:<null>	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:259)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:235)	at org.eclipse.jdt.core.tests.model.AbstractJavaModelTests.assertSourceEquals(AbstractJavaModelTests.java:779)	at org.eclipse.jdt.core.tests.model.AbstractJavaModelTests.assertSourceEquals(AbstractJavaModelTests.java:770)	at org.eclipse.jdt.core.tests.model.AttachSourceTests.testInnerClass10(AttachSourceTests.java:1069)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at junit.framework.TestCase.runTest(TestCase.java:176)	at junit.framework.TestCase.runBare(TestCase.java:141)	at junit.framework.TestResult$1.protect(TestResult.java:122)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at junit.framework.TestResult.run(TestResult.java:125)	at junit.framework.TestCase.run(TestCase.java:129)	at junit.framework.TestSuite.runTest(TestSuite.java:252)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:105)	at junit.framework.TestSuite.run(TestSuite.java:247)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:89)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite$1.protect(SuiteOfTestCases.java:77)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:86)	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)	at org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:66)	at org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run(CoreTestApplication.java:24)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)testMethodRetrieval(org.eclipse.jdt.core.tests.model.AttachSourceTests)junit.framework.AssertionFailedError: source code does not exist for the method A() [in A [in A.class [in x.y [in attach.jar [in AttachSourceTests]]]]]	at junit.framework.Assert.fail(Assert.java:57)	at junit.framework.Assert.assertTrue(Assert.java:22)	at junit.framework.TestCase.assertTrue(TestCase.java:192)	at org.eclipse.jdt.core.tests.model.AttachSourceTests.testMethodRetrieval(AttachSourceTests.java:1112)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at junit.framework.TestCase.runTest(TestCase.java:176)	at junit.framework.TestCase.runBare(TestCase.java:141)	at junit.framework.TestResult$1.protect(TestResult.java:122)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at junit.framework.TestResult.run(TestResult.java:125)	at junit.framework.TestCase.run(TestCase.java:129)	at junit.framework.TestSuite.runTest(TestSuite.java:252)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:105)	at junit.framework.TestSuite.run(TestSuite.java:247)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:89)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite$1.protect(SuiteOfTestCases.java:77)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:86)	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)	at org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:66)	at org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run(CoreTestApplication.java:24)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)testGetNameRange03(org.eclipse.jdt.core.tests.model.AttachSourceTests)junit.framework.ComparisonFailure: Unexpected name source.----------- Expected ------------V------------ but was --------------------- Difference is ---------- expected:<[V]> but was:<[]>	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:259)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:235)	at org.eclipse.jdt.core.tests.model.AbstractJavaModelTests.assertSourceEquals(AbstractJavaModelTests.java:790)	at org.eclipse.jdt.core.tests.model.AbstractJavaModelTests.assertSourceEquals(AbstractJavaModelTests.java:770)	at org.eclipse.jdt.core.tests.model.AttachSourceTests.testGetNameRange03(AttachSourceTests.java:819)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at junit.framework.TestCase.runTest(TestCase.java:176)	at junit.framework.TestCase.runBare(TestCase.java:141)	at junit.framework.TestResult$1.protect(TestResult.java:122)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at junit.framework.TestResult.run(TestResult.java:125)	at junit.framework.TestCase.run(TestCase.java:129)	at junit.framework.TestSuite.runTest(TestSuite.java:252)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:105)	at junit.framework.TestSuite.run(TestSuite.java:247)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:89)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite$1.protect(SuiteOfTestCases.java:77)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:86)	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)	at org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:66)	at org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run(CoreTestApplication.java:24)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)testGetNameRange04(org.eclipse.jdt.core.tests.model.AttachSourceTests)junit.framework.AssertionFailedError: Unexpected name range	at junit.framework.Assert.fail(Assert.java:57)	at junit.framework.Assert.assertTrue(Assert.java:22)	at junit.framework.TestCase.assertTrue(TestCase.java:192)	at org.eclipse.jdt.core.tests.model.AttachSourceTests.testGetNameRange04(AttachSourceTests.java:835)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at junit.framework.TestCase.runTest(TestCase.java:176)	at junit.framework.TestCase.runBare(TestCase.java:141)	at junit.framework.TestResult$1.protect(TestResult.java:122)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at junit.framework.TestResult.run(TestResult.java:125)	at junit.framework.TestCase.run(TestCase.java:129)	at junit.framework.TestSuite.runTest(TestSuite.java:252)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:105)	at junit.framework.TestSuite.run(TestSuite.java:247)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:89)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite$1.protect(SuiteOfTestCases.java:77)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:86)	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)	at org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:66)	at org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run(CoreTestApplication.java:24)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)"
499110,8/3/2016 10:40,loskutov,"[UI cleanup] Don't show ""Run|Debug as -> Applet"" menus anymore The time of the ""Java applets"" is over but in *each single* Java related project *each* menu opened on a project or folder or file shows this:Run As -> Java AppletDebug As -> Java AppletThis is an overkill. Eclipse UI is complex enough why should we made it even more complex? No one is seriously expecting to run Java Applets today.I understand that some one somewhere might still want to execute them but it should be enough to keep the Run/Debug configurations there and remove the context menus which affect everyone else every day.From the API point of view JavaAppletLaunchShortcut used in plugin.xml declaration can be kept there (it is public API) for downstream users needed this class for whatever reasons but the plugin.xml contribution can be removed.I will provide the trivial patch."
499122,8/3/2016 14:05,sxenos,"[newindex] Fix test failures in DeleteTests.testDeleteAllImports Failures in the newindex branch:org.eclipse.jdt.core.tests.model.DeleteTests.testDeleteAllImports (from org.eclipse.jdt.core.tests.model.AllJavaModelTests)Failing for the past 1 build (Since Failed#1430 )Took 0.5 sec.Error MessageUnexpected delta.----------- Expected ------------P[*]: {CHILDREN}\n <project root>[*]: {CHILDREN}\n <default>[*]: {CHILDREN}\n X.java[*]: {CHILDREN | FINE GRAINED | PRIMARY RESOURCE}\n <import container>[-]: {}------------ but was ------------Java Model[?]: {}\n\nP[*]: {CHILDREN}\n <project root>[*]: {CHILDREN}\n <default>[*]: {CHILDREN}\n X.java[*]: {CHILDREN | FINE GRAINED | PRIMARY RESOURCE}\n <import container>[-]: {}\n\nJava Model[?]: {}--------- Difference is ---------- expected:<[P[*]: {CHILDREN}\n <project root>[*]: {CHILDREN}\n <default>[*]: {CHILDREN}\n X.java[*]: {CHILDREN | FINE GRAINED | PRIMARY RESOURCE}\n <import container>[-]]: {}> but was:<[Java Model[?]: {}\n\nP[*]: {CHILDREN}\n <project root>[*]: {CHILDREN}\n <default>[*]: {CHILDREN}\n X.java[*]: {CHILDREN | FINE GRAINED | PRIMARY RESOURCE}\n <import container>[-]: {}\n\nJava Model[?]]: {}>Stacktracejunit.framework.ComparisonFailure: Unexpected delta.----------- Expected ------------P[*]: {CHILDREN}\n	<project root>[*]: {CHILDREN}\n		<default>[*]: {CHILDREN}\n			X.java[*]: {CHILDREN | FINE GRAINED | PRIMARY RESOURCE}\n				<import container>[-]: {}------------ but was ------------Java Model[?]: {}\n\nP[*]: {CHILDREN}\n	<project root>[*]: {CHILDREN}\n		<default>[*]: {CHILDREN}\n			X.java[*]: {CHILDREN | FINE GRAINED | PRIMARY RESOURCE}\n				<import container>[-]: {}\n\nJava Model[?]: {}--------- Difference is ---------- expected:<[P[*]: {CHILDREN}\n	<project root>[*]: {CHILDREN}\n		<default>[*]: {CHILDREN}\n			X.java[*]: {CHILDREN | FINE GRAINED | PRIMARY RESOURCE}\n				<import container>[-]]: {}> but was:<[Java Model[?]: {}\n\nP[*]: {CHILDREN}\n	<project root>[*]: {CHILDREN}\n		<default>[*]: {CHILDREN}\n			X.java[*]: {CHILDREN | FINE GRAINED | PRIMARY RESOURCE}\n				<import container>[-]: {}\n\nJava Model[?]]: {}>	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:259)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:235)	at org.eclipse.jdt.core.tests.model.AbstractJavaModelTests.assertDeltas(AbstractJavaModelTests.java:1043)	at org.eclipse.jdt.core.tests.model.AbstractJavaModelTests.assertDeltas(AbstractJavaModelTests.java:1033)	at org.eclipse.jdt.core.tests.model.DeleteTests.testDeleteAllImports(DeleteTests.java:75)Standard Output		""Java Model[?]: {}\n"" + 		""\n"" + 		""P[*]: {CHILDREN}\n"" + 		""	<project root>[*]: {CHILDREN}\n"" + 		""		<default>[*]: {CHILDREN}\n"" + 		""			X.java[*]: {CHILDREN | FINE GRAINED | PRIMARY RESOURCE}\n"" + 		""				<import container>[-]: {}\n"" + 		""\n"" + 		""Java Model[?]: {}""Standard Errorjava.lang.Throwable: Caller of IElementChangedListener#elementChanged	at org.eclipse.jdt.core.tests.model.AbstractJavaModelTests$DeltaListener.elementChanged(AbstractJavaModelTests.java:142)	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1665)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1655)	at org.eclipse.jdt.internal.core.DeltaProcessor.firePostChangeDelta(DeltaProcessor.java:1489)	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1465)	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyAndFire(DeltaProcessor.java:2187)	at org.eclipse.jdt.internal.core.DeltaProcessingState.consume(DeltaProcessingState.java:653)	at org.eclipse.jdt.internal.core.nd.indexer.Indexer.fireChange(Indexer.java:830)	at org.eclipse.jdt.internal.core.nd.indexer.Indexer.fireDelta(Indexer.java:246)	at org.eclipse.jdt.internal.core.nd.indexer.Indexer.rescan(Indexer.java:175)	at org.eclipse.jdt.internal.core.nd.indexer.Indexer$1.run(Indexer.java:79)	at org.eclipse.core.runtime.jobs.Job$2.run(Job.java:186)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)java.lang.Throwable: Caller of IElementChangedListener#elementChanged	at org.eclipse.jdt.core.tests.model.AbstractJavaModelTests$DeltaListener.elementChanged(AbstractJavaModelTests.java:142)	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1665)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1655)	at org.eclipse.jdt.internal.core.DeltaProcessor.firePostChangeDelta(DeltaProcessor.java:1489)	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1465)	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyAndFire(DeltaProcessor.java:2187)	at org.eclipse.jdt.internal.core.DeltaProcessor.resourceChanged(DeltaProcessor.java:2070)	at org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged(DeltaProcessingState.java:480)	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:299)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:289)	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:152)	at org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:374)	at org.eclipse.core.internal.resources.Workspace.endOperation(Workspace.java:1469)	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2253)	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2267)	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:795)	at org.eclipse.jdt.internal.core.JavaModel.delete(JavaModel.java:124)	at org.eclipse.jdt.core.tests.model.AbstractJavaModelTests.assertDeletion(AbstractJavaModelTests.java:1009)	at org.eclipse.jdt.core.tests.model.DeleteTests.testDeleteAllImports(DeleteTests.java:74)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:497)	at junit.framework.TestCase.runTest(TestCase.java:176)	at junit.framework.TestCase.runBare(TestCase.java:141)	at junit.framework.TestResult$1.protect(TestResult.java:122)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at junit.framework.TestResult.run(TestResult.java:125)	at junit.framework.TestCase.run(TestCase.java:129)	at junit.framework.TestSuite.runTest(TestSuite.java:252)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:105)	at junit.framework.TestSuite.run(TestSuite.java:247)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:89)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite$1.protect(SuiteOfTestCases.java:77)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:86)	at junit.framework.TestSuite.runTest(TestSuite.java:252)	at junit.framework.TestSuite.run(TestSuite.java:247)	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:264)	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153)	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:124)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:497)	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray2(ReflectionUtils.java:208)	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:156)	at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:82)	at org.eclipse.tycho.surefire.osgibooter.OsgiSurefireBooter.run(OsgiSurefireBooter.java:91)	at org.eclipse.tycho.surefire.osgibooter.HeadlessTestApplication.run(HeadlessTestApplication.java:21)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:497)	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:497)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)java.lang.Throwable: Caller of IElementChangedListener#elementChanged	at org.eclipse.jdt.core.tests.model.AbstractJavaModelTests$DeltaListener.elementChanged(AbstractJavaModelTests.java:142)	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1665)	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1655)	at org.eclipse.jdt.internal.core.DeltaProcessor.firePostChangeDelta(DeltaProcessor.java:1489)	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1465)	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyAndFire(DeltaProcessor.java:2187)	at org.eclipse.jdt.internal.core.DeltaProcessingState.consume(DeltaProcessingState.java:653)	at org.eclipse.jdt.internal.core.nd.indexer.Indexer.fireChange(Indexer.java:830)	at org.eclipse.jdt.internal.core.nd.indexer.Indexer.fireDelta(Indexer.java:246)	at org.eclipse.jdt.internal.core.nd.indexer.Indexer.rescan(Indexer.java:175)	at org.eclipse.jdt.internal.core.nd.indexer.Indexer$1.run(Indexer.java:79)	at org.eclipse.core.runtime.jobs.Job$2.run(Job.java:186)	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)"
499126,8/3/2016 15:04,register.eclipse,"[compiler] IllegalStateException in LookupEnvironment.countNonStaticNestingLevels DESCRIPTION:With http://search.maven.org/remotecontent?filepath=com/google/inject/guice/3.0/guice-3.0.jar in the classpath open type hierarchy for java.util.function.Function<T R>An IllegalStateException is reported:	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.countNonStaticNestingLevels(LookupEnvironment.java:1468)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getTypeFromTypeSignature(LookupEnvironment.java:1558)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.createFields(BinaryTypeBinding.java:626)	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.cachePartsFrom(BinaryTypeBinding.java:523)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:705)	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.createBinaryTypeFrom(LookupEnvironment.java:688)	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.accept(HierarchyResolver.java:113)[...]ANALYSIS:The ISE is caused for Unresolved type com.google.inject.internal.util.$ImmutableList.This is not a nested class but URB.depth returns 1 for it because of the '$' in the class name.PATCH:Use URB.depth to determine if the URB should be resolved in LookupEnvironment.getTypeFromTypeSignature"
499196,8/4/2016 18:55,jarthana,"Javadoc Location support for doclava federated documentation Created attachment 263466Can't find method level JavadocJavadoc location on a Jar library does not support method or Constructor level Doclava based javadocs. You can attach a javadoc jar by explicitly stating the `Path in archive` to the `reference` folder and get Class level support but methods and Constructors result in a note saying ""Note: This element has no attached source and the Javadoc could not be found in the attached Javadoc."" See attached screenshots. Doclava supports federated documentation which requires 2 things: 1. A documentation site2. Description of the site's contents. Doclava uses `.xml` file for #2 above. Eclipse help (http://help.eclipse.org/neon/index.jsp?topic=%2Forg.eclipse.jdt.doc.user%2Freference%2Fref-dialog-javadoc-location.htm) states ""Valid locations are URLs that point to a folder containing the API documentation's index.html and package-list file."" I created a valid package-list file for doclava based javadoc and it still doesn't work.To reproduce: 1. Attach Javadoc to Jar library2. Ensure path within archive is set to `/reference` folder3. Attempt to hover over class method and/or constructor."
499256,8/5/2016 19:46,sxenos,"[newindex] Fix test failures in CompletionTests18 The newindex branch is failing with the following failures:CompletionTests18org.eclipse.jdt.core.tests.model.CompletionTests18test008(org.eclipse.jdt.core.tests.model.CompletionTests18)junit.framework.ComparisonFailure: ----------- Expected ------------[POTENTIAL_METHOD_DECLARATION]{ LX; ()V null 14}\nabstract[KEYWORD]{abstract null null abstract null 24}\nclass[KEYWORD]{class null null class null 24}\nenum[KEYWORD]{enum null null enum null 24}\nfinal[KEYWORD]{final null null final null 24}\ninterface[KEYWORD]{interface null null interface null 24}\nnative[KEYWORD]{native null null native null 24}\nprivate[KEYWORD]{private null null private null 24}\nprotected[KEYWORD]{protected null null protected null 24}\npublic[KEYWORD]{public null null public null 24}\nstatic[KEYWORD]{static null null static null 24}\nstrictfp[KEYWORD]{strictfp null null strictfp null 24}\nsynchronized[KEYWORD]{synchronized null null synchronized null 24}\ntransient[KEYWORD]{transient null null transient null 24}\nvolatile[KEYWORD]{volatile null null volatile null 24}\nI[TYPE_REF]{I LI; null null 27}\nJ[TYPE_REF]{J LJ; null null 27}\nX[TYPE_REF]{X LX; null null 27}\nclone[METHOD_DECLARATION]{protected Object clone() throws CloneNotSupportedException Ljava.lang.Object; ()Ljava.lang.Object; clone null 27}\nequals[METHOD_DECLARATION]{public boolean equals(Object obj) Ljava.lang.Object; (Ljava.lang.Object;)Z equals (obj) 27}\nfinalize[METHOD_DECLARATION]{protected void finalize() throws Throwable Ljava.lang.Object; ()V finalize null 27}\nhashCode[METHOD_DECLARATION]{public int hashCode() Ljava.lang.Object; ()I hashCode null 27}\ntoString[METHOD_DECLARATION]{public String toString() Ljava.lang.Object; ()Ljava.lang.String; toString null 27}------------ but was ------------[POTENTIAL_METHOD_DECLARATION]{ LX; ()V null 14}\nabstract[KEYWORD]{abstract null null abstract null 24}\nclass[KEYWORD]{class null null class null 24}\nenum[KEYWORD]{enum null null enum null 24}\nfinal[KEYWORD]{final null null final null 24}\ninterface[KEYWORD]{interface null null interface null 24}\nnative[KEYWORD]{native null null native null 24}\nprivate[KEYWORD]{private null null private null 24}\nprotected[KEYWORD]{protected null null protected null 24}\npublic[KEYWORD]{public null null public null 24}\nstatic[KEYWORD]{static null null static null 24}\nstrictfp[KEYWORD]{strictfp null null strictfp null 24}\nsynchronized[KEYWORD]{synchronized null null synchronized null 24}\ntransient[KEYWORD]{transient null null transient null 24}\nvolatile[KEYWORD]{volatile null null volatile null 24}\nI[TYPE_REF]{I LI; null null 27}\nJ[TYPE_REF]{J LJ; null null 27}\nX[TYPE_REF]{X LX; null null 27}\nclone[METHOD_DECLARATION]{protected Object clone() throws CloneNotSupportedException Ljava.lang.Object; ()Ljava.lang.Object; clone null 27}\nequals[METHOD_DECLARATION]{public boolean equals(Object arg0) Ljava.lang.Object; (Ljava.lang.Object;)Z equals (arg0) 27}\nfinalize[METHOD_DECLARATION]{protected void finalize() throws Throwable Ljava.lang.Object; ()V finalize null 27}\nhashCode[METHOD_DECLARATION]{public int hashCode() Ljava.lang.Object; ()I hashCode null 27}\ntoString[METHOD_DECLARATION]{public String toString() Ljava.lang.Object; ()Ljava.lang.String; toString null 27}--------- Difference is ---------- expected:<...olean equals(Object [obj) Ljava.lang.Object; (Ljava.lang.Object;)Z equals (obj]) 27}\nfinalize[ME...> but was:<...olean equals(Object [arg0) Ljava.lang.Object; (Ljava.lang.Object;)Z equals (arg0]) 27}\nfinalize[ME...>	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:259)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:235)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:232)	at org.eclipse.jdt.core.tests.model.AbstractJavaModelCompletionTests.assertResults(AbstractJavaModelCompletionTests.java:194)	at org.eclipse.jdt.core.tests.model.CompletionTests18.test008(CompletionTests18.java:267)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at junit.framework.TestCase.runTest(TestCase.java:176)	at junit.framework.TestCase.runBare(TestCase.java:141)	at junit.framework.TestResult$1.protect(TestResult.java:122)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at junit.framework.TestResult.run(TestResult.java:125)	at junit.framework.TestCase.run(TestCase.java:129)	at junit.framework.TestSuite.runTest(TestSuite.java:252)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:105)	at junit.framework.TestSuite.run(TestSuite.java:247)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:89)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite$1.protect(SuiteOfTestCases.java:77)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:86)	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)	at org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:66)	at org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run(CoreTestApplication.java:24)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)test010(org.eclipse.jdt.core.tests.model.CompletionTests18)junit.framework.ComparisonFailure: ----------- Expected ------------goo[METHOD_REF]{goo() LX; (LI;)V goo (i) 24}\ngoo[METHOD_REF]{goo() LX; (Ljava.lang.String;)V goo (s) 24}\nmain[METHOD_REF]{main() LX; ([Ljava.lang.String;)V main (args) 24}\nclone[METHOD_REF]{clone() Ljava.lang.Object; ()Ljava.lang.Object; clone null 35}\nequals[METHOD_REF]{equals() Ljava.lang.Object; (Ljava.lang.Object;)Z equals (obj) 35}\nfinalize[METHOD_REF]{finalize() Ljava.lang.Object; ()V finalize null 35}\ngetClass[METHOD_REF]{getClass() Ljava.lang.Object; ()Ljava.lang.Class<*>; getClass null 35}\nhashCode[METHOD_REF]{hashCode() Ljava.lang.Object; ()I hashCode null 35}\nnotify[METHOD_REF]{notify() Ljava.lang.Object; ()V notify null 35}\nnotifyAll[METHOD_REF]{notifyAll() Ljava.lang.Object; ()V notifyAll null 35}\ntoString[METHOD_REF]{toString() Ljava.lang.Object; ()Ljava.lang.String; toString null 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; ()V wait null 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (J)V wait (millis) 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (JI)V wait (millis nanos) 35}------------ but was ------------goo[METHOD_REF]{goo() LX; (LI;)V goo (i) 24}\ngoo[METHOD_REF]{goo() LX; (Ljava.lang.String;)V goo (s) 24}\nmain[METHOD_REF]{main() LX; ([Ljava.lang.String;)V main (args) 24}\nclone[METHOD_REF]{clone() Ljava.lang.Object; ()Ljava.lang.Object; clone null 35}\nequals[METHOD_REF]{equals() Ljava.lang.Object; (Ljava.lang.Object;)Z equals (arg0) 35}\nfinalize[METHOD_REF]{finalize() Ljava.lang.Object; ()V finalize null 35}\ngetClass[METHOD_REF]{getClass() Ljava.lang.Object; ()Ljava.lang.Class<*>; getClass null 35}\nhashCode[METHOD_REF]{hashCode() Ljava.lang.Object; ()I hashCode null 35}\nnotify[METHOD_REF]{notify() Ljava.lang.Object; ()V notify null 35}\nnotifyAll[METHOD_REF]{notifyAll() Ljava.lang.Object; ()V notifyAll null 35}\ntoString[METHOD_REF]{toString() Ljava.lang.Object; ()Ljava.lang.String; toString null 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; ()V wait null 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (J)V wait (arg0) 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (JI)V wait (arg0 arg1) 35}--------- Difference is ---------- expected:<...Object;)Z equals ([obj) 35}\nfinalize[METHOD_REF]{finalize() Ljava.lang.Object; ()V finalize null 35}\ngetClass[METHOD_REF]{getClass() Ljava.lang.Object; ()Ljava.lang.Class<*>; getClass null 35}\nhashCode[METHOD_REF]{hashCode() Ljava.lang.Object; ()I hashCode null 35}\nnotify[METHOD_REF]{notify() Ljava.lang.Object; ()V notify null 35}\nnotifyAll[METHOD_REF]{notifyAll() Ljava.lang.Object; ()V notifyAll null 35}\ntoString[METHOD_REF]{toString() Ljava.lang.Object; ()Ljava.lang.String; toString null 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; ()V wait null 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (J)V wait (millis) 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (JI)V wait (millis nanos]) 35}> but was:<...Object;)Z equals ([arg0) 35}\nfinalize[METHOD_REF]{finalize() Ljava.lang.Object; ()V finalize null 35}\ngetClass[METHOD_REF]{getClass() Ljava.lang.Object; ()Ljava.lang.Class<*>; getClass null 35}\nhashCode[METHOD_REF]{hashCode() Ljava.lang.Object; ()I hashCode null 35}\nnotify[METHOD_REF]{notify() Ljava.lang.Object; ()V notify null 35}\nnotifyAll[METHOD_REF]{notifyAll() Ljava.lang.Object; ()V notifyAll null 35}\ntoString[METHOD_REF]{toString() Ljava.lang.Object; ()Ljava.lang.String; toString null 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; ()V wait null 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (J)V wait (arg0) 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (JI)V wait (arg0 arg1]) 35}>	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:259)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:235)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:232)	at org.eclipse.jdt.core.tests.model.AbstractJavaModelCompletionTests.assertResults(AbstractJavaModelCompletionTests.java:194)	at org.eclipse.jdt.core.tests.model.CompletionTests18.test010(CompletionTests18.java:367)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at junit.framework.TestCase.runTest(TestCase.java:176)	at junit.framework.TestCase.runBare(TestCase.java:141)	at junit.framework.TestResult$1.protect(TestResult.java:122)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at junit.framework.TestResult.run(TestResult.java:125)	at junit.framework.TestCase.run(TestCase.java:129)	at junit.framework.TestSuite.runTest(TestSuite.java:252)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:105)	at junit.framework.TestSuite.run(TestSuite.java:247)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:89)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite$1.protect(SuiteOfTestCases.java:77)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:86)	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)	at org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:66)	at org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run(CoreTestApplication.java:24)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)test009(org.eclipse.jdt.core.tests.model.CompletionTests18)junit.framework.ComparisonFailure: ----------- Expected ------------[POTENTIAL_METHOD_DECLARATION]{ LX; ()V null 14}\nabstract[KEYWORD]{abstract null null abstract null 24}\nclass[KEYWORD]{class null null class null 24}\nenum[KEYWORD]{enum null null enum null 24}\nfinal[KEYWORD]{final null null final null 24}\ninterface[KEYWORD]{interface null null interface null 24}\nnative[KEYWORD]{native null null native null 24}\nprivate[KEYWORD]{private null null private null 24}\nprotected[KEYWORD]{protected null null protected null 24}\npublic[KEYWORD]{public null null public null 24}\nstatic[KEYWORD]{static null null static null 24}\nstrictfp[KEYWORD]{strictfp null null strictfp null 24}\nsynchronized[KEYWORD]{synchronized null null synchronized null 24}\ntransient[KEYWORD]{transient null null transient null 24}\nvolatile[KEYWORD]{volatile null null volatile null 24}\nI[TYPE_REF]{I LI; null null 27}\nJ[TYPE_REF]{J LJ; null null 27}\nX[TYPE_REF]{X LX; null null 27}\nclone[METHOD_DECLARATION]{protected Object clone() throws CloneNotSupportedException Ljava.lang.Object; ()Ljava.lang.Object; clone null 27}\nequals[METHOD_DECLARATION]{public boolean equals(Object obj) Ljava.lang.Object; (Ljava.lang.Object;)Z equals (obj) 27}\nfinalize[METHOD_DECLARATION]{protected void finalize() throws Throwable Ljava.lang.Object; ()V finalize null 27}\nhashCode[METHOD_DECLARATION]{public int hashCode() Ljava.lang.Object; ()I hashCode null 27}\ntoString[METHOD_DECLARATION]{public String toString() Ljava.lang.Object; ()Ljava.lang.String; toString null 27}------------ but was ------------[POTENTIAL_METHOD_DECLARATION]{ LX; ()V null 14}\nabstract[KEYWORD]{abstract null null abstract null 24}\nclass[KEYWORD]{class null null class null 24}\nenum[KEYWORD]{enum null null enum null 24}\nfinal[KEYWORD]{final null null final null 24}\ninterface[KEYWORD]{interface null null interface null 24}\nnative[KEYWORD]{native null null native null 24}\nprivate[KEYWORD]{private null null private null 24}\nprotected[KEYWORD]{protected null null protected null 24}\npublic[KEYWORD]{public null null public null 24}\nstatic[KEYWORD]{static null null static null 24}\nstrictfp[KEYWORD]{strictfp null null strictfp null 24}\nsynchronized[KEYWORD]{synchronized null null synchronized null 24}\ntransient[KEYWORD]{transient null null transient null 24}\nvolatile[KEYWORD]{volatile null null volatile null 24}\nI[TYPE_REF]{I LI; null null 27}\nJ[TYPE_REF]{J LJ; null null 27}\nX[TYPE_REF]{X LX; null null 27}\nclone[METHOD_DECLARATION]{protected Object clone() throws CloneNotSupportedException Ljava.lang.Object; ()Ljava.lang.Object; clone null 27}\nequals[METHOD_DECLARATION]{public boolean equals(Object arg0) Ljava.lang.Object; (Ljava.lang.Object;)Z equals (arg0) 27}\nfinalize[METHOD_DECLARATION]{protected void finalize() throws Throwable Ljava.lang.Object; ()V finalize null 27}\nhashCode[METHOD_DECLARATION]{public int hashCode() Ljava.lang.Object; ()I hashCode null 27}\ntoString[METHOD_DECLARATION]{public String toString() Ljava.lang.Object; ()Ljava.lang.String; toString null 27}--------- Difference is ---------- expected:<...olean equals(Object [obj) Ljava.lang.Object; (Ljava.lang.Object;)Z equals (obj]) 27}\nfinalize[ME...> but was:<...olean equals(Object [arg0) Ljava.lang.Object; (Ljava.lang.Object;)Z equals (arg0]) 27}\nfinalize[ME...>	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:259)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:235)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:232)	at org.eclipse.jdt.core.tests.model.AbstractJavaModelCompletionTests.assertResults(AbstractJavaModelCompletionTests.java:194)	at org.eclipse.jdt.core.tests.model.CompletionTests18.test009(CompletionTests18.java:315)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at junit.framework.TestCase.runTest(TestCase.java:176)	at junit.framework.TestCase.runBare(TestCase.java:141)	at junit.framework.TestResult$1.protect(TestResult.java:122)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at junit.framework.TestResult.run(TestResult.java:125)	at junit.framework.TestCase.run(TestCase.java:129)	at junit.framework.TestSuite.runTest(TestSuite.java:252)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:105)	at junit.framework.TestSuite.run(TestSuite.java:247)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:89)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite$1.protect(SuiteOfTestCases.java:77)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:86)	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)	at org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:66)	at org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run(CoreTestApplication.java:24)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)testExpressionBody(org.eclipse.jdt.core.tests.model.CompletionTests18)junit.framework.ComparisonFailure: ----------- Expected ------------goo[METHOD_REF]{goo() LX; (LI;)V null null goo (i) [173 173] 24}\nmain[METHOD_REF]{main() LX; ([Ljava.lang.String;)V null null main (args) [173 173] 24}\nclone[METHOD_REF]{clone() Ljava.lang.Object; ()Ljava.lang.Object; null null clone null [173 173] 35}\nequals[METHOD_REF]{equals() Ljava.lang.Object; (Ljava.lang.Object;)Z null null equals (obj) [173 173] 35}\nfield[FIELD_REF]{field LX; I null null field null [173 173] 35}\nfinalize[METHOD_REF]{finalize() Ljava.lang.Object; ()V null null finalize null [173 173] 35}\nfoo[METHOD_REF]{foo() LX; ()V null null foo null [173 173] 35}\ngetClass[METHOD_REF]{getClass() Ljava.lang.Object; ()Ljava.lang.Class<*>; null null getClass null [173 173] 35}\nhashCode[METHOD_REF]{hashCode() Ljava.lang.Object; ()I null null hashCode null [173 173] 35}\nnotify[METHOD_REF]{notify() Ljava.lang.Object; ()V null null notify null [173 173] 35}\nnotifyAll[METHOD_REF]{notifyAll() Ljava.lang.Object; ()V null null notifyAll null [173 173] 35}\ntoString[METHOD_REF]{toString() Ljava.lang.Object; ()Ljava.lang.String; null null toString null [173 173] 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; ()V null null wait null [173 173] 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (J)V null null wait (millis) [173 173] 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (JI)V null null wait (millis nanos) [173 173] 35}------------ but was ------------goo[METHOD_REF]{goo() LX; (LI;)V null null goo (i) [173 173] 24}\nmain[METHOD_REF]{main() LX; ([Ljava.lang.String;)V null null main (args) [173 173] 24}\nclone[METHOD_REF]{clone() Ljava.lang.Object; ()Ljava.lang.Object; null null clone null [173 173] 35}\nequals[METHOD_REF]{equals() Ljava.lang.Object; (Ljava.lang.Object;)Z null null equals (arg0) [173 173] 35}\nfield[FIELD_REF]{field LX; I null null field null [173 173] 35}\nfinalize[METHOD_REF]{finalize() Ljava.lang.Object; ()V null null finalize null [173 173] 35}\nfoo[METHOD_REF]{foo() LX; ()V null null foo null [173 173] 35}\ngetClass[METHOD_REF]{getClass() Ljava.lang.Object; ()Ljava.lang.Class<*>; null null getClass null [173 173] 35}\nhashCode[METHOD_REF]{hashCode() Ljava.lang.Object; ()I null null hashCode null [173 173] 35}\nnotify[METHOD_REF]{notify() Ljava.lang.Object; ()V null null notify null [173 173] 35}\nnotifyAll[METHOD_REF]{notifyAll() Ljava.lang.Object; ()V null null notifyAll null [173 173] 35}\ntoString[METHOD_REF]{toString() Ljava.lang.Object; ()Ljava.lang.String; null null toString null [173 173] 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; ()V null null wait null [173 173] 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (J)V null null wait (arg0) [173 173] 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (JI)V null null wait (arg0 arg1) [173 173] 35}--------- Difference is ---------- expected:<...ull null equals ([obj) [173 173] 35}\nfield[FIELD_REF]{field LX; I null null field null [173 173] 35}\nfinalize[METHOD_REF]{finalize() Ljava.lang.Object; ()V null null finalize null [173 173] 35}\nfoo[METHOD_REF]{foo() LX; ()V null null foo null [173 173] 35}\ngetClass[METHOD_REF]{getClass() Ljava.lang.Object; ()Ljava.lang.Class<*>; null null getClass null [173 173] 35}\nhashCode[METHOD_REF]{hashCode() Ljava.lang.Object; ()I null null hashCode null [173 173] 35}\nnotify[METHOD_REF]{notify() Ljava.lang.Object; ()V null null notify null [173 173] 35}\nnotifyAll[METHOD_REF]{notifyAll() Ljava.lang.Object; ()V null null notifyAll null [173 173] 35}\ntoString[METHOD_REF]{toString() Ljava.lang.Object; ()Ljava.lang.String; null null toString null [173 173] 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; ()V null null wait null [173 173] 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (J)V null null wait (millis) [173 173] 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (JI)V null null wait (millis nanos]) [173 173] 35}> but was:<...ull null equals ([arg0) [173 173] 35}\nfield[FIELD_REF]{field LX; I null null field null [173 173] 35}\nfinalize[METHOD_REF]{finalize() Ljava.lang.Object; ()V null null finalize null [173 173] 35}\nfoo[METHOD_REF]{foo() LX; ()V null null foo null [173 173] 35}\ngetClass[METHOD_REF]{getClass() Ljava.lang.Object; ()Ljava.lang.Class<*>; null null getClass null [173 173] 35}\nhashCode[METHOD_REF]{hashCode() Ljava.lang.Object; ()I null null hashCode null [173 173] 35}\nnotify[METHOD_REF]{notify() Ljava.lang.Object; ()V null null notify null [173 173] 35}\nnotifyAll[METHOD_REF]{notifyAll() Ljava.lang.Object; ()V null null notifyAll null [173 173] 35}\ntoString[METHOD_REF]{toString() Ljava.lang.Object; ()Ljava.lang.String; null null toString null [173 173] 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; ()V null null wait null [173 173] 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (J)V null null wait (arg0) [173 173] 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (JI)V null null wait (arg0 arg1]) [173 173] 35}>	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:259)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:235)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:232)	at org.eclipse.jdt.core.tests.model.AbstractJavaModelCompletionTests.assertResults(AbstractJavaModelCompletionTests.java:194)	at org.eclipse.jdt.core.tests.model.CompletionTests18.testExpressionBody(CompletionTests18.java:786)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at junit.framework.TestCase.runTest(TestCase.java:176)	at junit.framework.TestCase.runBare(TestCase.java:141)	at junit.framework.TestResult$1.protect(TestResult.java:122)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at junit.framework.TestResult.run(TestResult.java:125)	at junit.framework.TestCase.run(TestCase.java:129)	at junit.framework.TestSuite.runTest(TestSuite.java:252)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.runTest(SuiteOfTestCases.java:105)	at junit.framework.TestSuite.run(TestSuite.java:247)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.superRun(SuiteOfTestCases.java:89)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite$1.protect(SuiteOfTestCases.java:77)	at junit.framework.TestResult.runProtected(TestResult.java:142)	at org.eclipse.jdt.core.tests.model.SuiteOfTestCases$Suite.run(SuiteOfTestCases.java:86)	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)	at org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main(RemotePluginTestRunner.java:66)	at org.eclipse.pde.internal.junit.runtime.CoreTestApplication.run(CoreTestApplication.java:24)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.internal.app.EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:198)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:388)	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:243)	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)	at java.lang.reflect.Method.invoke(Method.java:498)	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:673)	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:610)	at org.eclipse.equinox.launcher.Main.run(Main.java:1519)	at org.eclipse.equinox.launcher.Main.main(Main.java:1492)testExpressionBody2(org.eclipse.jdt.core.tests.model.CompletionTests18)junit.framework.ComparisonFailure: ----------- Expected ------------goo[METHOD_REF]{goo() LX; (LI;)V null null goo (i) [173 173] 24}\nmain[METHOD_REF]{main() LX; ([Ljava.lang.String;)V null null main (args) [173 173] 24}\nclone[METHOD_REF]{clone() Ljava.lang.Object; ()Ljava.lang.Object; null null clone null [173 173] 35}\nequals[METHOD_REF]{equals() Ljava.lang.Object; (Ljava.lang.Object;)Z null null equals (obj) [173 173] 35}\nfield[FIELD_REF]{field LX; I null null field null [173 173] 35}\nfinalize[METHOD_REF]{finalize() Ljava.lang.Object; ()V null null finalize null [173 173] 35}\nfoo[METHOD_REF]{foo() LX; ()V null null foo null [173 173] 35}\ngetClass[METHOD_REF]{getClass() Ljava.lang.Object; ()Ljava.lang.Class<*>; null null getClass null [173 173] 35}\nhashCode[METHOD_REF]{hashCode() Ljava.lang.Object; ()I null null hashCode null [173 173] 35}\nnotify[METHOD_REF]{notify() Ljava.lang.Object; ()V null null notify null [173 173] 35}\nnotifyAll[METHOD_REF]{notifyAll() Ljava.lang.Object; ()V null null notifyAll null [173 173] 35}\ntoString[METHOD_REF]{toString() Ljava.lang.Object; ()Ljava.lang.String; null null toString null [173 173] 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; ()V null null wait null [173 173] 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (J)V null null wait (millis) [173 173] 35}\nwait[METHOD_REF]{wait() Ljava.lang.Object; (JI)V null null wait (millis nanos) [173 173] 35}------------ but was ------------goo[METHOD_REF]{goo() LX; (LI;)V null null goo (i) [173 173] 24}\nmain[METHOD_REF]{main() LX; ([Ljava.lang.String;)V null null main (args) [173 173] 24}\nclone[METHOD_REF]{clone() Ljava.lang.Object; ()Ljava.lang.Object; null null clone null [173 173] 35}\nequals[METHOD_REF]{equals() Ljava.lang.Object; (Ljava.lang.Object;)Z null null equals (arg0) [173 173] 35}\nfield[FIELD_REF]{field LX; I null null field null [173 173] 35}\nfinalize[METHOD_REF]{finalize() Ljava.lang.Object; ()V null null finalize null [173 173] 35}\nfoo[METHOD_REF]{foo() LX; ()V null null foo "
499338,8/7/2016 23:33,manpalat,[1.9] [code select]support for resource references in TryStatement Address the rest of the dependencies - including selection and search (if anything extra to be done)
499597,8/12/2016 6:31,register.eclipse,"[null][1.8] NonNullByDefault not applied In the following class even though all possible locations are listed in NonNullByDefault one still must add a @NonNull to get rid of a warning about null type safety.import static org.eclipse.jdt.annotation.DefaultLocation.*;import org.eclipse.jdt.annotation.*;import java.util.Collection;import java.util.Collections;class Foo {	static @NonNull String @NonNull [] X = { ""A"" }; @NonNullByDefault({ PARAMETER RETURN_TYPE FIELD TYPE_PARAMETER TYPE_BOUND TYPE_ARGUMENT ARRAY_CONTENTS })	@SafeVarargs	static <T> Collection<T> of(@NonNull T @NonNull... elements) {		return Collections.singleton(elements[0]);	}		@NonNullByDefault({ PARAMETER RETURN_TYPE FIELD TYPE_PARAMETER TYPE_BOUND TYPE_ARGUMENT ARRAY_CONTENTS })	static Collection<String[]> foo() {		return Foo.<String[]>of(X); // <-- warning here	}	@NonNullByDefault({ PARAMETER RETURN_TYPE FIELD TYPE_PARAMETER TYPE_BOUND TYPE_ARGUMENT ARRAY_CONTENTS })	static Collection<String[]> bar() {		return Foo.<String @NonNull []>of(X); <-- no warning	}}"
499655,8/15/2016 4:57,register.eclipse,"last returned method in Variables view does not show correct visibility icon N20160814-2000.""last returned method"" in Variables view does not show correct visibility icon. It always uses the blue triangle for package/default visibility."
499742,8/16/2016 8:32,mistria,Add JDT to marketplace and associate it with java files As some Eclipse packages (such as the JS/Web one) do not contain JDT it seems likely that some users will now be willing to add JDT to some instance of Eclipse IDE to open .java files.The best way to make it possible for users is to add a marketplace entry for JDT and to add a fileExtension_java tag so it can be suggested for installation when opening a Java file in a non-Java-ready IDE.
499961,8/19/2016 2:20,jarthana,"ECJ's ant adapter does not set suitable compliance When a specific source and target is supplied to ECJ via the ant adapter the compiler doesn't get the compliance. This results in the following error:Compliance level '1.4' is incompatible with target level '9'. A compliance level '9' or better is required""Compliance"" is JDT specific and Ant's Javac task doesn't support this. But the ant adapter should take care of setting the compliance suitably."
500083,8/22/2016 13:07,manpalat,"[1.9][compiler] Bad error message/constant for non-final field as Try-resource BETA_JAVA9The error message for the non-final field used as Try-resource should not talk about a local variable:	static InputStream CONST = null;	void foo() {		try (CONST) { // Local variable CONST defined in an enclosing scope must be final or effectively final					} catch (IOException e) {			e.printStackTrace();		}	}Just starting with ""Variable"" should be good enough.The API constant in IProblem#OuterLocalMustBeEffectivelyFinal must be renamed as well."
500092,8/22/2016 16:49,mateusz.matela,[formatter] Blank lines at beginning of method body doesn't work in constructors This worked before 4.5 was missed during formatter rewrite.
500093,8/22/2016 16:54,mateusz.matela,"[formatter] AssertionError with 'Next line on wrap' for array initializers java.lang.AssertionError	at org.eclipse.jdt.internal.formatter.linewrap.WrapExecutor$LineAnalyzer.token(WrapExecutor.java:178)	at org.eclipse.jdt.internal.formatter.TokenTraverser.traverse(TokenTraverser.java:103)	at org.eclipse.jdt.internal.formatter.TokenManager.traverse(TokenManager.java:384)	at org.eclipse.jdt.internal.formatter.linewrap.WrapExecutor$LineAnalyzer.analyzeLine(WrapExecutor.java:133)	at org.eclipse.jdt.internal.formatter.linewrap.WrapExecutor.findWraps(WrapExecutor.java:416)	at org.eclipse.jdt.internal.formatter.linewrap.WrapExecutor.findWrapsCached(WrapExecutor.java:399)	at org.eclipse.jdt.internal.formatter.linewrap.WrapExecutor.applyWraps(WrapExecutor.java:318)	at org.eclipse.jdt.internal.formatter.linewrap.WrapExecutor.executeWraps(WrapExecutor.java:304)	at org.eclipse.jdt.internal.formatter.linewrap.WrapPreparator.finishUp(WrapPreparator.java:985)	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.prepareWraps(DefaultCodeFormatter.java:381)	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.prepareFormattedCode(DefaultCodeFormatter.java:200)	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:159)	at org.eclipse.jdt.internal.formatter.DefaultCodeFormatter.format(DefaultCodeFormatter.java:142)	at org.eclipse.jdt.internal.corext.util.CodeFormatterUtil.format2(CodeFormatterUtil.java:227)The code assumes that token marked as isNextLineOnWrap must be the last token in a line which may not be true in case of array initializers.Need to remove the assertion and update the algorithm if necessary."
500096,8/22/2016 22:07,mateusz.matela,"[formatter] Indent declarations within enum declaration doesn't affect enum constants When ""Declarations within enum declaration"" on Indentation tab is OFF enum constants get indented anyway."
500462,8/29/2016 22:45,eclipse.sprigogin,[newindex] Fix test failures in JavaElementDeltaTests JavaElementDeltaTests.testAddZIPArchive3 (from org.eclipse.jdt.core.tests.model.AllJavaModelTests)The following failure was observed in the JavaElementDeltaTests unit test on the newindex branch:org.eclipse.jdt.core.tests.model.JavaElementDeltaTests.testAddZIPArchive3 (from org.eclipse.jdt.core.tests.model.AllJavaModelTests)Failing for the past 1 build (Since Failed#1523 )Took 1 sec.Error MessageUnexpected delta.----------- Expected ------------P[*]: {CHILDREN}\n /jobs/genie.platform/eclipse.jdt.core-Gerrit/workspace/org.eclipse.jdt.core.tests.model/target/work/externalLib.abc[+]: {}------------ but was ------------P[*]: {CHILDREN}\n /jobs/genie.platform/eclipse.jdt.core-Gerrit/workspace/org.eclipse.jdt.core.tests.model/target/work/externalLib.abc[+]: {}\n\n--------- Difference is ---------- expected:<...ternalLib.abc[+]: {}[]> but was:<...ternalLib.abc[+]: {}[\n\n]>
500622,8/31/2016 22:41,manpalat,[9][search] Index module-info.java Investigate the indexing of module-info.java constructs.
500714,9/1/2016 20:53,eclipse.sprigogin,"JavaModelManager cache gets stale and returns invalid results The problem can be demonstrated by inserting the following two lines in ExclusionPatternsTests.testCreateExcludedPackage2 after the setClasspath(...) call:	clearDeltas();	getPackageFragmentRoot(""/P/src"").getChildren();The modified test fails with:junit.framework.ComparisonFailure: Unexpected children.----------- Expected ------------<default> [in src [in P]]\norg.eclipse.mypack [in src [in P]]------------ but was ------------<default> [in src [in P]]--------- Difference is ---------- expected:<...ult> [in src [in P]][\norg.eclipse.mypack [in src [in P]]]> but was:<...ult> [in src [in P]][]>	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertStringEquals(TestCase.java:259)	at org.eclipse.jdt.core.tests.junit.extension.TestCase.assertEquals(TestCase.java:235)	at org.eclipse.jdt.core.tests.model.AbstractJavaModelTests.assertElementsEqual(AbstractJavaModelTests.java:678)	at org.eclipse.jdt.core.tests.model.AbstractJavaModelTests.assertElementsEqual(AbstractJavaModelTests.java:656)	at org.eclipse.jdt.core.tests.model.AbstractJavaModelTests.assertSortedElementsEqual(AbstractJavaModelTests.java:527)	at org.eclipse.jdt.core.tests.model.ExclusionPatternsTests.testCreateExcludedPackage2(ExclusionPatternsTests.java:313)"
500716,9/2/2016 0:36,sasikanth.bharadwaj,[compiler][9] Compiler has to report error when service implementation in with clause is not declared in the same module There are a few cases when eclipse does not report errors in a module declaration. One of them is when the service implementation specified in the with clause is not declared in the same module. These need to be fixedRefer http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html#jigsaw-2.5 for details
500785,9/3/2016 0:16,eclipse.sprigogin,[newindex] Fix ResolveTests2.testBug227822a test failures ResolveTests2.testBug227822a fails on the newindex branch but only when run as a part of AllJavaModelTests suite.
500946,9/7/2016 2:04,manpalat,"[BETA_JAVA9] Some merge from master has gone wrong and needs to be investigated org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getTypeOrPackage(char[] char[]) in BETA_JAVA9 branch looks wrong. It has two if (packageBinding == null) { // have not looked for it before		.....}blocks where as in master there's only one such block which indicates somewhere some merge went wrong. Need to identify the merge and investigate other files as well for similar discrepancies"
501311,9/13/2016 4:57,sarika.sinha,"Active Trigger checkbox should be disabled I20160912-2000""Active Trigger"" checkbox should be enabled only when ""Trigger Point"" checkbox is checked. Without that checking ""Active Trigger"" is of no use."
501452,9/14/2016 16:45,lufimtse,"Add option to set JavaDocView's text color The javaDoc ""View"" can have it's background set to a user-defined color. However there is no option to set the text color.(See screenshot).The relevant code is in JavadocView.java. There are two places where ""insertPageProlog(..)"" is called with 'null' being given to foreground:HTMLPrinter.insertPageProlog(buffer 0 null fBackgroundColorRGB fgStyleSheet);If you specify some color (ex green: new RGB(01000) the text color is changed to green.In this task I would like to add the user option to be able to specify a custom color for the text. I will work on writing the patch.NOTE:JavadocView.java is separate from JavadocHover.java (which is the hoverbox that pops-up when you hover over a method with your mouse).I.e this task is specifically focused on the javadoc 'view'."
501562,9/16/2016 4:25,ma.becker,[HighDPI] JUnit Icons appear unsharp on retina display The Junit-icons are still provided in GIF format. SVGs and rendered normal and high resolution PNGs should be provided.
501577,9/16/2016 5:49,ma.becker,[HighDPI] org.eclipse.ltk.ui.refactoring still uses GIFs org.eclipse.lkt.ui.refactoring still uses GIFs even it already has the @2x PNGs.
501592,9/16/2016 7:33,ma.becker,[HighDPI] org.eclipse.jdt.jeview and org.eclipse.jdt.astview still use GIFs These two bundles still use GIFs and don't have HighDPI PNGs.
501631,9/17/2016 7:05,noopur_gupta,"[refactoring] ""Introduce Redirection"" dialog should use error icon on invalid method name Created attachment 264223Introduce Redirection dialogTesting the Eclipse IDE for Java Developers Neon.1 RC4 package:The ""Introduce Redirection"" refactoring's dialog uses the ""info"" rather than ""error"" icon when entering an invalid method name (see screenshot). IMHO ""error"" is warranted as ""OK"" gets disabled and for names merely violating Java naming conventions the dialog already uses the ""warning"" level."
502112,9/25/2016 17:42,register.eclipse,"[null][1.8] secondary old-style null annotations don't always work for methods e.g. when the type is a type variable DESCRIPTION:With Bug??499597 fixed I noted the following problem (in real code caused by a usage of guava's Optional.)Given a old style null annotation (like javax.annotation.Nullable):package org.foo;import java.lang.annotation.*;@Retention(RetentionPolicy.CLASS)public @interface Nullable {}... and a class annotated with it:package util;import org.foo.Nullable;public class Optional {	public static <T> T fromNullable(@Nullable T nullableReference) {		return nullableReference;	}}... when this is used in a project with type-use null annotations as primary null annotations and org.foo.Nullable as secondary null annotation:package test;import org.eclipse.jdt.annotation.NonNullByDefault;import org.eclipse.jdt.annotation.Nullable;import util.Optional;@NonNullByDefaultpublic class Test {	void f(@Nullable String s) {		Optional.<String>fromNullable(s);	}}... an incorrect error is reported:----------\n1. ERROR in test\Test.java (at line 11)\n	Optional.<String>fromNullable(s);\n	 ^\nNull type mismatch (type annotations): required '@NonNull String' but this expression has type '@Nullable String'\n----------\nOther similar problems can be seen in the test cases.ANALYSIS:Only the method??s ??old-style?? null-tagbits are set for parameters and return types but when null type annotations are used the nullity information is in expected to be available on the types for type inference method inheritance checks etc.PATCH:Creates corresponding null-annotated type bindings for the parameter and return types"
502271,9/27/2016 11:42,Olivier_Thomann,[1.9] Support Unicode 8.0 in ECJ +++ This bug was initially created as a clone of Bug #481000 +++Unicode 8.0 support is slated to be one of the features for Java 9 (JEP 227). When it is confirmed we should upgrade the compiler to support Unicode 8.0.
,,,
